/*!
 * ONNX Runtime Web v1.23.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var Dr=Object.defineProperty;var qi=Object.getOwnPropertyDescriptor;var Yi=Object.getOwnPropertyNames;var Ji=Object.prototype.hasOwnProperty;var Ur=(o=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(o,{get:(t,a)=>(typeof require<"u"?require:t)[a]}):o)(function(o){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+o+'" is not supported')});var R=(o,t)=>()=>(o&&(t=o(o=0)),t);var wt=(o,t)=>{for(var a in t)Dr(o,a,{get:t[a],enumerable:!0})},Xi=(o,t,a,u)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of Yi(t))!Ji.call(o,s)&&s!==a&&Dr(o,s,{get:()=>t[s],enumerable:!(u=qi(t,s))||u.enumerable});return o};var Ut=o=>Xi(Dr({},"__esModule",{value:!0}),o);var Pt,Ye,Je,Zi,So,Pr=R(()=>{Pt=new Map,Ye=[],Je=(o,t,a)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let u=Pt.get(o);if(u===void 0)Pt.set(o,{backend:t,priority:a});else{if(u.priority>a)return;if(u.priority===a&&u.backend!==t)throw new Error(`cannot register backend "${o}" using priority ${a}`)}if(a>=0){let s=Ye.indexOf(o);s!==-1&&Ye.splice(s,1);for(let c=0;c<Ye.length;c++)if(Pt.get(Ye[c]).priority<=a){Ye.splice(c,0,o);return}Ye.push(o)}return}throw new TypeError("not a valid backend")},Zi=async o=>{let t=Pt.get(o);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let a=!!t.initPromise;try{return a||(t.initPromise=t.backend.init(o)),await t.initPromise,t.initialized=!0,t.backend}catch(u){return a||(t.error=`${u}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},So=async o=>{let t=o.executionProviders||[],a=t.map(h=>typeof h=="string"?h:h.name),u=a.length===0?Ye:a,s,c=[],p=new Set;for(let h of u){let g=await Zi(h);typeof g=="string"?c.push({name:h,err:g}):(s||(s=g),s===g&&p.add(h))}if(!s)throw new Error(`no available backend found. ERR: ${c.map(h=>`[${h.name}] ${h.err}`).join(", ")}`);for(let{name:h,err:g}of c)a.includes(h)&&console.warn(`removing requested execution provider "${h}" from session options because it is not available: ${g}`);let d=t.filter(h=>p.has(typeof h=="string"?h:h.name));return[s,new Proxy(o,{get:(h,g)=>g==="executionProviders"?d:Reflect.get(h,g)})]}});var Ao=R(()=>{Pr()});var xo,Io=R(()=>{xo="1.23.0-dev.20250703-7fc6235861"});var Oo,re,Rr=R(()=>{Io();Oo="warning",re={wasm:{},webgl:{},webgpu:{},versions:{common:xo},set logLevel(o){if(o!==void 0){if(typeof o!="string"||["verbose","info","warning","error","fatal"].indexOf(o)===-1)throw new Error(`Unsupported logging level: ${o}`);Oo=o}},get logLevel(){return Oo}};Object.defineProperty(re,"logLevel",{enumerable:!0})});var J,Lo=R(()=>{Rr();J=re});var Bo,Co,Mo=R(()=>{Bo=(o,t)=>{let a=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);a.width=o.dims[3],a.height=o.dims[2];let u=a.getContext("2d");if(u!=null){let s,c;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(s=o.dims[2],c=o.dims[3]):(s=o.dims[3],c=o.dims[2]);let p=t?.format!==void 0?t.format:"RGB",d=t?.norm,h,g;d===void 0||d.mean===void 0?h=[255,255,255,255]:typeof d.mean=="number"?h=[d.mean,d.mean,d.mean,d.mean]:(h=[d.mean[0],d.mean[1],d.mean[2],0],d.mean[3]!==void 0&&(h[3]=d.mean[3])),d===void 0||d.bias===void 0?g=[0,0,0,0]:typeof d.bias=="number"?g=[d.bias,d.bias,d.bias,d.bias]:(g=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(g[3]=d.bias[3]));let y=c*s,v=0,T=y,_=y*2,C=-1;p==="RGBA"?(v=0,T=y,_=y*2,C=y*3):p==="RGB"?(v=0,T=y,_=y*2):p==="RBG"&&(v=0,_=y,T=y*2);for(let P=0;P<c;P++)for(let $=0;$<s;$++){let B=(o.data[v++]-g[0])*h[0],O=(o.data[T++]-g[1])*h[1],j=(o.data[_++]-g[2])*h[2],D=C===-1?255:(o.data[C++]-g[3])*h[3];u.fillStyle="rgba("+B+","+O+","+j+","+D+")",u.fillRect($,P,1,1)}if("toDataURL"in a)return a.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Co=(o,t)=>{let a=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),u;if(a!=null){let s,c,p;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(s=o.dims[2],c=o.dims[1],p=o.dims[3]):(s=o.dims[3],c=o.dims[2],p=o.dims[1]);let d=t!==void 0&&t.format!==void 0?t.format:"RGB",h=t?.norm,g,y;h===void 0||h.mean===void 0?g=[255,255,255,255]:typeof h.mean=="number"?g=[h.mean,h.mean,h.mean,h.mean]:(g=[h.mean[0],h.mean[1],h.mean[2],255],h.mean[3]!==void 0&&(g[3]=h.mean[3])),h===void 0||h.bias===void 0?y=[0,0,0,0]:typeof h.bias=="number"?y=[h.bias,h.bias,h.bias,h.bias]:(y=[h.bias[0],h.bias[1],h.bias[2],0],h.bias[3]!==void 0&&(y[3]=h.bias[3]));let v=c*s;if(t!==void 0&&(t.format!==void 0&&p===4&&t.format!=="RGBA"||p===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let T=4,_=0,C=1,P=2,$=3,B=0,O=v,j=v*2,D=-1;d==="RGBA"?(B=0,O=v,j=v*2,D=v*3):d==="RGB"?(B=0,O=v,j=v*2):d==="RBG"&&(B=0,j=v,O=v*2),u=a.createImageData(s,c);for(let U=0;U<c*s;_+=T,C+=T,P+=T,$+=T,U++)u.data[_]=(o.data[B++]-y[0])*g[0],u.data[C]=(o.data[O++]-y[1])*g[1],u.data[P]=(o.data[j++]-y[2])*g[2],u.data[$]=D===-1?255:(o.data[D++]-y[3])*g[3]}else throw new Error("Can not access image data");return u}});var kr,Do,Uo,Po,Ro,ko,No=R(()=>{Rt();kr=(o,t)=>{if(o===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:a,width:u}=t,s=t.norm??{mean:255,bias:0},c,p;typeof s.mean=="number"?c=[s.mean,s.mean,s.mean,s.mean]:c=[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],typeof s.bias=="number"?p=[s.bias,s.bias,s.bias,s.bias]:p=[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];let d=t.format!==void 0?t.format:"RGBA",h=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",g=a*u,y=h==="RGBA"?new Float32Array(g*4):new Float32Array(g*3),v=4,T=0,_=1,C=2,P=3,$=0,B=g,O=g*2,j=-1;d==="RGB"&&(v=3,T=0,_=1,C=2,P=-1),h==="RGBA"?j=g*3:h==="RBG"?($=0,O=g,B=g*2):h==="BGR"&&(O=0,B=g,$=g*2);for(let U=0;U<g;U++,T+=v,C+=v,_+=v,P+=v)y[$++]=(o[T]+p[0])/c[0],y[B++]=(o[_]+p[1])/c[1],y[O++]=(o[C]+p[2])/c[2],j!==-1&&P!==-1&&(y[j++]=(o[P]+p[3])/c[3]);return h==="RGBA"?new se("float32",y,[1,4,a,u]):new se("float32",y,[1,3,a,u])},Do=async(o,t)=>{let a=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,u=typeof ImageData<"u"&&o instanceof ImageData,s=typeof ImageBitmap<"u"&&o instanceof ImageBitmap,c=typeof o=="string",p,d=t??{},h=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},g=y=>typeof HTMLCanvasElement<"u"&&y instanceof HTMLCanvasElement||y instanceof OffscreenCanvas?y.getContext("2d"):null;if(a){let y=h();y.width=o.width,y.height=o.height;let v=g(y);if(v!=null){let T=o.height,_=o.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(T=t.resizedHeight,_=t.resizedWidth),t!==void 0){if(d=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");d.tensorFormat="RGBA",d.height=T,d.width=_}else d.tensorFormat="RGBA",d.height=T,d.width=_;v.drawImage(o,0,0),p=v.getImageData(0,0,_,T).data}else throw new Error("Can not access image data")}else if(u){let y,v;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(y=t.resizedHeight,v=t.resizedWidth):(y=o.height,v=o.width),t!==void 0&&(d=t),d.format="RGBA",d.height=y,d.width=v,t!==void 0){let T=h();T.width=v,T.height=y;let _=g(T);if(_!=null)_.putImageData(o,0,0),p=_.getImageData(0,0,v,y).data;else throw new Error("Can not access image data")}else p=o.data}else if(s){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");let y=h();y.width=o.width,y.height=o.height;let v=g(y);if(v!=null){let T=o.height,_=o.width;return v.drawImage(o,0,0,_,T),p=v.getImageData(0,0,_,T).data,d.height=T,d.width=_,kr(p,d)}else throw new Error("Can not access image data")}else{if(c)return new Promise((y,v)=>{let T=h(),_=g(T);if(!o||!_)return v();let C=new Image;C.crossOrigin="Anonymous",C.src=o,C.onload=()=>{T.width=C.width,T.height=C.height,_.drawImage(C,0,0,T.width,T.height);let P=_.getImageData(0,0,T.width,T.height);d.height=T.height,d.width=T.width,y(kr(P.data,d))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(p!==void 0)return kr(p,d);throw new Error("Input data provided is not supported - aborted tensor creation")},Uo=(o,t)=>{let{width:a,height:u,download:s,dispose:c}=t,p=[1,u,a,4];return new se({location:"texture",type:"float32",texture:o,dims:p,download:s,dispose:c})},Po=(o,t)=>{let{dataType:a,dims:u,download:s,dispose:c}=t;return new se({location:"gpu-buffer",type:a??"float32",gpuBuffer:o,dims:u,download:s,dispose:c})},Ro=(o,t)=>{let{dataType:a,dims:u,download:s,dispose:c}=t;return new se({location:"ml-tensor",type:a??"float32",mlTensor:o,dims:u,download:s,dispose:c})},ko=(o,t,a)=>new se({location:"cpu-pinned",type:o,data:t,dims:a??[t.length]})});var Xe,bt,Wo,Fo,Go=R(()=>{Xe=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),bt=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Wo=!1,Fo=()=>{if(!Wo){Wo=!0;let o=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,a=globalThis.Float16Array,u=typeof a<"u"&&a.from;o&&(Xe.set("int64",BigInt64Array),bt.set(BigInt64Array,"int64")),t&&(Xe.set("uint64",BigUint64Array),bt.set(BigUint64Array,"uint64")),u?(Xe.set("float16",a),bt.set(a,"float16")):Xe.set("float16",Uint16Array)}}});var $o,zo,jo=R(()=>{Rt();$o=o=>{let t=1;for(let a=0;a<o.length;a++){let u=o[a];if(typeof u!="number"||!Number.isSafeInteger(u))throw new TypeError(`dims[${a}] must be an integer, got: ${u}`);if(u<0)throw new RangeError(`dims[${a}] must be a non-negative integer, got: ${u}`);t*=u}return t},zo=(o,t)=>{switch(o.location){case"cpu":return new se(o.type,o.data,t);case"cpu-pinned":return new se({location:"cpu-pinned",data:o.data,type:o.type,dims:t});case"texture":return new se({location:"texture",texture:o.texture,type:o.type,dims:t});case"gpu-buffer":return new se({location:"gpu-buffer",gpuBuffer:o.gpuBuffer,type:o.type,dims:t});case"ml-tensor":return new se({location:"ml-tensor",mlTensor:o.mlTensor,type:o.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${o.location} is not supported`)}}});var se,Rt=R(()=>{Mo();No();Go();jo();se=class{constructor(t,a,u){Fo();let s,c;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,s=t.type,c=t.dims,t.location){case"cpu-pinned":{let d=Xe.get(s);if(!d)throw new TypeError(`unsupported type "${s}" to create tensor from pinned buffer`);if(!(t.data instanceof d))throw new TypeError(`buffer should be of type ${d.name}`);this.cpuData=t.data;break}case"texture":{if(s!=="float32")throw new TypeError(`unsupported type "${s}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case"ml-tensor":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint64"&&s!=="int8"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let d,h;if(typeof t=="string")if(s=t,h=u,t==="string"){if(!Array.isArray(a))throw new TypeError("A string tensor's data must be a string array.");d=a}else{let g=Xe.get(t);if(g===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(a)){if(t==="float16"&&g===Uint16Array||t==="uint4"||t==="int4")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${g.name} as data.`);t==="uint64"||t==="int64"?d=g.from(a,BigInt):d=g.from(a)}else if(a instanceof g)d=a;else if(a instanceof Uint8ClampedArray)if(t==="uint8")d=Uint8Array.from(a);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(t==="float16"&&a instanceof Uint16Array&&g!==Uint16Array)d=new globalThis.Float16Array(a.buffer,a.byteOffset,a.length);else throw new TypeError(`A ${s} tensor's data must be type of ${g}`)}else if(h=a,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let g=typeof t[0];if(g==="string")s="string",d=t;else if(g==="boolean")s="bool",d=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${g}.`)}else if(t instanceof Uint8ClampedArray)s="uint8",d=Uint8Array.from(t);else{let g=bt.get(t.constructor);if(g===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);s=g,d=t}if(h===void 0)h=[d.length];else if(!Array.isArray(h))throw new TypeError("A tensor's dims must be a number array");c=h,this.cpuData=d,this.dataLocation="cpu"}let p=$o(c);if(this.cpuData&&p!==this.cpuData.length&&!((s==="uint4"||s==="int4")&&Math.ceil(p/2)===this.cpuData.length))throw new Error(`Tensor's size(${p}) does not match data length(${this.cpuData.length}).`);this.type=s,this.dims=c,this.size=p}static async fromImage(t,a){return Do(t,a)}static fromTexture(t,a){return Uo(t,a)}static fromGpuBuffer(t,a){return Po(t,a)}static fromMLTensor(t,a){return Ro(t,a)}static fromPinnedBuffer(t,a,u){return ko(t,a,u)}toDataURL(t){return Bo(this,t)}toImageData(t){return Co(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let a=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=a,t&&this.disposer&&(this.disposer(),this.disposer=void 0),a}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return zo(this,t)}}});var Se,Nr=R(()=>{Rt();Se=se});var Vo,Ho,Ze,Qe,Ne,We,Wr=R(()=>{Rr();Vo=(o,t)=>{(typeof re.trace>"u"?!re.wasm.trace:!re.trace)||console.timeStamp(`${o}::ORT::${t}`)},Ho=(o,t)=>{let a=new Error().stack?.split(/\r\n|\r|\n/g)||[],u=!1;for(let s=0;s<a.length;s++){if(u&&!a[s].includes("TRACE_FUNC")){let c=`FUNC_${o}::${a[s].trim().split(" ")[1]}`;t&&(c+=`::${t}`),Vo("CPU",c);return}a[s].includes("TRACE_FUNC")&&(u=!0)}},Ze=o=>{(typeof re.trace>"u"?!re.wasm.trace:!re.trace)||Ho("BEGIN",o)},Qe=o=>{(typeof re.trace>"u"?!re.wasm.trace:!re.trace)||Ho("END",o)},Ne=o=>{(typeof re.trace>"u"?!re.wasm.trace:!re.trace)||console.time(`ORT::${o}`)},We=o=>{(typeof re.trace>"u"?!re.wasm.trace:!re.trace)||console.timeEnd(`ORT::${o}`)}});var kt,qo=R(()=>{Pr();Nr();Wr();kt=class o{constructor(t){this.handler=t}async run(t,a,u){Ze(),Ne("InferenceSession.run");let s={},c={};if(typeof t!="object"||t===null||t instanceof Se||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let p=!0;if(typeof a=="object"){if(a===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(a instanceof Se)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(a)){if(a.length===0)throw new TypeError("'fetches' cannot be an empty array.");p=!1;for(let g of a){if(typeof g!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(g)===-1)throw new RangeError(`'fetches' contains invalid output name: ${g}.`);s[g]=null}if(typeof u=="object"&&u!==null)c=u;else if(typeof u<"u")throw new TypeError("'options' must be an object.")}else{let g=!1,y=Object.getOwnPropertyNames(a);for(let v of this.outputNames)if(y.indexOf(v)!==-1){let T=a[v];(T===null||T instanceof Se)&&(g=!0,p=!1,s[v]=T)}if(g){if(typeof u=="object"&&u!==null)c=u;else if(typeof u<"u")throw new TypeError("'options' must be an object.")}else c=a}}else if(typeof a<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let g of this.inputNames)if(typeof t[g]>"u")throw new Error(`input '${g}' is missing in 'feeds'.`);if(p)for(let g of this.outputNames)s[g]=null;let d=await this.handler.run(t,s,c),h={};for(let g in d)if(Object.hasOwnProperty.call(d,g)){let y=d[g];y instanceof Se?h[g]=y:h[g]=new Se(y.type,y.data,y.dims)}return We("InferenceSession.run"),Qe(),h}async release(){return this.handler.dispose()}static async create(t,a,u,s){Ze(),Ne("InferenceSession.create");let c,p={};if(typeof t=="string"){if(c=t,typeof a=="object"&&a!==null)p=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(c=t,typeof a=="object"&&a!==null)p=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let y=t,v=0,T=t.byteLength;if(typeof a=="object"&&a!==null)p=a;else if(typeof a=="number"){if(v=a,!Number.isSafeInteger(v))throw new RangeError("'byteOffset' must be an integer.");if(v<0||v>=y.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${y.byteLength}).`);if(T=t.byteLength-v,typeof u=="number"){if(T=u,!Number.isSafeInteger(T))throw new RangeError("'byteLength' must be an integer.");if(T<=0||v+T>y.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${y.byteLength-v}].`);if(typeof s=="object"&&s!==null)p=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(typeof u<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof a<"u")throw new TypeError("'options' must be an object.");c=new Uint8Array(y,v,T)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[d,h]=await So(p),g=await d.createInferenceSessionHandler(c,h);return We("InferenceSession.create"),Qe(),new o(g)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}});var Qi,Yo=R(()=>{qo();Qi=kt});var Jo=R(()=>{});var Xo=R(()=>{});var Zo=R(()=>{});var Qo=R(()=>{});var Fr={};wt(Fr,{InferenceSession:()=>Qi,TRACE:()=>Vo,TRACE_EVENT_BEGIN:()=>Ne,TRACE_EVENT_END:()=>We,TRACE_FUNC_BEGIN:()=>Ze,TRACE_FUNC_END:()=>Qe,Tensor:()=>Se,env:()=>J,registerBackend:()=>Je});var Fe=R(()=>{Ao();Lo();Yo();Nr();Jo();Xo();Wr();Zo();Qo()});var Nt=R(()=>{"use strict"});var ra={};wt(ra,{default:()=>Ki});var ea,ta,Ki,na=R(()=>{"use strict";Gr();Ge();Wt();ea="ort-wasm-proxy-worker",ta=globalThis.self?.name===ea;ta&&(self.onmessage=o=>{let{type:t,in:a}=o.data;try{switch(t){case"init-wasm":Ft(a.wasm).then(()=>{Gt(a).then(()=>{postMessage({type:t})},u=>{postMessage({type:t,err:u})})},u=>{postMessage({type:t,err:u})});break;case"init-ep":{let{epName:u,env:s}=a;$t(s,u).then(()=>{postMessage({type:t})},c=>{postMessage({type:t,err:c})});break}case"copy-from":{let{buffer:u}=a,s=Tt(u);postMessage({type:t,out:s});break}case"create":{let{model:u,options:s}=a;zt(u,s).then(c=>{postMessage({type:t,out:c})},c=>{postMessage({type:t,err:c})});break}case"release":jt(a),postMessage({type:t});break;case"run":{let{sessionId:u,inputIndices:s,inputs:c,outputIndices:p,options:d}=a;Vt(u,s,c,p,new Array(p.length).fill(null),d).then(h=>{h.some(g=>g[3]!=="cpu")?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:h},qt([...c,...h]))},h=>{postMessage({type:t,err:h})});break}case"end-profiling":Ht(a),postMessage({type:t});break;default:}}catch(u){postMessage({type:t,err:u})}});Ki=ta?null:o=>new Worker(o??he,{type:"module",name:ea})});var aa={};wt(aa,{default:()=>eu});async function oa(o={}){var t=o,a=typeof window=="object",u=typeof WorkerGlobalScope<"u",s=u&&self.name?.startsWith("em-pthread");t.mountExternalData=(e,r)=>{e.startsWith("./")&&(e=e.substring(2)),(t.o||(t.o=new Map)).set(e,r)},t.unmountExternalData=()=>{delete t.o};var c,p,d=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,$:!0}).buffer.constructor,h=(e,r)=>{throw r},g=import.meta.url,y="";if(a||u){try{y=new URL(".",g).href}catch{}u&&(p=e=>{var r=new XMLHttpRequest;return r.open("GET",e,!1),r.responseType="arraybuffer",r.send(null),new Uint8Array(r.response)}),c=async e=>{if(oe(e))return new Promise((n,i)=>{var f=new XMLHttpRequest;f.open("GET",e,!0),f.responseType="arraybuffer",f.onload=()=>{f.status==200||f.status==0&&f.response?n(f.response):i(f.status)},f.onerror=i,f.send(null)});var r=await fetch(e,{credentials:"same-origin"});if(r.ok)return r.arrayBuffer();throw Error(r.status+" : "+r.url)}}var v,T,_,C,P,$,B,O=console.log.bind(console),j=console.error.bind(console),D=O,U=j,Z=!1,oe=e=>e.startsWith("file://");function l(){ue.buffer!=V.buffer&&Pe()}if(s){var K=!1;async function e(r){try{var n=r.data,i=n.i;if(i==="load"){let f=[];self.onmessage=m=>f.push(m),B=()=>{postMessage({i:"loaded"});for(let m of f)e(m);self.onmessage=e};for(let m of n.K)t[m]&&!t[m].proxy||(t[m]=(...b)=>{postMessage({i:"callHandler",J:m,args:b})},m=="print"&&(D=t[m]),m=="printErr"&&(U=t[m]));ue=n.T,Pe(),$(n.U)}else if(i==="run"){(function(f){var m=(l(),E)[f+52>>>2>>>0];f=(l(),E)[f+56>>>2>>>0],_o(m,m-f),ye(m)})(n.h),Lr(n.h,0,0,1,0,0),sn(),mr(n.h),K||(ro(),K=!0);try{await Ha(n.P,n.u)}catch(f){if(f!="unwind")throw f}}else n.target!=="setimmediate"&&(i==="checkMailbox"?K&&xt():i&&(U(`worker: received unknown command ${i}`),U(n)))}catch(f){throw yo(),f}}self.onunhandledrejection=r=>{throw r.reason||r},self.onmessage=e}var ue,V,H,Oe,M,A,E,z,ee,W,te,At=!1;function Pe(){var e=ue.buffer;t.HEAP8=V=new Int8Array(e),Oe=new Int16Array(e),t.HEAPU8=H=new Uint8Array(e),M=new Uint16Array(e),t.HEAP32=A=new Int32Array(e),t.HEAPU32=E=new Uint32Array(e),z=new Float32Array(e),ee=new Float64Array(e),W=new BigInt64Array(e),te=new BigUint64Array(e)}function ze(){At=!0,s?B():Ue.__wasm_call_ctors()}var ot,je=0,pe=null;function Te(){if(--je==0&&pe){var e=pe;pe=null,e()}}function de(e){throw U(e="Aborted("+e+")"),Z=!0,e+=". Build with -sASSERTIONS for more info.",At&&Eo(),e=new WebAssembly.RuntimeError(e),P?.(e),e}function Q(){if(!(yt={HaveOffsetConverter:Vi,__pthread_create_js:pn,__syscall_fcntl64:gn,__syscall_fstat64:yn,__syscall_getcwd:wn,__syscall_getdents64:bn,__syscall_ioctl:Tn,__syscall_lstat64:vn,__syscall_mkdirat:En,__syscall_newfstatat:_n,__syscall_openat:Sn,__syscall_readlinkat:An,__syscall_rmdir:xn,__syscall_stat64:In,__syscall_unlinkat:On,_abort_js:qa,_embind_register_bigint:Ja,_embind_register_bool:Xa,_embind_register_emval:Qa,_embind_register_float:es,_embind_register_integer:ts,_embind_register_memory_view:rs,_embind_register_std_string:ns,_embind_register_std_wstring:cs,_embind_register_void:ls,_emscripten_init_main_thread_js:ps,_emscripten_notify_mailbox_postmessage:ds,_emscripten_receive_on_main_thread_js:ms,_emscripten_runtime_keepalive_clear:hs,_emscripten_thread_cleanup:gs,_emscripten_thread_mailbox_await:mr,_emscripten_thread_set_strongref:ys,_emval_await:Un,_emval_create_invoker:_s,_emval_decref:pr,_emval_equals:Ss,_emval_get_global:As,_emval_get_module_property:xs,_emval_get_property:Is,_emval_incref:Os,_emval_invoke:Pn,_emval_invoke_i64:Pn,_emval_new_array:Ls,_emval_new_array_from_memory_view:Bs,_emval_new_cstring:Cs,_emval_new_object:Ms,_emval_run_destructors:Ds,_emval_set_property:Us,_gmtime_js:Ps,_localtime_js:Rs,_mktime_js:ks,_mmap_js:Wn,_munmap_js:Fn,_setitimer_js:Gn,_tzset_js:Ws,clock_time_get:$s,emscripten_asm_const_int:zs,emscripten_asm_const_ptr:js,emscripten_check_blocking_allowed:Vs,emscripten_date_now:Fs,emscripten_errn:Hs,emscripten_exit_with_live_runtime:qs,emscripten_get_heap_max:Ys,emscripten_get_now:Ns,emscripten_has_asyncify:Js,emscripten_num_logical_cores:Xs,emscripten_pc_get_function:Lt,emscripten_resize_heap:Zs,emscripten_stack_snapshot:Qs,emscripten_stack_unwind_buffer:Ks,emwgpuAdapterRequestDevice:ai,emwgpuBufferDestroy:si,emwgpuBufferGetConstMappedRange:ii,emwgpuBufferGetMappedRange:ui,emwgpuBufferMapAsync:fi,emwgpuBufferUnmap:ci,emwgpuDelete:li,emwgpuDeviceCreateBuffer:pi,emwgpuDeviceCreateShaderModule:di,emwgpuDeviceDestroy:mi,emwgpuDevicePopErrorScope:hi,emwgpuInstanceRequestAdapter:gi,emwgpuWaitAny:qn,environ_get:Jn,environ_sizes_get:Xn,exit:ur,fd_close:Zn,fd_read:Qn,fd_seek:Kn,fd_write:eo,memory:ue,proc_exit:ir,wgpuAdapterGetLimits:wi,wgpuAdapterHasFeature:bi,wgpuBufferGetSize:Ti,wgpuBufferGetUsage:vi,wgpuCommandEncoderBeginComputePass:Ei,wgpuCommandEncoderCopyBufferToBuffer:_i,wgpuCommandEncoderFinish:Si,wgpuCommandEncoderResolveQuerySet:Ai,wgpuComputePassEncoderDispatchWorkgroups:xi,wgpuComputePassEncoderEnd:Ii,wgpuComputePassEncoderSetBindGroup:Oi,wgpuComputePassEncoderSetPipeline:Li,wgpuComputePassEncoderWriteTimestamp:Bi,wgpuComputePipelineGetBindGroupLayout:Ci,wgpuDeviceCreateBindGroup:Mi,wgpuDeviceCreateCommandEncoder:Di,wgpuDeviceCreateComputePipeline:Ui,wgpuDeviceCreateQuerySet:Pi,wgpuDeviceGetAdapterInfo:Ri,wgpuDeviceGetFeatures:Ni,wgpuDeviceGetLimits:Wi,wgpuDeviceHasFeature:Fi,wgpuDevicePushErrorScope:Gi,wgpuQueueSubmit:$i,wgpuQueueWriteBuffer:zi}).I){yt.I=!0;var e=yt,r=/^(invoke_.*|__asyncjs__.*)$/;for(let[n,i]of Object.entries(e))typeof i=="function"&&(i.A||r.test(n))&&(e[n]=i=new WebAssembly.Suspending(i))}return{env:yt,wasi_snapshot_preview1:yt}}class q{name="ExitStatus";constructor(r){this.message=`Program terminated with exit(${r})`,this.status=r}}var ve=e=>{e.terminate(),e.onmessage=()=>{}},Re=[],at=e=>{ke.length==0&&(fn(),un(ke[0]));var r=ke.pop();if(!r)return 6;pt.push(r),Ve[e.h]=r,r.h=e.h;var n={i:"run",P:e.O,u:e.u,h:e.h};return r.postMessage(n,e.D),0},X=0,Y=(e,r,...n)=>{for(var i=2*n.length,f=we(),m=Dt(8*i),b=m>>>3,w=0;w<n.length;w++){var S=n[w];typeof S=="bigint"?((l(),W)[b+2*w>>>0]=1n,(l(),W)[b+2*w+1>>>0]=S):((l(),W)[b+2*w>>>0]=0n,(l(),ee)[b+2*w+1>>>0]=S)}return e=wo(e,0,i,m,r),ye(f),e};function ir(e){if(s)return Y(0,1,e);if(_=e,!(0<X)){for(var r of pt)ve(r);for(r of ke)ve(r);ke=[],pt=[],Ve={},Z=!0}h(0,new q(e))}function nn(e){if(s)return Y(1,0,e);ur(e)}var ur=e=>{if(_=e,s)throw nn(e),"unwind";ir(e)},ke=[],pt=[],on=[],Ve={},an=e=>{var r=e.h;delete Ve[r],ke.push(e),pt.splice(pt.indexOf(e),1),e.h=0,bo(r)};function sn(){on.forEach(e=>e())}var un=e=>new Promise(r=>{e.onmessage=f=>{var m=(f=f.data).i;if(f.s&&f.s!=Sr()){var b=Ve[f.s];b?b.postMessage(f,f.D):U(`Internal error! Worker sent a message "${m}" to target pthread ${f.s}, but that thread no longer exists!`)}else m==="checkMailbox"?xt():m==="spawnThread"?at(f):m==="cleanupThread"?an(Ve[f.R]):m==="loaded"?(e.loaded=!0,r(e)):f.target==="setimmediate"?e.postMessage(f):m==="callHandler"?t[f.J](...f.args):m&&U(`worker sent an unknown command ${m}`)},e.onerror=f=>{throw U(`worker sent an error! ${f.filename}:${f.lineno}: ${f.message}`),f};var n,i=[];for(n of[])t.propertyIsEnumerable(n)&&i.push(n);e.postMessage({i:"load",K:i,T:ue,U:T})});function fn(){var e=new Worker((()=>{let r=URL;return import.meta.url>"file:"&&import.meta.url<"file;"?new r("ort.jspi.bundle.min.mjs",import.meta.url):new URL(import.meta.url)})(),{type:"module",workerData:"em-pthread",name:"em-pthread"});ke.push(e)}var cn,fr=[],Ha=async(e,r)=>{X=0;var n=WebAssembly,i=n.promising,f=fr[e];f||(fr[e]=f=cn.get(e),hr?.has(f)&&(fr[e]=f=WebAssembly.promising(f))),e=i.call(n,f)(r),e=await e,0<X?_=e:Br(e)};function ln(e,r,n,i){return s?Y(2,1,e,r,n,i):pn(e,r,n,i)}var me=e=>-9007199254740992>e||9007199254740992<e?NaN:Number(e);function pn(e,r,n,i){if(e>>>=0,n>>>=0,i>>>=0,d===void 0)return 6;var f=[];return s&&f.length===0?ln(e,r>>>=0,n,i):(e={O:n,h:e,u:i,D:f},s?(e.i="spawnThread",postMessage(e,f),0):at(e))}var dn=typeof TextDecoder<"u"?new TextDecoder:void 0,mn=(e,r,n,i)=>{if(n=r+n,i)return n;for(;e[r]&&!(r>=n);)++r;return r},hn=(e,r=0,n,i)=>{if(16<(n=mn(e,r>>>=0,n,i))-r&&e.buffer&&dn)return dn.decode(e.buffer instanceof ArrayBuffer?e.subarray(r,n):e.slice(r,n));for(i="";r<n;){var f=e[r++];if(128&f){var m=63&e[r++];if((224&f)==192)i+=String.fromCharCode((31&f)<<6|m);else{var b=63&e[r++];65536>(f=(240&f)==224?(15&f)<<12|m<<6|b:(7&f)<<18|m<<12|b<<6|63&e[r++])?i+=String.fromCharCode(f):(f-=65536,i+=String.fromCharCode(55296|f>>10,56320|1023&f))}}else i+=String.fromCharCode(f)}return i},st=(e,r,n)=>(e>>>=0)?hn((l(),H),e,r,n):"";function gn(e,r,n){return s?Y(3,1,e,r,n):0}function yn(e,r){if(s)return Y(4,1,e,r)}function wn(e,r){if(s)return Y(5,1,e,r)}function bn(e,r,n){if(s)return Y(6,1,e,r,n)}function Tn(e,r,n){return s?Y(7,1,e,r,n):0}function vn(e,r){if(s)return Y(8,1,e,r)}function En(e,r,n){if(s)return Y(9,1,e,r,n)}function _n(e,r,n,i){if(s)return Y(10,1,e,r,n,i)}function Sn(e,r,n,i){if(s)return Y(11,1,e,r,n,i)}function An(e,r,n,i){if(s)return Y(12,1,e,r,n,i)}function xn(e){if(s)return Y(13,1,e)}function In(e,r){if(s)return Y(14,1,e,r)}function On(e,r,n){if(s)return Y(15,1,e,r,n)}var qa=()=>de(""),Ae=e=>{e>>>=0;for(var r="";;){var n=(l(),H)[e++>>>0];if(!n)return r;r+=String.fromCharCode(n)}},cr={},lr={},Ya={},it=class extends Error{constructor(e){super(e),this.name="BindingError"}};function Le(e,r,n={}){return function(i,f,m={}){var b=f.name;if(!i)throw new it(`type "${b}" must have a positive integer typeid pointer`);if(lr.hasOwnProperty(i)){if(m.L)return;throw new it(`Cannot register type '${b}' twice`)}lr[i]=f,delete Ya[i],cr.hasOwnProperty(i)&&(f=cr[i],delete cr[i],f.forEach(w=>w()))}(e,r,n)}var Ln=(e,r,n)=>{switch(r){case 1:return n?i=>(l(),V)[i>>>0]:i=>(l(),H)[i>>>0];case 2:return n?i=>(l(),Oe)[i>>>1>>>0]:i=>(l(),M)[i>>>1>>>0];case 4:return n?i=>(l(),A)[i>>>2>>>0]:i=>(l(),E)[i>>>2>>>0];case 8:return n?i=>(l(),W)[i>>>3>>>0]:i=>(l(),te)[i>>>3>>>0];default:throw new TypeError(`invalid integer width (${r}): ${e}`)}};function Ja(e,r,n,i,f){e>>>=0,n>>>=0,r=Ae(r>>>0);let m=b=>b;if(i=i===0n){let b=8*n;m=w=>BigInt.asUintN(b,w),f=m(f)}Le(e,{name:r,g:m,l:(b,w)=>(typeof w=="number"&&(w=BigInt(w)),w),j:Ln(r,n,!i),m:null})}function Xa(e,r,n,i){Le(e>>>=0,{name:r=Ae(r>>>0),g:function(f){return!!f},l:function(f,m){return m?n:i},j:function(f){return this.g((l(),H)[f>>>0])},m:null})}var Bn=[],He=[0,1,,1,null,1,!0,1,!1,1];function pr(e){9<(e>>>=0)&&--He[e+1]==0&&(He[e]=void 0,Bn.push(e))}var ge=e=>{if(!e)throw new it(`Cannot use deleted val. handle = ${e}`);return He[e]},Ee=e=>{switch(e){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let r=Bn.pop()||He.length;return He[r]=e,He[r+1]=1,r}};function dr(e){return this.g((l(),E)[e>>>2>>>0])}var Za={name:"emscripten::val",g:e=>{var r=ge(e);return pr(e),r},l:(e,r)=>Ee(r),j:dr,m:null};function Qa(e){return Le(e>>>0,Za)}var Ka=(e,r)=>{switch(r){case 4:return function(n){return this.g((l(),z)[n>>>2>>>0])};case 8:return function(n){return this.g((l(),ee)[n>>>3>>>0])};default:throw new TypeError(`invalid float width (${r}): ${e}`)}};function es(e,r,n){n>>>=0,Le(e>>>=0,{name:r=Ae(r>>>0),g:i=>i,l:(i,f)=>f,j:Ka(r,n),m:null})}function ts(e,r,n,i,f){e>>>=0,n>>>=0,r=Ae(r>>>0);let m=w=>w;if(i===0){var b=32-8*n;m=w=>w<<b>>>b,f=m(f)}Le(e,{name:r,g:m,l:(w,S)=>S,j:Ln(r,n,i!==0),m:null})}function rs(e,r,n){function i(m){var b=(l(),E)[m>>>2>>>0];return m=(l(),E)[m+4>>>2>>>0],new f((l(),V).buffer,m,b)}var f=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][r];Le(e>>>=0,{name:n=Ae(n>>>0),g:i,j:i},{L:!0})}var Be=(e,r,n)=>{var i=(l(),H);if(r>>>=0,0<n){var f=r;n=r+n-1;for(var m=0;m<e.length;++m){var b=e.codePointAt(m);if(127>=b){if(r>=n)break;i[r++>>>0]=b}else if(2047>=b){if(r+1>=n)break;i[r++>>>0]=192|b>>6,i[r++>>>0]=128|63&b}else if(65535>=b){if(r+2>=n)break;i[r++>>>0]=224|b>>12,i[r++>>>0]=128|b>>6&63,i[r++>>>0]=128|63&b}else{if(r+3>=n)break;i[r++>>>0]=240|b>>18,i[r++>>>0]=128|b>>12&63,i[r++>>>0]=128|b>>6&63,i[r++>>>0]=128|63&b,m++}}i[r>>>0]=0,e=r-f}else e=0;return e},Ce=e=>{for(var r=0,n=0;n<e.length;++n){var i=e.charCodeAt(n);127>=i?r++:2047>=i?r+=2:55296<=i&&57343>=i?(r+=4,++n):r+=3}return r};function ns(e,r){Le(e>>>=0,{name:r=Ae(r>>>0),g(n){var i=(l(),E)[n>>>2>>>0];return i=st(n+4,i,!0),_e(n),i},l(n,i){i instanceof ArrayBuffer&&(i=new Uint8Array(i));var f=typeof i=="string";if(!(f||ArrayBuffer.isView(i)&&i.BYTES_PER_ELEMENT==1))throw new it("Cannot pass non-string to std::string");var m=f?Ce(i):i.length,b=ht(4+m+1),w=b+4;return(l(),E)[b>>>2>>>0]=m,f?Be(i,w,m+1):(l(),H).set(i,w>>>0),n!==null&&n.push(_e,b),b},j:dr,m(n){_e(n)}})}var Cn=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,os=(e,r,n)=>{if(e>>>=1,16<(r=mn((l(),M),e,r/2,n))-e&&Cn)return Cn.decode((l(),M).buffer instanceof ArrayBuffer?(l(),M).subarray(e>>>0,r>>>0):(l(),M).slice(e,r));for(n="";e<r;++e){var i=(l(),M)[e>>>0];n+=String.fromCharCode(i)}return n},as=(e,r,n)=>{if(n??=2147483647,2>n)return 0;var i=r;n=(n-=2)<2*e.length?n/2:e.length;for(var f=0;f<n;++f){var m=e.charCodeAt(f);(l(),Oe)[r>>>1>>>0]=m,r+=2}return(l(),Oe)[r>>>1>>>0]=0,r-i},ss=e=>2*e.length,is=(e,r,n)=>{var i="";e>>>=2;for(var f=0;!(f>=r/4);f++){var m=(l(),E)[e+f>>>0];if(!m&&!n)break;i+=String.fromCodePoint(m)}return i},us=(e,r,n)=>{if(r>>>=0,n??=2147483647,4>n)return 0;var i=r;n=i+n-4;for(var f=0;f<e.length;++f){var m=e.codePointAt(f);if(65535<m&&f++,(l(),A)[r>>>2>>>0]=m,(r+=4)+4>n)break}return(l(),A)[r>>>2>>>0]=0,r-i},fs=e=>{for(var r=0,n=0;n<e.length;++n)65535<e.codePointAt(n)&&n++,r+=4;return r};function cs(e,r,n){if(e>>>=0,r>>>=0,n=Ae(n>>>=0),r===2)var i=os,f=as,m=ss;else i=is,f=us,m=fs;Le(e,{name:n,g:b=>{var w=(l(),E)[b>>>2>>>0];return w=i(b+4,w*r,!0),_e(b),w},l:(b,w)=>{if(typeof w!="string")throw new it(`Cannot pass non-string to C++ string type ${n}`);var S=m(w),x=ht(4+S+r);return(l(),E)[x>>>2>>>0]=S/r,f(w,x+4,S+r),b!==null&&b.push(_e,x),x},j:dr,m(b){_e(b)}})}function ls(e,r){Le(e>>>=0,{M:!0,name:r=Ae(r>>>0),g:()=>{},l:()=>{}})}function ps(e){Lr(e>>>0,!u,1,!a,131072,!1),sn()}var Mn=e=>{if(!Z)try{if(e(),!(0<X))try{s?Br(_):ur(_)}catch(r){r instanceof q||r=="unwind"||h(0,r)}}catch(r){r instanceof q||r=="unwind"||h(0,r)}};function mr(e){e>>>=0,typeof Atomics.S=="function"&&(Atomics.S((l(),A),e>>>2,e).value.then(xt),e+=128,Atomics.store((l(),A),e>>>2,1))}var xt=()=>{var e=Sr();e&&(mr(e),Mn(vo))};function ds(e,r){(e>>>=0)==r>>>0?setTimeout(xt):s?postMessage({s:e,i:"checkMailbox"}):(e=Ve[e])&&e.postMessage({i:"checkMailbox"})}var It=[];function ms(e,r,n,i,f){for(r>>>=0,i/=2,It.length=i,n=f>>>0>>>3,f=0;f<i;f++)(l(),W)[n+2*f>>>0]?It[f]=(l(),W)[n+2*f+1>>>0]:It[f]=(l(),ee)[n+2*f+1>>>0];return(r?Er[r]:ji[e])(...It)}var hs=()=>{X=0};function gs(e){e>>>=0,s?postMessage({i:"cleanupThread",R:e}):an(Ve[e])}function ys(e){}function ws(e){return(...r)=>e(...r)}var hr=null,Dn=async e=>{X+=1;try{return await e()}finally{--X}};function Un(e){return e>>>=0,Dn(async()=>{var r=await ge(e);return Ee(r)})}Un.A=!0;var gr=[],bs=e=>{var r=gr.length;return gr.push(e),r},Ts=(e,r)=>{for(var n=Array(e),i=0;i<e;++i){var f=i,m=(l(),E)[r+4*i>>>2>>>0],b=lr[m];if(b===void 0)throw e=`parameter ${i}`,m=to(m),r=Ae(m),_e(m),new it(`${e} has unknown type ${r}`);n[f]=b}return n},vs=(e,r,n)=>{var i=[];return e=e(i,n),i.length&&((l(),E)[r>>>2>>>0]=Ee(i)),e},Es={},Ot=e=>{var r=Es[e];return r===void 0?Ae(e):r};function _s(e,r,n){var[i,...f]=Ts(e,r>>>0);r=i.l.bind(i);var m=f.map(S=>S.j.bind(S));e--;var b={toValue:ge};switch(e=m.map((S,x)=>{var k=`argFromPtr${x}`;return b[k]=S,`${k}(args${x?"+"+8*x:""})`}),n){case 0:var w="toValue(handle)";break;case 2:w="new (toValue(handle))";break;case 3:w="";break;case 1:b.getStringOrSymbol=Ot,w="toValue(handle)[getStringOrSymbol(methodName)]"}return w+=`(${e})`,i.M||(b.toReturnWire=r,b.emval_returnValue=vs,w=`return emval_returnValue(toReturnWire, destructorsRef, ${w})`),w=`return function (handle, methodName, destructorsRef, args) {
  ${w}
  }`,n=new Function(Object.keys(b),w)(...Object.values(b)),w=`methodCaller<(${f.map(S=>S.name)}) => ${i.name}>`,bs(Object.defineProperty(n,"name",{value:w}))}function Ss(e,r){return r>>>=0,(e=ge(e>>>0))==ge(r)}function As(e){return(e>>>=0)==0?Ee(globalThis):(e=Ot(e),Ee(globalThis[e]))}function xs(e){return e=Ot(e>>>0),Ee(t[e])}function Is(e,r){return r>>>=0,e=ge(e>>>0),r=ge(r),Ee(e[r])}function Os(e){9<(e>>>=0)&&(He[e+1]+=1)}function Pn(e,r,n,i,f){return gr[e>>>0](r>>>0,n>>>0,i>>>0,f>>>0)}function Ls(){return Ee([])}function Bs(e){e=ge(e>>>0);for(var r=Array(e.length),n=0;n<e.length;n++)r[n]=e[n];return Ee(r)}function Cs(e){return Ee(Ot(e>>>0))}function Ms(){return Ee({})}function Ds(e){for(var r=ge(e>>>=0);r.length;){var n=r.pop();r.pop()(n)}pr(e)}function Us(e,r,n){r>>>=0,n>>>=0,e=ge(e>>>0),r=ge(r),n=ge(n),e[r]=n}function Ps(e,r){e=me(e),r>>>=0,e=new Date(1e3*e),(l(),A)[r>>>2>>>0]=e.getUTCSeconds(),(l(),A)[r+4>>>2>>>0]=e.getUTCMinutes(),(l(),A)[r+8>>>2>>>0]=e.getUTCHours(),(l(),A)[r+12>>>2>>>0]=e.getUTCDate(),(l(),A)[r+16>>>2>>>0]=e.getUTCMonth(),(l(),A)[r+20>>>2>>>0]=e.getUTCFullYear()-1900,(l(),A)[r+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,(l(),A)[r+28>>>2>>>0]=e}var Rn=e=>e%4==0&&(e%100!=0||e%400==0),kn=[0,31,60,91,121,152,182,213,244,274,305,335],Nn=[0,31,59,90,120,151,181,212,243,273,304,334];function Rs(e,r){e=me(e),r>>>=0,e=new Date(1e3*e),(l(),A)[r>>>2>>>0]=e.getSeconds(),(l(),A)[r+4>>>2>>>0]=e.getMinutes(),(l(),A)[r+8>>>2>>>0]=e.getHours(),(l(),A)[r+12>>>2>>>0]=e.getDate(),(l(),A)[r+16>>>2>>>0]=e.getMonth(),(l(),A)[r+20>>>2>>>0]=e.getFullYear()-1900,(l(),A)[r+24>>>2>>>0]=e.getDay();var n=(Rn(e.getFullYear())?kn:Nn)[e.getMonth()]+e.getDate()-1|0;(l(),A)[r+28>>>2>>>0]=n,(l(),A)[r+36>>>2>>>0]=-60*e.getTimezoneOffset(),n=new Date(e.getFullYear(),6,1).getTimezoneOffset();var i=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(n!=i&&e.getTimezoneOffset()==Math.min(i,n)),(l(),A)[r+32>>>2>>>0]=e}function ks(e){e>>>=0;var r=new Date((l(),A)[e+20>>>2>>>0]+1900,(l(),A)[e+16>>>2>>>0],(l(),A)[e+12>>>2>>>0],(l(),A)[e+8>>>2>>>0],(l(),A)[e+4>>>2>>>0],(l(),A)[e>>>2>>>0],0),n=(l(),A)[e+32>>>2>>>0],i=r.getTimezoneOffset(),f=new Date(r.getFullYear(),6,1).getTimezoneOffset(),m=new Date(r.getFullYear(),0,1).getTimezoneOffset(),b=Math.min(m,f);return 0>n?(l(),A)[e+32>>>2>>>0]=+(f!=m&&b==i):0<n!=(b==i)&&(f=Math.max(m,f),r.setTime(r.getTime()+6e4*((0<n?b:f)-i))),(l(),A)[e+24>>>2>>>0]=r.getDay(),n=(Rn(r.getFullYear())?kn:Nn)[r.getMonth()]+r.getDate()-1|0,(l(),A)[e+28>>>2>>>0]=n,(l(),A)[e>>>2>>>0]=r.getSeconds(),(l(),A)[e+4>>>2>>>0]=r.getMinutes(),(l(),A)[e+8>>>2>>>0]=r.getHours(),(l(),A)[e+12>>>2>>>0]=r.getDate(),(l(),A)[e+16>>>2>>>0]=r.getMonth(),(l(),A)[e+20>>>2>>>0]=r.getYear(),e=r.getTime(),BigInt(isNaN(e)?-1:e/1e3)}function Wn(e,r,n,i,f,m,b){return s?Y(16,1,e,r,n,i,f,m,b):-52}function Fn(e,r,n,i,f,m){if(s)return Y(17,1,e,r,n,i,f,m)}var dt={},Ns=()=>performance.timeOrigin+performance.now();function Gn(e,r){if(s)return Y(18,1,e,r);if(dt[e]&&(clearTimeout(dt[e].id),delete dt[e]),!r)return 0;var n=setTimeout(()=>{delete dt[e],Mn(()=>To(e,performance.timeOrigin+performance.now()))},r);return dt[e]={id:n,aa:r},0}function Ws(e,r,n,i){e>>>=0,r>>>=0,n>>>=0,i>>>=0;var f=new Date().getFullYear(),m=new Date(f,0,1).getTimezoneOffset();f=new Date(f,6,1).getTimezoneOffset();var b=Math.max(m,f);(l(),E)[e>>>2>>>0]=60*b,(l(),A)[r>>>2>>>0]=+(m!=f),e=(r=w=>{var S=Math.abs(w);return`UTC${0<=w?"-":"+"}${String(Math.floor(S/60)).padStart(2,"0")}${String(S%60).padStart(2,"0")}`})(m),r=r(f),f<m?(Be(e,n,17),Be(r,i,17)):(Be(e,i,17),Be(r,n,17))}var Fs=()=>Date.now(),Gs=1;function $s(e,r,n){if(n>>>=0,!(0<=e&&3>=e))return 28;if(e===0)e=Date.now();else{if(!Gs)return 52;e=performance.timeOrigin+performance.now()}return e=Math.round(1e6*e),(l(),W)[n>>>3>>>0]=BigInt(e),0}var yr=[],$n=(e,r)=>{yr.length=0;for(var n;n=(l(),H)[e++>>>0];){var i=n!=105;r+=(i&=n!=112)&&r%8?4:0,yr.push(n==112?(l(),E)[r>>>2>>>0]:n==106?(l(),W)[r>>>3>>>0]:n==105?(l(),A)[r>>>2>>>0]:(l(),ee)[r>>>3>>>0]),r+=i?8:4}return yr};function zs(e,r,n){return e>>>=0,r=$n(r>>>0,n>>>0),Er[e](...r)}function js(e,r,n){return e>>>=0,r=$n(r>>>0,n>>>0),Er[e](...r)}var Vs=()=>{};function Hs(e,r){return U(st(e>>>0,r>>>0))}var qs=()=>{throw X+=1,"unwind"};function Ys(){return 4294901760}var Js=()=>2,Xs=()=>navigator.hardwareConcurrency,qe={},zn=e=>{var r=Ce(e)+1,n=ht(r);return n&&Be(e,n,r),n};function Lt(e){if(!(2147483648&(e>>>=0)))return de("Cannot use emscripten_pc_get_function on native functions without -sUSE_OFFSET_CONVERTER"),0;if(!(e=qe[e]))return 0;var r;if(r=/^\s+at (.*) \(.*\)$/.exec(e))e=r[1];else{if(!(r=/^(.+?)@/.exec(e)))return 0;e=r[1]}return _e(Lt.C??0),Lt.C=zn(e),Lt.C}function Zs(e){e>>>=0;var r=(l(),H).length;if(e<=r||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var i=r*(1+.2/n);i=Math.min(i,e+100663296);e:{i=(Math.min(4294901760,65536*Math.ceil(Math.max(e,i)/65536))-ue.buffer.byteLength+65535)/65536|0;try{ue.grow(i),Pe();var f=1;break e}catch{}f=void 0}if(f)return!0}return!1}var Bt=e=>{var r;if(r=/\bwasm-function\[\d+\]:(0x[0-9a-f]+)/.exec(e))return+r[1];if(/\bwasm-function\[(\d+)\]:(\d+)/.exec(e))de("Legacy backtrace format detected but -sUSE_OFFSET_CONVERTER not present.");else if(r=/:(\d+):\d+(?:\)|$)/.exec(e))return 2147483648|+r[1];return 0},jn=e=>{e.forEach(r=>{var n=Bt(r);n&&(qe[n]=r)})};function Qs(){var e=Error().stack.toString().split(`
`);return e[0]=="Error"&&e.shift(),jn(e),qe.B=Bt(e[3]),qe.N=e,qe.B}function Ks(e,r,n){if(e>>>=0,r>>>=0,qe.B==e)var i=qe.N;else(i=Error().stack.toString().split(`
`))[0]=="Error"&&i.shift(),jn(i);for(var f=3;i[f]&&Bt(i[f])!=e;)++f;for(e=0;e<n&&i[e+f];++e)(l(),A)[r+4*e>>>2>>>0]=Bt(i[e+f]);return e}var Me=e=>{var r=Ce(e)+1,n=Dt(r);return Be(e,n,r),n},wr=[],ce=(e,r)=>{wr[e>>>=0]=r},xe=[],Ct=[],mt=(e,r)=>{Ct[e]=new Promise(n=>r.finally(()=>n(e)))},I=e=>{if(e)return wr[e>>>0]},Mt=(e,r,n)=>{(l(),E)[e>>>2>>>0]=r,(l(),E)[e+4>>>2>>>0]=n},Vn=e=>{var r=(l(),E)[e>>>2>>>0];return e=(l(),E)[e+4>>>2>>>0],st(r,e)},De=e=>{var r=(l(),E)[e>>>2>>>0];return e=(l(),E)[e+4>>>2>>>0],r?st(r,e):e===0?"":void 0},Hn=(e,r)=>{function n(f,m){f=e[f],(l(),A)[r+m>>>2>>>0]=f}function i(f,m){f=e[f],(l(),W)[r+m>>>3>>>0]=BigInt(f)}n("maxTextureDimension1D",4),n("maxTextureDimension2D",8),n("maxTextureDimension3D",12),n("maxTextureArrayLayers",16),n("maxBindGroups",20),n("maxBindGroupsPlusVertexBuffers",24),n("maxBindingsPerBindGroup",28),n("maxDynamicUniformBuffersPerPipelineLayout",32),n("maxDynamicStorageBuffersPerPipelineLayout",36),n("maxSampledTexturesPerShaderStage",40),n("maxSamplersPerShaderStage",44),n("maxStorageBuffersPerShaderStage",48),n("maxStorageTexturesPerShaderStage",52),n("maxUniformBuffersPerShaderStage",56),n("minUniformBufferOffsetAlignment",80),n("minStorageBufferOffsetAlignment",84),i("maxUniformBufferBindingSize",64),i("maxStorageBufferBindingSize",72),n("maxVertexBuffers",88),i("maxBufferSize",96),n("maxVertexAttributes",104),n("maxVertexBufferArrayStride",108),n("maxInterStageShaderVariables",112),n("maxColorAttachments",116),n("maxColorAttachmentBytesPerSample",120),n("maxComputeWorkgroupStorageSize",124),n("maxComputeInvocationsPerWorkgroup",128),n("maxComputeWorkgroupSizeX",132),n("maxComputeWorkgroupSizeY",136),n("maxComputeWorkgroupSizeZ",140),n("maxComputeWorkgroupsPerDimension",144),e.Z!==void 0&&n("maxImmediateSize",148)},ei=[,"validation","out-of-memory","internal"],ti=[,"compatibility","core"],br={1:"core-features-and-limits",2:"depth-clip-control",3:"depth32float-stencil8",4:"texture-compression-bc",5:"texture-compression-bc-sliced-3d",6:"texture-compression-etc2",7:"texture-compression-astc",8:"texture-compression-astc-sliced-3d",9:"timestamp-query",10:"indirect-first-instance",11:"shader-f16",12:"rg11b10ufloat-renderable",13:"bgra8unorm-storage",14:"float32-filterable",15:"float32-blendable",16:"clip-distances",17:"dual-source-blending",18:"subgroups",19:"texture-formats-tier1",20:"texture-formats-tier2",21:"primitive-index",327692:"chromium-experimental-unorm16-texture-formats",327693:"chromium-experimental-snorm16-texture-formats",327732:"chromium-experimental-multi-draw-indirect"},ri=[,"low-power","high-performance"],ni=[,"occlusion","timestamp"],oi={undefined:1,unknown:1,destroyed:2};function ai(e,r,n,i,f,m){r=me(r),n=me(n),i>>>=0,f>>>=0,m>>>=0,e=I(e>>>0);var b={};if(m){var w=(l(),E)[m+12>>>2>>>0];if(w){var S=(l(),E)[m+16>>>2>>>0];b.requiredFeatures=Array.from((l(),E).subarray(S>>>2>>>0,S+4*w>>>2>>>0),L=>br[L])}var x=(l(),E)[m+20>>>2>>>0];if(x){let L=function(Ie,ae,Mr=!1){ae=x+ae,(ae=(l(),E)[ae>>>2>>>0])==4294967295||Mr&&ae==0||(k[Ie]=ae)},fe=function(Ie,ae){ae=x+ae;var Mr=(l(),E)[ae>>>2>>>0],Hi=(l(),E)[ae+4>>>2>>>0];Mr==4294967295&&Hi==4294967295||(k[Ie]=4294967296*(l(),E)[ae+4>>>2>>>0]+(l(),E)[ae>>>2>>>0])};var N=L,ne=fe,k={};L("maxTextureDimension1D",4),L("maxTextureDimension2D",8),L("maxTextureDimension3D",12),L("maxTextureArrayLayers",16),L("maxBindGroups",20),L("maxBindGroupsPlusVertexBuffers",24),L("maxDynamicUniformBuffersPerPipelineLayout",32),L("maxDynamicStorageBuffersPerPipelineLayout",36),L("maxSampledTexturesPerShaderStage",40),L("maxSamplersPerShaderStage",44),L("maxStorageBuffersPerShaderStage",48),L("maxStorageTexturesPerShaderStage",52),L("maxUniformBuffersPerShaderStage",56),L("minUniformBufferOffsetAlignment",80),L("minStorageBufferOffsetAlignment",84),fe("maxUniformBufferBindingSize",64),fe("maxStorageBufferBindingSize",72),L("maxVertexBuffers",88),fe("maxBufferSize",96),L("maxVertexAttributes",104),L("maxVertexBufferArrayStride",108),L("maxInterStageShaderVariables",112),L("maxColorAttachments",116),L("maxColorAttachmentBytesPerSample",120),L("maxComputeWorkgroupStorageSize",124),L("maxComputeInvocationsPerWorkgroup",128),L("maxComputeWorkgroupSizeX",132),L("maxComputeWorkgroupSizeY",136),L("maxComputeWorkgroupSizeZ",140),L("maxComputeWorkgroupsPerDimension",144),L("maxImmediateSize",148,!0),b.requiredLimits=k}(w=(l(),E)[m+24>>>2>>>0])&&(w={label:De(w+4)},b.defaultQueue=w),b.label=De(m+4)}X+=1,mt(r,e.requestDevice(b).then(L=>{--X,ce(f,L.queue),ce(i,L),n&&(X+=1,mt(n,L.lost.then(fe=>{--X,L.onuncapturederror=()=>{};var Ie=we(),ae=Me(fe.message);Ar(n,oi[fe.reason],ae),ye(Ie)}))),L.onuncapturederror=fe=>{var Ie=5;fe.error instanceof GPUValidationError?Ie=2:fe.error instanceof GPUOutOfMemoryError?Ie=3:fe.error instanceof GPUInternalError&&(Ie=4);var ae=we();fe=Me(fe.error.message),go(i,Ie,fe),ye(ae)},Or(r,1,i,0)},L=>{--X;var fe=we();L=Me(L.message),Or(r,3,i,L),n&&Ar(n,4,L),ye(fe)}))}function si(e){var r=I(e>>>=0),n=xe[e];if(n){for(var i=0;i<n.length;++i)n[i]();delete xe[e]}r.destroy()}var ut=()=>{var e="getMappedRange size=0 no longer means WGPU_WHOLE_MAP_SIZE";ut.v||(ut.v={}),ut.v[e]||(ut.v[e]=1,U(e))};function ii(e,r,n){r>>>=0,n>>>=0;var i=I(e>>>=0);n===0&&ut(),n==4294967295&&(n=void 0);try{var f=i.getMappedRange(r,n)}catch{return 0}var m=Cr(16,f.byteLength);return(l(),H).set(new Uint8Array(f),m>>>0),xe[e].push(()=>_e(m)),m}function ui(e,r,n){r>>>=0,n>>>=0;var i=I(e>>>=0);n===0&&ut(),n==4294967295&&(n=void 0);try{var f=i.getMappedRange(r,n)}catch{return 0}var m=Cr(16,f.byteLength);return(l(),H).fill(0,m,f.byteLength),xe[e].push(()=>{new Uint8Array(f).set((l(),H).subarray(m>>>0,m+f.byteLength>>>0)),_e(m)}),m}function fi(e,r,n,i,f){e>>>=0,r=me(r),n=me(n),f>>>=0;var m=I(e);xe[e]=[],f==4294967295&&(f=void 0),X+=1,mt(r,m.mapAsync(n,i>>>0,f).then(()=>{--X,xr(r,1,0)},b=>{--X,we();var w=Me(b.message);xr(r,b.name==="AbortError"?4:b.name==="OperationError"?3:0,w),delete xe[e]}))}function ci(e){var r=I(e>>>=0),n=xe[e];if(n){for(var i=0;i<n.length;++i)n[i]();delete xe[e],r.unmap()}}function li(e){delete wr[e>>>0]}function pi(e,r,n){e>>>=0,r>>>=0,n>>>=0;var i=!!(l(),E)[r+32>>>2>>>0];r={label:De(r+4),usage:(l(),E)[r+16>>>2>>>0],size:4294967296*(l(),E)[r+28>>>2>>>0]+(l(),E)[r+24>>>2>>>0],mappedAtCreation:i},e=I(e);try{var f=e.createBuffer(r)}catch{return!1}return ce(n,f),i&&(xe[n]=[]),!0}function di(e,r,n){e>>>=0,r>>>=0,n>>>=0;var i=(l(),E)[r>>>2>>>0],f=(l(),E)[i+4>>>2>>>0];r={label:De(r+4),code:""},f===2&&(r.code=Vn(i+8)),ce(n,I(e).createShaderModule(r))}var mi=e=>{(e=I(e)).onuncapturederror=null,e.destroy()};function hi(e,r){r=me(r),e=I(e>>>0),X+=1,mt(r,e.popErrorScope().then(n=>{--X;var i=5;n?n instanceof GPUValidationError?i=2:n instanceof GPUOutOfMemoryError?i=3:n instanceof GPUInternalError&&(i=4):i=1;var f=we();n=n?Me(n.message):0,Ir(r,1,i,n),ye(f)},n=>{--X;var i=we();n=Me(n.message),Ir(r,1,5,n),ye(i)}))}function gi(e,r,n,i){if(r=me(r),i>>>=0,n>>>=0){var f=(l(),E)[n+4>>>2>>>0];f={featureLevel:ti[f],powerPreference:ri[(l(),E)[n+8>>>2>>>0]],forceFallbackAdapter:!!(l(),E)[n+12>>>2>>>0]},(n=(l(),E)[n>>>2>>>0])!==0&&(l(),f.da=!!(l(),E)[n+8>>>2>>>0])}"gpu"in navigator?(X+=1,mt(r,navigator.gpu.requestAdapter(f).then(m=>{if(--X,m)ce(i,m),gt(r,1,i,0);else{m=we();var b=Me("WebGPU not available on this browser (requestAdapter returned null)");gt(r,3,i,b),ye(m)}},m=>{--X;var b=we();m=Me(m.message),gt(r,4,i,m),ye(b)}))):(n=we(),f=Me("WebGPU not available on this browser (navigator.gpu is not available)"),gt(r,3,i,f),ye(n))}function qn(e,r,n){return e>>>=0,r>>>=0,n>>>=0,Dn(async()=>{var i=[];if(n){var f=(l(),A)[n>>>2>>>0];i.length=r+1,i[r]=new Promise(w=>setTimeout(w,f,0))}else i.length=r;for(var m=0;m<r;++m){var b=4294967296*(l(),E)[e+8*m+4>>>2>>>0]+(l(),E)[e+8*m>>>2>>>0];if(!(b in Ct))return b;i[m]=Ct[b]}return i=await Promise.race(i),delete Ct[i],i})}qn.A=!0;var Tr,vr={},Yn=()=>{if(!Tr){var e,r={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.language||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(e in vr)vr[e]===void 0?delete r[e]:r[e]=vr[e];var n=[];for(e in r)n.push(`${e}=${r[e]}`);Tr=n}return Tr};function Jn(e,r){if(s)return Y(19,1,e,r);e>>>=0,r>>>=0;var n,i=0,f=0;for(n of Yn()){var m=r+i;(l(),E)[e+f>>>2>>>0]=m,i+=Be(n,m,1/0)+1,f+=4}return 0}function Xn(e,r){if(s)return Y(20,1,e,r);e>>>=0,r>>>=0;var n=Yn();for(var i of((l(),E)[e>>>2>>>0]=n.length,e=0,n))e+=Ce(i)+1;return(l(),E)[r>>>2>>>0]=e,0}function Zn(e){return s?Y(21,1,e):52}function Qn(e,r,n,i){return s?Y(22,1,e,r,n,i):52}function Kn(e,r,n,i){return s?Y(23,1,e,r,n,i):70}var yi=[null,[],[]];function eo(e,r,n,i){if(s)return Y(24,1,e,r,n,i);r>>>=0,n>>>=0,i>>>=0;for(var f=0,m=0;m<n;m++){var b=(l(),E)[r>>>2>>>0],w=(l(),E)[r+4>>>2>>>0];r+=8;for(var S=0;S<w;S++){var x=e,k=(l(),H)[b+S>>>0],N=yi[x];k===0||k===10?((x===1?D:U)(hn(N)),N.length=0):N.push(k)}f+=w}return(l(),E)[i>>>2>>>0]=f,0}function wi(e,r){return Hn(I(e>>>0).limits,r>>>0),1}function bi(e,r){return I(e>>>0).features.has(br[r])}function Ti(e){return BigInt(I(e>>>0).size)}function vi(e){return BigInt(I(e>>>0).usage)}function Ei(e,r){if(e>>>=0,r>>>=0){var n=De(r+4);n={label:n,timestampWrites:r=(r=(l(),E)[r+12>>>2>>>0])!==0?{querySet:I((l(),E)[r+4>>>2>>>0]),beginningOfPassWriteIndex:(l(),E)[r+8>>>2>>>0],endOfPassWriteIndex:(l(),E)[r+12>>>2>>>0]}:void 0}}return e=I(e),r=fo(0),ce(r,e.beginComputePass(n)),r}function _i(e,r,n,i,f,m){n=me(n),f=me(f),m=me(m),I(e>>>0).copyBufferToBuffer(I(r>>>0),n,I(i>>>0),f,m)}function Si(e){e=I(e>>>0);var r=io(0);return ce(r,e.finish()),r}function Ai(e,r,n,i,f,m){m=me(m),I(e>>>0).resolveQuerySet(I(r>>>0),n,i,I(f>>>0),m)}function xi(e,r,n,i){I(e>>>0).dispatchWorkgroups(r,n,i)}function Ii(e){I(e>>>0).end()}function Oi(e,r,n,i,f){i>>>=0,f>>>=0,e=I(e>>>0),n=I(n>>>0),i==0?e.setBindGroup(r,n):e.setBindGroup(r,n,(l(),E),f>>>2,i)}function Li(e,r){I(e>>>0).setPipeline(I(r>>>0))}function Bi(e,r,n){I(e>>>0).ba(I(r>>>0),n)}function Ci(e,r){e=I(e>>>0);var n=so(0);return ce(n,e.getBindGroupLayout(r)),n}function Mi(e,r){e>>>=0;var n=De(4+(r>>>=0)),i=I((l(),E)[r+12>>>2>>>0]),f=(l(),E)[r+16>>>2>>>0];r=(l(),E)[r+20>>>2>>>0];for(var m=[],b=0;b<f;++b){var w=m,S=w.push,x=r+40*b,k=(l(),E)[x+8>>>2>>>0],N=(l(),E)[x+32>>>2>>>0],ne=(l(),E)[x+36>>>2>>>0],L=(l(),E)[x+4>>>2>>>0];k?(N=x+24,(N=(l(),E)[N>>>2>>>0]+4294967296*(l(),A)[N+4>>>2>>>0])==-1&&(N=void 0),x={binding:L,resource:{buffer:I(k),offset:4294967296*(l(),E)[x+4+16>>>2>>>0]+(l(),E)[x+16>>>2>>>0],size:N}}):x=N?{binding:L,resource:I(N)}:{binding:L,resource:I(ne)},S.call(w,x)}return n={label:n,layout:i,entries:m},e=I(e),i=ao(0),ce(i,e.createBindGroup(n)),i}function Di(e,r){var n;return e>>>=0,(r>>>=0)&&(n={label:De(r+4)}),e=I(e),r=uo(0),ce(r,e.createCommandEncoder(n)),r}function Ui(e,r){e>>>=0;var n=r>>>0;r=De(n+4);var i=(i=(l(),E)[n+12>>>2>>>0])?I(i):"auto";if(n+=16){var f=I((l(),E)[n+4>>>2>>>0]),m=(l(),E)[n+16>>>2>>>0],b=(l(),E)[n+20>>>2>>>0];if(m){for(var w={},S=0;S<m;++S){var x=b+24*S;w[Vn(x+4)]=(l(),ee)[x+16>>>3>>>0]}m=w}else m=void 0;n={module:f,constants:m,entryPoint:De(n+8)}}else n=void 0;return r={label:r,layout:i,compute:n},e=I(e),i=co(0),ce(i,e.createComputePipeline(r)),i}function Pi(e,r){e>>>=0,r>>>=0,r={type:ni[(l(),E)[r+12>>>2>>>0]],count:(l(),E)[r+16>>>2>>>0]},e=I(e);var n=lo(0);return ce(n,e.createQuerySet(r)),n}function Ri(e,r){e=I(e>>>0).adapterInfo,r>>>=0,(l(),A)[r+52>>>2>>>0]=e.subgroupMinSize,(l(),A)[r+56>>>2>>>0]=e.subgroupMaxSize;var n=zn(e.vendor+e.architecture+e.device+e.description),i=Ce(e.vendor);return Mt(r+4,n,i),n+=i,i=Ce(e.architecture),Mt(r+12,n,i),n+=i,i=Ce(e.device),Mt(r+20,n,i),Mt(r+28,n+i,Ce(e.description)),(l(),A)[r+36>>>2>>>0]=2,e=e.isFallbackAdapter?3:4,(l(),A)[r+40>>>2>>>0]=e,(l(),A)[r+44>>>2>>>0]=0,(l(),A)[r+48>>>2>>>0]=0,1}var ki={"core-features-and-limits":1,"depth-clip-control":2,"depth32float-stencil8":3,"texture-compression-bc":4,"texture-compression-bc-sliced-3d":5,"texture-compression-etc2":6,"texture-compression-astc":7,"texture-compression-astc-sliced-3d":8,"timestamp-query":9,"indirect-first-instance":10,"shader-f16":11,"rg11b10ufloat-renderable":12,"bgra8unorm-storage":13,"float32-filterable":14,"float32-blendable":15,"clip-distances":16,"dual-source-blending":17,subgroups:18,"texture-formats-tier1":19,"texture-formats-tier2":20,"primitive-index":21,"chromium-experimental-unorm16-texture-formats":327692,"chromium-experimental-snorm16-texture-formats":327693,"chromium-experimental-multi-draw-indirect":327732};function Ni(e,r){r>>>=0,e=I(e>>>0);var n=ht(4*e.features.size),i=0,f=0;e.features.forEach(m=>{0<=(m=ki[m])&&((l(),A)[n+i>>>2>>>0]=m,i+=4,f++)}),(l(),E)[r+4>>>2>>>0]=n,(l(),E)[r>>>2>>>0]=f}function Wi(e,r){return Hn(I(e>>>0).limits,r>>>0),1}function Fi(e,r){return I(e>>>0).features.has(br[r])}function Gi(e,r){I(e>>>0).pushErrorScope(ei[r])}function $i(e,r,n){r>>>=0,n>>>=0,e=I(e>>>0),r=Array.from((l(),A).subarray(n>>>2>>>0,n+4*r>>>2>>>0),i=>I(i)),e.submit(r)}function zi(e,r,n,i,f){n=me(n),i>>>=0,f>>>=0,e=I(e>>>0),r=I(r>>>0),i=(l(),H).subarray(i>>>0,i+f>>>0),e.writeBuffer(r,n,i,0,f)}s||function(){for(var e=t.numThreads-1;e--;)fn();Re.push(()=>{je++,function(r){s?r():Promise.all(ke.map(un)).then(r)}(()=>Te())})}(),s||(ue=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),Pe()),t.wasmBinary&&(v=t.wasmBinary),t.stackSave=()=>we(),t.stackRestore=e=>ye(e),t.stackAlloc=e=>Dt(e),t.setValue=function(e,r,n="i8"){switch(n.endsWith("*")&&(n="*"),n){case"i1":case"i8":(l(),V)[e>>>0]=r;break;case"i16":(l(),Oe)[e>>>1>>>0]=r;break;case"i32":(l(),A)[e>>>2>>>0]=r;break;case"i64":(l(),W)[e>>>3>>>0]=BigInt(r);break;case"float":(l(),z)[e>>>2>>>0]=r;break;case"double":(l(),ee)[e>>>3>>>0]=r;break;case"*":(l(),E)[e>>>2>>>0]=r;break;default:de(`invalid type for setValue: ${n}`)}},t.getValue=function(e,r="i8"){switch(r.endsWith("*")&&(r="*"),r){case"i1":case"i8":return(l(),V)[e>>>0];case"i16":return(l(),Oe)[e>>>1>>>0];case"i32":return(l(),A)[e>>>2>>>0];case"i64":return(l(),W)[e>>>3>>>0];case"float":return(l(),z)[e>>>2>>>0];case"double":return(l(),ee)[e>>>3>>>0];case"*":return(l(),E)[e>>>2>>>0];default:de(`invalid type for getValue: ${r}`)}},t.UTF8ToString=st,t.stringToUTF8=Be,t.lengthBytesUTF8=Ce;var ji=[ir,nn,ln,gn,yn,wn,bn,Tn,vn,En,_n,Sn,An,xn,In,On,Wn,Fn,Gn,Jn,Xn,Zn,Qn,Kn,eo],Er={1070448:(e,r,n,i,f)=>{if(t===void 0||!t.o)return 1;if((e=st(Number(e>>>0))).startsWith("./")&&(e=e.substring(2)),!(e=t.o.get(e)))return 2;if(r=Number(r>>>0),n=Number(n>>>0),i=Number(i>>>0),r+n>e.byteLength)return 3;try{let m=e.subarray(r,r+n);switch(f){case 0:(l(),H).set(m,i>>>0);break;case 1:t.F?t.F(i,m):t.Y(i,m);break;default:return 4}return 0}catch{return 4}},1071272:(e,r,n)=>{t.H(e,(l(),H).subarray(r>>>0,r+n>>>0))},1071336:()=>t.W(),1071378:e=>{t.G(e)},1071415:()=>typeof wasmOffsetConverter<"u"};function Vi(){return typeof wasmOffsetConverter<"u"}var to,ro,_r,Sr,_e,ht,no,oo,ao,so,io,uo,fo,co,lo,po,mo,ho,Ar,xr,Ir,gt,Or,go,Lr,yo,wo,bo,Br,To,vo,Cr,Eo,_o,ye,Dt,we,yt,Ue=await async function(){function e(i,f){i=Ue=i.exports;var m=/^(OrtAppendExecutionProvider|OrtCreateSession|OrtRun|OrtRunWithBinding|OrtBindInput|main|__main_argc_argv)$/;hr=new Set;var b={};for(let[w,S]of Object.entries(i))typeof S=="function"?(m.test(w)&&(hr.add(S),S=WebAssembly.promising(S)),b[w]=ws(S)):b[w]=S;return Ue=b,Ue=function(){var w=Ue,S=k=>N=>k(N)>>>0,x=k=>()=>k()>>>0;return(w=Object.assign({},w)).__getTypeName=S(w.__getTypeName),w.pthread_self=x(w.pthread_self),w.malloc=S(w.malloc),w.memalign=(k=>(N,ne)=>k(N,ne)>>>0)(w.memalign),w._emscripten_stack_alloc=S(w._emscripten_stack_alloc),w.emscripten_stack_get_current=x(w.emscripten_stack_get_current),w}(),on.push(Ue._emscripten_tls_init),cn=Ue.__indirect_function_table,T=f,to=(f=Ue).__getTypeName,ro=f._embind_initialize_bindings,t._OrtInit=f.OrtInit,t._OrtGetLastError=f.OrtGetLastError,t._OrtCreateSessionOptions=f.OrtCreateSessionOptions,t._OrtAppendExecutionProvider=f.OrtAppendExecutionProvider,t._OrtAddFreeDimensionOverride=f.OrtAddFreeDimensionOverride,t._OrtAddSessionConfigEntry=f.OrtAddSessionConfigEntry,t._OrtReleaseSessionOptions=f.OrtReleaseSessionOptions,t._OrtCreateSession=f.OrtCreateSession,t._OrtReleaseSession=f.OrtReleaseSession,t._OrtGetInputOutputCount=f.OrtGetInputOutputCount,t._OrtGetInputOutputMetadata=f.OrtGetInputOutputMetadata,t._OrtFree=f.OrtFree,t._OrtCreateTensor=f.OrtCreateTensor,t._OrtGetTensorData=f.OrtGetTensorData,t._OrtReleaseTensor=f.OrtReleaseTensor,t._OrtCreateRunOptions=f.OrtCreateRunOptions,t._OrtAddRunConfigEntry=f.OrtAddRunConfigEntry,t._OrtReleaseRunOptions=f.OrtReleaseRunOptions,t._OrtCreateBinding=f.OrtCreateBinding,t._OrtBindInput=f.OrtBindInput,t._OrtBindOutput=f.OrtBindOutput,t._OrtClearBoundOutputs=f.OrtClearBoundOutputs,t._OrtReleaseBinding=f.OrtReleaseBinding,t._OrtRunWithBinding=f.OrtRunWithBinding,t._OrtRun=f.OrtRun,t._OrtEndProfiling=f.OrtEndProfiling,t._OrtGetWebGpuDevice=_r=f.OrtGetWebGpuDevice,Sr=f.pthread_self,t._free=_e=f.free,t._malloc=ht=f.malloc,t._wgpuBufferRelease=no=f.wgpuBufferRelease,t._wgpuCreateInstance=oo=f.wgpuCreateInstance,ao=f.emwgpuCreateBindGroup,so=f.emwgpuCreateBindGroupLayout,io=f.emwgpuCreateCommandBuffer,uo=f.emwgpuCreateCommandEncoder,fo=f.emwgpuCreateComputePassEncoder,co=f.emwgpuCreateComputePipeline,lo=f.emwgpuCreateQuerySet,po=f.emwgpuCreateBuffer,mo=f.emwgpuCreateDevice,ho=f.emwgpuCreateQueue,Ar=f.emwgpuOnDeviceLostCompleted,xr=f.emwgpuOnMapAsyncCompleted,Ir=f.emwgpuOnPopErrorScopeCompleted,gt=f.emwgpuOnRequestAdapterCompleted,Or=f.emwgpuOnRequestDeviceCompleted,go=f.emwgpuOnUncapturedError,Lr=f._emscripten_thread_init,yo=f._emscripten_thread_crashed,wo=f._emscripten_run_js_on_main_thread,bo=f._emscripten_thread_free_data,Br=f._emscripten_thread_exit,To=f._emscripten_timeout,vo=f._emscripten_check_mailbox,Cr=f.memalign,Eo=f.__trap,_o=f.emscripten_stack_set_limits,ye=f._emscripten_stack_restore,Dt=f._emscripten_stack_alloc,we=f.emscripten_stack_get_current,Te(),Ue}je++;var r,n=Q();return t.instantiateWasm?new Promise(i=>{t.instantiateWasm(n,(f,m)=>{i(e(f,m))})}):s?new Promise(i=>{$=f=>{var m=new WebAssembly.Instance(f,Q());i(e(m,f))}}):(ot??=t.locateFile?t.locateFile?t.locateFile("ort-wasm-simd-threaded.jspi.wasm",y):y+"ort-wasm-simd-threaded.jspi.wasm":new URL("ort-wasm-simd-threaded.jspi.wasm",import.meta.url).href,r=await async function(i){var f=ot;if(!v&&typeof WebAssembly.instantiateStreaming=="function"&&!oe(f))try{var m=fetch(f,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(m,i)}catch(b){U(`wasm streaming compile failed: ${b}`),U("falling back to ArrayBuffer instantiation")}return async function(b,w){try{var S=await async function(x){if(!v)try{var k=await c(x);return new Uint8Array(k)}catch{}if(x==ot&&v)x=new Uint8Array(v);else{if(!p)throw"both async and sync fetching of the wasm failed";x=p(x)}return x}(b);return await WebAssembly.instantiate(S,w)}catch(x){U(`failed to asynchronously prepare wasm: ${x}`),de(x)}}(f,i)}(n),e(r.instance,r.module))}();return function e(){0<je?pe=e:s?(C?.(t),ze()):((()=>{for(var r=Re;0<r.length;)r.shift()(t)})(),0<je?pe=e:async function(){t.calledRun=!0,Z||(ze(),C?.(t))}())}(),t.PTR_SIZE=4,t.webgpuInit=e=>{let r=new WeakMap,n,i,f=1;t.webgpuRegisterDevice=w=>{if(i!==void 0)throw Error("another WebGPU EP inference session is being created.");if(w){var S=r.get(w);if(!S){let x=((k,N=0)=>{var ne=ho(N);return N=mo(N,ne),ce(ne,k.queue),ce(N,k),N})(w,S=oo(0));S=[f++,S,x],r.set(w,S)}return n=w,i=S[0],S}n=void 0,i=0};let m=new Map;t.webgpuOnCreateSession=w=>{if(i!==void 0){var S=i;if(i=void 0,w){let x=_r(S);m.set(w,x),S===0&&e(n??I(x))}n=void 0}},t.webgpuOnReleaseSession=w=>{m.delete(w)};let b=Symbol("gpuBufferMetadata");t.webgpuRegisterBuffer=(w,S,x)=>{if(x)return w[b]=[x,NaN],x;if(x=w[b])return x[1]++,x[0];if((S=m.get(S))===void 0)throw Error("Invalid session handle passed to webgpuRegisterBuffer");return S=((k,N=0)=>(k.mapState!="pending"||de(),N=po(N,k.mapState=="mapped"?3:1),ce(N,k),k.mapState=="mapped"&&(xe[N]=[]),N))(w,S),w[b]=[S,1],S},t.webgpuUnregisterBuffer=w=>{let S=w[b];if(!S)throw Error("Buffer is not registered");S[1]--,S[1]===0&&(no(S[0]),delete w[b])},t.webgpuGetBuffer=w=>I(w),t.webgpuCreateDownloader=(w,S,x)=>{if((x=m.get(x))===void 0)throw Error("Invalid session handle passed to webgpuRegisterBuffer");let k=I(x),N=16*Math.ceil(Number(S)/16);return async()=>{let ne=k.createBuffer({size:N,usage:9});try{let L=k.createCommandEncoder();return L.copyBufferToBuffer(w,0,ne,0,N),k.queue.submit([L.finish()]),await ne.mapAsync(GPUMapMode.READ),ne.getMappedRange().slice(0,S)}finally{ne.destroy()}}},t.F=(w,S)=>{var x=S.buffer;let k=S.byteOffset,N=S.byteLength;if(S=16*Math.ceil(Number(N)/16),w=I(w),!n){var ne=_r(i);n=I(ne)}let L=(ne=n.createBuffer({mappedAtCreation:!0,size:S,usage:6})).getMappedRange();new Uint8Array(L).set(new Uint8Array(x,k,N)),ne.unmap(),(x=n.createCommandEncoder()).copyBufferToBuffer(ne,0,w,0,S),n.queue.submit([x.finish()]),ne.destroy()}},t.webnnInit=e=>{let r=e[0];[t.W,t.G,t.webnnEnsureTensor,t.H,t.webnnDownloadTensor,t.V,t.webnnEnableTraceEvent]=e.slice(1),t.webnnReleaseTensorId=t.G,t.webnnUploadTensor=t.H,t.webnnRegisterMLContext=t.V,t.webnnOnRunStart=n=>r.onRunStart(n),t.webnnOnRunEnd=r.onRunEnd.bind(r),t.webnnOnReleaseSession=n=>{r.onReleaseSession(n)},t.webnnCreateMLTensorDownloader=(n,i)=>r.createMLTensorDownloader(n,i),t.webnnRegisterMLTensor=(n,i,f,m)=>r.registerMLTensor(n,i,f,m),t.webnnCreateMLContext=n=>r.createMLContext(n),t.webnnRegisterMLConstant=(n,i,f,m,b,w)=>r.registerMLConstant(n,i,f,m,b,t.o,w),t.webnnRegisterGraphInput=r.registerGraphInput.bind(r),t.webnnIsGraphInput=r.isGraphInput.bind(r),t.webnnRegisterGraphOutput=r.registerGraphOutput.bind(r),t.webnnIsGraphOutput=r.isGraphOutput.bind(r),t.webnnCreateTemporaryTensor=r.createTemporaryTensor.bind(r),t.webnnIsGraphInputOutputTypeSupported=r.isGraphInputOutputTypeSupported.bind(r)},At?t:new Promise((e,r)=>{C=e,P=r})}var eu,tu,sa=R(()=>{"use strict";eu=oa,tu=globalThis.self?.name?.startsWith("em-pthread");tu&&oa()});var fa,zr,ru,he,ca,$r,nu,ou,la,au,ia,pa,ua,da,Wt=R(()=>{"use strict";Nt();fa=typeof location>"u"?void 0:location.origin,zr=import.meta.url>"file:"&&import.meta.url<"file;",ru=()=>{if(!!1){if(zr){let o=URL;return new URL(new o("ort.jspi.bundle.min.mjs",import.meta.url).href,fa).href}return import.meta.url}},he=ru(),ca=()=>{if(he&&!he.startsWith("blob:"))return he.substring(0,he.lastIndexOf("/")+1)},$r=(o,t)=>{try{let a=t??he;return(a?new URL(o,a):new URL(o)).origin===fa}catch{return!1}},nu=(o,t)=>{let a=t??he;try{return(a?new URL(o,a):new URL(o)).href}catch{return}},ou=(o,t)=>`${t??"./"}${o}`,la=async o=>{let a=await(await fetch(o,{credentials:"same-origin"})).blob();return URL.createObjectURL(a)},au=async o=>(await import(/*webpackIgnore:true*/o)).default,ia=(na(),Ut(ra)).default,pa=async()=>{if(!he)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if($r(he))return[void 0,ia()];let o=await la(he);return[o,ia(o)]},ua=(sa(),Ut(aa)).default,da=async(o,t,a,u)=>{let s=ua&&!(o||t);if(s)if(he)s=$r(he);else if(u&&!a)s=!0;else throw new Error("cannot determine the script source URL.");if(s)return[void 0,ua];{let c="ort-wasm-simd-threaded.jspi.mjs",p=o??nu(c,t),d=!!1&&a&&p&&!$r(p,t),h=d?await la(p):p??ou(c,t);return[d?h:void 0,await au(h)]}}});var jr,Vr,Yt,ma,su,iu,uu,Ft,F,Ge=R(()=>{"use strict";Wt();Vr=!1,Yt=!1,ma=!1,su=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},iu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},uu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},Ft=async o=>{if(Vr)return Promise.resolve();if(Yt)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(ma)throw new Error("previous call to 'initializeWebAssembly()' failed.");Yt=!0;let t=o.initTimeout,a=o.numThreads;if(o.simd!==!1){if(o.simd==="relaxed"){if(!uu())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!iu())throw new Error("WebAssembly SIMD is not supported in the current environment.")}if(!("Suspending"in WebAssembly))throw new Error("WebAssembly JSPI is not supported in the current environment.");let u=su();a>1&&!u&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+a+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),o.numThreads=a=1);let s=o.wasmPaths,c=typeof s=="string"?s:void 0,p=s?.mjs,d=p?.href??p,h=s?.wasm,g=h?.href??h,y=o.wasmBinary,[v,T]=await da(d,c,a>1,!!y||!!g),_=!1,C=[];if(t>0&&C.push(new Promise(P=>{setTimeout(()=>{_=!0,P()},t)})),C.push(new Promise((P,$)=>{let B={numThreads:a};if(y)B.wasmBinary=y;else if(g||c)B.locateFile=O=>g??c+O;else if(d&&d.indexOf("blob:")!==0)B.locateFile=O=>new URL(O,d).href;else if(v){let O=ca();O&&(B.locateFile=j=>O+j)}T(B).then(O=>{Yt=!1,Vr=!0,jr=O,P(),v&&URL.revokeObjectURL(v)},O=>{Yt=!1,ma=!0,$(O)})})),await Promise.race(C),_)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},F=()=>{if(Vr&&jr)return jr;throw new Error("WebAssembly is not initialized yet.")}});var le,vt,G,Jt=R(()=>{"use strict";Ge();le=(o,t)=>{let a=F(),u=a.lengthBytesUTF8(o)+1,s=a._malloc(u);return a.stringToUTF8(o,s,u),t.push(s),s},vt=(o,t,a,u)=>{if(typeof o=="object"&&o!==null){if(a.has(o))throw new Error("Circular reference in options");a.add(o)}Object.entries(o).forEach(([s,c])=>{let p=t?t+s:s;if(typeof c=="object")vt(c,p+".",a,u);else if(typeof c=="string"||typeof c=="number")u(p,c.toString());else if(typeof c=="boolean")u(p,c?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof c}`)})},G=o=>{let t=F(),a=t.stackSave();try{let u=t.PTR_SIZE,s=t.stackAlloc(2*u);t._OrtGetLastError(s,s+u);let c=Number(t.getValue(s,u===4?"i32":"i64")),p=t.getValue(s+u,"*"),d=p?t.UTF8ToString(p):"";throw new Error(`${o} ERROR_CODE: ${c}, ERROR_MESSAGE: ${d}`)}finally{t.stackRestore(a)}}});var ha,ga=R(()=>{"use strict";Ge();Jt();ha=o=>{let t=F(),a=0,u=[],s=o||{};try{if(o?.logSeverityLevel===void 0)s.logSeverityLevel=2;else if(typeof o.logSeverityLevel!="number"||!Number.isInteger(o.logSeverityLevel)||o.logSeverityLevel<0||o.logSeverityLevel>4)throw new Error(`log severity level is not valid: ${o.logSeverityLevel}`);if(o?.logVerbosityLevel===void 0)s.logVerbosityLevel=0;else if(typeof o.logVerbosityLevel!="number"||!Number.isInteger(o.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${o.logVerbosityLevel}`);o?.terminate===void 0&&(s.terminate=!1);let c=0;return o?.tag!==void 0&&(c=le(o.tag,u)),a=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,c),a===0&&G("Can't create run options."),o?.extra!==void 0&&vt(o.extra,"",new WeakSet,(p,d)=>{let h=le(p,u),g=le(d,u);t._OrtAddRunConfigEntry(a,h,g)!==0&&G(`Can't set a run config entry: ${p} - ${d}.`)}),[a,u]}catch(c){throw a!==0&&t._OrtReleaseRunOptions(a),u.forEach(p=>t._free(p)),c}}});var fu,cu,lu,qr,Hr,pu,ya,wa=R(()=>{"use strict";Ge();Jt();fu=o=>{switch(o){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${o}`)}},cu=o=>{switch(o){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${o}`)}},lu=o=>{o.extra||(o.extra={}),o.extra.session||(o.extra.session={});let t=o.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),o.executionProviders&&o.executionProviders.some(a=>(typeof a=="string"?a:a.name)==="webgpu")&&(o.enableMemPattern=!1)},qr=(o,t,a,u)=>{let s=le(t,u),c=le(a,u);F()._OrtAddSessionConfigEntry(o,s,c)!==0&&G(`Can't set a session config entry: ${t} - ${a}.`)},Hr=(o,t,a,u)=>{let s=le(t,u),c=le(a,u);o.push([s,c])},pu=async(o,t,a)=>{for(let u of t){let s=typeof u=="string"?u:u.name,c=[];switch(s){case"webnn":if(s="WEBNN",typeof u!="string"){let v=u?.deviceType;v&&qr(o,"deviceType",v,a)}break;case"webgpu":{s="WebGPU";let y;if(typeof u!="string"){let T=u;if(T.device)if(typeof GPUDevice<"u"&&T.device instanceof GPUDevice)y=T.device;else throw new Error("Invalid GPU device set in WebGPU EP options.")}let v=F().webgpuRegisterDevice(y);if(v){let[T,_,C]=v;Hr(c,"deviceId",T.toString(),a),Hr(c,"webgpuInstance",_.toString(),a),Hr(c,"webgpuDevice",C.toString(),a)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${s}`)}let p=le(s,a),d=c.length,h=0,g=0;if(d>0){h=F()._malloc(d*F().PTR_SIZE),a.push(h),g=F()._malloc(d*F().PTR_SIZE),a.push(g);for(let y=0;y<d;y++)F().setValue(h+y*F().PTR_SIZE,c[y][0],"*"),F().setValue(g+y*F().PTR_SIZE,c[y][1],"*")}await F()._OrtAppendExecutionProvider(o,p,h,g,d)!==0&&G(`Can't append execution provider: ${s}.`)}},ya=async o=>{let t=F(),a=0,u=[],s=o||{};lu(s);try{let c=fu(s.graphOptimizationLevel??"all"),p=cu(s.executionMode??"sequential"),d=typeof s.logId=="string"?le(s.logId,u):0,h=s.logSeverityLevel??2;if(!Number.isInteger(h)||h<0||h>4)throw new Error(`log severity level is not valid: ${h}`);let g=s.logVerbosityLevel??0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);let y=typeof s.optimizedModelFilePath=="string"?le(s.optimizedModelFilePath,u):0;if(a=t._OrtCreateSessionOptions(c,!!s.enableCpuMemArena,!!s.enableMemPattern,p,!!s.enableProfiling,0,d,h,g,y),a===0&&G("Can't create session options."),s.executionProviders&&await pu(a,s.executionProviders,u),s.enableGraphCapture!==void 0){if(typeof s.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${s.enableGraphCapture}`);qr(a,"enableGraphCapture",s.enableGraphCapture.toString(),u)}if(s.freeDimensionOverrides)for(let[v,T]of Object.entries(s.freeDimensionOverrides)){if(typeof v!="string")throw new Error(`free dimension override name must be a string: ${v}`);if(typeof T!="number"||!Number.isInteger(T)||T<0)throw new Error(`free dimension override value must be a non-negative integer: ${T}`);let _=le(v,u);t._OrtAddFreeDimensionOverride(a,_,T)!==0&&G(`Can't set a free dimension override: ${v} - ${T}.`)}return s.extra!==void 0&&vt(s.extra,"",new WeakSet,(v,T)=>{qr(a,v,T,u)}),[a,u]}catch(c){throw a!==0&&t._OrtReleaseSessionOptions(a)!==0&&G("Can't release session options."),u.forEach(p=>t._free(p)),c}}});var $e,Xt,ft,et,Et,Zt,Qt,Yr,tt=R(()=>{"use strict";$e=o=>{switch(o){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${o}`)}},Xt=o=>{switch(o){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${o}`)}},ft=(o,t)=>{let a=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][o],u=typeof t=="number"?t:t.reduce((s,c)=>s*c,1);return a>0?Math.ceil(u*a):void 0},et=o=>{switch(o){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${o}`)}},Et=o=>{switch(o){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${o}`)}},Zt=o=>o==="float32"||o==="float16"||o==="int32"||o==="int64"||o==="uint32"||o==="uint8"||o==="bool"||o==="uint4"||o==="int4",Qt=o=>o==="float32"||o==="float16"||o==="int32"||o==="int64"||o==="uint32"||o==="uint64"||o==="int8"||o==="uint8"||o==="bool"||o==="uint4"||o==="int4",Yr=o=>{switch(o){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${o}`)}}});var _t,Jr=R(()=>{"use strict";Nt();_t=async o=>{if(typeof o=="string")if(!1)try{let{readFile:t}=Ur("node:fs/promises");return new Uint8Array(await t(o))}catch(t){if(t.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:a}=Ur("node:fs"),u=a(o),s=[];for await(let c of u)s.push(c);return new Uint8Array(Buffer.concat(s))}throw t}else{let t=await fetch(o);if(!t.ok)throw new Error(`failed to load external data file: ${o}`);let a=t.headers.get("Content-Length"),u=a?parseInt(a,10):0;if(u<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${o}, no response body.`);let s=t.body.getReader(),c;try{c=new ArrayBuffer(u)}catch(d){if(d instanceof RangeError){let h=Math.ceil(u/65536);c=new WebAssembly.Memory({initial:h,maximum:h}).buffer}else throw d}let p=0;for(;;){let{done:d,value:h}=await s.read();if(d)break;let g=h.byteLength;new Uint8Array(c,p,g).set(h),p+=g}return new Uint8Array(c,0,u)}}else return o instanceof Blob?new Uint8Array(await o.arrayBuffer()):o instanceof Uint8Array?o:new Uint8Array(o)}});var ba,Ta=R(()=>{"use strict";tt();ba=(o,t)=>new(et(t))(o)});var du,mu,va,Ea,_a,hu,ie,Xr=R(()=>{"use strict";tt();du=["V","I","W","E","F"],mu=(o,t)=>{console.log(`[${du[o]},${new Date().toISOString()}]${t}`)},_a=(o,t)=>{va=o,Ea=t},hu=(o,t)=>{let a=Et(o),u=Et(va);a>=u&&mu(a,typeof t=="function"?t():t)},ie=(...o)=>{Ea&&hu(...o)}});var Aa,Qr,xa,gu,Sa,yu,Ia,Kt,er,Zr,Oa,La=R(()=>{"use strict";tt();Xr();Aa=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),Qr=(o,t)=>{if(t==="int32")return o;let a=Aa.get(t);if(!a)throw new Error(`WebNN backend does not support data type: ${t}`);let u=a/8;if(o.byteLength%u!==0)throw new Error(`Invalid Uint8Array length - must be a multiple of ${u}.`);let s=o.byteLength/u,c=new(et(t))(o.buffer,o.byteOffset,s);switch(t){case"int64":case"uint64":{let p=new Int32Array(s);for(let d=0;d<s;d++){let h=c[d];if(h>2147483647n||h<-2147483648n)throw new Error("Can not convert int64 data to int32 - value out of range.");p[d]=Number(h)}return new Uint8Array(p.buffer)}case"int8":case"uint8":case"uint32":{if(t==="uint32"&&c.some(d=>d>2147483647))throw new Error("Can not convert uint32 data to int32 - value out of range.");let p=Int32Array.from(c,Number);return new Uint8Array(p.buffer)}default:throw new Error(`Unsupported data conversion from ${t} to 'int32'`)}},xa=(o,t)=>{if(t==="int32")return o;if(o.byteLength%4!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");let a=o.byteLength/4,u=new Int32Array(o.buffer,o.byteOffset,a);switch(t){case"int64":{let s=BigInt64Array.from(u,BigInt);return new Uint8Array(s.buffer)}case"uint64":{if(u.some(c=>c<0))throw new Error("Can not convert int32 data to uin64 - negative value found.");let s=BigUint64Array.from(u,BigInt);return new Uint8Array(s.buffer)}case"int8":{if(u.some(c=>c<-128||c>127))throw new Error("Can not convert int32 data to int8 - value out of range.");let s=Int8Array.from(u,Number);return new Uint8Array(s.buffer)}case"uint8":{if(u.some(s=>s<0||s>255))throw new Error("Can not convert int32 data to uint8 - value out of range.");return Uint8Array.from(u,Number)}case"uint32":{if(u.some(c=>c<0))throw new Error("Can not convert int32 data to uint32 - negative value found.");let s=Uint32Array.from(u,Number);return new Uint8Array(s.buffer)}default:throw new Error(`Unsupported data conversion from 'int32' to ${t}`)}},gu=1,Sa=()=>gu++,yu=new Map([["int8","int32"],["uint8","int32"],["uint32","int32"],["int64","int32"]]),Ia=(o,t)=>{let a=Aa.get(o);if(!a)throw new Error(`WebNN backend does not support data type: ${o}`);return t.length>0?Math.ceil(t.reduce((u,s)=>u*s)*a/8):0},Kt=class{constructor(t){this.isDataConverted=!1;let{sessionId:a,context:u,tensor:s,dataType:c,shape:p,fallbackDataType:d}=t;this.sessionId=a,this.mlContext=u,this.mlTensor=s,this.dataType=c,this.tensorShape=p,this.fallbackDataType=d}get tensor(){return this.mlTensor}get type(){return this.dataType}get fallbackType(){return this.fallbackDataType}get shape(){return this.tensorShape}get byteLength(){return Ia(this.dataType,this.tensorShape)}destroy(){ie("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(t){this.mlContext.writeTensor(this.mlTensor,t)}async read(t){if(this.fallbackDataType){let a=await this.mlContext.readTensor(this.mlTensor),u=xa(new Uint8Array(a),this.dataType);if(t){(t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength)).set(u);return}else return u.buffer}else return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(t,a,u){return this.mlContext===t&&this.dataType===a&&this.tensorShape.length===u.length&&this.tensorShape.every((s,c)=>s===u[c])}setIsDataConverted(t){this.isDataConverted=t}},er=class{constructor(t,a){this.tensorManager=t;this.wrapper=a}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(t,a,u,s){let c=this.tensorManager.getMLContext(t),p=this.tensorManager.getMLOpSupportLimits(t),d;if(!p?.input.dataTypes.includes(a)){if(d=yu.get(a),!d||p?.input.dataTypes.includes(d))throw new Error(`WebNN backend does not support data type: ${a}`);ie("verbose",()=>`[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${a} to ${d}`)}if(this.wrapper){if(this.wrapper.canReuseTensor(c,a,u))return this.wrapper.tensor;if(s){if(this.wrapper.byteLength!==Ia(a,u))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let h=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(t,a,u,h,!0,!0,d),s&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(t){let a=t;if(this.wrapper){if(this.wrapper.fallbackType)if(this.wrapper.fallbackType==="int32")a=Qr(t,this.wrapper.type),this.wrapper.setIsDataConverted(!0);else throw new Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);if(t.byteLength===this.wrapper.byteLength){this.wrapper.write(a);return}else ie("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor()}this.activeUpload?this.activeUpload.set(a):this.activeUpload=new Uint8Array(a)}async download(t){if(this.activeUpload){let a=this.wrapper?.isDataConverted?xa(this.activeUpload,this.wrapper?.type):this.activeUpload;if(t){t instanceof ArrayBuffer?new Uint8Array(t).set(a):new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(a);return}else return a.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return t?this.wrapper.read(t):this.wrapper.read()}},Zr=class{constructor(t){this.backend=t;this.tensorTrackersById=new Map;this.freeTensors=[];this.externalTensors=new Set}getMLContext(t){let a=this.backend.getMLContext(t);if(!a)throw new Error("MLContext not found for session.");return a}getMLOpSupportLimits(t){return this.backend.getMLOpSupportLimits(t)}reserveTensorId(){let t=Sa();return this.tensorTrackersById.set(t,new er(this)),t}releaseTensorId(t){let a=this.tensorTrackersById.get(t);a&&(this.tensorTrackersById.delete(t),a.tensorWrapper&&this.releaseTensor(a.tensorWrapper))}async ensureTensor(t,a,u,s,c){ie("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${a}, dataType: ${u}, shape: ${s}, copyOld: ${c}}`);let p=this.tensorTrackersById.get(a);if(!p)throw new Error("Tensor not found.");return p.ensureTensor(t,u,s,c)}upload(t,a){let u=this.tensorTrackersById.get(t);if(!u)throw new Error("Tensor not found.");u.upload(a)}async download(t,a){ie("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${t}, dstBuffer: ${a?.byteLength}}`);let u=this.tensorTrackersById.get(t);if(!u)throw new Error("Tensor not found.");return u.download(a)}releaseTensorsForSession(t){for(let a of this.freeTensors)a.sessionId===t&&a.destroy();this.freeTensors=this.freeTensors.filter(a=>a.sessionId!==t)}registerTensor(t,a,u,s){let c=this.getMLContext(t),p=Sa(),d=new Kt({sessionId:t,context:c,tensor:a,dataType:u,shape:s});return this.tensorTrackersById.set(p,new er(this,d)),this.externalTensors.add(d),p}async getCachedTensor(t,a,u,s,c,p,d){let h=this.getMLContext(t);for(let[y,v]of this.freeTensors.entries())if(v.canReuseTensor(h,a,u)){ie("verbose",()=>`[WebNN] Reusing tensor {dataType: ${a}, ${d?`fallbackDataType: ${d},`:""} shape: ${u}`);let T=this.freeTensors.splice(y,1)[0];return T.sessionId=t,T}ie("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${a}, ${d?`fallbackDataType: ${d},`:""} shape: ${u}}`);let g=await h.createTensor({dataType:d??a,shape:u,dimensions:u,usage:s,writable:c,readable:p});return new Kt({sessionId:t,context:h,tensor:g,dataType:a,shape:u,fallbackDataType:d})}releaseTensor(t){this.externalTensors.has(t)&&this.externalTensors.delete(t),this.freeTensors.push(t)}},Oa=(...o)=>new Zr(...o)});var Ba={};wt(Ba,{WebNNBackend:()=>Kr});var tr,wu,Kr,Ca=R(()=>{"use strict";tt();Ge();Ta();La();Xr();tr=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),wu=(o,t)=>{if(o===t)return!0;if(o===void 0||t===void 0)return!1;let a=Object.keys(o).sort(),u=Object.keys(t).sort();return a.length===u.length&&a.every((s,c)=>s===u[c]&&o[s]===t[s])},Kr=class{constructor(t){this.tensorManager=Oa(this);this.mlContextBySessionId=new Map;this.sessionIdsByMLContext=new Map;this.mlContextCache=[];this.sessionGraphInputs=new Map;this.sessionGraphOutputs=new Map;this.temporaryGraphInputs=[];this.temporaryGraphOutputs=[];this.temporarySessionTensorIds=new Map;this.mlOpSupportLimitsBySessionId=new Map;_a(t.logLevel,!!t.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(t){ie("verbose",()=>`[WebNN] onRunStart {sessionId: ${t}}`),this.activeSessionId=t}onRunEnd(t){ie("verbose",()=>`[WebNN] onRunEnd {sessionId: ${t}}`);let a=this.temporarySessionTensorIds.get(t);if(a){for(let u of a)ie("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${u}}`),this.tensorManager.releaseTensorId(u);this.temporarySessionTensorIds.delete(t),this.activeSessionId=void 0}}async createMLContext(t){if(t instanceof GPUDevice){let u=this.mlContextCache.findIndex(s=>s.gpuDevice===t);if(u!==-1)return this.mlContextCache[u].mlContext;{let s=await navigator.ml.createContext(t);return this.mlContextCache.push({gpuDevice:t,mlContext:s}),s}}else if(t===void 0){let u=this.mlContextCache.findIndex(s=>s.options===void 0&&s.gpuDevice===void 0);if(u!==-1)return this.mlContextCache[u].mlContext;{let s=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:s}),s}}let a=this.mlContextCache.findIndex(u=>wu(u.options,t));if(a!==-1)return this.mlContextCache[a].mlContext;{let u=await navigator.ml.createContext(t);return this.mlContextCache.push({options:t,mlContext:u}),u}}registerMLContext(t,a){this.mlContextBySessionId.set(t,a);let u=this.sessionIdsByMLContext.get(a);u||(u=new Set,this.sessionIdsByMLContext.set(a,u)),u.add(t),this.mlOpSupportLimitsBySessionId.has(t)||this.mlOpSupportLimitsBySessionId.set(t,a.opSupportLimits()),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(t,this.temporaryGraphInputs),this.temporaryGraphInputs=[]),this.temporaryGraphOutputs.length>0&&(this.sessionGraphOutputs.set(t,this.temporaryGraphOutputs),this.temporaryGraphOutputs=[])}onReleaseSession(t){this.sessionGraphInputs.delete(t),this.sessionGraphOutputs.delete(t);let a=this.mlContextBySessionId.get(t);if(!a)return;this.tensorManager.releaseTensorsForSession(t),this.mlContextBySessionId.delete(t),this.mlOpSupportLimitsBySessionId.delete(t);let u=this.sessionIdsByMLContext.get(a);if(u.delete(t),u.size===0){this.sessionIdsByMLContext.delete(a);let s=this.mlContextCache.findIndex(c=>c.mlContext===a);s!==-1&&this.mlContextCache.splice(s,1)}}getMLContext(t){return this.mlContextBySessionId.get(t)}getMLOpSupportLimits(t){return this.mlOpSupportLimitsBySessionId.get(t)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(t){ie("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t)}async ensureTensor(t,a,u,s,c){let p=tr.get(u);if(!p)throw new Error(`Unsupported ONNX data type: ${u}`);return this.tensorManager.ensureTensor(t??this.currentSessionId,a,p,s,c)}async createTemporaryTensor(t,a,u){ie("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${a}, shape: ${u}}`);let s=tr.get(a);if(!s)throw new Error(`Unsupported ONNX data type: ${a}`);let c=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(t,c,s,u,!1);let p=this.temporarySessionTensorIds.get(t);return p?p.push(c):this.temporarySessionTensorIds.set(t,[c]),c}uploadTensor(t,a){if(!F().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");ie("verbose",()=>`[WebNN] uploadTensor {tensorId: ${t}, data: ${a.byteLength}}`),this.tensorManager.upload(t,a)}async downloadTensor(t,a){return this.tensorManager.download(t,a)}createMLTensorDownloader(t,a){return async()=>{let u=await this.tensorManager.download(t);return ba(u,a)}}registerMLTensor(t,a,u,s){let c=tr.get(u);if(!c)throw new Error(`Unsupported ONNX data type: ${u}`);let p=this.tensorManager.registerTensor(t,a,c,s);return ie("verbose",()=>`[WebNN] registerMLTensor {tensor: ${a}, dataType: ${c}, dimensions: ${s}} -> {tensorId: ${p}}`),p}registerMLConstant(t,a,u,s,c,p,d=!1){if(!p)throw new Error("External mounted files are not available.");let h=t;t.startsWith("./")&&(h=t.substring(2));let g=p.get(h);if(!g)throw new Error(`File with name ${h} not found in preloaded files.`);if(a+u>g.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let y=g.slice(a,a+u).buffer,v;switch(c.dataType){case"float32":v=new Float32Array(y);break;case"float16":v=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(y):new Uint16Array(y);break;case"int32":v=new Int32Array(y);break;case"uint32":v=new Uint32Array(y);break;case"int64":if(d){let T=Qr(new Uint8Array(y),"int64");v=new Int32Array(T.buffer),c.dataType="int32"}else v=new BigInt64Array(y);break;case"uint64":v=new BigUint64Array(y);break;case"int8":v=new Int8Array(y);break;case"int4":case"uint4":case"uint8":v=new Uint8Array(y);break;default:throw new Error(`Unsupported data type: ${c.dataType} in creating WebNN Constant from external data.`)}return ie("verbose",()=>`[WebNN] registerMLConstant {dataType: ${c.dataType}, shape: ${c.shape}}} ${d?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),s.constant(c,v)}registerGraphInput(t){this.temporaryGraphInputs.push(t)}registerGraphOutput(t){this.temporaryGraphOutputs.push(t)}isGraphInput(t,a){let u=this.sessionGraphInputs.get(t);return u?u.includes(a):!1}isGraphOutput(t,a){let u=this.sessionGraphOutputs.get(t);return u?u.includes(a):!1}isGraphInputOutputTypeSupported(t,a,u=!0){let s=tr.get($e(a)),c=this.mlOpSupportLimitsBySessionId.get(t);return typeof s>"u"?!1:u?!!c?.input.dataTypes.includes(s):!!c?.output.dataTypes.includes(s)}flush(){}}});var bu,Gt,$t,rt,Tu,Ma,Tt,zt,jt,Da,Vt,Ht,qt,Gr=R(()=>{"use strict";Fe();ga();wa();tt();Ge();Jt();Jr();bu=(o,t)=>{F()._OrtInit(o,t)!==0&&G("Can't initialize onnxruntime.")},Gt=async o=>{bu(o.wasm.numThreads,Et(o.logLevel))},$t=async(o,t)=>{F().asyncInit?.();let a=o.webgpu.adapter;if(t==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");if(a){if(typeof a.limits!="object"||typeof a.features!="object"||typeof a.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let u=o.webgpu.powerPreference;if(u!==void 0&&u!=="low-power"&&u!=="high-performance")throw new Error(`Invalid powerPreference setting: "${u}"`);let s=o.webgpu.forceFallbackAdapter;if(s!==void 0&&typeof s!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${s}"`);if(a=await navigator.gpu.requestAdapter({powerPreference:u,forceFallbackAdapter:s}),!a)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if(t==="webnn"&&(typeof navigator>"u"||!navigator.ml))throw new Error("WebNN is not supported in current environment");if(t==="webgpu"&&F().webgpuInit(u=>{o.webgpu.device=u}),t==="webnn"){let u=new(Ca(),Ut(Ba)).WebNNBackend(o);F().webnnInit([u,()=>u.reserveTensorId(),s=>u.releaseTensorId(s),async(s,c,p,d,h)=>u.ensureTensor(s,c,p,d,h),(s,c)=>{u.uploadTensor(s,c)},async(s,c)=>u.downloadTensor(s,c),(s,c)=>u.registerMLContext(s,c),!!o.trace])}},rt=new Map,Tu=o=>{let t=F(),a=t.stackSave();try{let u=t.PTR_SIZE,s=t.stackAlloc(2*u);t._OrtGetInputOutputCount(o,s,s+u)!==0&&G("Can't get session input/output count.");let p=u===4?"i32":"i64";return[Number(t.getValue(s,p)),Number(t.getValue(s+u,p))]}finally{t.stackRestore(a)}},Ma=(o,t)=>{let a=F(),u=a.stackSave(),s=0;try{let c=a.PTR_SIZE,p=a.stackAlloc(2*c);a._OrtGetInputOutputMetadata(o,t,p,p+c)!==0&&G("Can't get session input/output metadata.");let h=Number(a.getValue(p,"*"));s=Number(a.getValue(p+c,"*"));let g=a.HEAP32[s/4];if(g===0)return[h,0];let y=a.HEAPU32[s/4+1],v=[];for(let T=0;T<y;T++){let _=Number(a.getValue(s+8+T*c,"*"));v.push(_!==0?a.UTF8ToString(_):Number(a.getValue(s+8+(T+y)*c,"*")))}return[h,g,v]}finally{a.stackRestore(u),s!==0&&a._OrtFree(s)}},Tt=o=>{let t=F(),a=t._malloc(o.byteLength);if(a===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${o.byteLength}.`);return t.HEAPU8.set(o,a),[a,o.byteLength]},zt=async(o,t)=>{let a,u,s=F();Array.isArray(o)?[a,u]=o:o.buffer===s.HEAPU8.buffer?[a,u]=[o.byteOffset,o.byteLength]:[a,u]=Tt(o);let c=0,p=0,d=0,h=[],g=[],y=[];try{if([p,h]=await ya(t),t?.externalData&&s.mountExternalData){let D=[];for(let U of t.externalData){let Z=typeof U=="string"?U:U.path;D.push(_t(typeof U=="string"?U:U.data).then(oe=>{s.mountExternalData(Z,oe)}))}await Promise.all(D)}for(let D of t?.executionProviders??[])if((typeof D=="string"?D:D.name)==="webnn"){if(s.shouldTransferToMLTensor=!1,typeof D!="string"){let Z=D,oe=Z?.context,l=Z?.gpuDevice,K=Z?.deviceType,ue=Z?.powerPreference;oe?s.currentContext=oe:l?s.currentContext=await s.webnnCreateMLContext(l):s.currentContext=await s.webnnCreateMLContext({deviceType:K,powerPreference:ue})}else s.currentContext=await s.webnnCreateMLContext();break}c=await s._OrtCreateSession(a,u,p),s.webgpuOnCreateSession?.(c),c===0&&G("Can't create a session."),s.jsepOnCreateSession?.(),s.currentContext&&(s.webnnRegisterMLContext(c,s.currentContext),s.currentContext=void 0,s.shouldTransferToMLTensor=!0);let[v,T]=Tu(c),_=!!t?.enableGraphCapture,C=[],P=[],$=[],B=[],O=[];for(let D=0;D<v;D++){let[U,Z,oe]=Ma(c,D);U===0&&G("Can't get an input name."),g.push(U);let l=s.UTF8ToString(U);C.push(l),$.push(Z===0?{name:l,isTensor:!1}:{name:l,isTensor:!0,type:Xt(Z),shape:oe})}for(let D=0;D<T;D++){let[U,Z,oe]=Ma(c,D+v);U===0&&G("Can't get an output name."),y.push(U);let l=s.UTF8ToString(U);P.push(l),B.push(Z===0?{name:l,isTensor:!1}:{name:l,isTensor:!0,type:Xt(Z),shape:oe});{if(_&&t?.preferredOutputLocation===void 0){O.push("gpu-buffer");continue}let K=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[l]??"cpu",ue=s.webnnIsGraphOutput;if(K==="cpu"&&ue&&ue(c,l)){O.push("ml-tensor-cpu-output");continue}if(K!=="cpu"&&K!=="cpu-pinned"&&K!=="gpu-buffer"&&K!=="ml-tensor")throw new Error(`Not supported preferred output location: ${K}.`);if(_&&K!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${K}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);O.push(K)}}let j=null;return O.some(D=>D==="gpu-buffer"||D==="ml-tensor"||D==="ml-tensor-cpu-output")&&(d=s._OrtCreateBinding(c),d===0&&G("Can't create IO binding."),j={handle:d,outputPreferredLocations:O,outputPreferredLocationsEncoded:O.map(D=>D==="ml-tensor-cpu-output"?"ml-tensor":D).map(D=>Yr(D))}),rt.set(c,[c,g,y,j,_,!1]),[c,C,P,$,B]}catch(v){throw g.forEach(T=>s._OrtFree(T)),y.forEach(T=>s._OrtFree(T)),d!==0&&s._OrtReleaseBinding(d)!==0&&G("Can't release IO binding."),c!==0&&s._OrtReleaseSession(c)!==0&&G("Can't release session."),v}finally{s._free(a),p!==0&&s._OrtReleaseSessionOptions(p)!==0&&G("Can't release session options."),h.forEach(v=>s._free(v)),s.unmountExternalData?.()}},jt=o=>{let t=F(),a=rt.get(o);if(!a)throw new Error(`cannot release session. invalid session id: ${o}`);let[u,s,c,p,d]=a;p&&(d&&t._OrtClearBoundOutputs(p.handle)!==0&&G("Can't clear bound outputs."),t._OrtReleaseBinding(p.handle)!==0&&G("Can't release IO binding.")),t.jsepOnReleaseSession?.(o),t.webnnOnReleaseSession?.(o),t.webgpuOnReleaseSession?.(o),s.forEach(h=>t._OrtFree(h)),c.forEach(h=>t._OrtFree(h)),t._OrtReleaseSession(u)!==0&&G("Can't release session."),rt.delete(o)},Da=async(o,t,a,u,s,c,p=!1)=>{if(!o){t.push(0);return}let d=F(),h=d.PTR_SIZE,g=o[0],y=o[1],v=o[3],T=v,_,C;if(g==="string"&&(v==="gpu-buffer"||v==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(p&&v!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${c} when enableGraphCapture is true.`);if(v==="gpu-buffer"){let B=o[2].gpuBuffer;C=ft($e(g),y);{let O=d.webgpuRegisterBuffer;if(!O)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');_=O(B,u)}}else if(v==="ml-tensor"){let B=o[2].mlTensor;C=ft($e(g),y);let O=d.webnnRegisterMLTensor;if(!O)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');_=O(u,B,$e(g),y)}else{let B=o[2];if(Array.isArray(B)){C=h*B.length,_=d._malloc(C),a.push(_);for(let O=0;O<B.length;O++){if(typeof B[O]!="string")throw new TypeError(`tensor data at index ${O} is not a string`);d.setValue(_+O*h,le(B[O],a),"*")}}else{let O=d.webnnIsGraphInput,j=d.webnnIsGraphOutput;if(g!=="string"&&O&&j){let D=d.UTF8ToString(s);if(O(u,D)||j(u,D)){let U=$e(g);C=ft(U,y),T="ml-tensor";let Z=d.webnnCreateTemporaryTensor,oe=d.webnnUploadTensor;if(!Z||!oe)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let l=await Z(u,U,y);oe(l,new Uint8Array(B.buffer,B.byteOffset,B.byteLength)),_=l}else C=B.byteLength,_=d._malloc(C),a.push(_),d.HEAPU8.set(new Uint8Array(B.buffer,B.byteOffset,C),_)}else C=B.byteLength,_=d._malloc(C),a.push(_),d.HEAPU8.set(new Uint8Array(B.buffer,B.byteOffset,C),_)}}let P=d.stackSave(),$=d.stackAlloc(4*y.length);try{y.forEach((O,j)=>d.setValue($+j*h,O,h===4?"i32":"i64"));let B=d._OrtCreateTensor($e(g),_,C,$,y.length,Yr(T));B===0&&G(`Can't create tensor for input/output. session=${u}, index=${c}.`),t.push(B)}finally{d.stackRestore(P)}},Vt=async(o,t,a,u,s,c)=>{let p=F(),d=p.PTR_SIZE,h=rt.get(o);if(!h)throw new Error(`cannot run inference. invalid session id: ${o}`);let g=h[0],y=h[1],v=h[2],T=h[3],_=h[4],C=h[5],P=t.length,$=u.length,B=0,O=[],j=[],D=[],U=[],Z=p.stackSave(),oe=p.stackAlloc(P*d),l=p.stackAlloc(P*d),K=p.stackAlloc($*d),ue=p.stackAlloc($*d);try{[B,O]=ha(c),Ne("wasm prepareInputOutputTensor");for(let M=0;M<P;M++)await Da(a[M],j,U,o,y[t[M]],t[M],_);for(let M=0;M<$;M++)await Da(s[M],D,U,o,v[u[M]],P+u[M],_);We("wasm prepareInputOutputTensor");for(let M=0;M<P;M++)p.setValue(oe+M*d,j[M],"*"),p.setValue(l+M*d,y[t[M]],"*");for(let M=0;M<$;M++)p.setValue(K+M*d,D[M],"*"),p.setValue(ue+M*d,v[u[M]],"*");if(T&&!C){let{handle:M,outputPreferredLocations:A,outputPreferredLocationsEncoded:E}=T;if(y.length!==P)throw new Error(`input count from feeds (${P}) is expected to be always equal to model's input count (${y.length}).`);Ne("wasm bindInputsOutputs");for(let z=0;z<P;z++){let ee=t[z];await p._OrtBindInput(M,y[ee],j[z])!==0&&G(`Can't bind input[${z}] for session=${o}.`)}for(let z=0;z<$;z++){let ee=u[z];s[z]?.[3]?p._OrtBindOutput(M,v[ee],D[z],0)!==0&&G(`Can't bind pre-allocated output[${z}] for session=${o}.`):p._OrtBindOutput(M,v[ee],0,E[ee])!==0&&G(`Can't bind output[${z}] to ${A[z]} for session=${o}.`)}We("wasm bindInputsOutputs"),rt.set(o,[g,y,v,T,_,!0])}p.jsepOnRunStart?.(g),p.webnnOnRunStart?.(g);let V;T?V=await p._OrtRunWithBinding(g,T.handle,$,K,B):V=await p._OrtRun(g,l,oe,P,ue,$,K,B),V!==0&&G("failed to call OrtRun().");let H=[],Oe=[];Ne("wasm ProcessOutputTensor");for(let M=0;M<$;M++){let A=Number(p.getValue(K+M*d,"*"));if(A===D[M]){H.push(s[M]);continue}let E=p.stackSave(),z=p.stackAlloc(4*d),ee=!1,W,te=0;try{p._OrtGetTensorData(A,z,z+d,z+2*d,z+3*d)!==0&&G(`Can't access output tensor data on index ${M}.`);let Pe=d===4?"i32":"i64",ze=Number(p.getValue(z,Pe));te=p.getValue(z+d,"*");let ot=p.getValue(z+d*2,"*"),je=Number(p.getValue(z+d*3,Pe)),pe=[];for(let Q=0;Q<je;Q++)pe.push(Number(p.getValue(ot+Q*d,Pe)));p._OrtFree(ot)!==0&&G("Can't free memory for tensor dims.");let Te=pe.reduce((Q,q)=>Q*q,1);W=Xt(ze);let de=T?.outputPreferredLocations[u[M]];if(W==="string"){if(de==="gpu-buffer"||de==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let Q=[];for(let q=0;q<Te;q++){let ve=p.getValue(te+q*d,"*"),Re=p.getValue(te+(q+1)*d,"*"),at=q===Te-1?void 0:Re-ve;Q.push(p.UTF8ToString(ve,at))}H.push([W,pe,Q,"cpu"])}else if(de==="gpu-buffer"&&Te>0){let Q=p.webgpuGetBuffer;if(!Q)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let q=Q(te),ve=ft(ze,Te);if(ve===void 0||!Zt(W))throw new Error(`Unsupported data type: ${W}`);ee=!0;{p.webgpuRegisterBuffer(q,o,te);let Re=p.webgpuCreateDownloader(q,ve,o);H.push([W,pe,{gpuBuffer:q,download:async()=>{let at=await Re();return new(et(W))(at)},dispose:()=>{p._OrtReleaseTensor(A)!==0&&G("Can't release tensor.")}},"gpu-buffer"])}}else if(de==="ml-tensor"&&Te>0){let Q=p.webnnEnsureTensor,q=p.webnnIsGraphInputOutputTypeSupported;if(!Q||!q)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(ft(ze,Te)===void 0||!Qt(W))throw new Error(`Unsupported data type: ${W}`);if(!q(o,W,!1))throw new Error(`preferredLocation "ml-tensor" for ${W} output is not supported by current WebNN Context.`);let Re=await Q(o,te,ze,pe,!1);ee=!0,H.push([W,pe,{mlTensor:Re,download:p.webnnCreateMLTensorDownloader(te,W),dispose:()=>{p.webnnReleaseTensorId(te),p._OrtReleaseTensor(A)}},"ml-tensor"])}else if(de==="ml-tensor-cpu-output"&&Te>0){let Q=p.webnnCreateMLTensorDownloader(te,W)(),q=H.length;ee=!0,Oe.push((async()=>{let ve=[q,await Q];return p.webnnReleaseTensorId(te),p._OrtReleaseTensor(A),ve})()),H.push([W,pe,[],"cpu"])}else{let Q=et(W),q=new Q(Te);new Uint8Array(q.buffer,q.byteOffset,q.byteLength).set(p.HEAPU8.subarray(te,te+q.byteLength)),H.push([W,pe,q,"cpu"])}}finally{p.stackRestore(E),W==="string"&&te&&p._free(te),ee||p._OrtReleaseTensor(A)}}T&&!_&&(p._OrtClearBoundOutputs(T.handle)!==0&&G("Can't clear bound outputs."),rt.set(o,[g,y,v,T,_,!1]));for(let[M,A]of await Promise.all(Oe))H[M][2]=A;return We("wasm ProcessOutputTensor"),H}finally{p.webnnOnRunEnd?.(g),p.stackRestore(Z),a.forEach(V=>{V&&V[3]==="gpu-buffer"&&p.webgpuUnregisterBuffer(V[2].gpuBuffer)}),s.forEach(V=>{V&&V[3]==="gpu-buffer"&&p.webgpuUnregisterBuffer(V[2].gpuBuffer)}),j.forEach(V=>p._OrtReleaseTensor(V)),D.forEach(V=>p._OrtReleaseTensor(V)),U.forEach(V=>p._free(V)),B!==0&&p._OrtReleaseRunOptions(B),O.forEach(V=>p._free(V))}},Ht=o=>{let t=F(),a=rt.get(o);if(!a)throw new Error("invalid session id");let u=a[0],s=t._OrtEndProfiling(u);s===0&&G("Can't get an profile file name."),t._OrtFree(s)},qt=o=>{let t=[];for(let a of o){let u=a[2];!Array.isArray(u)&&"buffer"in u&&t.push(u.buffer)}return t}});var nt,be,St,nr,or,rr,en,tn,ct,lt,Eu,Ua,Pa,Ra,ka,Na,Wa,Fa,rn=R(()=>{"use strict";Fe();Gr();Ge();Wt();nt=()=>!!J.wasm.proxy&&typeof document<"u",St=!1,nr=!1,or=!1,tn=new Map,ct=(o,t)=>{let a=tn.get(o);a?a.push(t):tn.set(o,[t])},lt=()=>{if(St||!nr||or||!be)throw new Error("worker not ready")},Eu=o=>{switch(o.data.type){case"init-wasm":St=!1,o.data.err?(or=!0,en[1](o.data.err)):(nr=!0,en[0]()),rr&&(URL.revokeObjectURL(rr),rr=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=tn.get(o.data.type);o.data.err?t.shift()[1](o.data.err):t.shift()[0](o.data.out);break}default:}},Ua=async()=>{if(!nr){if(St)throw new Error("multiple calls to 'initWasm()' detected.");if(or)throw new Error("previous call to 'initWasm()' failed.");if(St=!0,nt())return new Promise((o,t)=>{be?.terminate(),pa().then(([a,u])=>{try{be=u,be.onerror=c=>t(c),be.onmessage=Eu,en=[o,t];let s={type:"init-wasm",in:J};!s.in.wasm.wasmPaths&&(a||zr)&&(s.in.wasm.wasmPaths={wasm:new URL("ort-wasm-simd-threaded.jspi.wasm",import.meta.url).href}),be.postMessage(s),rr=a}catch(s){t(s)}},t)});try{await Ft(J.wasm),await Gt(J),nr=!0}catch(o){throw or=!0,o}finally{St=!1}}},Pa=async o=>{if(nt())return lt(),new Promise((t,a)=>{ct("init-ep",[t,a]);let u={type:"init-ep",in:{epName:o,env:J}};be.postMessage(u)});await $t(J,o)},Ra=async o=>nt()?(lt(),new Promise((t,a)=>{ct("copy-from",[t,a]);let u={type:"copy-from",in:{buffer:o}};be.postMessage(u,[o.buffer])})):Tt(o),ka=async(o,t)=>{if(nt()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return lt(),new Promise((a,u)=>{ct("create",[a,u]);let s={type:"create",in:{model:o,options:{...t}}},c=[];o instanceof Uint8Array&&c.push(o.buffer),be.postMessage(s,c)})}else return zt(o,t)},Na=async o=>{if(nt())return lt(),new Promise((t,a)=>{ct("release",[t,a]);let u={type:"release",in:o};be.postMessage(u)});jt(o)},Wa=async(o,t,a,u,s,c)=>{if(nt()){if(a.some(p=>p[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(s.some(p=>p))throw new Error("pre-allocated output tensor is not supported for proxy.");return lt(),new Promise((p,d)=>{ct("run",[p,d]);let h=a,g={type:"run",in:{sessionId:o,inputIndices:t,inputs:h,outputIndices:u,options:c}};be.postMessage(g,qt(h))})}else return Vt(o,t,a,u,s,c)},Fa=async o=>{if(nt())return lt(),new Promise((t,a)=>{ct("end-profiling",[t,a]);let u={type:"end-profiling",in:o};be.postMessage(u)});Ht(o)}});var Ga,_u,ar,$a=R(()=>{"use strict";Fe();rn();tt();Nt();Jr();Ga=(o,t)=>{switch(o.location){case"cpu":return[o.type,o.dims,o.data,"cpu"];case"gpu-buffer":return[o.type,o.dims,{gpuBuffer:o.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[o.type,o.dims,{mlTensor:o.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${o.location} for ${t()}`)}},_u=o=>{switch(o[3]){case"cpu":return new Se(o[0],o[2],o[1]);case"gpu-buffer":{let t=o[0];if(!Zt(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:a,download:u,dispose:s}=o[2];return Se.fromGpuBuffer(a,{dataType:t,dims:o[1],download:u,dispose:s})}case"ml-tensor":{let t=o[0];if(!Qt(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:a,download:u,dispose:s}=o[2];return Se.fromMLTensor(a,{dataType:t,dims:o[1],download:u,dispose:s})}default:throw new Error(`invalid data location: ${o[3]}`)}},ar=class{async fetchModelAndCopyToWasmMemory(t){return Ra(await _t(t))}async loadModel(t,a){Ze();let u;typeof t=="string"?u=await this.fetchModelAndCopyToWasmMemory(t):u=t,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await ka(u,a),Qe()}async dispose(){return Na(this.sessionId)}async run(t,a,u){Ze();let s=[],c=[];Object.entries(t).forEach(T=>{let _=T[0],C=T[1],P=this.inputNames.indexOf(_);if(P===-1)throw new Error(`invalid input '${_}'`);s.push(C),c.push(P)});let p=[],d=[];Object.entries(a).forEach(T=>{let _=T[0],C=T[1],P=this.outputNames.indexOf(_);if(P===-1)throw new Error(`invalid output '${_}'`);p.push(C),d.push(P)});let h=s.map((T,_)=>Ga(T,()=>`input "${this.inputNames[c[_]]}"`)),g=p.map((T,_)=>T?Ga(T,()=>`output "${this.outputNames[d[_]]}"`):null),y=await Wa(this.sessionId,c,h,d,g,u),v={};for(let T=0;T<y.length;T++)v[this.outputNames[d[T]]]=p[T]??_u(y[T]);return Qe(),v}startProfiling(){}endProfiling(){Fa(this.sessionId)}}});var ja={};wt(ja,{OnnxruntimeWebAssemblyBackend:()=>sr,initializeFlags:()=>za,wasmBackend:()=>Su});var za,sr,Su,Va=R(()=>{"use strict";Fe();rn();$a();za=()=>{(typeof J.wasm.initTimeout!="number"||J.wasm.initTimeout<0)&&(J.wasm.initTimeout=0);let o=J.wasm.simd;if(typeof o!="boolean"&&o!==void 0&&o!=="fixed"&&o!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${o}". Reset it to \`false\` and ignore SIMD feature checking.`),J.wasm.simd=!1),typeof J.wasm.proxy!="boolean"&&(J.wasm.proxy=!1),typeof J.wasm.trace!="boolean"&&(J.wasm.trace=!1),typeof J.wasm.numThreads!="number"||!Number.isInteger(J.wasm.numThreads)||J.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)J.wasm.numThreads=1;else{let t=typeof navigator>"u"?Ur("node:os").cpus().length:navigator.hardwareConcurrency;J.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},sr=class{async init(t){za(),await Ua(),await Pa(t)}async createInferenceSessionHandler(t,a){let u=new ar;return await u.loadModel(t,a),u}},Su=new sr});Fe();Fe();Fe();var Ko="1.23.0";var _c=Fr;{let o=(Va(),Ut(ja)).wasmBackend;Je("webgpu",o,5),Je("webnn",o,5),Je("cpu",o,10),Je("wasm",o,10)}Object.defineProperty(J.versions,"web",{value:Ko,enumerable:!0});export{Qi as InferenceSession,Vo as TRACE,Ne as TRACE_EVENT_BEGIN,We as TRACE_EVENT_END,Ze as TRACE_FUNC_BEGIN,Qe as TRACE_FUNC_END,Se as Tensor,_c as default,J as env,Je as registerBackend};
//# sourceMappingURL=ort.jspi.bundle.min.mjs.map
