/*!
 * ONNX Runtime Web v1.23.0-dev.20250906-ecb26fb775
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";
var ort = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // common/dist/esm/backend-impl.js
  var backends, backendsSortedByPriority, registerBackend, tryResolveAndInitializeBackend, resolveBackendAndExecutionProviders;
  var init_backend_impl = __esm({
    "common/dist/esm/backend-impl.js"() {
      "use strict";
      backends = /* @__PURE__ */ new Map();
      backendsSortedByPriority = [];
      registerBackend = (name, backend, priority) => {
        if (backend && typeof backend.init === "function" && typeof backend.createInferenceSessionHandler === "function") {
          const currentBackend = backends.get(name);
          if (currentBackend === void 0) {
            backends.set(name, { backend, priority });
          } else if (currentBackend.priority > priority) {
            return;
          } else if (currentBackend.priority === priority) {
            if (currentBackend.backend !== backend) {
              throw new Error(`cannot register backend "${name}" using priority ${priority}`);
            }
          }
          if (priority >= 0) {
            const i = backendsSortedByPriority.indexOf(name);
            if (i !== -1) {
              backendsSortedByPriority.splice(i, 1);
            }
            for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
              if (backends.get(backendsSortedByPriority[i2]).priority <= priority) {
                backendsSortedByPriority.splice(i2, 0, name);
                return;
              }
            }
            backendsSortedByPriority.push(name);
          }
          return;
        }
        throw new TypeError("not a valid backend");
      };
      tryResolveAndInitializeBackend = async (backendName) => {
        const backendInfo = backends.get(backendName);
        if (!backendInfo) {
          return "backend not found.";
        }
        if (backendInfo.initialized) {
          return backendInfo.backend;
        } else if (backendInfo.aborted) {
          return backendInfo.error;
        } else {
          const isInitializing = !!backendInfo.initPromise;
          try {
            if (!isInitializing) {
              backendInfo.initPromise = backendInfo.backend.init(backendName);
            }
            await backendInfo.initPromise;
            backendInfo.initialized = true;
            return backendInfo.backend;
          } catch (e) {
            if (!isInitializing) {
              backendInfo.error = `${e}`;
              backendInfo.aborted = true;
            }
            return backendInfo.error;
          } finally {
            delete backendInfo.initPromise;
          }
        }
      };
      resolveBackendAndExecutionProviders = async (options) => {
        const eps = options.executionProviders || [];
        const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
        const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
        let backend;
        const errors = [];
        const availableBackendNames = /* @__PURE__ */ new Set();
        for (const backendName of backendNames) {
          const resolveResult = await tryResolveAndInitializeBackend(backendName);
          if (typeof resolveResult === "string") {
            errors.push({ name: backendName, err: resolveResult });
          } else {
            if (!backend) {
              backend = resolveResult;
            }
            if (backend === resolveResult) {
              availableBackendNames.add(backendName);
            }
          }
        }
        if (!backend) {
          throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
        }
        for (const { name, err } of errors) {
          if (backendHints.includes(name)) {
            console.warn(`removing requested execution provider "${name}" from session options because it is not available: ${err}`);
          }
        }
        const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === "string" ? i : i.name));
        return [
          backend,
          new Proxy(options, {
            get: (target, prop) => {
              if (prop === "executionProviders") {
                return filteredEps;
              }
              return Reflect.get(target, prop);
            }
          })
        ];
      };
    }
  });

  // common/dist/esm/backend.js
  var init_backend = __esm({
    "common/dist/esm/backend.js"() {
      "use strict";
      init_backend_impl();
    }
  });

  // common/dist/esm/version.js
  var version;
  var init_version = __esm({
    "common/dist/esm/version.js"() {
      "use strict";
      version = "1.23.0-dev.20250703-7fc6235861";
    }
  });

  // common/dist/esm/env-impl.js
  var logLevelValue, env;
  var init_env_impl = __esm({
    "common/dist/esm/env-impl.js"() {
      "use strict";
      init_version();
      logLevelValue = "warning";
      env = {
        wasm: {},
        webgl: {},
        webgpu: {},
        versions: { common: version },
        set logLevel(value) {
          if (value === void 0) {
            return;
          }
          if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
            throw new Error(`Unsupported logging level: ${value}`);
          }
          logLevelValue = value;
        },
        get logLevel() {
          return logLevelValue;
        }
      };
      Object.defineProperty(env, "logLevel", { enumerable: true });
    }
  });

  // common/dist/esm/env.js
  var env2;
  var init_env = __esm({
    "common/dist/esm/env.js"() {
      "use strict";
      init_env_impl();
      env2 = env;
    }
  });

  // common/dist/esm/tensor-conversion-impl.js
  var tensorToDataURL, tensorToImageData;
  var init_tensor_conversion_impl = __esm({
    "common/dist/esm/tensor-conversion-impl.js"() {
      "use strict";
      tensorToDataURL = (tensor, options) => {
        const canvas = typeof document !== "undefined" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
        canvas.width = tensor.dims[3];
        canvas.height = tensor.dims[2];
        const pixels2DContext = canvas.getContext("2d");
        if (pixels2DContext != null) {
          let width;
          let height;
          if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
            width = tensor.dims[2];
            height = tensor.dims[3];
          } else {
            width = tensor.dims[3];
            height = tensor.dims[2];
          }
          const inputformat = options?.format !== void 0 ? options.format : "RGB";
          const norm = options?.norm;
          let normMean;
          let normBias;
          if (norm === void 0 || norm.mean === void 0) {
            normMean = [255, 255, 255, 255];
          } else {
            if (typeof norm.mean === "number") {
              normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
            } else {
              normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];
              if (norm.mean[3] !== void 0) {
                normMean[3] = norm.mean[3];
              }
            }
          }
          if (norm === void 0 || norm.bias === void 0) {
            normBias = [0, 0, 0, 0];
          } else {
            if (typeof norm.bias === "number") {
              normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
            } else {
              normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
              if (norm.bias[3] !== void 0) {
                normBias[3] = norm.bias[3];
              }
            }
          }
          const stride = height * width;
          let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
          if (inputformat === "RGBA") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
          } else if (inputformat === "RGB") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
          } else if (inputformat === "RBG") {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
          }
          for (let i = 0; i < height; i++) {
            for (let j = 0; j < width; j++) {
              const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
              const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
              const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
              const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
              pixels2DContext.fillStyle = "rgba(" + R + "," + G + "," + B + "," + A + ")";
              pixels2DContext.fillRect(j, i, 1, 1);
            }
          }
          if ("toDataURL" in canvas) {
            return canvas.toDataURL();
          } else {
            throw new Error("toDataURL is not supported");
          }
        } else {
          throw new Error("Can not access image data");
        }
      };
      tensorToImageData = (tensor, options) => {
        const pixels2DContext = typeof document !== "undefined" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d");
        let image;
        if (pixels2DContext != null) {
          let width;
          let height;
          let channels;
          if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
            width = tensor.dims[2];
            height = tensor.dims[1];
            channels = tensor.dims[3];
          } else {
            width = tensor.dims[3];
            height = tensor.dims[2];
            channels = tensor.dims[1];
          }
          const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
          const norm = options?.norm;
          let normMean;
          let normBias;
          if (norm === void 0 || norm.mean === void 0) {
            normMean = [255, 255, 255, 255];
          } else {
            if (typeof norm.mean === "number") {
              normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
            } else {
              normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];
              if (norm.mean[3] !== void 0) {
                normMean[3] = norm.mean[3];
              }
            }
          }
          if (norm === void 0 || norm.bias === void 0) {
            normBias = [0, 0, 0, 0];
          } else {
            if (typeof norm.bias === "number") {
              normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
            } else {
              normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
              if (norm.bias[3] !== void 0) {
                normBias[3] = norm.bias[3];
              }
            }
          }
          const stride = height * width;
          if (options !== void 0) {
            if (options.format !== void 0 && channels === 4 && options.format !== "RGBA" || channels === 3 && options.format !== "RGB" && options.format !== "BGR") {
              throw new Error("Tensor format doesn't match input tensor dims");
            }
          }
          const step = 4;
          let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
          let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
          if (inputformat === "RGBA") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
          } else if (inputformat === "RGB") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
          } else if (inputformat === "RBG") {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
          }
          image = pixels2DContext.createImageData(width, height);
          for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
            image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
            image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
            image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
            image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
          }
        } else {
          throw new Error("Can not access image data");
        }
        return image;
      };
    }
  });

  // common/dist/esm/tensor-factory-impl.js
  var bufferToTensor, tensorFromImage, tensorFromTexture, tensorFromGpuBuffer, tensorFromMLTensor, tensorFromPinnedBuffer;
  var init_tensor_factory_impl = __esm({
    "common/dist/esm/tensor-factory-impl.js"() {
      "use strict";
      init_tensor_impl();
      bufferToTensor = (buffer, options) => {
        if (buffer === void 0) {
          throw new Error("Image buffer must be defined");
        }
        if (options.height === void 0 || options.width === void 0) {
          throw new Error("Image height and width must be defined");
        }
        if (options.tensorLayout === "NHWC") {
          throw new Error("NHWC Tensor layout is not supported yet");
        }
        const { height, width } = options;
        const norm = options.norm ?? { mean: 255, bias: 0 };
        let normMean;
        let normBias;
        if (typeof norm.mean === "number") {
          normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
        } else {
          normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];
        }
        if (typeof norm.bias === "number") {
          normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
        } else {
          normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];
        }
        const inputformat = options.format !== void 0 ? options.format : "RGBA";
        const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
        const stride = height * width;
        const float32Data = outputformat === "RGBA" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
        let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGB") {
          step = 3;
          rImagePointer = 0;
          gImagePointer = 1;
          bImagePointer = 2;
          aImagePointer = -1;
        }
        if (outputformat === "RGBA") {
          aTensorPointer = stride * 3;
        } else if (outputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        } else if (outputformat === "BGR") {
          bTensorPointer = 0;
          gTensorPointer = stride;
          rTensorPointer = stride * 2;
        }
        for (let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
          float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
          float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
          float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
          if (aTensorPointer !== -1 && aImagePointer !== -1) {
            float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
          }
        }
        const outputTensor = outputformat === "RGBA" ? new Tensor("float32", float32Data, [1, 4, height, width]) : new Tensor("float32", float32Data, [1, 3, height, width]);
        return outputTensor;
      };
      tensorFromImage = async (image, options) => {
        const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
        const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
        const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
        const isString = typeof image === "string";
        let data;
        let bufferToTensorOptions = options ?? {};
        const createCanvas = () => {
          if (typeof document !== "undefined") {
            return document.createElement("canvas");
          } else if (typeof OffscreenCanvas !== "undefined") {
            return new OffscreenCanvas(1, 1);
          } else {
            throw new Error("Canvas is not supported");
          }
        };
        const createCanvasContext = (canvas) => {
          if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
            return canvas.getContext("2d");
          } else if (canvas instanceof OffscreenCanvas) {
            return canvas.getContext("2d");
          } else {
            return null;
          }
        };
        if (isHTMLImageEle) {
          const canvas = createCanvas();
          canvas.width = image.width;
          canvas.height = image.height;
          const pixels2DContext = createCanvasContext(canvas);
          if (pixels2DContext != null) {
            let height = image.height;
            let width = image.width;
            if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
              height = options.resizedHeight;
              width = options.resizedWidth;
            }
            if (options !== void 0) {
              bufferToTensorOptions = options;
              if (options.tensorFormat !== void 0) {
                throw new Error("Image input config format must be RGBA for HTMLImageElement");
              } else {
                bufferToTensorOptions.tensorFormat = "RGBA";
              }
              bufferToTensorOptions.height = height;
              bufferToTensorOptions.width = width;
            } else {
              bufferToTensorOptions.tensorFormat = "RGBA";
              bufferToTensorOptions.height = height;
              bufferToTensorOptions.width = width;
            }
            pixels2DContext.drawImage(image, 0, 0);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
          } else {
            throw new Error("Can not access image data");
          }
        } else if (isImageDataEle) {
          let height;
          let width;
          if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
            height = options.resizedHeight;
            width = options.resizedWidth;
          } else {
            height = image.height;
            width = image.width;
          }
          if (options !== void 0) {
            bufferToTensorOptions = options;
          }
          bufferToTensorOptions.format = "RGBA";
          bufferToTensorOptions.height = height;
          bufferToTensorOptions.width = width;
          if (options !== void 0) {
            const tempCanvas = createCanvas();
            tempCanvas.width = width;
            tempCanvas.height = height;
            const pixels2DContext = createCanvasContext(tempCanvas);
            if (pixels2DContext != null) {
              pixels2DContext.putImageData(image, 0, 0);
              data = pixels2DContext.getImageData(0, 0, width, height).data;
            } else {
              throw new Error("Can not access image data");
            }
          } else {
            data = image.data;
          }
        } else if (isImageBitmap) {
          if (options === void 0) {
            throw new Error("Please provide image config with format for Imagebitmap");
          }
          const canvas = createCanvas();
          canvas.width = image.width;
          canvas.height = image.height;
          const pixels2DContext = createCanvasContext(canvas);
          if (pixels2DContext != null) {
            const height = image.height;
            const width = image.width;
            pixels2DContext.drawImage(image, 0, 0, width, height);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
            return bufferToTensor(data, bufferToTensorOptions);
          } else {
            throw new Error("Can not access image data");
          }
        } else if (isString) {
          return new Promise((resolve, reject) => {
            const canvas = createCanvas();
            const context = createCanvasContext(canvas);
            if (!image || !context) {
              return reject();
            }
            const newImage = new Image();
            newImage.crossOrigin = "Anonymous";
            newImage.src = image;
            newImage.onload = () => {
              canvas.width = newImage.width;
              canvas.height = newImage.height;
              context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
              const img = context.getImageData(0, 0, canvas.width, canvas.height);
              bufferToTensorOptions.height = canvas.height;
              bufferToTensorOptions.width = canvas.width;
              resolve(bufferToTensor(img.data, bufferToTensorOptions));
            };
          });
        } else {
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
        if (data !== void 0) {
          return bufferToTensor(data, bufferToTensorOptions);
        } else {
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
      };
      tensorFromTexture = (texture, options) => {
        const { width, height, download, dispose } = options;
        const dims = [1, height, width, 4];
        return new Tensor({ location: "texture", type: "float32", texture, dims, download, dispose });
      };
      tensorFromGpuBuffer = (gpuBuffer, options) => {
        const { dataType, dims, download, dispose } = options;
        return new Tensor({ location: "gpu-buffer", type: dataType ?? "float32", gpuBuffer, dims, download, dispose });
      };
      tensorFromMLTensor = (mlTensor, options) => {
        const { dataType, dims, download, dispose } = options;
        return new Tensor({ location: "ml-tensor", type: dataType ?? "float32", mlTensor, dims, download, dispose });
      };
      tensorFromPinnedBuffer = (type, buffer, dims) => new Tensor({ location: "cpu-pinned", type, data: buffer, dims: dims ?? [buffer.length] });
    }
  });

  // common/dist/esm/tensor-impl-type-mapping.js
  var NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP, NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, isTypedArrayChecked, checkTypedArray;
  var init_tensor_impl_type_mapping = __esm({
    "common/dist/esm/tensor-impl-type-mapping.js"() {
      "use strict";
      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
        ["float32", Float32Array],
        ["uint8", Uint8Array],
        ["int8", Int8Array],
        ["uint16", Uint16Array],
        ["int16", Int16Array],
        ["int32", Int32Array],
        ["bool", Uint8Array],
        ["float64", Float64Array],
        ["uint32", Uint32Array],
        ["int4", Uint8Array],
        ["uint4", Uint8Array]
      ]);
      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
        [Float32Array, "float32"],
        [Uint8Array, "uint8"],
        [Int8Array, "int8"],
        [Uint16Array, "uint16"],
        [Int16Array, "int16"],
        [Int32Array, "int32"],
        [Float64Array, "float64"],
        [Uint32Array, "uint32"]
      ]);
      isTypedArrayChecked = false;
      checkTypedArray = () => {
        if (!isTypedArrayChecked) {
          isTypedArrayChecked = true;
          const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && BigInt64Array.from;
          const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && BigUint64Array.from;
          const Float16Array2 = globalThis.Float16Array;
          const isFloat16ArrayAvailable = typeof Float16Array2 !== "undefined" && Float16Array2.from;
          if (isBigInt64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
          }
          if (isBigUint64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
          }
          if (isFloat16ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Float16Array2);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array2, "float16");
          } else {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Uint16Array);
          }
        }
      };
    }
  });

  // common/dist/esm/tensor-utils-impl.js
  var calculateSize, tensorReshape;
  var init_tensor_utils_impl = __esm({
    "common/dist/esm/tensor-utils-impl.js"() {
      "use strict";
      init_tensor_impl();
      calculateSize = (dims) => {
        let size = 1;
        for (let i = 0; i < dims.length; i++) {
          const dim = dims[i];
          if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
          }
          if (dim < 0) {
            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
          }
          size *= dim;
        }
        return size;
      };
      tensorReshape = (tensor, dims) => {
        switch (tensor.location) {
          case "cpu":
            return new Tensor(tensor.type, tensor.data, dims);
          case "cpu-pinned":
            return new Tensor({
              location: "cpu-pinned",
              data: tensor.data,
              type: tensor.type,
              dims
            });
          case "texture":
            return new Tensor({
              location: "texture",
              texture: tensor.texture,
              type: tensor.type,
              dims
            });
          case "gpu-buffer":
            return new Tensor({
              location: "gpu-buffer",
              gpuBuffer: tensor.gpuBuffer,
              type: tensor.type,
              dims
            });
          case "ml-tensor":
            return new Tensor({
              location: "ml-tensor",
              mlTensor: tensor.mlTensor,
              type: tensor.type,
              dims
            });
          default:
            throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
        }
      };
    }
  });

  // common/dist/esm/tensor-impl.js
  var Tensor;
  var init_tensor_impl = __esm({
    "common/dist/esm/tensor-impl.js"() {
      "use strict";
      init_tensor_conversion_impl();
      init_tensor_factory_impl();
      init_tensor_impl_type_mapping();
      init_tensor_utils_impl();
      Tensor = class {
        /**
         * implementation.
         */
        constructor(arg0, arg1, arg2) {
          checkTypedArray();
          let type;
          let dims;
          if (typeof arg0 === "object" && "location" in arg0) {
            this.dataLocation = arg0.location;
            type = arg0.type;
            dims = arg0.dims;
            switch (arg0.location) {
              case "cpu-pinned": {
                const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);
                if (!expectedTypedArrayConstructor) {
                  throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
                }
                if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
                  throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
                }
                this.cpuData = arg0.data;
                break;
              }
              case "texture": {
                if (type !== "float32") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
                }
                this.gpuTextureData = arg0.texture;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              case "gpu-buffer": {
                if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
                }
                this.gpuBufferData = arg0.gpuBuffer;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              case "ml-tensor": {
                if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint64" && type !== "int8" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from MLTensor`);
                }
                this.mlTensorData = arg0.mlTensor;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              default:
                throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
            }
          } else {
            let data;
            let maybeDims;
            if (typeof arg0 === "string") {
              type = arg0;
              maybeDims = arg2;
              if (arg0 === "string") {
                if (!Array.isArray(arg1)) {
                  throw new TypeError("A string tensor's data must be a string array.");
                }
                data = arg1;
              } else {
                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
                if (typedArrayConstructor === void 0) {
                  throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                }
                if (Array.isArray(arg1)) {
                  if (arg0 === "float16" && typedArrayConstructor === Uint16Array || arg0 === "uint4" || arg0 === "int4") {
                    throw new TypeError(`Creating a ${arg0} tensor from number array is not supported. Please use ${typedArrayConstructor.name} as data.`);
                  } else if (arg0 === "uint64" || arg0 === "int64") {
                    data = typedArrayConstructor.from(arg1, BigInt);
                  } else {
                    data = typedArrayConstructor.from(arg1);
                  }
                } else if (arg1 instanceof typedArrayConstructor) {
                  data = arg1;
                } else if (arg1 instanceof Uint8ClampedArray) {
                  if (arg0 === "uint8") {
                    data = Uint8Array.from(arg1);
                  } else {
                    throw new TypeError(`A Uint8ClampedArray tensor's data must be type of uint8`);
                  }
                } else if (arg0 === "float16" && arg1 instanceof Uint16Array && typedArrayConstructor !== Uint16Array) {
                  data = new globalThis.Float16Array(arg1.buffer, arg1.byteOffset, arg1.length);
                } else {
                  throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
                }
              }
            } else {
              maybeDims = arg1;
              if (Array.isArray(arg0)) {
                if (arg0.length === 0) {
                  throw new TypeError("Tensor type cannot be inferred from an empty array.");
                }
                const firstElementType = typeof arg0[0];
                if (firstElementType === "string") {
                  type = "string";
                  data = arg0;
                } else if (firstElementType === "boolean") {
                  type = "bool";
                  data = Uint8Array.from(arg0);
                } else {
                  throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
                }
              } else if (arg0 instanceof Uint8ClampedArray) {
                type = "uint8";
                data = Uint8Array.from(arg0);
              } else {
                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
                if (mappedType === void 0) {
                  throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                }
                type = mappedType;
                data = arg0;
              }
            }
            if (maybeDims === void 0) {
              maybeDims = [data.length];
            } else if (!Array.isArray(maybeDims)) {
              throw new TypeError("A tensor's dims must be a number array");
            }
            dims = maybeDims;
            this.cpuData = data;
            this.dataLocation = "cpu";
          }
          const size = calculateSize(dims);
          if (this.cpuData && size !== this.cpuData.length) {
            if ((type === "uint4" || type === "int4") && Math.ceil(size / 2) === this.cpuData.length) {
            } else {
              throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
            }
          }
          this.type = type;
          this.dims = dims;
          this.size = size;
        }
        // #endregion
        // #region factory
        static async fromImage(image, options) {
          return tensorFromImage(image, options);
        }
        static fromTexture(texture, options) {
          return tensorFromTexture(texture, options);
        }
        static fromGpuBuffer(gpuBuffer, options) {
          return tensorFromGpuBuffer(gpuBuffer, options);
        }
        static fromMLTensor(mlTensor, options) {
          return tensorFromMLTensor(mlTensor, options);
        }
        static fromPinnedBuffer(type, buffer, dims) {
          return tensorFromPinnedBuffer(type, buffer, dims);
        }
        // #endregion
        // #region conversions
        toDataURL(options) {
          return tensorToDataURL(this, options);
        }
        toImageData(options) {
          return tensorToImageData(this, options);
        }
        // #endregion
        // #region properties
        get data() {
          this.ensureValid();
          if (!this.cpuData) {
            throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
          }
          return this.cpuData;
        }
        get location() {
          return this.dataLocation;
        }
        get texture() {
          this.ensureValid();
          if (!this.gpuTextureData) {
            throw new Error("The data is not stored as a WebGL texture.");
          }
          return this.gpuTextureData;
        }
        get gpuBuffer() {
          this.ensureValid();
          if (!this.gpuBufferData) {
            throw new Error("The data is not stored as a WebGPU buffer.");
          }
          return this.gpuBufferData;
        }
        get mlTensor() {
          this.ensureValid();
          if (!this.mlTensorData) {
            throw new Error("The data is not stored as a WebNN MLTensor.");
          }
          return this.mlTensorData;
        }
        // #endregion
        // #region methods
        async getData(releaseData) {
          this.ensureValid();
          switch (this.dataLocation) {
            case "cpu":
            case "cpu-pinned":
              return this.data;
            case "texture":
            case "gpu-buffer":
            case "ml-tensor": {
              if (!this.downloader) {
                throw new Error("The current tensor is not created with a specified data downloader.");
              }
              if (this.isDownloading) {
                throw new Error("The current tensor is being downloaded.");
              }
              try {
                this.isDownloading = true;
                const data = await this.downloader();
                this.downloader = void 0;
                this.dataLocation = "cpu";
                this.cpuData = data;
                if (releaseData && this.disposer) {
                  this.disposer();
                  this.disposer = void 0;
                }
                return data;
              } finally {
                this.isDownloading = false;
              }
            }
            default:
              throw new Error(`cannot get data from location: ${this.dataLocation}`);
          }
        }
        dispose() {
          if (this.isDownloading) {
            throw new Error("The current tensor is being downloaded.");
          }
          if (this.disposer) {
            this.disposer();
            this.disposer = void 0;
          }
          this.cpuData = void 0;
          this.gpuTextureData = void 0;
          this.gpuBufferData = void 0;
          this.mlTensorData = void 0;
          this.downloader = void 0;
          this.isDownloading = void 0;
          this.dataLocation = "none";
        }
        // #endregion
        // #region tensor utilities
        ensureValid() {
          if (this.dataLocation === "none") {
            throw new Error("The tensor is disposed.");
          }
        }
        reshape(dims) {
          this.ensureValid();
          if (this.downloader || this.disposer) {
            throw new Error("Cannot reshape a tensor that owns GPU resource.");
          }
          return tensorReshape(this, dims);
        }
      };
    }
  });

  // common/dist/esm/tensor.js
  var Tensor2;
  var init_tensor = __esm({
    "common/dist/esm/tensor.js"() {
      "use strict";
      init_tensor_impl();
      Tensor2 = Tensor;
    }
  });

  // common/dist/esm/trace.js
  var TRACE, TRACE_FUNC, TRACE_FUNC_BEGIN, TRACE_FUNC_END, TRACE_EVENT_BEGIN, TRACE_EVENT_END;
  var init_trace = __esm({
    "common/dist/esm/trace.js"() {
      "use strict";
      init_env_impl();
      TRACE = (deviceType, label) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        console.timeStamp(`${deviceType}::ORT::${label}`);
      };
      TRACE_FUNC = (msg, extraMsg) => {
        const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
        let hasTraceFunc = false;
        for (let i = 0; i < stack.length; i++) {
          if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {
            let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;
            if (extraMsg) {
              label += `::${extraMsg}`;
            }
            TRACE("CPU", label);
            return;
          }
          if (stack[i].includes("TRACE_FUNC")) {
            hasTraceFunc = true;
          }
        }
      };
      TRACE_FUNC_BEGIN = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        TRACE_FUNC("BEGIN", extraMsg);
      };
      TRACE_FUNC_END = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        TRACE_FUNC("END", extraMsg);
      };
      TRACE_EVENT_BEGIN = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        console.time(`ORT::${extraMsg}`);
      };
      TRACE_EVENT_END = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        console.timeEnd(`ORT::${extraMsg}`);
      };
    }
  });

  // common/dist/esm/inference-session-impl.js
  var InferenceSession;
  var init_inference_session_impl = __esm({
    "common/dist/esm/inference-session-impl.js"() {
      "use strict";
      init_backend_impl();
      init_tensor();
      init_trace();
      InferenceSession = class _InferenceSession {
        constructor(handler) {
          this.handler = handler;
        }
        async run(feeds, arg1, arg2) {
          TRACE_FUNC_BEGIN();
          TRACE_EVENT_BEGIN("InferenceSession.run");
          const fetches = {};
          let options = {};
          if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
            throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
          }
          let isFetchesEmpty = true;
          if (typeof arg1 === "object") {
            if (arg1 === null) {
              throw new TypeError("Unexpected argument[1]: cannot be null.");
            }
            if (arg1 instanceof Tensor2) {
              throw new TypeError("'fetches' cannot be a Tensor");
            }
            if (Array.isArray(arg1)) {
              if (arg1.length === 0) {
                throw new TypeError("'fetches' cannot be an empty array.");
              }
              isFetchesEmpty = false;
              for (const name of arg1) {
                if (typeof name !== "string") {
                  throw new TypeError("'fetches' must be a string array or an object.");
                }
                if (this.outputNames.indexOf(name) === -1) {
                  throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                }
                fetches[name] = null;
              }
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              let isFetches = false;
              const arg1Keys = Object.getOwnPropertyNames(arg1);
              for (const name of this.outputNames) {
                if (arg1Keys.indexOf(name) !== -1) {
                  const v = arg1[name];
                  if (v === null || v instanceof Tensor2) {
                    isFetches = true;
                    isFetchesEmpty = false;
                    fetches[name] = v;
                  }
                }
              }
              if (isFetches) {
                if (typeof arg2 === "object" && arg2 !== null) {
                  options = arg2;
                } else if (typeof arg2 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else {
                options = arg1;
              }
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
          }
          for (const name of this.inputNames) {
            if (typeof feeds[name] === "undefined") {
              throw new Error(`input '${name}' is missing in 'feeds'.`);
            }
          }
          if (isFetchesEmpty) {
            for (const name of this.outputNames) {
              fetches[name] = null;
            }
          }
          const results = await this.handler.run(feeds, fetches, options);
          const returnValue = {};
          for (const key in results) {
            if (Object.hasOwnProperty.call(results, key)) {
              const result = results[key];
              if (result instanceof Tensor2) {
                returnValue[key] = result;
              } else {
                returnValue[key] = new Tensor2(result.type, result.data, result.dims);
              }
            }
          }
          TRACE_EVENT_END("InferenceSession.run");
          TRACE_FUNC_END();
          return returnValue;
        }
        async release() {
          return this.handler.dispose();
        }
        static async create(arg0, arg1, arg2, arg3) {
          TRACE_FUNC_BEGIN();
          TRACE_EVENT_BEGIN("InferenceSession.create");
          let filePathOrUint8Array;
          let options = {};
          if (typeof arg0 === "string") {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else if (arg0 instanceof Uint8Array) {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
            const buffer = arg0;
            let byteOffset = 0;
            let byteLength = arg0.byteLength;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 === "number") {
              byteOffset = arg1;
              if (!Number.isSafeInteger(byteOffset)) {
                throw new RangeError("'byteOffset' must be an integer.");
              }
              if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
                throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
              }
              byteLength = arg0.byteLength - byteOffset;
              if (typeof arg2 === "number") {
                byteLength = arg2;
                if (!Number.isSafeInteger(byteLength)) {
                  throw new RangeError("'byteLength' must be an integer.");
                }
                if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                  throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                }
                if (typeof arg3 === "object" && arg3 !== null) {
                  options = arg3;
                } else if (typeof arg3 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'byteLength' must be a number.");
              }
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
          } else {
            throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
          }
          const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
          const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
          TRACE_EVENT_END("InferenceSession.create");
          TRACE_FUNC_END();
          return new _InferenceSession(handler);
        }
        startProfiling() {
          this.handler.startProfiling();
        }
        endProfiling() {
          this.handler.endProfiling();
        }
        get inputNames() {
          return this.handler.inputNames;
        }
        get outputNames() {
          return this.handler.outputNames;
        }
        get inputMetadata() {
          return this.handler.inputMetadata;
        }
        get outputMetadata() {
          return this.handler.outputMetadata;
        }
      };
    }
  });

  // common/dist/esm/inference-session.js
  var InferenceSession2;
  var init_inference_session = __esm({
    "common/dist/esm/inference-session.js"() {
      "use strict";
      init_inference_session_impl();
      InferenceSession2 = InferenceSession;
    }
  });

  // common/dist/esm/tensor-conversion.js
  var init_tensor_conversion = __esm({
    "common/dist/esm/tensor-conversion.js"() {
      "use strict";
    }
  });

  // common/dist/esm/tensor-factory.js
  var init_tensor_factory = __esm({
    "common/dist/esm/tensor-factory.js"() {
      "use strict";
    }
  });

  // common/dist/esm/onnx-model.js
  var init_onnx_model = __esm({
    "common/dist/esm/onnx-model.js"() {
      "use strict";
    }
  });

  // common/dist/esm/onnx-value.js
  var init_onnx_value = __esm({
    "common/dist/esm/onnx-value.js"() {
      "use strict";
    }
  });

  // common/dist/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    InferenceSession: () => InferenceSession2,
    TRACE: () => TRACE,
    TRACE_EVENT_BEGIN: () => TRACE_EVENT_BEGIN,
    TRACE_EVENT_END: () => TRACE_EVENT_END,
    TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
    TRACE_FUNC_END: () => TRACE_FUNC_END,
    Tensor: () => Tensor2,
    env: () => env2,
    registerBackend: () => registerBackend
  });
  var init_esm = __esm({
    "common/dist/esm/index.js"() {
      "use strict";
      init_backend();
      init_env();
      init_inference_session();
      init_tensor();
      init_tensor_conversion();
      init_tensor_factory();
      init_trace();
      init_onnx_model();
      init_onnx_value();
    }
  });

  // web/lib/wasm/wasm-utils-env.ts
  var isNode;
  var init_wasm_utils_env = __esm({
    "web/lib/wasm/wasm-utils-env.ts"() {
      "use strict";
      isNode = false;
    }
  });

  // web/lib/wasm/proxy-worker/main.ts
  var main_exports = {};
  __export(main_exports, {
    default: () => main_default
  });
  var WORKER_NAME, isProxyWorker, main_default;
  var init_main = __esm({
    "web/lib/wasm/proxy-worker/main.ts"() {
      "use strict";
      init_wasm_core_impl();
      init_wasm_factory();
      init_wasm_utils_import();
      WORKER_NAME = "ort-wasm-proxy-worker";
      isProxyWorker = globalThis.self?.name === WORKER_NAME;
      if (isProxyWorker) {
        self.onmessage = (ev) => {
          const { type, in: message } = ev.data;
          try {
            switch (type) {
              case "init-wasm":
                initializeWebAssembly(message.wasm).then(
                  () => {
                    initRuntime(message).then(
                      () => {
                        postMessage({ type });
                      },
                      (err) => {
                        postMessage({ type, err });
                      }
                    );
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              case "init-ep": {
                const { epName, env: env3 } = message;
                initEp(env3, epName).then(
                  () => {
                    postMessage({ type });
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "copy-from": {
                const { buffer } = message;
                const bufferData = copyFromExternalBuffer(buffer);
                postMessage({ type, out: bufferData });
                break;
              }
              case "create": {
                const { model, options } = message;
                createSession(model, options).then(
                  (sessionMetadata) => {
                    postMessage({ type, out: sessionMetadata });
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "release":
                releaseSession(message);
                postMessage({ type });
                break;
              case "run": {
                const { sessionId, inputIndices, inputs, outputIndices, options } = message;
                run(sessionId, inputIndices, inputs, outputIndices, new Array(outputIndices.length).fill(null), options).then(
                  (outputs) => {
                    if (outputs.some((o) => o[3] !== "cpu")) {
                      postMessage({ type, err: "Proxy does not support non-cpu tensor location." });
                    } else {
                      postMessage(
                        { type, out: outputs },
                        extractTransferableBuffers([...inputs, ...outputs])
                      );
                    }
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "end-profiling":
                endProfiling(message);
                postMessage({ type });
                break;
              default:
            }
          } catch (err) {
            postMessage({ type, err });
          }
        };
      }
      main_default = isProxyWorker ? null : (urlOverride) => new Worker(urlOverride ?? scriptSrc, { type: false ? "module" : "classic", name: WORKER_NAME });
    }
  });

  // web/lib/wasm/wasm-utils-import.ts
  var origin, getScriptSrc, scriptSrc, inferWasmPathPrefixFromScriptSrc, isSameOrigin, normalizeUrl, fallbackUrl, preload, dynamicImportDefault, createProxyWorker, importProxyWorker, embeddedWasmModule, importWasmModule;
  var init_wasm_utils_import = __esm({
    "web/lib/wasm/wasm-utils-import.ts"() {
      "use strict";
      init_wasm_utils_env();
      origin = isNode || typeof location === "undefined" ? void 0 : location.origin;
      getScriptSrc = () => {
        if (isNode) {
          return void 0;
        }
        if (false) {
          if (isEsmImportMetaUrlHardcodedAsFileUri) {
            const URL2 = URL;
            return new URL(new URL2("ort.js", void 0).href, origin).href;
          }
          return void 0;
        }
        return typeof document !== "undefined" ? document.currentScript?.src : (
          // use `self.location.href` if available
          typeof self !== "undefined" ? self.location?.href : void 0
        );
      };
      scriptSrc = getScriptSrc();
      inferWasmPathPrefixFromScriptSrc = () => {
        if (scriptSrc && !scriptSrc.startsWith("blob:")) {
          return scriptSrc.substring(0, scriptSrc.lastIndexOf("/") + 1);
        }
        return void 0;
      };
      isSameOrigin = (filename, prefixOverride) => {
        try {
          const baseUrl = prefixOverride ?? scriptSrc;
          const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
          return url.origin === origin;
        } catch {
          return false;
        }
      };
      normalizeUrl = (filename, prefixOverride) => {
        const baseUrl = prefixOverride ?? scriptSrc;
        try {
          const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
          return url.href;
        } catch {
          return void 0;
        }
      };
      fallbackUrl = (filename, prefixOverride) => `${prefixOverride ?? "./"}${filename}`;
      preload = async (absoluteUrl) => {
        const response = await fetch(absoluteUrl, { credentials: "same-origin" });
        const blob = await response.blob();
        return URL.createObjectURL(blob);
      };
      dynamicImportDefault = async (url) => (await import(
        /* webpackIgnore: true */
        url
      )).default;
      createProxyWorker = // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
      false ? void 0 : (init_main(), __toCommonJS(main_exports)).default;
      importProxyWorker = async () => {
        if (!scriptSrc) {
          throw new Error("Failed to load proxy worker: cannot determine the script source URL.");
        }
        if (isSameOrigin(scriptSrc)) {
          return [void 0, createProxyWorker()];
        }
        const url = await preload(scriptSrc);
        return [url, createProxyWorker(url)];
      };
      embeddedWasmModule = false ? (
        // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
        (true ? null : false ? null : null).default
      ) : void 0;
      importWasmModule = async (urlOverride, prefixOverride, isMultiThreaded, isWasmOverridden) => {
        let useEmbeddedModule = embeddedWasmModule && !(urlOverride || prefixOverride);
        if (useEmbeddedModule) {
          if (!scriptSrc) {
            if (isWasmOverridden && !isMultiThreaded) {
              useEmbeddedModule = true;
            } else {
              throw new Error("cannot determine the script source URL.");
            }
          } else {
            useEmbeddedModule = isSameOrigin(scriptSrc);
          }
        }
        if (useEmbeddedModule) {
          return [void 0, embeddedWasmModule];
        } else {
          const wasmModuleFilename = true ? "ort-wasm-simd-threaded.jsep.mjs" : false ? "ort-wasm-simd-threaded.asyncify.mjs" : "ort-wasm-simd-threaded.mjs";
          const wasmModuleUrl = urlOverride ?? normalizeUrl(wasmModuleFilename, prefixOverride);
          const needPreload = !isNode && isMultiThreaded && wasmModuleUrl && !isSameOrigin(wasmModuleUrl, prefixOverride);
          const url = needPreload ? await preload(wasmModuleUrl) : wasmModuleUrl ?? fallbackUrl(wasmModuleFilename, prefixOverride);
          return [needPreload ? url : void 0, await dynamicImportDefault(url)];
        }
      };
    }
  });

  // web/lib/wasm/wasm-factory.ts
  var wasm, initialized, initializing, aborted, isMultiThreadSupported, isSimdSupported, isRelaxedSimdSupported, initializeWebAssembly, getInstance;
  var init_wasm_factory = __esm({
    "web/lib/wasm/wasm-factory.ts"() {
      "use strict";
      init_wasm_utils_import();
      initialized = false;
      initializing = false;
      aborted = false;
      isMultiThreadSupported = () => {
        if (typeof SharedArrayBuffer === "undefined") {
          return false;
        }
        try {
          if (typeof MessageChannel !== "undefined") {
            new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
          }
          return WebAssembly.validate(
            new Uint8Array([
              0,
              97,
              115,
              109,
              1,
              0,
              0,
              0,
              1,
              4,
              1,
              96,
              0,
              0,
              3,
              2,
              1,
              0,
              5,
              4,
              1,
              3,
              1,
              1,
              10,
              11,
              1,
              9,
              0,
              65,
              0,
              254,
              16,
              2,
              0,
              26,
              11
            ])
          );
        } catch (e) {
          return false;
        }
      };
      isSimdSupported = () => {
        try {
          return WebAssembly.validate(
            new Uint8Array([
              0,
              97,
              115,
              109,
              1,
              0,
              0,
              0,
              1,
              4,
              1,
              96,
              0,
              0,
              3,
              2,
              1,
              0,
              10,
              30,
              1,
              28,
              0,
              65,
              0,
              253,
              15,
              253,
              12,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              253,
              186,
              1,
              26,
              11
            ])
          );
        } catch (e) {
          return false;
        }
      };
      isRelaxedSimdSupported = () => {
        try {
          return WebAssembly.validate(
            new Uint8Array([
              0,
              97,
              115,
              109,
              1,
              0,
              0,
              0,
              1,
              5,
              1,
              96,
              0,
              1,
              123,
              3,
              2,
              1,
              0,
              10,
              19,
              1,
              17,
              0,
              65,
              1,
              253,
              15,
              65,
              2,
              253,
              15,
              65,
              3,
              253,
              15,
              253,
              147,
              2,
              11
            ])
          );
        } catch (e) {
          return false;
        }
      };
      initializeWebAssembly = async (flags) => {
        if (initialized) {
          return Promise.resolve();
        }
        if (initializing) {
          throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
        }
        if (aborted) {
          throw new Error("previous call to 'initializeWebAssembly()' failed.");
        }
        initializing = true;
        const timeout = flags.initTimeout;
        let numThreads = flags.numThreads;
        if (flags.simd === false) {
        } else if (flags.simd === "relaxed") {
          if (!isRelaxedSimdSupported()) {
            throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.");
          }
        } else if (!isSimdSupported()) {
          throw new Error("WebAssembly SIMD is not supported in the current environment.");
        }
        const multiThreadSupported = isMultiThreadSupported();
        if (numThreads > 1 && !multiThreadSupported) {
          if (typeof self !== "undefined" && !self.crossOriginIsolated) {
            console.warn(
              "env.wasm.numThreads is set to " + numThreads + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."
            );
          }
          console.warn(
            "WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."
          );
          flags.numThreads = numThreads = 1;
        }
        const wasmPaths = flags.wasmPaths;
        const wasmPrefixOverride = typeof wasmPaths === "string" ? wasmPaths : void 0;
        const mjsPathOverrideFlag = wasmPaths?.mjs;
        const mjsPathOverride = mjsPathOverrideFlag?.href ?? mjsPathOverrideFlag;
        const wasmPathOverrideFlag = wasmPaths?.wasm;
        const wasmPathOverride = wasmPathOverrideFlag?.href ?? wasmPathOverrideFlag;
        const wasmBinaryOverride = flags.wasmBinary;
        const [objectUrl, ortWasmFactory] = await importWasmModule(
          mjsPathOverride,
          wasmPrefixOverride,
          numThreads > 1,
          !!wasmBinaryOverride || !!wasmPathOverride
        );
        let isTimeout = false;
        const tasks = [];
        if (timeout > 0) {
          tasks.push(
            new Promise((resolve) => {
              setTimeout(() => {
                isTimeout = true;
                resolve();
              }, timeout);
            })
          );
        }
        tasks.push(
          new Promise((resolve, reject) => {
            const config = {
              /**
               * The number of threads. WebAssembly will create (Module.numThreads - 1) workers. If it is 1, no worker will be
               * created.
               */
              numThreads
            };
            if (wasmBinaryOverride) {
              config.wasmBinary = wasmBinaryOverride;
            } else if (wasmPathOverride || wasmPrefixOverride) {
              config.locateFile = (fileName) => wasmPathOverride ?? wasmPrefixOverride + fileName;
            } else if (mjsPathOverride && mjsPathOverride.indexOf("blob:") !== 0) {
              config.locateFile = (fileName) => new URL(fileName, mjsPathOverride).href;
            } else if (objectUrl) {
              const inferredWasmPathPrefix = inferWasmPathPrefixFromScriptSrc();
              if (inferredWasmPathPrefix) {
                config.locateFile = (fileName) => inferredWasmPathPrefix + fileName;
              }
            }
            ortWasmFactory(config).then(
              // wasm module initialized successfully
              (module) => {
                initializing = false;
                initialized = true;
                wasm = module;
                resolve();
                if (objectUrl) {
                  URL.revokeObjectURL(objectUrl);
                }
              },
              // wasm module failed to initialize
              (what) => {
                initializing = false;
                aborted = true;
                reject(what);
              }
            );
          })
        );
        await Promise.race(tasks);
        if (isTimeout) {
          throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);
        }
      };
      getInstance = () => {
        if (initialized && wasm) {
          return wasm;
        }
        throw new Error("WebAssembly is not initialized yet.");
      };
    }
  });

  // web/lib/wasm/wasm-utils.ts
  var allocWasmString, iterateExtraOptions, checkLastError;
  var init_wasm_utils = __esm({
    "web/lib/wasm/wasm-utils.ts"() {
      "use strict";
      init_wasm_factory();
      allocWasmString = (data, allocs) => {
        const wasm2 = getInstance();
        const dataLength = wasm2.lengthBytesUTF8(data) + 1;
        const dataOffset = wasm2._malloc(dataLength);
        wasm2.stringToUTF8(data, dataOffset, dataLength);
        allocs.push(dataOffset);
        return dataOffset;
      };
      iterateExtraOptions = (options, prefix, seen, handler) => {
        if (typeof options == "object" && options !== null) {
          if (seen.has(options)) {
            throw new Error("Circular reference in options");
          } else {
            seen.add(options);
          }
        }
        Object.entries(options).forEach(([key, value]) => {
          const name = prefix ? prefix + key : key;
          if (typeof value === "object") {
            iterateExtraOptions(value, name + ".", seen, handler);
          } else if (typeof value === "string" || typeof value === "number") {
            handler(name, value.toString());
          } else if (typeof value === "boolean") {
            handler(name, value ? "1" : "0");
          } else {
            throw new Error(`Can't handle extra config type: ${typeof value}`);
          }
        });
      };
      checkLastError = (message) => {
        const wasm2 = getInstance();
        const stack = wasm2.stackSave();
        try {
          const ptrSize = wasm2.PTR_SIZE;
          const paramsOffset = wasm2.stackAlloc(2 * ptrSize);
          wasm2._OrtGetLastError(paramsOffset, paramsOffset + ptrSize);
          const errorCode = Number(wasm2.getValue(paramsOffset, ptrSize === 4 ? "i32" : "i64"));
          const errorMessagePointer = wasm2.getValue(paramsOffset + ptrSize, "*");
          const errorMessage = errorMessagePointer ? wasm2.UTF8ToString(errorMessagePointer) : "";
          throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);
        } finally {
          wasm2.stackRestore(stack);
        }
      };
    }
  });

  // web/lib/wasm/run-options.ts
  var setRunOptions;
  var init_run_options = __esm({
    "web/lib/wasm/run-options.ts"() {
      "use strict";
      init_wasm_factory();
      init_wasm_utils();
      setRunOptions = (options) => {
        const wasm2 = getInstance();
        let runOptionsHandle = 0;
        const allocs = [];
        const runOptions = options || {};
        try {
          if (options?.logSeverityLevel === void 0) {
            runOptions.logSeverityLevel = 2;
          } else if (typeof options.logSeverityLevel !== "number" || !Number.isInteger(options.logSeverityLevel) || options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
            throw new Error(`log severity level is not valid: ${options.logSeverityLevel}`);
          }
          if (options?.logVerbosityLevel === void 0) {
            runOptions.logVerbosityLevel = 0;
          } else if (typeof options.logVerbosityLevel !== "number" || !Number.isInteger(options.logVerbosityLevel)) {
            throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);
          }
          if (options?.terminate === void 0) {
            runOptions.terminate = false;
          }
          let tagDataOffset = 0;
          if (options?.tag !== void 0) {
            tagDataOffset = allocWasmString(options.tag, allocs);
          }
          runOptionsHandle = wasm2._OrtCreateRunOptions(
            runOptions.logSeverityLevel,
            runOptions.logVerbosityLevel,
            !!runOptions.terminate,
            tagDataOffset
          );
          if (runOptionsHandle === 0) {
            checkLastError("Can't create run options.");
          }
          if (options?.extra !== void 0) {
            iterateExtraOptions(options.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
              const keyDataOffset = allocWasmString(key, allocs);
              const valueDataOffset = allocWasmString(value, allocs);
              if (wasm2._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                checkLastError(`Can't set a run config entry: ${key} - ${value}.`);
              }
            });
          }
          return [runOptionsHandle, allocs];
        } catch (e) {
          if (runOptionsHandle !== 0) {
            wasm2._OrtReleaseRunOptions(runOptionsHandle);
          }
          allocs.forEach((alloc) => wasm2._free(alloc));
          throw e;
        }
      };
    }
  });

  // web/lib/wasm/session-options.ts
  var getGraphOptimzationLevel, getExecutionMode, appendDefaultOptions, appendSessionConfig, setExecutionProviders, setSessionOptions;
  var init_session_options = __esm({
    "web/lib/wasm/session-options.ts"() {
      "use strict";
      init_wasm_factory();
      init_wasm_utils();
      getGraphOptimzationLevel = (graphOptimizationLevel) => {
        switch (graphOptimizationLevel) {
          case "disabled":
            return 0;
          case "basic":
            return 1;
          case "extended":
            return 2;
          case "layout":
            return 3;
          case "all":
            return 99;
          default:
            throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);
        }
      };
      getExecutionMode = (executionMode) => {
        switch (executionMode) {
          case "sequential":
            return 0;
          case "parallel":
            return 1;
          default:
            throw new Error(`unsupported execution mode: ${executionMode}`);
        }
      };
      appendDefaultOptions = (options) => {
        if (!options.extra) {
          options.extra = {};
        }
        if (!options.extra.session) {
          options.extra.session = {};
        }
        const session = options.extra.session;
        if (!session.use_ort_model_bytes_directly) {
          session.use_ort_model_bytes_directly = "1";
        }
        if (options.executionProviders && options.executionProviders.some((ep) => (typeof ep === "string" ? ep : ep.name) === "webgpu")) {
          options.enableMemPattern = false;
        }
      };
      appendSessionConfig = (sessionOptionsHandle, key, value, allocs) => {
        const keyDataOffset = allocWasmString(key, allocs);
        const valueDataOffset = allocWasmString(value, allocs);
        if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
          checkLastError(`Can't set a session config entry: ${key} - ${value}.`);
        }
      };
      setExecutionProviders = async (sessionOptionsHandle, executionProviders, allocs) => {
        for (const ep of executionProviders) {
          let epName = typeof ep === "string" ? ep : ep.name;
          const epOptions = [];
          switch (epName) {
            case "webnn":
              epName = "WEBNN";
              if (typeof ep !== "string") {
                const webnnOptions = ep;
                const deviceType = webnnOptions?.deviceType;
                if (deviceType) {
                  appendSessionConfig(sessionOptionsHandle, "deviceType", deviceType, allocs);
                }
              }
              break;
            case "webgpu":
              if (false) {
                epName = "WebGPU";
                let customDevice;
                if (typeof ep !== "string") {
                  const customOptions = ep;
                  if (customOptions.device) {
                    if (typeof GPUDevice !== "undefined" && customOptions.device instanceof GPUDevice) {
                      customDevice = customOptions.device;
                    } else {
                      throw new Error("Invalid GPU device set in WebGPU EP options.");
                    }
                  }
                }
                const info = getInstance().webgpuRegisterDevice(customDevice);
                if (info) {
                  const [deviceId, instanceHandle, deviceHandle] = info;
                  appendEpOption(epOptions, "deviceId", deviceId.toString(), allocs);
                  appendEpOption(epOptions, "webgpuInstance", instanceHandle.toString(), allocs);
                  appendEpOption(epOptions, "webgpuDevice", deviceHandle.toString(), allocs);
                }
              } else {
                epName = "JS";
                if (typeof ep !== "string") {
                  const webgpuOptions = ep;
                  if (webgpuOptions?.preferredLayout) {
                    if (webgpuOptions.preferredLayout !== "NCHW" && webgpuOptions.preferredLayout !== "NHWC") {
                      throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${webgpuOptions.preferredLayout}`);
                    }
                    appendSessionConfig(sessionOptionsHandle, "preferredLayout", webgpuOptions.preferredLayout, allocs);
                  }
                }
              }
              break;
            case "wasm":
            case "cpu":
              continue;
            default:
              throw new Error(`not supported execution provider: ${epName}`);
          }
          const epNameDataOffset = allocWasmString(epName, allocs);
          const epOptionsCount = epOptions.length;
          let keysOffset = 0;
          let valuesOffset = 0;
          if (epOptionsCount > 0) {
            keysOffset = getInstance()._malloc(epOptionsCount * getInstance().PTR_SIZE);
            allocs.push(keysOffset);
            valuesOffset = getInstance()._malloc(epOptionsCount * getInstance().PTR_SIZE);
            allocs.push(valuesOffset);
            for (let i = 0; i < epOptionsCount; i++) {
              getInstance().setValue(keysOffset + i * getInstance().PTR_SIZE, epOptions[i][0], "*");
              getInstance().setValue(valuesOffset + i * getInstance().PTR_SIZE, epOptions[i][1], "*");
            }
          }
          if (await getInstance()._OrtAppendExecutionProvider(
            sessionOptionsHandle,
            epNameDataOffset,
            keysOffset,
            valuesOffset,
            epOptionsCount
          ) !== 0) {
            checkLastError(`Can't append execution provider: ${epName}.`);
          }
        }
      };
      setSessionOptions = async (options) => {
        const wasm2 = getInstance();
        let sessionOptionsHandle = 0;
        const allocs = [];
        const sessionOptions = options || {};
        appendDefaultOptions(sessionOptions);
        try {
          const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? "all");
          const executionMode = getExecutionMode(sessionOptions.executionMode ?? "sequential");
          const logIdDataOffset = typeof sessionOptions.logId === "string" ? allocWasmString(sessionOptions.logId, allocs) : 0;
          const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2;
          if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {
            throw new Error(`log severity level is not valid: ${logSeverityLevel}`);
          }
          const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0;
          if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {
            throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);
          }
          const optimizedModelFilePathOffset = typeof sessionOptions.optimizedModelFilePath === "string" ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs) : 0;
          sessionOptionsHandle = wasm2._OrtCreateSessionOptions(
            graphOptimizationLevel,
            !!sessionOptions.enableCpuMemArena,
            !!sessionOptions.enableMemPattern,
            executionMode,
            !!sessionOptions.enableProfiling,
            0,
            logIdDataOffset,
            logSeverityLevel,
            logVerbosityLevel,
            optimizedModelFilePathOffset
          );
          if (sessionOptionsHandle === 0) {
            checkLastError("Can't create session options.");
          }
          if (sessionOptions.executionProviders) {
            await setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);
          }
          if (sessionOptions.enableGraphCapture !== void 0) {
            if (typeof sessionOptions.enableGraphCapture !== "boolean") {
              throw new Error(`enableGraphCapture must be a boolean value: ${sessionOptions.enableGraphCapture}`);
            }
            appendSessionConfig(
              sessionOptionsHandle,
              "enableGraphCapture",
              sessionOptions.enableGraphCapture.toString(),
              allocs
            );
          }
          if (sessionOptions.freeDimensionOverrides) {
            for (const [name, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {
              if (typeof name !== "string") {
                throw new Error(`free dimension override name must be a string: ${name}`);
              }
              if (typeof value !== "number" || !Number.isInteger(value) || value < 0) {
                throw new Error(`free dimension override value must be a non-negative integer: ${value}`);
              }
              const nameOffset = allocWasmString(name, allocs);
              if (wasm2._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {
                checkLastError(`Can't set a free dimension override: ${name} - ${value}.`);
              }
            }
          }
          if (sessionOptions.extra !== void 0) {
            iterateExtraOptions(sessionOptions.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
              appendSessionConfig(sessionOptionsHandle, key, value, allocs);
            });
          }
          return [sessionOptionsHandle, allocs];
        } catch (e) {
          if (sessionOptionsHandle !== 0) {
            if (wasm2._OrtReleaseSessionOptions(sessionOptionsHandle) !== 0) {
              checkLastError("Can't release session options.");
            }
          }
          allocs.forEach((alloc) => wasm2._free(alloc));
          throw e;
        }
      };
    }
  });

  // web/lib/wasm/wasm-common.ts
  var tensorDataTypeStringToEnum, tensorDataTypeEnumToString, calculateTensorSizeInBytes, tensorTypeToTypedArrayConstructor, logLevelStringToEnum, isGpuBufferSupportedType, isMLTensorSupportedType, dataLocationStringToEnum;
  var init_wasm_common = __esm({
    "web/lib/wasm/wasm-common.ts"() {
      "use strict";
      tensorDataTypeStringToEnum = (type) => {
        switch (type) {
          case "int8":
            return 3 /* int8 */;
          case "uint8":
            return 2 /* uint8 */;
          case "bool":
            return 9 /* bool */;
          case "int16":
            return 5 /* int16 */;
          case "uint16":
            return 4 /* uint16 */;
          case "int32":
            return 6 /* int32 */;
          case "uint32":
            return 12 /* uint32 */;
          case "float16":
            return 10 /* float16 */;
          case "float32":
            return 1 /* float */;
          case "float64":
            return 11 /* double */;
          case "string":
            return 8 /* string */;
          case "int64":
            return 7 /* int64 */;
          case "uint64":
            return 13 /* uint64 */;
          case "int4":
            return 22 /* int4 */;
          case "uint4":
            return 21 /* uint4 */;
          default:
            throw new Error(`unsupported data type: ${type}`);
        }
      };
      tensorDataTypeEnumToString = (typeProto) => {
        switch (typeProto) {
          case 3 /* int8 */:
            return "int8";
          case 2 /* uint8 */:
            return "uint8";
          case 9 /* bool */:
            return "bool";
          case 5 /* int16 */:
            return "int16";
          case 4 /* uint16 */:
            return "uint16";
          case 6 /* int32 */:
            return "int32";
          case 12 /* uint32 */:
            return "uint32";
          case 10 /* float16 */:
            return "float16";
          case 1 /* float */:
            return "float32";
          case 11 /* double */:
            return "float64";
          case 8 /* string */:
            return "string";
          case 7 /* int64 */:
            return "int64";
          case 13 /* uint64 */:
            return "uint64";
          case 22 /* int4 */:
            return "int4";
          case 21 /* uint4 */:
            return "uint4";
          default:
            throw new Error(`unsupported data type: ${typeProto}`);
        }
      };
      calculateTensorSizeInBytes = (dateType, dimsOrSize) => {
        const elementSize = [
          -1,
          // undefined = 0
          4,
          // float = 1
          1,
          // uint8 = 2
          1,
          // int8 = 3
          2,
          // uint16 = 4
          2,
          // int16 = 5
          4,
          // int32 = 6
          8,
          // int64 = 7
          -1,
          // string = 8
          1,
          // bool = 9
          2,
          // float16 = 10
          8,
          // double = 11
          4,
          // uint32 = 12
          8,
          // uint64 = 13
          -1,
          // complex64 = 14
          -1,
          // complex128 = 15
          -1,
          // bfloat16 = 16
          -1,
          // FLOAT8E4M3FN = 17
          -1,
          // FLOAT8E4M3FNUZ = 18
          -1,
          // FLOAT8E5M2 = 19
          -1,
          // FLOAT8E5M2FNUZ = 20
          0.5,
          // uint4 = 21
          0.5
          // int4 = 22
        ][dateType];
        const size = typeof dimsOrSize === "number" ? dimsOrSize : dimsOrSize.reduce((a, b) => a * b, 1);
        return elementSize > 0 ? Math.ceil(size * elementSize) : void 0;
      };
      tensorTypeToTypedArrayConstructor = (type) => {
        switch (type) {
          case "float16":
            return typeof Float16Array !== "undefined" && Float16Array.from ? Float16Array : Uint16Array;
          case "float32":
            return Float32Array;
          case "uint8":
            return Uint8Array;
          case "int8":
            return Int8Array;
          case "uint16":
            return Uint16Array;
          case "int16":
            return Int16Array;
          case "int32":
            return Int32Array;
          case "bool":
            return Uint8Array;
          case "float64":
            return Float64Array;
          case "uint32":
            return Uint32Array;
          case "int64":
            return BigInt64Array;
          case "uint64":
            return BigUint64Array;
          default:
            throw new Error(`unsupported type: ${type}`);
        }
      };
      logLevelStringToEnum = (logLevel) => {
        switch (logLevel) {
          case "verbose":
            return 0;
          case "info":
            return 1;
          case "warning":
            return 2;
          case "error":
            return 3;
          case "fatal":
            return 4;
          default:
            throw new Error(`unsupported logging level: ${logLevel}`);
        }
      };
      isGpuBufferSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint8" || type === "bool" || type === "uint4" || type === "int4";
      isMLTensorSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint64" || type === "int8" || type === "uint8" || type === "bool" || type === "uint4" || type === "int4";
      dataLocationStringToEnum = (location2) => {
        switch (location2) {
          case "none":
            return 0;
          case "cpu":
            return 1;
          case "cpu-pinned":
            return 2;
          case "texture":
            return 3;
          case "gpu-buffer":
            return 4;
          case "ml-tensor":
            return 5;
          default:
            throw new Error(`unsupported data location: ${location2}`);
        }
      };
    }
  });

  // web/lib/wasm/wasm-utils-load-file.ts
  var loadFile;
  var init_wasm_utils_load_file = __esm({
    "web/lib/wasm/wasm-utils-load-file.ts"() {
      "use strict";
      init_wasm_utils_env();
      loadFile = async (file) => {
        if (typeof file === "string") {
          if (isNode) {
            try {
              const { readFile } = __require("node:fs/promises");
              return new Uint8Array(await readFile(file));
            } catch (e) {
              if (e.code === "ERR_FS_FILE_TOO_LARGE") {
                const { createReadStream } = __require("node:fs");
                const stream = createReadStream(file);
                const chunks = [];
                for await (const chunk of stream) {
                  chunks.push(chunk);
                }
                return new Uint8Array(Buffer.concat(chunks));
              }
              throw e;
            }
          } else {
            const response = await fetch(file);
            if (!response.ok) {
              throw new Error(`failed to load external data file: ${file}`);
            }
            const contentLengthHeader = response.headers.get("Content-Length");
            const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;
            if (fileSize < 1073741824) {
              return new Uint8Array(await response.arrayBuffer());
            } else {
              if (!response.body) {
                throw new Error(`failed to load external data file: ${file}, no response body.`);
              }
              const reader = response.body.getReader();
              let buffer;
              try {
                buffer = new ArrayBuffer(fileSize);
              } catch (e) {
                if (e instanceof RangeError) {
                  const pages = Math.ceil(fileSize / 65536);
                  buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;
                } else {
                  throw e;
                }
              }
              let offset = 0;
              while (true) {
                const { done, value } = await reader.read();
                if (done) {
                  break;
                }
                const chunkSize = value.byteLength;
                const chunk = new Uint8Array(buffer, offset, chunkSize);
                chunk.set(value);
                offset += chunkSize;
              }
              return new Uint8Array(buffer, 0, fileSize);
            }
          }
        } else if (file instanceof Blob) {
          return new Uint8Array(await file.arrayBuffer());
        } else if (file instanceof Uint8Array) {
          return file;
        } else {
          return new Uint8Array(file);
        }
      };
    }
  });

  // web/lib/wasm/jsep/log.ts
  var logLevelPrefix, doLog, configLogLevel, debug, configureLogger, LOG, LOG_DEBUG;
  var init_log = __esm({
    "web/lib/wasm/jsep/log.ts"() {
      "use strict";
      init_wasm_common();
      logLevelPrefix = ["V", "I", "W", "E", "F"];
      doLog = (level, message) => {
        console.log(`[${logLevelPrefix[level]},${(/* @__PURE__ */ new Date()).toISOString()}]${message}`);
      };
      configureLogger = ($configLogLevel, $debug) => {
        configLogLevel = $configLogLevel;
        debug = $debug;
      };
      LOG = (logLevel, msg) => {
        const messageLevel = logLevelStringToEnum(logLevel);
        const configLevel = logLevelStringToEnum(configLogLevel);
        if (messageLevel >= configLevel) {
          doLog(messageLevel, typeof msg === "function" ? msg() : msg);
        }
      };
      LOG_DEBUG = (...args) => {
        if (debug) {
          LOG(...args);
        }
      };
    }
  });

  // web/lib/wasm/jsep/util.ts
  var MatMulUtil, BroadcastUtil, ShapeUtil, PoolConvUtil, GemmUtil, MIN_CLIP, MAX_CLIP;
  var init_util = __esm({
    "web/lib/wasm/jsep/util.ts"() {
      "use strict";
      MatMulUtil = class {
        /**
         * Calculate the expected shape when matrix multiplication
         * @param a The shape of tensor A. Should be a tuple of 2 positive integers
         * @param b The shape of tensor B. Should be a tuple of 2 positive integers
         * @returns The expected shape of the result, or undefined if N/A
         */
        static calcMatMulShape(a, b) {
          return a[1] !== b[0] ? void 0 : [a[0], b[1]];
        }
      };
      BroadcastUtil = class {
        /**
         * Calculate the expected shape when broadcasting 2 tensors
         * @param a The shape of tensor A. Should be an array of positive integers
         * @param b The shape of tensor B. Should be an array of positive integers
         * @param isMatMul Whether the operation is MatMul
         * @returns The expected shape of the result, or undefined if N/A
         */
        static calcShape(adims, bdims, isMatMul = false) {
          const arank = adims.length;
          const brank = bdims.length;
          if (arank === 0) {
            return bdims;
          }
          if (brank === 0) {
            return adims;
          }
          const crank = Math.max(adims.length, bdims.length);
          const cdims = new Array(crank);
          if (isMatMul) {
            if (arank < 2 || brank < 2) {
              return void 0;
            }
            const cShapeMatMul = MatMulUtil.calcMatMulShape(
              [adims[arank - 2], adims[arank - 1]],
              [bdims[brank - 2], bdims[brank - 1]]
            );
            if (cShapeMatMul === void 0) {
              return void 0;
            }
            [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;
          }
          for (let i = isMatMul ? 3 : 1; i <= crank; i++) {
            const aLen = arank - i < 0 ? 1 : adims[arank - i];
            const bLen = brank - i < 0 ? 1 : bdims[brank - i];
            if (aLen !== bLen && aLen > 1 && bLen > 1) {
              return void 0;
            }
            const max = Math.max(aLen, bLen);
            if (aLen && bLen) {
              cdims[crank - i] = Math.max(aLen, bLen);
            } else {
              if (max > 1) {
                return void 0;
              }
              cdims[crank - i] = 0;
            }
          }
          return cdims;
        }
        /**
         * Determine if a shape is unidirectional broadcastable to another shape
         * @param shape The input shape
         * @param finalShape The desired shape after broadcasting
         */
        static isValidBroadcast(shape, finalShape) {
          const inputRank = shape.length;
          const finalRank = finalShape.length;
          if (inputRank > finalRank) {
            return false;
          }
          for (let i = 1; i <= inputRank; i++) {
            if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {
              return false;
            }
          }
          return true;
        }
      };
      ShapeUtil = class _ShapeUtil {
        /**
         * calculate the size (number of elements)
         */
        static size(dims) {
          return _ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);
        }
        /**
         * convert dims corresponding to type change to pack. ex. uint8 data to uint32
         */
        static convertShape(dims, size = 4) {
          const rank = dims.length;
          if (rank === 0) {
            return [];
          }
          const newDims = new Array(rank);
          let i = rank - 1;
          while (i >= 0) {
            if (dims[i] % size === 0) {
              newDims[i] = dims[i] / size;
              break;
            }
            if (size % dims[i] !== 0) {
              throw new Error("cannot convert shape");
            }
            newDims[i] = 1;
            size /= dims[i];
            i--;
          }
          for (i--; i >= 0; i--) {
            newDims[i] = dims[i];
          }
          return newDims;
        }
        /**
         * calculate the size (number of elements) from the given axis (inclusive)
         */
        static sizeFromDimension(dims, axis) {
          if (axis < 0 || axis > dims.length) {
            throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);
          }
          return _ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);
        }
        /**
         * calculate the size (number of elements) to the given axis (exclusive)
         */
        static sizeToDimension(dims, axis) {
          if (axis < 0 || axis > dims.length) {
            throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);
          }
          return _ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);
        }
        /**
         * calculate the size (number of elements) from and to the given axis [start, end)
         */
        static getSizeFromDimensionRange(dims, start, end) {
          let size = 1;
          for (let i = start; i < end; i++) {
            if (dims[i] < 0) {
              throw new Error(
                // eslint-disable-next-line max-len
                "cannot get valid size from specified dimension range. Most likely the range contains negative values in them."
              );
            }
            size *= Number(dims[i]);
          }
          return size;
        }
        static computeStrides(dims) {
          const rank = dims.length;
          if (rank === 0) {
            return [];
          } else if (rank === 1) {
            return [1];
          }
          const strides = new Array(rank);
          strides[rank - 1] = 1;
          strides[rank - 2] = dims[rank - 1];
          for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * dims[i + 1];
          }
          return strides;
        }
        /**
         * normalize axis of range [-r, r) into [0, r).
         */
        static normalizeAxis(axis, tensorRank) {
          if (axis < -tensorRank && axis >= tensorRank) {
            throw new Error("unsupported axis for this operation.");
          }
          return axis < 0 ? axis + tensorRank : axis;
        }
        static normalizeAxes(axes, tensorRank) {
          return axes.map((x) => this.normalizeAxis(x, tensorRank ?? axes.length));
        }
        /**
         * Sorts a given array based on the indices in the Perm array
         * Used in Transpose
         * @param a Array to be sorted such as dims or strides
         * @param perm Perm given; if null a will be reversed
         */
        static sortBasedOnPerm(a, perm) {
          if (perm) {
            return perm.map((v) => a[v]);
          } else {
            return a.slice().reverse();
          }
        }
        /**
         * Pads a given shape according to the padding values
         * @param dims shape of the Tensor to be padded
         * @param pad pad values
         */
        static padShape(dims, pad2) {
          const rank = dims.length;
          return dims.map((v, i) => v + pad2[i] + pad2[i + rank]);
        }
        /**
         * Determines if the two shapes are identical
         * @param shape1
         * @param shape2
         */
        static areEqual(shape1, shape2) {
          if (shape1.length !== shape2.length) {
            return false;
          }
          return shape1.every((v, i) => v === shape2[i]);
        }
      };
      PoolConvUtil = class _PoolConvUtil {
        /**
         * Adjust the kernel, strides, pads to correct rank. Set to default value if not present
         * @param isGlobalOperator If true, perform global pooling.
         * @param inputDims The input tensor dimension.
         * @param kernelShape The size of the kernel along each axis.
         * @param strides Stride along each axis.
         * @param dilations Dilation along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         */
        static adjustPoolAttributes(isGlobalOperator, inputDims, kernelShape, strides, dilations, pads) {
          if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {
            throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
          }
          if (isGlobalOperator) {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              if (dim >= kernelShape.length) {
                kernelShape.push(inputDims[dim + 2]);
              } else {
                kernelShape[dim] = inputDims[dim + 2];
              }
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (dim < strides.length) {
              if (strides[dim] < 0) {
                throw new Error("strides should be greater than or equal to 1");
              }
            } else {
              strides.push(1);
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (dim < dilations.length) {
              if (dilations[dim] < 0) {
                throw new Error("dilations should be greater than or equal to 1");
              }
            } else {
              dilations.push(1);
            }
          }
          for (let dim = 0; dim < kernelShape.length * 2; dim++) {
            if (dim < pads.length) {
              if (pads[dim] < 0) {
                throw new Error("pad should be greater than or equal to 1");
              }
            } else {
              pads.push(0);
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (kernelShape[dim] <= 0) {
              throw new Error("kernel shapes need to be greater than 0");
            }
            if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {
              throw new Error("pads should be smaller than kernel");
            }
          }
        }
        // adjust pad values based on 'autoPad' attribute
        static adjustPadsBasedOnAutoPad(inputDims, strides, dilations, kernelShape, pads, isChannelLast, autoPad) {
          if (!autoPad) {
            return;
          }
          if (pads.length !== 2 * (inputDims.length - 2)) {
            throw new Error("length of pads should be twice the length of data dimensions");
          }
          if (strides.length !== inputDims.length - 2) {
            throw new Error("length of strides should be the length of data dimensions");
          }
          if (kernelShape.length !== inputDims.length - 2) {
            throw new Error("length of kernel shapes should be the length of data dimensions");
          }
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            _PoolConvUtil.adjustPadAndReturnShape(
              inputDims[dim + (isChannelLast ? 1 : 2)],
              strides[dim],
              dilations[dim],
              kernelShape[dim],
              pads,
              dim,
              dim + inputDims.length - 2,
              autoPad
            );
          }
        }
        /**
         * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)
         * @param isGlobalOperator If true, perform global pooling.
         * @param inputDims The input tensor dimension. (inputs[0].dims)
         * @param strides Stride along each axis.
         * @param dilations Dilation along each axis.
         * @param kernelShape The size of the kernel along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
         *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
         */
        static computePoolOutputShape(isGlobalOperator, inputDims, strides, dilations, kernelShape, pads, autoPad) {
          if (inputDims.length <= 0) {
            throw new Error("input shape must be of size greater than 0");
          }
          const outputDims = [inputDims[0], inputDims[1]];
          _PoolConvUtil.computeShapeHelper(
            isGlobalOperator,
            inputDims,
            outputDims,
            strides,
            dilations,
            kernelShape,
            pads,
            autoPad
          );
          return outputDims;
        }
        /**
         * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)
         * @param inputDims The input tensor dimension. (inputs[0].dims)
         * @param filterDims The filter tensor dimension. (inputs[1].dims)
         * @param strides Stride along each axis.
         * @param kernelShape The size of the kernel along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
         *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
         */
        static computeConvOutputShape(inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {
          if (inputDims.length <= 0 || filterDims.length <= 0) {
            throw new Error("invalid input tensor dims or invalid filter tensor dims");
          }
          const outputDims = [inputDims[0], filterDims[0]];
          _PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
          return outputDims;
        }
        // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels
        // called by computePoolOutputShape() and computeConvOutputShape()
        // adjust pads based on 'autoPad' attribute prior to shape computation
        static computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {
          if (isGlobalOperator) {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              outputDims.push(1);
            }
          } else {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              outputDims.push(
                _PoolConvUtil.adjustPadAndReturnShape(
                  inputDims[dim + 2],
                  strides[dim],
                  dilations[dim],
                  kernelShape[dim],
                  pads,
                  dim,
                  dim + inputDims.length - 2,
                  autoPad
                )
              );
            }
          }
        }
        // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()
        // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension
        static adjustPadAndReturnShape(inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {
          const dkernel = dilation * (kernel - 1) + 1;
          if (autoPad && autoPad !== "NOTSET") {
            switch (autoPad) {
              case "VALID":
                pads[padHeadIndex] = 0;
                pads[padTailIndex] = 0;
                return Math.floor((inSize - dkernel) / stride + 1);
              case "SAME_LOWER":
              case "SAME_UPPER":
                if (dilation !== 1) {
                  throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                } else {
                  const legacyTargetSize = (inSize + stride - 1) / stride;
                  const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;
                  pads[padHeadIndex] = autoPad === "SAME_LOWER" ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);
                  pads[padTailIndex] = padNeeded - pads[padHeadIndex];
                  return Math.floor((inSize + padNeeded - kernel) / stride + 1);
                }
              default:
                throw new Error("Unsupported AutoPad type");
            }
          } else {
            return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);
          }
        }
      };
      GemmUtil = class {
        // will make sure input shapes are compatible for this op
        // and return back the shape of the output in the form of a tuple
        // will throw exception if the input shapes are not compatible
        static getShapeOfGemmResult(leftShape, transLeft, rightShape, transRight, biasShape) {
          if (leftShape.length !== 2 || rightShape.length !== 2) {
            throw new Error("shape need to be of size 2");
          }
          let M;
          let K;
          let N;
          if (transLeft) {
            M = leftShape[1];
            K = leftShape[0];
          } else {
            M = leftShape[0];
            K = leftShape[1];
          }
          let kDim = -1;
          if (transRight) {
            N = rightShape[0];
            kDim = 1;
          } else {
            N = rightShape[1];
            kDim = 0;
          }
          if (rightShape[kDim] !== K) {
            throw new Error("dimension mismatch");
          }
          if (M <= 0 || N <= 0 || K <= 0) {
            throw new Error("invalid shape specified");
          }
          if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {
            throw new Error("gemm: invalid bias shape for broadcast");
          }
          return [M, N, K];
        }
      };
      MIN_CLIP = -34028234663852886e22;
      MAX_CLIP = 34028234663852886e22;
    }
  });

  // web/lib/wasm/jsep/tensor-view.ts
  var createView;
  var init_tensor_view = __esm({
    "web/lib/wasm/jsep/tensor-view.ts"() {
      "use strict";
      init_wasm_common();
      createView = (dataBuffer, type) => new (tensorTypeToTypedArrayConstructor(type))(dataBuffer);
    }
  });

  // web/lib/wasm/jsep/webnn/tensor-manager.ts
  var webnnDataTypeToSize, convertDataToInt32, convertInt32ToData, tensorGuid, createNewTensorId, webnnDataTypeToFallback, calculateByteLength, TensorWrapper, TensorIdTracker, TensorManagerImpl, createTensorManager;
  var init_tensor_manager = __esm({
    "web/lib/wasm/jsep/webnn/tensor-manager.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      webnnDataTypeToSize = /* @__PURE__ */ new Map([
        ["float32", 32],
        ["float16", 16],
        ["int32", 32],
        ["uint32", 32],
        ["int64", 64],
        ["uint64", 64],
        ["int8", 8],
        ["uint8", 8],
        ["int4", 4],
        ["uint4", 4]
      ]);
      convertDataToInt32 = (data, dataType) => {
        if (dataType === "int32") {
          return data;
        }
        const dataTypeSize = webnnDataTypeToSize.get(dataType);
        if (!dataTypeSize) {
          throw new Error(`WebNN backend does not support data type: ${dataType}`);
        }
        const bytesPerElement = dataTypeSize / 8;
        if (data.byteLength % bytesPerElement !== 0) {
          throw new Error(`Invalid Uint8Array length - must be a multiple of ${bytesPerElement}.`);
        }
        const numElements = data.byteLength / bytesPerElement;
        const originalArray = new (tensorTypeToTypedArrayConstructor(dataType))(data.buffer, data.byteOffset, numElements);
        switch (dataType) {
          case "int64":
          case "uint64": {
            const int32Array = new Int32Array(numElements);
            for (let i = 0; i < numElements; i++) {
              const value = originalArray[i];
              if (value > 2147483647n || value < -2147483648n) {
                throw new Error(`Can not convert int64 data to int32 - value out of range.`);
              }
              int32Array[i] = Number(value);
            }
            return new Uint8Array(int32Array.buffer);
          }
          case "int8":
          case "uint8":
          case "uint32": {
            if (dataType === "uint32") {
              if (originalArray.some((value) => value > 2147483647)) {
                throw new Error(`Can not convert uint32 data to int32 - value out of range.`);
              }
            }
            const int32Array = Int32Array.from(originalArray, Number);
            return new Uint8Array(int32Array.buffer);
          }
          default:
            throw new Error(`Unsupported data conversion from ${dataType} to 'int32'`);
        }
      };
      convertInt32ToData = (data, dataType) => {
        if (dataType === "int32") {
          return data;
        }
        if (data.byteLength % 4 !== 0) {
          throw new Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");
        }
        const numElements = data.byteLength / 4;
        const int32Array = new Int32Array(data.buffer, data.byteOffset, numElements);
        switch (dataType) {
          case "int64": {
            const bigInt64Array = BigInt64Array.from(int32Array, BigInt);
            return new Uint8Array(bigInt64Array.buffer);
          }
          case "uint64": {
            if (int32Array.some((value) => value < 0)) {
              throw new Error("Can not convert int32 data to uin64 - negative value found.");
            }
            const bigUint64Array = BigUint64Array.from(int32Array, BigInt);
            return new Uint8Array(bigUint64Array.buffer);
          }
          case "int8": {
            if (int32Array.some((value) => value < -128 || value > 127)) {
              throw new Error("Can not convert int32 data to int8 - value out of range.");
            }
            const int8Array = Int8Array.from(int32Array, Number);
            return new Uint8Array(int8Array.buffer);
          }
          case "uint8": {
            if (int32Array.some((value) => value < 0 || value > 255)) {
              throw new Error("Can not convert int32 data to uint8 - value out of range.");
            }
            return Uint8Array.from(int32Array, Number);
          }
          case "uint32": {
            if (int32Array.some((value) => value < 0)) {
              throw new Error("Can not convert int32 data to uint32 - negative value found.");
            }
            const uint32Array = Uint32Array.from(int32Array, Number);
            return new Uint8Array(uint32Array.buffer);
          }
          default:
            throw new Error(`Unsupported data conversion from 'int32' to ${dataType}`);
        }
      };
      tensorGuid = 1;
      createNewTensorId = () => tensorGuid++;
      webnnDataTypeToFallback = /* @__PURE__ */ new Map([
        ["int8", "int32"],
        ["uint8", "int32"],
        ["uint32", "int32"],
        ["int64", "int32"]
      ]);
      calculateByteLength = (dataType, shape) => {
        const dataTypeSize = webnnDataTypeToSize.get(dataType);
        if (!dataTypeSize) {
          throw new Error(`WebNN backend does not support data type: ${dataType}`);
        }
        return shape.length > 0 ? Math.ceil(shape.reduce((a, b) => a * b) * dataTypeSize / 8) : 0;
      };
      TensorWrapper = class {
        constructor(descriptor) {
          // This flag is used to indicate whether the data has been converted to fallback data type.
          this.isDataConverted = false;
          const { sessionId, context, tensor, dataType, shape, fallbackDataType } = descriptor;
          this.sessionId = sessionId;
          this.mlContext = context;
          this.mlTensor = tensor;
          this.dataType = dataType;
          this.tensorShape = shape;
          this.fallbackDataType = fallbackDataType;
        }
        get tensor() {
          return this.mlTensor;
        }
        get type() {
          return this.dataType;
        }
        get fallbackType() {
          return this.fallbackDataType;
        }
        get shape() {
          return this.tensorShape;
        }
        get byteLength() {
          return calculateByteLength(this.dataType, this.tensorShape);
        }
        destroy() {
          LOG_DEBUG("verbose", () => "[WebNN] TensorWrapper.destroy");
          this.mlTensor.destroy();
        }
        write(data) {
          this.mlContext.writeTensor(this.mlTensor, data);
        }
        async read(dstBuffer) {
          if (this.fallbackDataType) {
            const data = await this.mlContext.readTensor(this.mlTensor);
            const originalData = convertInt32ToData(new Uint8Array(data), this.dataType);
            if (dstBuffer) {
              const targetBuffer = dstBuffer instanceof ArrayBuffer ? new Uint8Array(dstBuffer) : new Uint8Array(dstBuffer.buffer, dstBuffer.byteOffset, dstBuffer.byteLength);
              targetBuffer.set(originalData);
              return void 0;
            } else {
              return originalData.buffer;
            }
          } else {
            return dstBuffer ? this.mlContext.readTensor(this.mlTensor, dstBuffer) : this.mlContext.readTensor(this.mlTensor);
          }
        }
        canReuseTensor(context, dataType, shape) {
          return this.mlContext === context && this.dataType === dataType && this.tensorShape.length === shape.length && this.tensorShape.every((v, i) => v === shape[i]);
        }
        setIsDataConverted(isConverted) {
          this.isDataConverted = isConverted;
        }
      };
      TensorIdTracker = class {
        constructor(tensorManager, wrapper) {
          this.tensorManager = tensorManager;
          this.wrapper = wrapper;
        }
        get tensorWrapper() {
          return this.wrapper;
        }
        releaseTensor() {
          if (this.tensorWrapper) {
            this.tensorManager.releaseTensor(this.tensorWrapper);
            this.wrapper = void 0;
          }
        }
        async ensureTensor(sessionId, dataType, shape, copyOld) {
          const context = this.tensorManager.getMLContext(sessionId);
          const opLimits = this.tensorManager.getMLOpSupportLimits(sessionId);
          let fallbackDataType;
          if (!opLimits?.input.dataTypes.includes(dataType)) {
            fallbackDataType = webnnDataTypeToFallback.get(dataType);
            if (!fallbackDataType || opLimits?.input.dataTypes.includes(fallbackDataType)) {
              throw new Error(`WebNN backend does not support data type: ${dataType}`);
            }
            LOG_DEBUG(
              "verbose",
              () => `[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${dataType} to ${fallbackDataType}`
            );
          }
          if (this.wrapper) {
            if (this.wrapper.canReuseTensor(context, dataType, shape)) {
              return this.wrapper.tensor;
            } else {
              if (copyOld) {
                if (this.wrapper.byteLength !== calculateByteLength(dataType, shape)) {
                  throw new Error("Unable to copy data to tensor with different size.");
                }
                this.activeUpload = new Uint8Array(await this.wrapper.read());
              }
              this.tensorManager.releaseTensor(this.wrapper);
            }
          }
          const usage = typeof MLTensorUsage == "undefined" ? void 0 : MLTensorUsage.READ | MLTensorUsage.WRITE;
          this.wrapper = await this.tensorManager.getCachedTensor(
            sessionId,
            dataType,
            shape,
            usage,
            true,
            true,
            fallbackDataType
          );
          if (copyOld && this.activeUpload) {
            this.wrapper.write(this.activeUpload);
            this.activeUpload = void 0;
          }
          return this.wrapper.tensor;
        }
        upload(data) {
          let newData = data;
          if (this.wrapper) {
            if (this.wrapper.fallbackType) {
              if (this.wrapper.fallbackType === "int32") {
                newData = convertDataToInt32(data, this.wrapper.type);
                this.wrapper.setIsDataConverted(true);
              } else {
                throw new Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);
              }
            }
            if (data.byteLength === this.wrapper.byteLength) {
              this.wrapper.write(newData);
              return;
            } else {
              LOG_DEBUG("verbose", () => "Data size does not match tensor size. Releasing tensor.");
              this.releaseTensor();
            }
          }
          if (this.activeUpload) {
            this.activeUpload.set(newData);
          } else {
            this.activeUpload = new Uint8Array(newData);
          }
        }
        async download(dstBuffer) {
          if (this.activeUpload) {
            const dstData = this.wrapper?.isDataConverted ? convertInt32ToData(this.activeUpload, this.wrapper?.type) : this.activeUpload;
            if (dstBuffer) {
              if (dstBuffer instanceof ArrayBuffer) {
                new Uint8Array(dstBuffer).set(dstData);
              } else {
                new Uint8Array(dstBuffer.buffer, dstBuffer.byteOffset, dstBuffer.byteLength).set(dstData);
              }
              return;
            } else {
              return dstData.buffer;
            }
          }
          if (!this.wrapper) {
            throw new Error("Tensor has not been created.");
          }
          if (!dstBuffer) {
            return this.wrapper.read();
          }
          return this.wrapper.read(dstBuffer);
        }
      };
      TensorManagerImpl = class {
        constructor(backend) {
          this.backend = backend;
          this.tensorTrackersById = /* @__PURE__ */ new Map();
          this.freeTensors = [];
          this.externalTensors = /* @__PURE__ */ new Set();
        }
        getMLContext(sessionId) {
          const context = this.backend.getMLContext(sessionId);
          if (!context) {
            throw new Error("MLContext not found for session.");
          }
          return context;
        }
        getMLOpSupportLimits(sessionId) {
          return this.backend.getMLOpSupportLimits(sessionId);
        }
        reserveTensorId() {
          const tensorId = createNewTensorId();
          this.tensorTrackersById.set(tensorId, new TensorIdTracker(this));
          return tensorId;
        }
        releaseTensorId(tensorId) {
          const tensorTracker = this.tensorTrackersById.get(tensorId);
          if (!tensorTracker) {
            return;
          }
          this.tensorTrackersById.delete(tensorId);
          if (tensorTracker.tensorWrapper) {
            this.releaseTensor(tensorTracker.tensorWrapper);
          }
        }
        async ensureTensor(sessionId, tensorId, dataType, shape, copyOld) {
          LOG_DEBUG(
            "verbose",
            () => `[WebNN] TensorManager.ensureTensor {tensorId: ${tensorId}, dataType: ${dataType}, shape: ${shape}, copyOld: ${copyOld}}`
          );
          const tensor = this.tensorTrackersById.get(tensorId);
          if (!tensor) {
            throw new Error("Tensor not found.");
          }
          return tensor.ensureTensor(sessionId, dataType, shape, copyOld);
        }
        upload(tensorId, data) {
          const tensor = this.tensorTrackersById.get(tensorId);
          if (!tensor) {
            throw new Error("Tensor not found.");
          }
          tensor.upload(data);
        }
        async download(tensorId, dstBuffer) {
          LOG_DEBUG(
            "verbose",
            () => `[WebNN] TensorManager.download {tensorId: ${tensorId}, dstBuffer: ${dstBuffer?.byteLength}}`
          );
          const tensorTracker = this.tensorTrackersById.get(tensorId);
          if (!tensorTracker) {
            throw new Error("Tensor not found.");
          }
          return tensorTracker.download(dstBuffer);
        }
        releaseTensorsForSession(sessionId) {
          for (const tensor of this.freeTensors) {
            if (tensor.sessionId === sessionId) {
              tensor.destroy();
            }
          }
          this.freeTensors = this.freeTensors.filter((tensor) => tensor.sessionId !== sessionId);
        }
        registerTensor(sessionId, mlTensor, dataType, shape) {
          const context = this.getMLContext(sessionId);
          const tensorId = createNewTensorId();
          const wrapper = new TensorWrapper({
            sessionId,
            context,
            tensor: mlTensor,
            dataType,
            shape
          });
          this.tensorTrackersById.set(tensorId, new TensorIdTracker(this, wrapper));
          this.externalTensors.add(wrapper);
          return tensorId;
        }
        /**
         * Get or create an MLTensor with the given data type and shape.
         */
        async getCachedTensor(sessionId, dataType, shape, usage, writable, readable, fallbackDataType) {
          const context = this.getMLContext(sessionId);
          for (const [index, tensor2] of this.freeTensors.entries()) {
            if (tensor2.canReuseTensor(context, dataType, shape)) {
              LOG_DEBUG(
                "verbose",
                () => `[WebNN] Reusing tensor {dataType: ${dataType}, ${fallbackDataType ? `fallbackDataType: ${fallbackDataType},` : ""} shape: ${shape}`
              );
              const wrapper = this.freeTensors.splice(index, 1)[0];
              wrapper.sessionId = sessionId;
              return wrapper;
            }
          }
          LOG_DEBUG(
            "verbose",
            () => `[WebNN] MLContext.createTensor {dataType: ${dataType}, ${fallbackDataType ? `fallbackDataType: ${fallbackDataType},` : ""} shape: ${shape}}`
          );
          const tensor = await context.createTensor({
            dataType: fallbackDataType ?? dataType,
            // If fallback data type is provided, use it.
            shape,
            dimensions: shape,
            usage,
            writable,
            readable
          });
          return new TensorWrapper({ sessionId, context, tensor, dataType, shape, fallbackDataType });
        }
        /**
         * Release tensor for reuse unless external.
         */
        releaseTensor(tensorWrapper) {
          if (this.externalTensors.has(tensorWrapper)) {
            this.externalTensors.delete(tensorWrapper);
          }
          this.freeTensors.push(tensorWrapper);
        }
      };
      createTensorManager = (...args) => new TensorManagerImpl(...args);
    }
  });

  // web/lib/wasm/jsep/backend-webnn.ts
  var onnxDataTypeToWebnnDataType, compareMLContextOptions, WebNNBackend;
  var init_backend_webnn = __esm({
    "web/lib/wasm/jsep/backend-webnn.ts"() {
      "use strict";
      init_wasm_common();
      init_wasm_factory();
      init_tensor_view();
      init_tensor_manager();
      init_log();
      onnxDataTypeToWebnnDataType = /* @__PURE__ */ new Map([
        [1 /* float */, "float32"],
        [10 /* float16 */, "float16"],
        [6 /* int32 */, "int32"],
        [12 /* uint32 */, "uint32"],
        [7 /* int64 */, "int64"],
        [13 /* uint64 */, "uint64"],
        [22 /* int4 */, "int4"],
        [21 /* uint4 */, "uint4"],
        [3 /* int8 */, "int8"],
        [2 /* uint8 */, "uint8"],
        [9 /* bool */, "uint8"]
      ]);
      compareMLContextOptions = (a, b) => {
        if (a === b) {
          return true;
        }
        if (a === void 0 || b === void 0) {
          return false;
        }
        const aKeys = Object.keys(a).sort();
        const bKeys = Object.keys(b).sort();
        return aKeys.length === bKeys.length && aKeys.every((key, index) => key === bKeys[index] && a[key] === b[key]);
      };
      WebNNBackend = class {
        constructor(env3) {
          /**
           * Tensor managers for each session.
           */
          this.tensorManager = createTensorManager(this);
          /**
           * Maps from session id to MLContexts.
           */
          this.mlContextBySessionId = /* @__PURE__ */ new Map();
          /**
           * Maps from MLContext to session ids.
           */
          this.sessionIdsByMLContext = /* @__PURE__ */ new Map();
          /**
           * Cache of MLContexts.
           */
          this.mlContextCache = [];
          /**
           * Maps from session id to list of graph inputs.
           */
          this.sessionGraphInputs = /* @__PURE__ */ new Map();
          /**
           * Maps from session id to list of graph outputs.
           */
          this.sessionGraphOutputs = /* @__PURE__ */ new Map();
          /**
           * Temporary graph inputs for the current session.
           * These inputs will be registered when the session is created.
           */
          this.temporaryGraphInputs = [];
          /**
           * Temporary graph outputs for the current session.
           * These outputs will be registered when the session is created.
           */
          this.temporaryGraphOutputs = [];
          /**
           * Temporary tensors for the current session.
           */
          this.temporarySessionTensorIds = /* @__PURE__ */ new Map();
          /**
           * Maps from session id to MLOpSupportLimits.
           */
          this.mlOpSupportLimitsBySessionId = /* @__PURE__ */ new Map();
          configureLogger(env3.logLevel, !!env3.debug);
        }
        get currentSessionId() {
          if (this.activeSessionId === void 0) {
            throw new Error("No active session");
          }
          return this.activeSessionId;
        }
        onRunStart(sessionId) {
          LOG_DEBUG("verbose", () => `[WebNN] onRunStart {sessionId: ${sessionId}}`);
          this.activeSessionId = sessionId;
        }
        onRunEnd(sessionId) {
          LOG_DEBUG("verbose", () => `[WebNN] onRunEnd {sessionId: ${sessionId}}`);
          const tensorIds = this.temporarySessionTensorIds.get(sessionId);
          if (!tensorIds) {
            return;
          }
          for (const tensorId of tensorIds) {
            LOG_DEBUG("verbose", () => `[WebNN] releasing temporary tensor {tensorId: ${tensorId}}`);
            this.tensorManager.releaseTensorId(tensorId);
          }
          this.temporarySessionTensorIds.delete(sessionId);
          this.activeSessionId = void 0;
        }
        async createMLContext(optionsOrDevice) {
          if (optionsOrDevice instanceof GPUDevice) {
            const mlContextIndex2 = this.mlContextCache.findIndex((entry) => entry.gpuDevice === optionsOrDevice);
            if (mlContextIndex2 !== -1) {
              return this.mlContextCache[mlContextIndex2].mlContext;
            } else {
              const mlContext = await navigator.ml.createContext(optionsOrDevice);
              this.mlContextCache.push({ gpuDevice: optionsOrDevice, mlContext });
              return mlContext;
            }
          } else if (optionsOrDevice === void 0) {
            const mlContextIndex2 = this.mlContextCache.findIndex(
              (entry) => entry.options === void 0 && entry.gpuDevice === void 0
            );
            if (mlContextIndex2 !== -1) {
              return this.mlContextCache[mlContextIndex2].mlContext;
            } else {
              const mlContext = await navigator.ml.createContext();
              this.mlContextCache.push({ mlContext });
              return mlContext;
            }
          }
          const mlContextIndex = this.mlContextCache.findIndex(
            (entry) => compareMLContextOptions(entry.options, optionsOrDevice)
          );
          if (mlContextIndex !== -1) {
            return this.mlContextCache[mlContextIndex].mlContext;
          } else {
            const mlContext = await navigator.ml.createContext(optionsOrDevice);
            this.mlContextCache.push({ options: optionsOrDevice, mlContext });
            return mlContext;
          }
        }
        registerMLContext(sessionId, mlContext) {
          this.mlContextBySessionId.set(sessionId, mlContext);
          let sessionIds = this.sessionIdsByMLContext.get(mlContext);
          if (!sessionIds) {
            sessionIds = /* @__PURE__ */ new Set();
            this.sessionIdsByMLContext.set(mlContext, sessionIds);
          }
          sessionIds.add(sessionId);
          if (!this.mlOpSupportLimitsBySessionId.has(sessionId)) {
            this.mlOpSupportLimitsBySessionId.set(sessionId, mlContext.opSupportLimits());
          }
          if (this.temporaryGraphInputs.length > 0) {
            this.sessionGraphInputs.set(sessionId, this.temporaryGraphInputs);
            this.temporaryGraphInputs = [];
          }
          if (this.temporaryGraphOutputs.length > 0) {
            this.sessionGraphOutputs.set(sessionId, this.temporaryGraphOutputs);
            this.temporaryGraphOutputs = [];
          }
        }
        onReleaseSession(sessionId) {
          this.sessionGraphInputs.delete(sessionId);
          this.sessionGraphOutputs.delete(sessionId);
          const mlContext = this.mlContextBySessionId.get(sessionId);
          if (!mlContext) {
            return;
          }
          this.tensorManager.releaseTensorsForSession(sessionId);
          this.mlContextBySessionId.delete(sessionId);
          this.mlOpSupportLimitsBySessionId.delete(sessionId);
          const sessionIds = this.sessionIdsByMLContext.get(mlContext);
          sessionIds.delete(sessionId);
          if (sessionIds.size === 0) {
            this.sessionIdsByMLContext.delete(mlContext);
            const mlContextIndex = this.mlContextCache.findIndex((entry) => entry.mlContext === mlContext);
            if (mlContextIndex !== -1) {
              this.mlContextCache.splice(mlContextIndex, 1);
            }
          }
        }
        getMLContext(sessionId) {
          return this.mlContextBySessionId.get(sessionId);
        }
        getMLOpSupportLimits(sessionId) {
          return this.mlOpSupportLimitsBySessionId.get(sessionId);
        }
        reserveTensorId() {
          return this.tensorManager.reserveTensorId();
        }
        releaseTensorId(tensorId) {
          LOG_DEBUG("verbose", () => `[WebNN] releaseTensorId {tensorId: ${tensorId}}`);
          this.tensorManager.releaseTensorId(tensorId);
        }
        async ensureTensor(sessionId, tensorId, onnxDataType, dimensions, copyOld) {
          const webnnDataType = onnxDataTypeToWebnnDataType.get(onnxDataType);
          if (!webnnDataType) {
            throw new Error(`Unsupported ONNX data type: ${onnxDataType}`);
          }
          return this.tensorManager.ensureTensor(
            sessionId ?? this.currentSessionId,
            tensorId,
            webnnDataType,
            dimensions,
            copyOld
          );
        }
        async createTemporaryTensor(sessionId, onnxDataType, shape) {
          LOG_DEBUG("verbose", () => `[WebNN] createTemporaryTensor {onnxDataType: ${onnxDataType}, shape: ${shape}}`);
          const dataType = onnxDataTypeToWebnnDataType.get(onnxDataType);
          if (!dataType) {
            throw new Error(`Unsupported ONNX data type: ${onnxDataType}`);
          }
          const tensorId = this.tensorManager.reserveTensorId();
          await this.tensorManager.ensureTensor(sessionId, tensorId, dataType, shape, false);
          const tensorIds = this.temporarySessionTensorIds.get(sessionId);
          if (!tensorIds) {
            this.temporarySessionTensorIds.set(sessionId, [tensorId]);
          } else {
            tensorIds.push(tensorId);
          }
          return tensorId;
        }
        uploadTensor(tensorId, data) {
          const wasm2 = getInstance();
          if (!wasm2.shouldTransferToMLTensor) {
            throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");
          }
          LOG_DEBUG("verbose", () => `[WebNN] uploadTensor {tensorId: ${tensorId}, data: ${data.byteLength}}`);
          this.tensorManager.upload(tensorId, data);
        }
        async downloadTensor(tensorId, dstBuffer) {
          return this.tensorManager.download(tensorId, dstBuffer);
        }
        createMLTensorDownloader(tensorId, type) {
          return async () => {
            const data = await this.tensorManager.download(tensorId);
            return createView(data, type);
          };
        }
        registerMLTensor(sessionId, tensor, onnxDataType, dimensions) {
          const webnnDataType = onnxDataTypeToWebnnDataType.get(onnxDataType);
          if (!webnnDataType) {
            throw new Error(`Unsupported ONNX data type: ${onnxDataType}`);
          }
          const id = this.tensorManager.registerTensor(sessionId, tensor, webnnDataType, dimensions);
          LOG_DEBUG(
            "verbose",
            () => `[WebNN] registerMLTensor {tensor: ${tensor}, dataType: ${webnnDataType}, dimensions: ${dimensions}} -> {tensorId: ${id}}`
          );
          return id;
        }
        // Register a WebNN Constant operand from external data.
        registerMLConstant(externalFilePath, dataOffset, dataLength, builder, desc, mountedFiles, shouldConvertInt64ToInt32 = false) {
          if (!mountedFiles) {
            throw new Error("External mounted files are not available.");
          }
          let filePath = externalFilePath;
          if (externalFilePath.startsWith("./")) {
            filePath = externalFilePath.substring(2);
          }
          const fileData = mountedFiles.get(filePath);
          if (!fileData) {
            throw new Error(`File with name ${filePath} not found in preloaded files.`);
          }
          if (dataOffset + dataLength > fileData.byteLength) {
            throw new Error("Out of bounds: data offset and length exceed the external file data size.");
          }
          const buffer = fileData.slice(dataOffset, dataOffset + dataLength).buffer;
          let bufferView;
          switch (desc.dataType) {
            case "float32":
              bufferView = new Float32Array(buffer);
              break;
            case "float16":
              bufferView = typeof Float16Array !== "undefined" && Float16Array.from ? new Float16Array(buffer) : new Uint16Array(buffer);
              break;
            case "int32":
              bufferView = new Int32Array(buffer);
              break;
            case "uint32":
              bufferView = new Uint32Array(buffer);
              break;
            case "int64":
              if (shouldConvertInt64ToInt32) {
                const int32Buffer = convertDataToInt32(new Uint8Array(buffer), "int64");
                bufferView = new Int32Array(int32Buffer.buffer);
                desc.dataType = "int32";
              } else {
                bufferView = new BigInt64Array(buffer);
              }
              break;
            case "uint64":
              bufferView = new BigUint64Array(buffer);
              break;
            case "int8":
              bufferView = new Int8Array(buffer);
              break;
            case "int4":
            case "uint4":
            case "uint8":
              bufferView = new Uint8Array(buffer);
              break;
            default:
              throw new Error(`Unsupported data type: ${desc.dataType} in creating WebNN Constant from external data.`);
          }
          LOG_DEBUG(
            "verbose",
            () => `[WebNN] registerMLConstant {dataType: ${desc.dataType}, shape: ${desc.shape}}} ${shouldConvertInt64ToInt32 ? "(Note: it was int64 data type and registered to int32 as workaround)" : ""}`
          );
          return builder.constant(desc, bufferView);
        }
        registerGraphInput(inputName) {
          this.temporaryGraphInputs.push(inputName);
        }
        registerGraphOutput(outputName) {
          this.temporaryGraphOutputs.push(outputName);
        }
        isGraphInput(sessionId, inputName) {
          const inputNames = this.sessionGraphInputs.get(sessionId);
          if (!inputNames) {
            return false;
          }
          return inputNames.includes(inputName);
        }
        isGraphOutput(sessionId, outputName) {
          const outputNames = this.sessionGraphOutputs.get(sessionId);
          if (!outputNames) {
            return false;
          }
          return outputNames.includes(outputName);
        }
        isGraphInputOutputTypeSupported(sessionId, type, isInput = true) {
          const dataType = onnxDataTypeToWebnnDataType.get(tensorDataTypeStringToEnum(type));
          const opLimits = this.mlOpSupportLimitsBySessionId.get(sessionId);
          if (typeof dataType === "undefined") {
            return false;
          }
          if (isInput) {
            return !!opLimits?.input.dataTypes.includes(dataType);
          } else {
            return !!opLimits?.output.dataTypes.includes(dataType);
          }
        }
        flush() {
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/types.ts
  var init_types = __esm({
    "web/lib/wasm/jsep/webgpu/types.ts"() {
      "use strict";
    }
  });

  // web/lib/wasm/jsep/webgpu/gpu-data-manager.ts
  var bucketFreelist, bucketArr, calcNormalizedBufferSize, calcBucketBufferSize, guid, createNewGpuDataId, downloadGpuData, GpuDataManagerImpl, createGpuDataManager;
  var init_gpu_data_manager = __esm({
    "web/lib/wasm/jsep/webgpu/gpu-data-manager.ts"() {
      "use strict";
      init_log();
      init_types();
      bucketFreelist = /* @__PURE__ */ new Map([
        [64, 250],
        [128, 200],
        [256, 200],
        [512, 200],
        [2048, 230],
        [4096, 200],
        [8192, 50],
        [16384, 50],
        [32768, 50],
        [65536, 50],
        [131072, 50],
        [262144, 50],
        [524288, 50],
        [1048576, 50],
        [2097152, 30],
        [4194304, 20],
        [8388608, 10],
        [12582912, 10],
        [16777216, 10],
        [26214400, 15],
        [33554432, 22],
        [44236800, 2],
        [58982400, 6],
        // we don't want to cache the bucket sizes below but not caching them
        // results in some major performance hits for models like sd-turbo.
        [67108864, 6],
        [134217728, 6],
        [167772160, 6]
      ]);
      bucketArr = [];
      calcNormalizedBufferSize = (size) => Math.ceil(Number(size) / 16) * 16;
      calcBucketBufferSize = (size) => {
        for (let idx = 0; idx < bucketArr.length; idx++) {
          const sizeForBucket = bucketArr[idx];
          if (size <= sizeForBucket) {
            return sizeForBucket;
          }
        }
        return Math.ceil(size / 16) * 16;
      };
      guid = 1;
      createNewGpuDataId = () => guid++;
      downloadGpuData = async (backend, gpuBuffer, originalSize, getTargetBuffer) => {
        const bufferSize = calcNormalizedBufferSize(originalSize);
        const gpuReadBuffer = backend.device.createBuffer(
          // eslint-disable-next-line no-bitwise
          { size: bufferSize, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ }
        );
        try {
          const commandEncoder = backend.getCommandEncoder();
          backend.endComputePass();
          commandEncoder.copyBufferToBuffer(
            gpuBuffer,
            0,
            gpuReadBuffer,
            0,
            bufferSize
          );
          backend.flush();
          await gpuReadBuffer.mapAsync(GPUMapMode.READ);
          const arrayBuffer = gpuReadBuffer.getMappedRange();
          if (getTargetBuffer) {
            const targetBuffer = getTargetBuffer();
            targetBuffer.set(new Uint8Array(arrayBuffer, 0, originalSize));
            return targetBuffer;
          } else {
            return new Uint8Array(arrayBuffer.slice(0, originalSize));
          }
        } finally {
          gpuReadBuffer.destroy();
        }
      };
      GpuDataManagerImpl = class {
        constructor(backend) {
          this.backend = backend;
          this.storageCache = /* @__PURE__ */ new Map();
          this.freeBuffers = /* @__PURE__ */ new Map();
          this.freeUniformBuffers = /* @__PURE__ */ new Map();
          this.buffersPending = [];
          this.capturedPendingBuffers = /* @__PURE__ */ new Map();
          for (const [key] of bucketFreelist) {
            bucketArr.push(key);
            this.freeBuffers.set(key, []);
            this.freeUniformBuffers.set(key, []);
          }
          this.sessionCount = 0;
        }
        upload(id, data) {
          const srcArrayBuffer = data.buffer;
          const srcOffset = data.byteOffset;
          const srcLength = data.byteLength;
          const size = calcNormalizedBufferSize(srcLength);
          const gpuDataCache = this.storageCache.get(id);
          if (!gpuDataCache) {
            throw new Error("gpu data for uploading does not exist");
          }
          if (Number(gpuDataCache.originalSize) !== srcLength) {
            throw new Error(`inconsistent data size. gpu data size=${gpuDataCache.originalSize}, data size=${srcLength}`);
          }
          const gpuBufferForUploading = this.backend.device.createBuffer(
            // eslint-disable-next-line no-bitwise
            { mappedAtCreation: true, size, usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC }
          );
          const arrayBuffer = gpuBufferForUploading.getMappedRange();
          new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer, srcOffset, srcLength));
          gpuBufferForUploading.unmap();
          const commandEncoder = this.backend.device.createCommandEncoder();
          commandEncoder.copyBufferToBuffer(gpuBufferForUploading, 0, gpuDataCache.gpuData.buffer, 0, size);
          this.backend.device.queue.submit([commandEncoder.finish()]);
          gpuBufferForUploading.destroy();
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.upload(id=${id})`);
        }
        memcpy(sourceId, destinationId) {
          const sourceGpuDataCache = this.storageCache.get(sourceId);
          if (!sourceGpuDataCache) {
            throw new Error("source gpu data for memcpy does not exist");
          }
          const destinationGpuDataCache = this.storageCache.get(destinationId);
          if (!destinationGpuDataCache) {
            throw new Error("destination gpu data for memcpy does not exist");
          }
          if (sourceGpuDataCache.originalSize !== destinationGpuDataCache.originalSize) {
            throw new Error("inconsistent source and destination gpu data size");
          }
          const size = calcNormalizedBufferSize(sourceGpuDataCache.originalSize);
          const commandEncoder = this.backend.getCommandEncoder();
          this.backend.endComputePass();
          commandEncoder.copyBufferToBuffer(
            sourceGpuDataCache.gpuData.buffer,
            0,
            destinationGpuDataCache.gpuData.buffer,
            0,
            size
          );
        }
        registerExternalBuffer(buffer, originalSize, previous) {
          let id;
          if (previous) {
            id = previous[0];
            if (buffer === previous[1]) {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, buffer is the same, skip.`
              );
              return id;
            } else if (this.backend.capturedCommandList.has(this.backend.currentSessionId)) {
              throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);
            }
          } else {
            id = createNewGpuDataId();
          }
          this.storageCache.set(id, { gpuData: { id, type: 0 /* default */, buffer }, originalSize });
          LOG_DEBUG(
            "verbose",
            () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, registered.`
          );
          return id;
        }
        unregisterExternalBuffer(id) {
          if (id !== void 0) {
            this.storageCache.delete(id);
            LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${id}`);
          }
        }
        // eslint-disable-next-line no-bitwise
        create(size, usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST) {
          const bufferSize = calcBucketBufferSize(size);
          let gpuBuffer;
          const isStorage = (usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE;
          const isUniform = (usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;
          if (isStorage || isUniform) {
            const freeBuffers = isStorage ? this.freeBuffers : this.freeUniformBuffers;
            const buffers = freeBuffers.get(bufferSize);
            if (!buffers) {
              gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
            } else {
              if (buffers.length > 0) {
                gpuBuffer = buffers.pop();
              } else {
                gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
              }
            }
          } else {
            gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
          }
          const gpuData = { id: createNewGpuDataId(), type: 0 /* default */, buffer: gpuBuffer };
          this.storageCache.set(gpuData.id, { gpuData, originalSize: Number(size) });
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.create(size=${size}) => id=${gpuData.id}`);
          return gpuData;
        }
        get(id) {
          return this.storageCache.get(id)?.gpuData;
        }
        release(idInput) {
          const id = typeof idInput === "bigint" ? Number(idInput) : idInput;
          const cachedData = this.storageCache.get(id);
          if (!cachedData) {
            if (this.storageCache.size === 0) {
              return 0;
            } else {
              throw new Error("releasing data does not exist");
            }
          }
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.release(id=${id}), gpuDataId=${cachedData.gpuData.id}`);
          this.storageCache.delete(id);
          this.buffersPending.push(cachedData.gpuData.buffer);
          return cachedData.originalSize;
        }
        async download(id, getTargetBuffer) {
          const cachedData = this.storageCache.get(Number(id));
          if (!cachedData) {
            throw new Error("data does not exist");
          }
          await downloadGpuData(this.backend, cachedData.gpuData.buffer, cachedData.originalSize, getTargetBuffer);
        }
        refreshPendingBuffers() {
          if (this.buffersPending.length === 0) {
            return;
          }
          if (this.backend.sessionStatus === "default") {
            for (const buffer of this.buffersPending) {
              const maxInFreeList = bucketFreelist.get(buffer.size);
              if ((buffer.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {
                const freelist = this.freeBuffers.get(buffer.size) || [];
                if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                  buffer.destroy();
                } else {
                  freelist.push(buffer);
                }
              } else if ((buffer.usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM) {
                const freelist = this.freeUniformBuffers.get(buffer.size) || [];
                if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                  buffer.destroy();
                } else {
                  freelist.push(buffer);
                }
              } else {
                buffer.destroy();
              }
            }
            this.buffersPending = [];
          } else {
            let capturedBuffers = this.capturedPendingBuffers.get(this.backend.currentSessionId);
            if (!capturedBuffers) {
              capturedBuffers = [];
              this.capturedPendingBuffers.set(this.backend.currentSessionId, capturedBuffers);
            }
            for (const buffer of this.buffersPending) {
              capturedBuffers.push(buffer);
            }
            this.buffersPending = [];
          }
        }
        dispose() {
          this.freeBuffers.forEach((buffers) => {
            buffers.forEach((buffer) => {
              buffer.destroy();
            });
          });
          this.freeUniformBuffers.forEach((buffers) => {
            buffers.forEach((buffer) => {
              buffer.destroy();
            });
          });
          this.storageCache.forEach((storage) => {
            storage.gpuData.buffer.destroy();
          });
          this.capturedPendingBuffers.forEach((buffers) => {
            buffers.forEach((buffer) => {
              buffer.destroy();
            });
          });
          this.storageCache = /* @__PURE__ */ new Map();
          this.freeBuffers = /* @__PURE__ */ new Map();
          this.freeUniformBuffers = /* @__PURE__ */ new Map();
          this.capturedPendingBuffers = /* @__PURE__ */ new Map();
        }
        onCreateSession() {
          this.sessionCount += 1;
        }
        onReleaseSession(sessionId) {
          const pendingBuffers = this.capturedPendingBuffers.get(sessionId);
          if (pendingBuffers) {
            pendingBuffers.forEach((buffer) => {
              buffer.destroy();
            });
            this.capturedPendingBuffers.delete(sessionId);
          }
          this.sessionCount -= 1;
          if (this.sessionCount === 0) {
            LOG_DEBUG("warning", () => "[WebGPU] Clearing webgpu buffer cache");
            this.storageCache.forEach((storage) => {
              storage.gpuData.buffer.destroy();
            });
            this.storageCache = /* @__PURE__ */ new Map();
          }
        }
      };
      createGpuDataManager = (...args) => new GpuDataManagerImpl(...args);
    }
  });

  // web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts
  var AttributeWithCacheKeyImpl, createAttributeWithCacheKey;
  var init_attribute_with_cache_key = __esm({
    "web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts"() {
      "use strict";
      AttributeWithCacheKeyImpl = class {
        constructor(attribute) {
          Object.assign(this, attribute);
        }
        get cacheKey() {
          if (!this.key) {
            this.key = Object.getOwnPropertyNames(this).sort().map((name) => `${this[name]}`).join(";");
          }
          return this.key;
        }
      };
      createAttributeWithCacheKey = (attribute) => new AttributeWithCacheKeyImpl(attribute);
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/common.ts
  var WORKGROUP_SIZE, getWgslMappedType, tensorTypeToWsglStorageType, tensorTypeToWsglValueType, createTensorShapeVariables, getMaxComponents, fillVector, castToF32, sumVector, getElementAt, createIndicesHelper, inputVariable, outputVariable, atomicOutputVariable, internalVariable, ShaderHelperImpl, createShaderHelper;
  var init_common = __esm({
    "web/lib/wasm/jsep/webgpu/ops/common.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      WORKGROUP_SIZE = 64;
      getWgslMappedType = (type, components) => {
        if (components === 3) {
          throw new Error("vec3 has same alignment as vec4, use vec4 instead");
        }
        switch (Number(type)) {
          case 10 /* float16 */:
            return components > 1 ? `vec${components}<f16>` : "f16";
          case 1 /* float */:
            return components > 1 ? `vec${components}<f32>` : "f32";
          case 6 /* int32 */:
            return components > 1 ? `vec${components}<i32>` : "i32";
          case 12 /* uint32 */:
            return components > 1 ? `vec${components}<u32>` : "u32";
          case 7 /* int64 */:
            if (components > 1) {
              throw new Error("currently not supported vecX of uint64 yet");
            }
            return ["vec2<u32>", "i32"];
          case 13 /* uint64 */:
            if (components > 1) {
              throw new Error("currently not supported vecX of uint64 yet");
            }
            return ["vec2<u32>", "u32"];
          case 9 /* bool */:
            if (components !== 4) {
              throw new Error("bool must be vec4");
            }
            return ["u32", "vec4<bool>"];
          case 22 /* int4 */:
            return "i32";
          case 21 /* uint4 */:
            return "u32";
          default:
            throw new Error(`Unknown data type: ${type}`);
        }
      };
      tensorTypeToWsglStorageType = (type, components = 1) => {
        const mappedType = getWgslMappedType(type, components);
        return typeof mappedType === "string" ? mappedType : mappedType[0];
      };
      tensorTypeToWsglValueType = (type, components = 1) => {
        const mappedType = getWgslMappedType(type, components);
        return typeof mappedType === "string" ? mappedType : mappedType[1];
      };
      createTensorShapeVariables = (...dims) => {
        const programUniforms = [];
        dims.forEach((dim) => {
          if (dim.length !== 0) {
            programUniforms.push(
              { type: 12 /* uint32 */, data: dim },
              { type: 12 /* uint32 */, data: ShapeUtil.computeStrides(dim) }
            );
          }
        });
        return programUniforms;
      };
      getMaxComponents = (size) => {
        if (size % 4 === 0) {
          return 4;
        } else if (size % 2 === 0) {
          return 2;
        }
        return 1;
      };
      fillVector = (dataType = "f32", components, value = "0") => {
        if (!components || components === 1) {
          return `${dataType}(${value})`;
        }
        return `vec${components}<${dataType}>(${value})`;
      };
      castToF32 = (dataType, components, value) => {
        if (dataType === "f32") {
          return value;
        }
        if (components === 1) {
          return `f32(${value})`;
        }
        return `vec${components}<f32>(${value})`;
      };
      sumVector = (name, components) => {
        if (components === 4) {
          return `(${name}.x + ${name}.y + ${name}.z + ${name}.w)`;
        } else if (components === 2) {
          return `(${name}.x + ${name}.y)`;
        } else if (components === 3) {
          return `(${name}.x + ${name}.y + ${name}.z)`;
        }
        return name;
      };
      getElementAt = (name, index, length, type) => {
        if (name.startsWith("uniforms.") && length > 4) {
          if (typeof index === "string") {
            if (type === "f16") {
              return `${name}[(${index}) / 8][(${index}) % 8 / 4][(${index}) % 8 % 4]`;
            } else {
              return `${name}[(${index}) / 4][(${index}) % 4]`;
            }
          } else {
            if (type === "f16") {
              return `${name}[${Math.floor(index / 8)}][${Math.floor(index % 8 / 4)}][${index % 8 % 4}]`;
            } else {
              return `${name}[${Math.floor(index / 4)}][${index % 4}]`;
            }
          }
        } else {
          return length > 1 ? `${name}[${index}]` : name;
        }
      };
      createIndicesHelper = (name, tensorType, shapeOrRank, usage, components) => {
        const useUniform = typeof shapeOrRank === "number";
        const rank = useUniform ? shapeOrRank : shapeOrRank.length;
        const rankIdentity = [...new Array(rank).keys()];
        const indicesType = rank < 2 ? "u32" : rank <= 4 ? `vec${rank}<u32>` : `array<u32, ${rank}>`;
        const mappedType = getWgslMappedType(tensorType, components);
        const valueType = typeof mappedType === "string" ? mappedType : mappedType[1];
        const storageType = typeof mappedType === "string" ? mappedType : mappedType[0];
        const type = { indices: indicesType, value: valueType, storage: storageType, tensor: tensorType };
        const normalizeDim = (dim) => typeof dim === "string" ? dim : `${dim}u`;
        const implementationUsed = {
          offsetToIndices: false,
          indicesToOffset: false,
          broadcastedIndicesToOffset: false,
          set: false,
          setByIndices: false,
          get: false,
          getByIndices: false
        };
        const uniformPrefix = useUniform ? "uniforms." : "";
        const shape = `${uniformPrefix}${name}_shape`;
        const strides = `${uniformPrefix}${name}_strides`;
        let o2iSnippet = "";
        for (let i = 0; i < rank - 1; i++) {
          o2iSnippet += `
    let dim${i} = current / ${getElementAt(strides, i, rank)};
    let rest${i} = current % ${getElementAt(strides, i, rank)};
    indices[${i}] = dim${i};
    current = rest${i};
    `;
        }
        o2iSnippet += `indices[${rank - 1}] = current;`;
        const offsetToIndicesImplementation = rank < 2 ? "" : `
  fn o2i_${name}(offset: u32) -> ${type.indices} {
    var indices: ${type.indices};
    var current = offset;
    ${o2iSnippet}
    return indices;
  }`;
        const offsetToIndices = (varOffset) => {
          implementationUsed.offsetToIndices = true;
          return rank < 2 ? varOffset : `o2i_${name}(${varOffset})`;
        };
        const offsets = [];
        if (rank >= 2) {
          for (let i = rank - 1; i >= 0; i--) {
            offsets.push(`${getElementAt(strides, i, rank)} * (indices[${i}])`);
          }
        }
        const indicesToOffsetImplementation = rank < 2 ? "" : `
  fn i2o_${name}(indices: ${type.indices}) -> u32 {
    return ${offsets.join("+")};
  }`;
        const indicesToOffset = (varIndices) => {
          implementationUsed.indicesToOffset = true;
          return rank < 2 ? varIndices : `i2o_${name}(${varIndices})`;
        };
        const indices = (...init2) => rank === 0 ? "0u" : `${type.indices}(${init2.map(normalizeDim).join(",")})`;
        const indicesGet = (varIndices, idx) => {
          if (rank < 2) {
            return `${varIndices}`;
          } else {
            return `${getElementAt(varIndices, idx, rank)}`;
          }
        };
        const indicesSet = (varIndices, idx, value) => {
          if (rank < 2) {
            return `${varIndices}=${value};`;
          } else {
            return `${getElementAt(varIndices, idx, rank)}=${value};`;
          }
        };
        const broadcastedIndicesToOffsetImplementation = {};
        const broadcastedIndicesToOffset = (varIndices, output) => {
          implementationUsed.broadcastedIndicesToOffset = true;
          const implKey = `${output.name}broadcastedIndicesTo${name}Offset`;
          if (implKey in broadcastedIndicesToOffsetImplementation) {
            return `${implKey}(${varIndices})`;
          }
          const offsets2 = [];
          for (let i = rank - 1; i >= 0; i--) {
            const idx = output.indicesGet("outputIndices", i + output.rank - rank);
            offsets2.push(`${indicesGet(strides, i)} * (${idx} % ${indicesGet(shape, i)})`);
          }
          broadcastedIndicesToOffsetImplementation[implKey] = `fn ${implKey}(outputIndices: ${output.type.indices}) -> u32 {
             return ${offsets2.length > 0 ? offsets2.join("+") : "0u"};
           }`;
          return `${implKey}(${varIndices})`;
        };
        const setByOffset = (offset, value) => (() => {
          if (type.storage === type.value) {
            return `${name}[${offset}]=${value};`;
          } else if (type.storage === "vec2<u32>" && type.value === "i32") {
            return `${name}[${offset}]=vec2<u32>(u32(${value}), select(0u, 0xFFFFFFFFu, ${value} < 0));`;
          } else if (type.storage === "vec2<u32>" && type.value === "u32") {
            return `${name}[${offset}]=vec2<u32>(u32(${value}), 0u);`;
          } else if (type.storage === "u32" && type.value === "vec4<bool>") {
            return `${name}[${offset}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${value}));`;
          } else {
            throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
          }
        })();
        const getByOffset = (offset) => (() => {
          if (type.storage === type.value) {
            return `${name}[${offset}]`;
          } else if (type.storage === "vec2<u32>" && type.value === "i32") {
            return `i32(${name}[${offset}].x)`;
          } else if (type.storage === "vec2<u32>" && type.value === "u32") {
            return `u32(${name}[${offset}].x)`;
          } else if (type.storage === "u32" && type.value === "vec4<bool>") {
            return `vec4<bool>(bool(${name}[${offset}] & 0xFFu), bool(${name}[${offset}] & 0xFF00u), bool(${name}[${offset}] & 0xFF0000u), bool(${name}[${offset}] & 0xFF000000u))`;
          } else {
            throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
          }
        })();
        const getByIndicesImplementation = rank < 2 ? "" : `
  fn get_${name}ByIndices(indices: ${type.indices}) -> ${valueType} {
    return ${getByOffset(`i2o_${name}(indices)`)};
  }`;
        const getImplementation = rank < 2 ? "" : (() => {
          const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
          const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
          return `
  fn get_${name}(${functionParams}) -> ${valueType} {
    return get_${name}ByIndices(${indices(dimsParams)});
  }`;
        })();
        const get = (...indices2) => {
          if (indices2.length !== rank) {
            throw new Error(`indices length must be ${rank}`);
          }
          const normalizedIndices = indices2.map(normalizeDim).join(",");
          if (rank === 0) {
            return getByOffset("0u");
          } else if (rank === 1) {
            return getByOffset(normalizedIndices[0]);
          } else {
            implementationUsed.get = true;
            implementationUsed.getByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `get_${name}(${normalizedIndices})`;
          }
        };
        const getByIndices = (varIndices) => {
          if (rank < 2) {
            return getByOffset(varIndices);
          } else {
            implementationUsed.getByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `get_${name}ByIndices(${varIndices})`;
          }
        };
        const setByIndicesImplementation = rank < 2 ? "" : `
  fn set_${name}ByIndices(indices: ${type.indices}, value: ${valueType}) {
    ${setByOffset(`i2o_${name}(indices)`, "value")}
  }`;
        const setImplementation = rank < 2 ? "" : (() => {
          const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
          const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
          return `
  fn set_${name}(${functionParams}, value: ${valueType}) {
    set_${name}ByIndices(${indices(dimsParams)}, value);
  }`;
        })();
        const set = (...indicesAndValue) => {
          if (indicesAndValue.length !== rank + 1) {
            throw new Error(`indices length must be ${rank}`);
          }
          const value = indicesAndValue[rank];
          if (typeof value !== "string") {
            throw new Error("value must be string");
          }
          const normalizedIndices = indicesAndValue.slice(0, rank).map(normalizeDim).join(",");
          if (rank === 0) {
            return setByOffset("0u", value);
          } else if (rank === 1) {
            return setByOffset(normalizedIndices[0], value);
          } else {
            implementationUsed.set = true;
            implementationUsed.setByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `set_${name}(${normalizedIndices}, ${value})`;
          }
        };
        const setByIndices = (varIndices, value) => {
          if (rank < 2) {
            return setByOffset(varIndices, value);
          } else {
            implementationUsed.setByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `set_${name}ByIndices(${varIndices}, ${value});`;
          }
        };
        const impl = () => {
          const impls = [];
          let needShapeStrides = false;
          if (implementationUsed.offsetToIndices) {
            impls.push(offsetToIndicesImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.indicesToOffset) {
            impls.push(indicesToOffsetImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.broadcastedIndicesToOffset) {
            Object.values(broadcastedIndicesToOffsetImplementation).forEach((impl2) => impls.push(impl2));
            needShapeStrides = true;
          }
          if (implementationUsed.set) {
            impls.push(setImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.setByIndices) {
            impls.push(setByIndicesImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.get) {
            impls.push(getImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.getByIndices) {
            impls.push(getByIndicesImplementation);
            needShapeStrides = true;
          }
          if (!useUniform && needShapeStrides) {
            impls.unshift(
              `const ${shape} = ${type.indices}(${shapeOrRank.join(",")});`,
              `const ${strides} = ${type.indices}(${ShapeUtil.computeStrides(shapeOrRank).join(",")});`
            );
          }
          return impls.join("\n");
        };
        return {
          impl,
          type,
          offsetToIndices,
          indicesToOffset,
          broadcastedIndicesToOffset,
          indices,
          indicesGet,
          indicesSet,
          set,
          setByOffset,
          setByIndices,
          get,
          getByOffset,
          getByIndices,
          // isVec4,
          usage,
          name,
          strides,
          shape,
          rank
        };
      };
      inputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "input", components);
      outputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "output", components);
      atomicOutputVariable = (name, type, shapeOrRank) => createIndicesHelper(name, type, shapeOrRank, "atomicOutput", 1);
      internalVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "internal", components);
      ShaderHelperImpl = class {
        constructor(normalizedDispatchGroup, limits) {
          this.normalizedDispatchGroup = normalizedDispatchGroup;
          this.limits = limits;
          this.internalVariables = [];
          this.variables = [];
          this.uniforms = [];
          this.variableIndex = 0;
        }
        guardAgainstOutOfBoundsWorkgroupSizes(size) {
          const sizeInCode = typeof size === "number" ? `${size}u` : size;
          return `if (global_idx >= ${sizeInCode}) { return; }`;
        }
        mainStart(workgroupSize = WORKGROUP_SIZE) {
          const workgroupSizeX = typeof workgroupSize === "number" ? workgroupSize : workgroupSize[0];
          const workgroupSizeY = typeof workgroupSize === "number" ? 1 : workgroupSize[1];
          const workgroupSizeZ = typeof workgroupSize === "number" ? 1 : workgroupSize[2];
          if (workgroupSizeX > this.limits.maxComputeWorkgroupSizeX || workgroupSizeY > this.limits.maxComputeWorkgroupSizeY || workgroupSizeZ > this.limits.maxComputeWorkgroupSizeZ) {
            throw new Error(
              `workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`
            );
          }
          if (workgroupSizeX * workgroupSizeY * workgroupSizeZ > this.limits.maxComputeInvocationsPerWorkgroup) {
            throw new Error(
              `workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`
            );
          }
          const is1DimensionDispatch = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1;
          const paramList = is1DimensionDispatch ? `@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>` : `@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`;
          const globalIdxDefinition = is1DimensionDispatch ? `let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;` : `let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${workgroupSizeX * workgroupSizeY * workgroupSizeZ}u + local_idx;`;
          return `@compute @workgroup_size(${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ})
  fn main(${paramList}) {
    ${globalIdxDefinition}
  `;
        }
        appendVariableUniforms(variable) {
          if (variable.rank !== 0) {
            if (variable.shape.startsWith("uniforms.")) {
              this.uniforms.push({ name: variable.shape.replace("uniforms.", ""), type: "u32", length: variable.rank });
            }
            if (variable.strides.startsWith("uniforms.")) {
              this.uniforms.push({ name: variable.strides.replace("uniforms.", ""), type: "u32", length: variable.rank });
            }
          }
        }
        declareVariable(variable, bindingIndex) {
          if (variable.usage === "internal") {
            throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");
          }
          this.variables.push(variable);
          this.appendVariableUniforms(variable);
          const access = variable.usage === "input" ? "read" : "read_write";
          const storageType = variable.usage === "atomicOutput" ? `atomic<i32>` : variable.type.storage;
          return `@group(0) @binding(${bindingIndex}) var<storage, ${access}> ${variable.name}: array<${storageType}>;`;
        }
        declareVariables(...variables) {
          return variables.map((v) => this.declareVariable(v, this.variableIndex++)).join("\n");
        }
        registerInternalVariable(variable) {
          if (variable.usage !== "internal") {
            throw new Error(
              "cannot use input or output variable with registerInternalVariable(). use declareVariables() instead."
            );
          }
          this.internalVariables.push(variable);
          this.appendVariableUniforms(variable);
        }
        registerInternalVariables(...variables) {
          variables.forEach((v) => this.registerInternalVariable(v));
          return this;
        }
        registerUniform(name, type, length = 1) {
          this.uniforms.push({ name, type, length });
          return this;
        }
        registerUniforms(additionalUniforms) {
          this.uniforms = this.uniforms.concat(additionalUniforms);
          return this;
        }
        uniformDeclaration() {
          if (this.uniforms.length === 0) {
            return "";
          }
          const uniformSnippets = [];
          for (const { name, type, length } of this.uniforms) {
            if (length && length > 4) {
              if (type === "f16") {
                uniformSnippets.push(`@align(16) ${name}:array<mat2x4<${type}>, ${Math.ceil(length / 8)}>`);
              } else {
                uniformSnippets.push(`${name}:array<vec4<${type}>, ${Math.ceil(length / 4)}>`);
              }
            } else {
              const typeTemp = length == null || length === 1 ? type : `vec${length}<${type}>`;
              uniformSnippets.push(`${name}:${typeTemp}`);
            }
          }
          return `
      struct Uniforms { ${uniformSnippets.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`;
        }
        /**
         * Get additional implementation that needs to be added to the shader source.
         */
        get additionalImplementations() {
          return this.uniformDeclaration() + this.variables.map((i) => i.impl()).join("\n") + this.internalVariables.map((i) => i.impl()).join("\n");
        }
        /**
         * Get the variable info of the shader program.
         */
        get variablesInfo() {
          if (this.uniforms.length === 0) {
            return void 0;
          }
          const uniformWgslTypeToDataType = (type) => [12 /* uint32 */, 10 /* float16 */, 1 /* float */, 6 /* int32 */][["u32", "f16", "f32", "i32"].indexOf(type)];
          return this.uniforms.map((u) => [uniformWgslTypeToDataType(u.type), u.length ?? 1]);
        }
      };
      createShaderHelper = (dispatchGroup, limits) => new ShaderHelperImpl(dispatchGroup, limits);
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/transpose.ts
  var validateInputs, getAdjustedPerm, getOutputShape, permFunctionBody, squeezeShape, isTransposeReshape, createTransposeProgramInfo, transpose, parseTransposeAttributes;
  var init_transpose = __esm({
    "web/lib/wasm/jsep/webgpu/ops/transpose.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs = (inputs, perm) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Transpose requires 1 input.");
        }
        if (perm.length !== 0 && perm.length !== inputs[0].dims.length) {
          throw new Error(`perm size ${perm.length} does not match input rank ${inputs[0].dims.length}`);
        }
      };
      getAdjustedPerm = (inputRank, perm) => perm.length !== 0 ? perm : [...new Array(inputRank).keys()].reverse();
      getOutputShape = (inputShape, perm) => ShapeUtil.sortBasedOnPerm(inputShape, getAdjustedPerm(inputShape.length, perm));
      permFunctionBody = (perm, rank, input, output) => {
        let reverseFunc = `fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`;
        for (let i = 0; i < rank; ++i) {
          reverseFunc += `a[${perm[i]}]=i[${i}];`;
        }
        return reverseFunc += "return a;}";
      };
      squeezeShape = (shape, adjustedPerm) => {
        const newShape = [];
        const newPerm = [];
        for (let i = 0; i < shape.length; ++i) {
          if (shape[i] !== 1) {
            newShape.push(shape[i]);
          }
          if (shape[adjustedPerm[i]] !== 1) {
            newPerm.push(adjustedPerm[i]);
          }
        }
        return { newShape, newPerm };
      };
      isTransposeReshape = (perm, shape) => {
        let lastPermutedAxis = 0;
        for (let i = 0; i < perm.length; ++i) {
          if (shape[perm[i]] === 1) {
            continue;
          }
          if (perm[i] < lastPermutedAxis) {
            return false;
          }
          lastPermutedAxis = perm[i];
        }
        return true;
      };
      createTransposeProgramInfo = (inputTensor, permAttr) => {
        const inputDataType = inputTensor.dataType;
        const inputRank = inputTensor.dims.length;
        const perm = getAdjustedPerm(inputRank, permAttr);
        const outputShape = getOutputShape(inputTensor.dims, perm);
        let newInputShape = inputTensor.dims;
        let newOutputShape = outputShape;
        const transposeAsReshape = inputRank < 2 || isTransposeReshape(perm, inputTensor.dims);
        let getShaderSource;
        if (transposeAsReshape) {
          getShaderSource = (shaderHelper) => {
            const input = inputVariable("input", inputDataType, newInputShape, 4);
            const output = outputVariable("output", inputDataType, newOutputShape, 4);
            return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`;
          };
          return {
            name: "TransposeCopy",
            shaderCache: { inputDependencies: ["type"] },
            getRunData: () => {
              const outputSize = ShapeUtil.size(outputShape);
              return {
                outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
                dispatchGroup: { x: Math.ceil(
                  outputSize / 64 / 4
                  /* components */
                ) },
                programUniforms: [{ type: 12 /* uint32 */, data: Math.ceil(outputSize / 4) }]
              };
            },
            getShaderSource
          };
        }
        const { newShape, newPerm } = squeezeShape(inputTensor.dims, perm);
        const channelsLast = ShapeUtil.areEqual(newPerm, [2, 3, 1]);
        const channelsFirst = ShapeUtil.areEqual(newPerm, [3, 1, 2]);
        const useShared = newShape.length === 2 || channelsLast || channelsFirst;
        if (useShared) {
          newInputShape = channelsLast ? [newShape[0], newShape[1] * newShape[2]] : channelsFirst ? [newShape[0] * newShape[1], newShape[2]] : newShape;
          newOutputShape = [newInputShape[1], newInputShape[0]];
          const tileSize = 16;
          getShaderSource = (shaderHelper) => {
            const input = inputVariable("a", inputDataType, newInputShape.length);
            const output = outputVariable("output", inputDataType, newOutputShape.length);
            return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
  var<workgroup> tile : array<array<${output.type.value}, ${tileSize + 1}>, ${tileSize}>;
  ${shaderHelper.mainStart([tileSize, tileSize, 1])}
    let stride = (uniforms.output_shape[1] - 1) / ${tileSize} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${tileSize}u + local_id.x;
    let input_row = workgroup_id_x * ${tileSize}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${input.getByIndices(`${input.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${tileSize}u + local_id.x;
    let output_row = workgroup_id_y * ${tileSize}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${output.setByIndices(`${output.type.indices}(output_row, output_col)`, "tile[local_id.x][local_id.y]")}
    }
  }`;
          };
          return {
            name: "TransposeShared",
            shaderCache: { inputDependencies: ["type"] },
            getRunData: () => {
              const outputSize = ShapeUtil.size(outputShape);
              return {
                outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
                dispatchGroup: { x: Math.ceil(newOutputShape[1] / tileSize), y: Math.ceil(newOutputShape[0] / tileSize) },
                programUniforms: [
                  { type: 12 /* uint32 */, data: outputSize },
                  ...createTensorShapeVariables(newInputShape, newOutputShape)
                ]
              };
            },
            getShaderSource
          };
        }
        getShaderSource = (shaderHelper) => {
          const input = inputVariable("a", inputDataType, newInputShape.length);
          const output = outputVariable("output", inputDataType, newOutputShape.length);
          return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

  ${permFunctionBody(perm, inputRank, input, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${output.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${output.setByOffset("global_idx", input.getByIndices("aIndices"))}
  }`;
        };
        return {
          name: "Transpose",
          shaderCache: { hint: `${permAttr}`, inputDependencies: ["rank"] },
          getRunData: () => {
            const outputSize = ShapeUtil.size(outputShape);
            return {
              outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms: [
                { type: 12 /* uint32 */, data: outputSize },
                ...createTensorShapeVariables(newInputShape, newOutputShape)
              ]
            };
          },
          getShaderSource
        };
      };
      transpose = (context, attributes) => {
        validateInputs(context.inputs, attributes.perm);
        context.compute(createTransposeProgramInfo(context.inputs[0], attributes.perm));
      };
      parseTransposeAttributes = (attributes) => createAttributeWithCacheKey({ perm: attributes.perm });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts
  var reduceOps, reduceSharedOps, reduceInitValues, reduceOutputValues, getInnerMostAxes, computeOutAndReduceShapes, expandShapeToKeepDim, areAxesInnerMostDims, getAxesPermutation, createReduceSharedProgramInfo, reduceCommon, reduceMeanShared, reduceL1Shared, reduceL2Shared, reduceLogSumExpShared, reduceMaxShared, reduceMinShared, reduceProdShared, reduceSumShared, reduceSumSquareShared, reduceLogSumShared;
  var init_reduce_shared = __esm({
    "web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_reduce();
      init_transpose();
      reduceOps = {
        max: "select(bestValue, candidate, candidate > bestValue)",
        min: "select(bestValue, candidate, candidate < bestValue)",
        mean: "bestValue + candidate",
        sum: "bestValue + candidate",
        prod: "bestValue * candidate",
        sumSquare: "bestValue + candidate * candidate",
        logSumExp: "bestValue + exp(candidate)",
        l1: "bestValue + abs(candidate)",
        l2: "bestValue + candidate * candidate",
        logSum: "bestValue + candidate"
      };
      reduceSharedOps = {
        max: "select(bestValue, candidate, candidate > bestValue)",
        min: "select(bestValue, candidate, candidate < bestValue)",
        mean: "bestValue + candidate",
        sum: "bestValue + candidate",
        prod: "bestValue * candidate",
        sumSquare: "bestValue + candidate",
        logSumExp: "bestValue + candidate",
        l1: "bestValue + candidate",
        l2: "bestValue + candidate",
        logSum: "bestValue + candidate"
      };
      reduceInitValues = {
        max: "_A[offset]",
        min: "_A[offset]",
        mean: "0",
        sum: "0",
        prod: "1",
        sumSquare: "0",
        logSumExp: "0",
        l1: "0",
        l2: "0",
        logSum: "0"
      };
      reduceOutputValues = {
        max: "bestValue",
        min: "bestValue",
        sum: "bestValue",
        prod: "bestValue",
        sumSquare: "bestValue",
        logSumExp: "log(bestValue)",
        l1: "bestValue",
        l2: "sqrt(bestValue)",
        logSum: "log(bestValue)"
      };
      getInnerMostAxes = (numInnerAxes, rank) => {
        const res = [];
        for (let i = rank - numInnerAxes; i < rank; ++i) {
          res.push(i);
        }
        return res;
      };
      computeOutAndReduceShapes = (shape, axes) => {
        const outputShape = [];
        const rank = shape.length;
        for (let dim = 0; dim < rank; dim++) {
          if (axes.indexOf(dim) === -1) {
            outputShape.push(shape[dim]);
          }
        }
        const reduceShape = axes.map((dim) => shape[dim]);
        return [outputShape, reduceShape];
      };
      expandShapeToKeepDim = (shape, axes) => {
        const rank = shape.length + axes.length;
        const expandShape = [];
        let shapeIdx = 0;
        for (let dim = 0; dim < rank; dim++) {
          if (axes.indexOf(dim) === -1) {
            expandShape.push(shape[shapeIdx++]);
          } else {
            expandShape.push(1);
          }
        }
        return expandShape;
      };
      areAxesInnerMostDims = (axes, rank) => {
        for (let i = 0; i < axes.length; ++i) {
          if (axes[axes.length - i - 1] !== rank - 1 - i) {
            return false;
          }
        }
        return true;
      };
      getAxesPermutation = (axes, rank) => {
        const res = [];
        if (!areAxesInnerMostDims(axes, rank)) {
          for (let i = 0; i < rank; ++i) {
            if (axes.indexOf(i) === -1) {
              res.push(i);
            }
          }
          axes.forEach((axis) => res.push(axis));
        }
        return res;
      };
      createReduceSharedProgramInfo = (name, cacheKey, inputs, reduceType, outputDataType, outputShape, reduceShape) => {
        const inputShape = inputs[0].dims;
        const outputSize = ShapeUtil.size(outputShape);
        const reduceSize = ShapeUtil.size(reduceShape);
        const input = inputVariable("_A", inputs[0].dataType, inputShape);
        const output = outputVariable("output", outputDataType, outputShape);
        let workgroupSize = 64;
        if (outputSize === 1) {
          workgroupSize = 256;
        }
        const sharedMemorySnippet = `
          var<workgroup> aBestValues : array<f32, ${workgroupSize}>;
       `;
        const getShaderSource = (shaderHelper) => `
        ${shaderHelper.registerUniform("reduceSize", "u32").declareVariables(input, output)}
        ${sharedMemorySnippet}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${shaderHelper.mainStart(workgroupSize)}

          let outputIndex = global_idx / ${workgroupSize};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${reduceInitValues[reduceType]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${workgroupSize}) {
           let candidate = f32(${input.getByOffset("offset + k")});
           bestValue = ${reduceOps[reduceType]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${workgroupSize}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${reduceSharedOps[reduceType]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${output.setByOffset(
          "outputIndex",
          `${reduceType === "mean" ? `${output.type.storage}(bestValue / f32(uniforms.reduceSize))` : `${output.type.storage}(${reduceOutputValues[reduceType]})`}`
        )};
         }
        }`;
        return {
          name,
          // Note that in JSEP, WG size is not included in cache by default, but WebGPU EP it is.
          shaderCache: { hint: `${cacheKey};${workgroupSize}`, inputDependencies: ["type"] },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: outputSize },
            programUniforms: [{ type: 12 /* uint32 */, data: reduceSize }]
          })
        };
      };
      reduceCommon = (context, name, attributes, reduceType) => {
        const updatedAttributes = context.inputs.length === 1 ? attributes : createReduceAttributesFromInputs(context.inputs, attributes);
        let updatedAxes = updatedAttributes.axes;
        if (updatedAxes.length === 0 && !updatedAttributes.noopWithEmptyAxes) {
          updatedAxes = context.inputs[0].dims.map((_dim, i) => i);
        }
        const normalizeAxes = ShapeUtil.normalizeAxes(updatedAxes, context.inputs[0].dims.length);
        let axes = normalizeAxes;
        let input = context.inputs[0];
        const permutedAxes = getAxesPermutation(axes, context.inputs[0].dims.length);
        if (permutedAxes.length > 0) {
          input = context.compute(createTransposeProgramInfo(context.inputs[0], permutedAxes), {
            inputs: [0],
            outputs: [-1]
          })[0];
          axes = getInnerMostAxes(axes.length, input.dims.length);
        }
        const [outputShape, reduceShape] = computeOutAndReduceShapes(input.dims, axes);
        let finalOutputShape = outputShape;
        if (updatedAttributes.keepDims) {
          finalOutputShape = expandShapeToKeepDim(outputShape, normalizeAxes);
        }
        context.compute(
          createReduceSharedProgramInfo(
            name,
            updatedAttributes.cacheKey,
            [input],
            reduceType,
            context.inputs[0].dataType,
            finalOutputShape,
            reduceShape
          ),
          { inputs: [input] }
        );
      };
      reduceMeanShared = (context, attributes) => {
        reduceCommon(context, "ReduceMeanShared", attributes, "mean");
      };
      reduceL1Shared = (context, attributes) => {
        reduceCommon(context, "ReduceL1Shared", attributes, "l1");
      };
      reduceL2Shared = (context, attributes) => {
        reduceCommon(context, "ReduceL2Shared", attributes, "l2");
      };
      reduceLogSumExpShared = (context, attributes) => {
        reduceCommon(context, "ReduceLogSumExpShared", attributes, "logSumExp");
      };
      reduceMaxShared = (context, attributes) => {
        reduceCommon(context, "ReduceMaxShared", attributes, "max");
      };
      reduceMinShared = (context, attributes) => {
        reduceCommon(context, "ReduceMinShared", attributes, "min");
      };
      reduceProdShared = (context, attributes) => {
        reduceCommon(context, "ReduceProdShared", attributes, "prod");
      };
      reduceSumShared = (context, attributes) => {
        reduceCommon(context, "ReduceSumShared", attributes, "sum");
      };
      reduceSumSquareShared = (context, attributes) => {
        reduceCommon(context, "ReduceSumSquareShared", attributes, "sumSquare");
      };
      reduceLogSumShared = (context, attributes) => {
        reduceCommon(context, "ReduceLogSumShared", attributes, "logSum");
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/reduce.ts
  var validateInputs2, noOp, createReduceProgramInfo, createReduceAttributesFromInputs, runReduceProgram, reduceLogSumNaive, reduceL1Naive, reduceL2Naive, reduceLogSumExpNaive, reduceMaxNaive, reduceMeanNaive, reduceMinNaive, reduceProdNaive, reduceSumNaive, reduceSumSquareNaive, useNaiveReduceMethod, reduceMean, reduceL1, reduceL2, reduceLogSumExp, reduceMax, reduceMin, reduceProd, reduceSum, reduceSumSquare, reduceLogSum;
  var init_reduce = __esm({
    "web/lib/wasm/jsep/webgpu/ops/reduce.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      init_reduce_shared();
      validateInputs2 = (inputs) => {
        if (!inputs || inputs.length === 0 || inputs.length > 2) {
          throw new Error("Reduce op requires 1 or 2 inputs.");
        }
        if (inputs.length === 2 && inputs[1].dims.length !== 1) {
          throw new Error("Invalid axes input dims.");
        }
      };
      noOp = (input) => ["", "", `var value = ${input.getByIndices("input_indices")};`, ""];
      createReduceProgramInfo = (name, shaderCache, inputs, reduceOp, axesInput, outputDataType, keepDims = false, noopWithEmptyAxes = false) => {
        const outputShape = [];
        const inputShape = inputs[0].dims;
        const inputRank = inputShape.length;
        const axes = ShapeUtil.normalizeAxes(axesInput, inputRank);
        const reduceOnAllAxes = !noopWithEmptyAxes && axes.length === 0;
        inputShape.forEach((d, i) => {
          if (reduceOnAllAxes || axes.indexOf(i) >= 0) {
            if (keepDims) {
              outputShape.push(1);
            }
          } else {
            outputShape.push(d);
          }
        });
        const outputRank = outputShape.length;
        const outputSize = ShapeUtil.size(outputShape);
        const getShaderSource = (shaderHelper) => {
          const idxCopy = [];
          const input = inputVariable("_A", inputs[0].dataType, inputRank);
          const output = outputVariable("output", outputDataType, outputRank);
          const ops = reduceOp(input, output, axes);
          let reduceOps2 = ops[2];
          for (let k = 0, l = 0; k < inputRank; k++) {
            if (reduceOnAllAxes || axes.indexOf(k) >= 0) {
              if (keepDims) {
                l++;
              }
              reduceOps2 = `for(var j${k}: u32 = 0; j${k} < ${inputShape[k]}; j${k}++) {
                  ${ops[2].includes("last_index") ? `let last_index = j${k};` : ""}
                  ${input.indicesSet("input_indices", k, `j${k}`)}
                  ${reduceOps2}
                }`;
            } else {
              idxCopy.push(`${input.indicesSet("input_indices", k, output.indicesGet("output_indices", l))};`);
              l++;
            }
          }
          return `

        ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${input.type.indices};
          let output_indices = ${output.offsetToIndices("global_idx")};

          ${idxCopy.join("\n")}
          ${ops[0]}       // init ops for reduce max/min
          ${ops[1]}
          ${reduceOps2}
          ${ops[3]}
          ${ops.length === 4 ? output.setByOffset("global_idx", "value") : ops.slice(4).join("\n")}
        }`;
        };
        return {
          name,
          shaderCache,
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(inputShape, outputShape)
            ]
          })
        };
      };
      createReduceAttributesFromInputs = (inputs, attributes) => {
        const axes = [];
        if (inputs[1].dims[0] > 0) {
          inputs[1].getBigInt64Array().forEach((v) => axes.push(Number(v)));
        }
        return createAttributeWithCacheKey({
          axes,
          keepDims: attributes.keepDims,
          noopWithEmptyAxes: attributes.noopWithEmptyAxes
        });
      };
      runReduceProgram = (context, name, attributes, reduceOp) => {
        const inputs = context.inputs;
        const updatedAttributes = inputs.length === 1 ? attributes : createReduceAttributesFromInputs(inputs, attributes);
        context.compute(
          createReduceProgramInfo(
            name,
            { hint: updatedAttributes.cacheKey, inputDependencies: ["rank"] },
            [inputs[0]],
            updatedAttributes.noopWithEmptyAxes && updatedAttributes.axes.length === 0 ? noOp : reduceOp,
            updatedAttributes.axes,
            inputs[0].dataType,
            updatedAttributes.keepDims,
            updatedAttributes.noopWithEmptyAxes
          ),
          { inputs: [0] }
        );
      };
      reduceLogSumNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += ${input.getByIndices("input_indices")};`,
          "value = log(value);"
        ];
        runReduceProgram(context, "ReduceLogSum", attributes, reduceOp);
      };
      reduceL1Naive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += abs(${input.getByIndices("input_indices")});`,
          ""
        ];
        runReduceProgram(context, "ReduceL1", attributes, reduceOp);
      };
      reduceL2Naive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
          "",
          `t = ${input.getByIndices("input_indices")}; value += (t * t);`,
          "value = sqrt(value);"
        ];
        runReduceProgram(context, "ReduceL2", attributes, reduceOp);
      };
      reduceLogSumExpNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += exp(${input.getByIndices("input_indices")});`,
          "value = log(value);"
        ];
        runReduceProgram(context, "ReduceLogSumExp", attributes, reduceOp);
      };
      reduceMaxNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, _output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(input.indicesSet("input_indices", k, 0));
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};`,
            `value = max(value, ${input.getByIndices("input_indices")});`,
            ""
          ];
        };
        runReduceProgram(context, "ReduceMax", attributes, reduceOp);
      };
      reduceMeanNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output, axes) => {
          let size = 1;
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              size *= context.inputs[0].dims[k];
            }
          }
          return [
            "var sum = f32(0);",
            "",
            `sum += f32(${input.getByIndices("input_indices")});`,
            `let value = ${output.type.value}(sum / ${size});`
          ];
        };
        runReduceProgram(context, "ReduceMean", attributes, reduceOp);
      };
      reduceMinNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, _output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`input_indices[${k}] = 0;`);
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};`,
            `value = min(value, ${input.getByIndices("input_indices")});`,
            ""
          ];
        };
        runReduceProgram(context, "ReduceMin", attributes, reduceOp);
      };
      reduceProdNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(1);`,
          "",
          `value *= ${input.getByIndices("input_indices")};`,
          ""
        ];
        runReduceProgram(context, "ReduceProd", attributes, reduceOp);
      };
      reduceSumNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += ${input.getByIndices("input_indices")};`,
          ""
        ];
        runReduceProgram(context, "ReduceSum", attributes, reduceOp);
      };
      reduceSumSquareNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
          "",
          `t = ${input.getByIndices("input_indices")}; value += t * t;`,
          ""
        ];
        runReduceProgram(context, "ReduceSumSquare", attributes, reduceOp);
      };
      useNaiveReduceMethod = (shape, axes, noopWithEmptyAxes) => {
        if (axes.length === 0) {
          return noopWithEmptyAxes;
        }
        let outputSize = 1;
        let reduceSize = 1;
        for (let dim = 0; dim < axes.length; dim++) {
          if (axes.indexOf(dim) === -1) {
            outputSize *= shape[dim];
          } else {
            reduceSize *= shape[dim];
          }
        }
        return reduceSize < 32 && outputSize > 1024;
      };
      reduceMean = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceMeanNaive(context, attributes);
        } else {
          reduceMeanShared(context, attributes);
        }
      };
      reduceL1 = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceL1Naive(context, attributes);
        } else {
          reduceL1Shared(context, attributes);
        }
      };
      reduceL2 = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceL2Naive(context, attributes);
        } else {
          reduceL2Shared(context, attributes);
        }
      };
      reduceLogSumExp = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceLogSumExpNaive(context, attributes);
        } else {
          reduceLogSumExpShared(context, attributes);
        }
      };
      reduceMax = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceMaxNaive(context, attributes);
        } else {
          reduceMaxShared(context, attributes);
        }
      };
      reduceMin = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceMinNaive(context, attributes);
        } else {
          reduceMinShared(context, attributes);
        }
      };
      reduceProd = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceProdNaive(context, attributes);
        } else {
          reduceProdShared(context, attributes);
        }
      };
      reduceSum = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceSumNaive(context, attributes);
        } else {
          reduceSumShared(context, attributes);
        }
      };
      reduceSumSquare = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceSumSquareNaive(context, attributes);
        } else {
          reduceSumSquareShared(context, attributes);
        }
      };
      reduceLogSum = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceLogSumNaive(context, attributes);
        } else {
          reduceLogSumShared(context, attributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/argminmax.ts
  var validateInputs3, argMin, argMax, parseArgMinMaxAttributes;
  var init_argminmax = __esm({
    "web/lib/wasm/jsep/webgpu/ops/argminmax.ts"() {
      "use strict";
      init_wasm_common();
      init_attribute_with_cache_key();
      init_reduce();
      validateInputs3 = (inputs) => {
        if (!inputs || inputs.length === 0 || inputs.length > 2) {
          throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");
        }
        if (inputs[0].dataType !== 1 /* float */) {
          throw new Error("Invalid input type.");
        }
      };
      argMin = (context, attributes) => {
        validateInputs3(context.inputs);
        const argMinMaxOp = (input, output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`input_indices[${k}] = 0;`);
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
            `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? "<=" : "<"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
            "",
            output.setByOffset("global_idx", "best_index")
          ];
        };
        context.compute(
          createReduceProgramInfo(
            "ArgMin",
            { hint: attributes.cacheKey, inputDependencies: ["rank"] },
            [context.inputs[0]],
            argMinMaxOp,
            [attributes.axis],
            7 /* int64 */,
            attributes.keepDims
          ),
          { inputs: [0] }
        );
      };
      argMax = (context, attributes) => {
        validateInputs3(context.inputs);
        const argMinMaxOp = (input, output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`input_indices[${k}] = 0;`);
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
            `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? ">=" : ">"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
            "",
            output.setByOffset("global_idx", "best_index")
          ];
        };
        context.compute(
          createReduceProgramInfo(
            "argMax",
            { hint: attributes.cacheKey, inputDependencies: ["rank"] },
            [context.inputs[0]],
            argMinMaxOp,
            [attributes.axis],
            7 /* int64 */,
            attributes.keepDims
          ),
          { inputs: [0] }
        );
      };
      parseArgMinMaxAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/attention.ts
  var validateAttentionInputs, initVarStub, createInPlaceSoftmaxProgramInfo, createAttentionProbsProgramInfo, createVxAttentionScoreProgramInfo, applyAttention, prepare, attention;
  var init_attention = __esm({
    "web/lib/wasm/jsep/webgpu/ops/attention.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_types();
      init_common();
      validateAttentionInputs = (inputs, attributes) => {
        const input = inputs[0];
        const weights = inputs[1];
        const bias = inputs[2];
        const maskIndex = inputs[3];
        const past = inputs[4];
        const attentionBias = inputs[5];
        if (past && attentionBias) {
          throw new Error("Attention cannot have both past and attention_bias");
        }
        if (input.dims.length !== 3) {
          throw new Error('Input "input" must have 3 dimensions');
        }
        const batchSize = input.dims[0];
        const sequenceLength = input.dims[1];
        const inputHiddenSize = input.dims[2];
        if (bias.dims.length !== 1) {
          throw new Error('Input "bias" is expected to have 1 dimensions');
        }
        if (weights.dims.length !== 2) {
          throw new Error('Input "weights" is expected to have 2 dimensions');
        }
        if (weights.dims[0] !== inputHiddenSize) {
          throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");
        }
        if (bias.dims[0] !== weights.dims[1]) {
          throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');
        }
        let qHiddenSize = bias.dims[0] / 3;
        let kHiddenSize = qHiddenSize;
        let vHiddenSize = kHiddenSize;
        if (attributes.qkvHiddenSizes.length > 0) {
          if (attributes.qkvHiddenSizes.length !== 3) {
            throw new Error("qkv_hidden_sizes attribute should have 3 elements");
          }
          for (const sz of attributes.qkvHiddenSizes) {
            if (sz % attributes.numHeads !== 0) {
              throw new Error("qkv_hidden_sizes should be divisible by num_heads");
            }
          }
          qHiddenSize = attributes.qkvHiddenSizes[0];
          kHiddenSize = attributes.qkvHiddenSizes[1];
          vHiddenSize = attributes.qkvHiddenSizes[2];
        }
        const kvSequenceLength = sequenceLength;
        if (qHiddenSize !== kHiddenSize) {
          throw new Error("qkv_hidden_sizes first element should be same as the second");
        }
        if (bias.dims[0] !== qHiddenSize + kHiddenSize + vHiddenSize) {
          throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');
        }
        let pastSequenceLength = 0;
        if (past) {
          if (kHiddenSize !== vHiddenSize) {
            throw new Error('Input "past" expect k_hidden_size == v_hidden_size');
          }
          if (past.dims.length !== 5) {
            throw new Error('Input "past" must have 5 dimensions');
          }
          if (past.dims[0] !== 2) {
            throw new Error('Input "past" first dimension must be 2');
          }
          if (past.dims[1] !== batchSize) {
            throw new Error('Input "past" second dimension must be batch_size');
          }
          if (past.dims[2] !== attributes.numHeads) {
            throw new Error('Input "past" third dimension must be num_heads');
          }
          if (past.dims[4] !== kHiddenSize / attributes.numHeads) {
            throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');
          }
          if (!attributes.pastPresentShareBuffer) {
            pastSequenceLength = past.dims[3];
          }
        }
        const totalSequenceLength = kvSequenceLength + pastSequenceLength;
        const maxSequenceLength = -1;
        const maskType = 0 /* none */;
        if (maskIndex) {
          throw new Error("Mask not supported");
        }
        if (past) {
          throw new Error("past is not supported");
        }
        if (attentionBias) {
          if (attentionBias.dims.length !== 4) {
            throw new Error('Input "attention_bias" must have 4 dimensions');
          }
          if (attentionBias.dims[0] !== batchSize || attentionBias.dims[1] !== attributes.numHeads || attentionBias.dims[2] !== sequenceLength || attentionBias.dims[3] !== totalSequenceLength) {
            throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
          }
        }
        return {
          batchSize,
          sequenceLength,
          pastSequenceLength,
          kvSequenceLength,
          totalSequenceLength,
          maxSequenceLength,
          inputHiddenSize,
          hiddenSize: qHiddenSize,
          vHiddenSize,
          headSize: Math.floor(qHiddenSize / attributes.numHeads),
          vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
          numHeads: attributes.numHeads,
          isUnidirectional: false,
          pastPresentShareBuffer: false,
          maskFilterValue: attributes.maskFilterValue,
          maskType,
          scale: attributes.scale,
          broadcastResPosBias: false,
          passPastInKv: false,
          qkvFormat: 1 /* qkvBNSH */
        };
      };
      initVarStub = (seqLensInput, totalSequenceLengthInput, initPastSequenceLength) => {
        if (totalSequenceLengthInput && seqLensInput) {
          return `
      let total_sequence_length_input = u32(${totalSequenceLengthInput.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${seqLensInput?.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `;
        } else {
          return `
    ${initPastSequenceLength ? "let past_sequence_length = uniforms.past_sequence_length" : ""};
    let present_sequence_length = total_sequence_length;
    `;
        }
      };
      createInPlaceSoftmaxProgramInfo = (input, batchSize, numHeads, pastSequenceLength, sequenceLength, totalSequenceLength, seqLens, totalSequenceLengthInput) => {
        const components = getMaxComponents(seqLens ? 1 : totalSequenceLength);
        let WG = 64;
        const totalSequenceLengthComp = totalSequenceLength / components;
        if (totalSequenceLengthComp < WG) {
          WG = 32;
        }
        const elementsPerThread = Math.ceil(totalSequenceLength / components / WG);
        const programUniforms = [
          { type: 12 /* uint32 */, data: batchSize },
          { type: 12 /* uint32 */, data: numHeads },
          { type: 12 /* uint32 */, data: pastSequenceLength },
          { type: 12 /* uint32 */, data: sequenceLength },
          { type: 12 /* uint32 */, data: totalSequenceLengthComp },
          { type: 12 /* uint32 */, data: elementsPerThread }
        ];
        const dataType = tensorTypeToWsglStorageType(input.dataType, components);
        const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
        const inputDependencies = ["type"];
        if (seqLens) {
          inputDependencies.push("type");
        }
        if (totalSequenceLengthInput) {
          inputDependencies.push("type");
        }
        const getShaderSource = (shaderHelper) => {
          const inputHelper = outputVariable("x", input.dataType, input.dims, components);
          const inputHelpers = [inputHelper];
          const seqLensInputHelper = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
          if (seqLensInputHelper) {
            inputHelpers.push(seqLensInputHelper);
          }
          const totalSequenceLengthInputHelper = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
          if (totalSequenceLengthInputHelper) {
            inputHelpers.push(totalSequenceLengthInputHelper);
          }
          const elemValueType = tensorTypeToWsglValueType(input.dataType);
          const uniforms = [
            { name: "batch_size", type: "u32" },
            { name: "num_heads", type: "u32" },
            { name: "past_sequence_length", type: "u32" },
            { name: "sequence_length", type: "u32" },
            { name: "total_sequence_length", type: "u32" },
            { name: "elements_per_thread", type: "u32" }
          ];
          return `
  var<workgroup> thread_max: array<f32, ${WG}>;
  var<workgroup> thread_sum: array<f32, ${WG}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputHelpers)}
  ${shaderHelper.mainStart([WG, 1, 1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${initVarStub(seqLensInputHelper, totalSequenceLengthInputHelper, false)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${WG}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${seqLens ? "u32(past_sequence_length + workgroup_id.y + 1)" : "total_sequence_length"};
    var thread_max_vector = ${f32Type}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${f32Type}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(() => {
            switch (components) {
              case 1:
                return "thread_max_vector";
              case 2:
                return "max(thread_max_vector.x, thread_max_vector.y)";
              case 4:
                return "max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";
              default:
                throw new Error(`Unsupported components: ${components}`);
            }
          })()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${WG}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${f32Type}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${f32Type}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(() => {
            switch (components) {
              case 1:
                return "sum_vector";
              case 2:
                return "sum_vector.x + sum_vector.y";
              case 4:
                return "sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";
              default:
                throw new Error(`Unsupported components: ${components}`);
            }
          })()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${WG}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${inputHelper.type.value}(${elemValueType}(1.0) / ${elemValueType}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${f32Type}(x[offset + i]);
        x[offset + i] = ${inputHelper.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${seqLens ? `
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${inputHelper.type.value}(${elemValueType}(0));
        }` : ""};
  }`;
        };
        return {
          name: "AttentionProbsSoftmax",
          shaderCache: { hint: `${WG};${dataType};${components}`, inputDependencies },
          getShaderSource,
          getRunData: () => ({
            outputs: [],
            dispatchGroup: { x: 1, y: sequenceLength, z: batchSize * numHeads },
            programUniforms
          })
        };
      };
      createAttentionProbsProgramInfo = (outputCount, q, key, pastKey, attentionBias, parameters, pastSequenceLength, seqLens, totalSequenceLengthInput) => {
        const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
        const probsShape = [parameters.batchSize, parameters.numHeads, parameters.sequenceLength, totalSequenceLength];
        const presentKey = outputCount > 1 && pastKey;
        const kvNumHeads = parameters.kvNumHeads ? parameters.kvNumHeads : parameters.numHeads;
        const presentKeyShape = presentKey ? [parameters.batchSize, kvNumHeads, totalSequenceLength, parameters.headSize] : void 0;
        const nReps = parameters.nReps ? parameters.nReps : 1;
        const alpha = parameters.scale === 0 ? 1 / Math.sqrt(parameters.headSize) : parameters.scale;
        const components = getMaxComponents(parameters.headSize);
        const vectorizedHeadSize = parameters.headSize / components;
        const TILE_SIZE = 12;
        const dispatch = {
          x: Math.ceil(totalSequenceLength / TILE_SIZE),
          y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
          z: parameters.batchSize * parameters.numHeads
        };
        const programUniforms = [
          { type: 12 /* uint32 */, data: parameters.sequenceLength },
          { type: 12 /* uint32 */, data: vectorizedHeadSize },
          { type: 12 /* uint32 */, data: totalSequenceLength },
          { type: 12 /* uint32 */, data: parameters.numHeads },
          { type: 12 /* uint32 */, data: parameters.headSize },
          { type: 1 /* float */, data: alpha },
          { type: 12 /* uint32 */, data: pastSequenceLength },
          { type: 12 /* uint32 */, data: parameters.kvSequenceLength },
          { type: 12 /* uint32 */, data: nReps }
        ];
        const feedPastKey = presentKey && pastKey && ShapeUtil.size(pastKey.dims) > 0;
        const inputDependencies = ["type", "type"];
        if (feedPastKey) {
          inputDependencies.push("type");
        }
        if (attentionBias) {
          inputDependencies.push("type");
        }
        if (seqLens) {
          inputDependencies.push("type");
        }
        if (totalSequenceLengthInput) {
          inputDependencies.push("type");
        }
        const outputs = [{ dims: probsShape, dataType: q.dataType, gpuDataType: 0 /* default */ }];
        if (presentKey) {
          outputs.push({ dims: presentKeyShape, dataType: q.dataType, gpuDataType: 0 /* default */ });
        }
        const getShaderSource = (shaderHelper) => {
          const qInput = inputVariable("q", q.dataType, q.dims, components);
          const kInput = inputVariable("key", key.dataType, key.dims, components);
          const inputVars = [qInput, kInput];
          if (feedPastKey) {
            const pastKeyInput = inputVariable("past_key", pastKey.dataType, pastKey.dims, components);
            inputVars.push(pastKeyInput);
          }
          if (attentionBias) {
            inputVars.push(inputVariable("attention_bias", attentionBias.dataType, attentionBias.dims));
          }
          const seqLensInputVariable = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
          if (seqLensInputVariable) {
            inputVars.push(seqLensInputVariable);
          }
          const totalSequenceLengthInputVariable = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
          if (totalSequenceLengthInputVariable) {
            inputVars.push(totalSequenceLengthInputVariable);
          }
          const output = outputVariable("output", q.dataType, probsShape);
          const outputVars = [output];
          if (presentKey) {
            outputVars.push(outputVariable("present_key", q.dataType, presentKeyShape, components));
          }
          const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
          const uniforms = [
            { name: "M", type: "u32" },
            { name: "K", type: "u32" },
            { name: "N", type: "u32" },
            { name: "num_heads", type: "u32" },
            { name: "head_size", type: "u32" },
            { name: "alpha", type: "f32" },
            { name: "past_sequence_length", type: "u32" },
            { name: "kv_sequence_length", type: "u32" },
            { name: "n_reps", type: "u32" }
          ];
          return `
  const TILE_SIZE = ${TILE_SIZE}u;

  var<workgroup> tileQ: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileK: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${nReps === 1 ? "headIdx" : "headIdx / uniforms.n_reps"};
    let kv_num_heads = ${nReps === 1 ? "uniforms.num_heads" : "uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${initVarStub(seqLensInputVariable, totalSequenceLengthInputVariable, true)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${feedPastKey && presentKey ? "let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;" : ""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${presentKey ? "let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;" : ""}
    var value = ${f32Type}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${(() => {
            if (feedPastKey && presentKey) {
              return `
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`;
            } else {
              return `
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`;
            }
          })()}
      ${presentKey ? `if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }` : ""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${f32Type}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(() => {
            switch (components) {
              case 1:
                return "value";
              case 2:
                return "value.x + value.y";
              case 4:
                return "value.x + value.y + value.z + value.w";
              default:
                throw new Error(`Unsupported components: ${components}`);
            }
          })()};
        output[outputIdx] = ${output.type.value} (sum * uniforms.alpha) + ${attentionBias ? "attention_bias[outputIdx]" : "0.0"};
    }
  }`;
        };
        return {
          name: "AttentionProbs",
          shaderCache: {
            hint: `${components};${attentionBias !== void 0};${pastKey !== void 0};${outputCount}`,
            inputDependencies
          },
          getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
          getShaderSource
        };
      };
      createVxAttentionScoreProgramInfo = (outputCount, probs, v, pastValue, params, pastSequenceLength, seqLens = void 0, totalSequenceLengthInput = void 0) => {
        const totalSequenceLength = pastSequenceLength + params.kvSequenceLength;
        const nReps = params.nReps ? params.nReps : 1;
        const repeatedVHiddenSize = params.vHiddenSize * nReps;
        const presentValue = outputCount > 1 && pastValue;
        const kvNumHeads = params.kvNumHeads ? params.kvNumHeads : params.numHeads;
        const presentValueShape = presentValue ? [params.batchSize, kvNumHeads, totalSequenceLength, params.headSize] : void 0;
        const outputShape = [params.batchSize, params.sequenceLength, repeatedVHiddenSize];
        const TILE_SIZE = 12;
        const dispatch = {
          x: Math.ceil(params.vHeadSize / TILE_SIZE),
          y: Math.ceil(params.sequenceLength / TILE_SIZE),
          z: params.batchSize * params.numHeads
        };
        const programUniforms = [
          { type: 12 /* uint32 */, data: params.sequenceLength },
          { type: 12 /* uint32 */, data: totalSequenceLength },
          { type: 12 /* uint32 */, data: params.vHeadSize },
          { type: 12 /* uint32 */, data: params.numHeads },
          { type: 12 /* uint32 */, data: params.headSize },
          { type: 12 /* uint32 */, data: repeatedVHiddenSize },
          { type: 12 /* uint32 */, data: pastSequenceLength },
          { type: 12 /* uint32 */, data: params.kvSequenceLength },
          { type: 12 /* uint32 */, data: nReps }
        ];
        const feedPastValue = presentValue && pastValue && ShapeUtil.size(pastValue.dims) > 0;
        const inputDependencies = ["type", "type"];
        if (feedPastValue) {
          inputDependencies.push("type");
        }
        if (seqLens) {
          inputDependencies.push("type");
        }
        if (totalSequenceLengthInput) {
          inputDependencies.push("type");
        }
        const outputs = [{ dims: outputShape, dataType: probs.dataType, gpuDataType: 0 /* default */ }];
        if (presentValue) {
          outputs.push({ dims: presentValueShape, dataType: probs.dataType, gpuDataType: 0 /* default */ });
        }
        const getShaderSource = (shaderHelper) => {
          const probsHelper = inputVariable("probs", probs.dataType, probs.dims);
          const vHelper = inputVariable("v", v.dataType, v.dims);
          const inputVars = [probsHelper, vHelper];
          if (feedPastValue) {
            inputVars.push(inputVariable("past_value", pastValue.dataType, pastValue.dims));
          }
          const seqLensInputVariable = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
          if (seqLens) {
            inputVars.push(seqLensInputVariable);
          }
          const totalSequenceLengthInputVariable = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
          if (totalSequenceLengthInput) {
            inputVars.push(totalSequenceLengthInputVariable);
          }
          const output = outputVariable("output", probs.dataType, outputShape);
          const outputVars = [output];
          if (presentValue) {
            outputVars.push(outputVariable("present_value", probs.dataType, presentValueShape));
          }
          const uniforms = [
            { name: "M", type: "u32" },
            { name: "K", type: "u32" },
            { name: "N", type: "u32" },
            { name: "num_heads", type: "u32" },
            { name: "head_size", type: "u32" },
            { name: "v_hidden_size", type: "u32" },
            { name: "past_sequence_length", type: "u32" },
            { name: "kv_sequence_length", type: "u32" },
            { name: "n_reps", type: "u32" }
          ];
          return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileQ: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileV: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${nReps === 1 ? "headIdx" : "headIdx / uniforms.n_reps"};
   let kv_num_heads = ${nReps === 1 ? "uniforms.num_heads" : "uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${initVarStub(seqLensInputVariable, totalSequenceLengthInputVariable, true)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${feedPastValue && presentValue ? "let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;" : ""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${presentValue ? "let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;" : ""}
   var value = ${probsHelper.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${(() => {
            if (feedPastValue && presentValue) {
              return `
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `;
            } else {
              return `
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`;
            }
          })()}
        ${presentValue ? `
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }` : ""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`;
        };
        return {
          name: "AttentionScore",
          shaderCache: { hint: `${pastValue !== void 0};${outputCount}`, inputDependencies },
          getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
          getShaderSource
        };
      };
      applyAttention = (context, q, k, v, _maskIndex, _past, pastKey, pastValue, attentionBiasInput, parameters, seqLens = void 0, totalSequenceLengthInput = void 0) => {
        const outputCount = Math.min(context.outputCount, 1 + (pastKey ? 1 : 0) + (pastValue ? 1 : 0));
        const pastSequenceLength = outputCount > 1 ? parameters.pastSequenceLength : 0;
        const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
        const attentionBias = attentionBiasInput && ShapeUtil.size(attentionBiasInput.dims) > 0 ? attentionBiasInput : void 0;
        const inputsK = [q, k];
        if (outputCount > 1 && pastKey && ShapeUtil.size(pastKey.dims) > 0) {
          inputsK.push(pastKey);
        }
        if (attentionBias) {
          inputsK.push(attentionBias);
        }
        if (seqLens) {
          inputsK.push(seqLens);
        }
        if (totalSequenceLengthInput) {
          inputsK.push(totalSequenceLengthInput);
        }
        const probs = context.compute(
          createAttentionProbsProgramInfo(
            outputCount,
            q,
            k,
            pastKey,
            attentionBias,
            parameters,
            pastSequenceLength,
            seqLens,
            totalSequenceLengthInput
          ),
          { inputs: inputsK, outputs: outputCount > 1 ? [-1, 1] : [-1] }
        )[0];
        context.compute(
          createInPlaceSoftmaxProgramInfo(
            probs,
            parameters.batchSize,
            parameters.numHeads,
            pastSequenceLength,
            parameters.sequenceLength,
            totalSequenceLength,
            seqLens,
            totalSequenceLengthInput
          ),
          { inputs: seqLens && totalSequenceLengthInput ? [probs, seqLens, totalSequenceLengthInput] : [probs], outputs: [] }
        );
        const inputsV = [probs, v];
        if (outputCount > 1 && pastValue && ShapeUtil.size(pastValue.dims) > 0) {
          inputsV.push(pastValue);
        }
        if (seqLens) {
          inputsV.push(seqLens);
        }
        if (totalSequenceLengthInput) {
          inputsV.push(totalSequenceLengthInput);
        }
        context.compute(
          createVxAttentionScoreProgramInfo(
            outputCount,
            probs,
            v,
            pastValue,
            parameters,
            pastSequenceLength,
            seqLens,
            totalSequenceLengthInput
          ),
          {
            inputs: inputsV,
            outputs: outputCount > 1 ? [0, 2] : [0]
          }
        );
      };
      prepare = (context, parameters) => {
        const outputShape = [parameters.batchSize, parameters.numHeads, parameters.sequenceLength, parameters.headSize];
        const M = parameters.sequenceLength;
        const K = parameters.inputHiddenSize;
        const N = parameters.headSize;
        const TILE_SIZE = 12;
        const dispatch = {
          x: Math.ceil(parameters.headSize / TILE_SIZE),
          y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
          z: parameters.batchSize * parameters.numHeads
        };
        const inputs = [context.inputs[0], context.inputs[1], context.inputs[2]];
        const programUniforms = [
          { type: 12 /* uint32 */, data: M },
          { type: 12 /* uint32 */, data: K },
          { type: 12 /* uint32 */, data: N },
          { type: 12 /* uint32 */, data: parameters.numHeads },
          { type: 12 /* uint32 */, data: parameters.headSize },
          { type: 12 /* uint32 */, data: parameters.hiddenSize },
          { type: 12 /* uint32 */, data: parameters.hiddenSize + parameters.hiddenSize + parameters.vHiddenSize }
        ];
        const getShaderSource = (shaderHelper) => {
          const outputQ = outputVariable("output_q", inputs[0].dataType, outputShape);
          const outputK = outputVariable("output_k", inputs[0].dataType, outputShape);
          const outputV = outputVariable("output_v", inputs[0].dataType, outputShape);
          const input = inputVariable("input", inputs[0].dataType, inputs[0].dims);
          const weight = inputVariable("weight", inputs[1].dataType, inputs[1].dims);
          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims);
          const dataType = input.type.storage;
          const uniforms = [
            { name: "M", type: "u32" },
            { name: "K", type: "u32" },
            { name: "N", type: "u32" },
            { name: "num_heads", type: "u32" },
            { name: "head_size", type: "u32" },
            { name: "hidden_size", type: "u32" },
            { name: "ldb", type: "u32" }
          ];
          return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileInput: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightQ: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightK: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightV: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(input, weight, bias, outputQ, outputK, outputV)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${dataType}(0);
    var valueK = ${dataType}(0);
    var valueV = ${dataType}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`;
        };
        return context.compute(
          {
            name: "AttentionPrepare",
            shaderCache: { inputDependencies: ["type", "type", "type"] },
            getRunData: () => ({
              outputs: [
                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ }
              ],
              dispatchGroup: dispatch,
              programUniforms
            }),
            getShaderSource
          },
          { inputs, outputs: [-1, -1, -1] }
        );
      };
      attention = (context, attributes) => {
        const params = validateAttentionInputs(context.inputs, attributes);
        const [q, k, v] = prepare(context, params);
        return applyAttention(
          context,
          q,
          k,
          v,
          context.inputs[4],
          void 0,
          void 0,
          void 0,
          context.inputs[5],
          params
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/batch-norm.ts
  var validateInputs4, createBatchNormInferenceProgramInfo, parseBatchNormAttributes, batchNorm;
  var init_batch_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/batch-norm.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs4 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 5) {
          throw new Error("BatchNormalization requires 5 inputs");
        }
        const checkShapeEqual = (actual, expected, message) => {
          const r = expected.length;
          if (r !== actual.length) {
            throw new Error(`${message}: num dimensions != ${r}`);
          }
          expected.forEach((v, i) => {
            if (v !== actual[i]) {
              throw new Error(`${message}: dim[${i}] do not match`);
            }
          });
        };
        if (inputs[0].dims.length > 1) {
          const shape = attributes.format === "NHWC" ? attributes.spatial ? inputs[0].dims.slice(-1) : inputs[0].dims.slice(-1).concat(inputs[0].dims.slice(1, inputs[0].dims.length - 1)) : inputs[0].dims.slice(1, attributes.spatial ? 2 : void 0);
          checkShapeEqual(inputs[1].dims, shape, "Invalid input scale");
          checkShapeEqual(inputs[2].dims, shape, "Invalid input B");
          checkShapeEqual(inputs[3].dims, shape, "Invalid input mean");
          checkShapeEqual(inputs[4].dims, shape, "Invalid input var");
        } else {
          checkShapeEqual(inputs[1].dims, [1], "Invalid input scale");
          checkShapeEqual(inputs[2].dims, [1], "Invalid input B");
          checkShapeEqual(inputs[3].dims, [1], "Invalid input mean");
          checkShapeEqual(inputs[4].dims, [1], "Invalid input var");
        }
      };
      createBatchNormInferenceProgramInfo = (inputs, attributes) => {
        const { epsilon, spatial, format } = attributes;
        const yShape = inputs[0].dims;
        const components = spatial ? getMaxComponents(yShape[yShape.length - 1]) : 1;
        const cComponents = format === "NHWC" && yShape.length > 1 ? components : 1;
        const outputSize = ShapeUtil.size(yShape) / components;
        const useShapesUniforms = spatial;
        const shapeOrRank = useShapesUniforms ? yShape.length : yShape;
        const x = inputVariable("x", inputs[0].dataType, inputs[0].dims, components);
        const scale = inputVariable("scale", inputs[1].dataType, inputs[1].dims, cComponents);
        const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims, cComponents);
        const inputMean = inputVariable("inputMean", inputs[3].dataType, inputs[3].dims, cComponents);
        const inputVar = inputVariable("inputVar", inputs[4].dataType, inputs[4].dims, cComponents);
        const y = outputVariable("y", inputs[0].dataType, shapeOrRank, components);
        const calcCOffset = () => {
          let cOffset = "";
          if (spatial) {
            cOffset = `let cOffset = ${yShape.length === 1 ? "0u" : format === "NHWC" ? `outputIndices[${yShape.length - 1}] / ${components}` : "outputIndices[1]"};`;
          } else {
            if (format === "NCHW") {
              cOffset = `
            ${y.indicesSet("outputIndices", "0", "0")}
            let cOffset = ${y.indicesToOffset("outputIndices")};`;
            } else {
              cOffset = `var cIndices = ${scale.type.indices}(0);
                       cIndices[0] = outputIndices[${yShape.length - 1}];`;
              for (let i = 1; i < scale.rank; i++) {
                cOffset += `cIndices[${i}] = outputIndices[${i}];`;
              }
              cOffset += `let cOffset = ${scale.indicesToOffset("cIndices")};`;
            }
          }
          return cOffset;
        };
        const getInferenceModeShaderSource = (helper) => `
  const epsilon = ${epsilon};
  ${helper.registerUniform("outputSize", "u32").declareVariables(x, scale, bias, inputMean, inputVar, y)}
  ${helper.mainStart()}
  ${helper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${y.offsetToIndices(`global_idx * ${components}`)};
    ${calcCOffset()}
    let scale = ${scale.getByOffset("cOffset")};
    let bias = ${bias.getByOffset("cOffset")};
    let inputMean = ${inputMean.getByOffset("cOffset")};
    let inputVar = ${inputVar.getByOffset("cOffset")};
    let x = ${x.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${y.setByOffset("global_idx", "value")}
  }`;
        return {
          name: "BatchNormalization",
          shaderCache: {
            hint: `${attributes.epsilon}_${attributes.format}_${spatial}_${components}`,
            inputDependencies: useShapesUniforms ? ["rank", "type", "type", "type", "type"] : void 0
          },
          getShaderSource: getInferenceModeShaderSource,
          getRunData: () => ({
            outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: useShapesUniforms ? [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(yShape)] : [{ type: 12 /* uint32 */, data: outputSize }]
          })
        };
      };
      parseBatchNormAttributes = (attributes) => createAttributeWithCacheKey(attributes);
      batchNorm = (context, attributes) => {
        const { inputs, outputCount } = context;
        const updatedAttributes = parseBatchNormAttributes({ ...attributes, outputCount });
        if (env2.webgpu.validateInputContent) {
          validateInputs4(inputs, updatedAttributes);
        }
        if (attributes.trainingMode) {
          throw new Error("BatchNormalization trainingMode is not supported yet.");
        } else {
          context.compute(createBatchNormInferenceProgramInfo(inputs, updatedAttributes));
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/bias-add.ts
  var validateInputs5, createBiasAddProgramInfo, biasAdd;
  var init_bias_add = __esm({
    "web/lib/wasm/jsep/webgpu/ops/bias-add.ts"() {
      "use strict";
      init_util();
      init_common();
      validateInputs5 = (inputs) => {
        if (inputs[0].dims.length !== 3) {
          throw new Error("input should have 3 dimensions");
        }
        if (![320, 640, 1280].includes(inputs[0].dims[2])) {
          throw new Error("number of channels should be 320, 640 or 1280");
        }
        if (inputs[1].dims.length !== 1) {
          throw new Error("bias is expected to have 1 dimensions");
        }
        if (inputs[0].dims[2] !== inputs[1].dims[0]) {
          throw new Error("last dimension of input and bias are not the same");
        }
      };
      createBiasAddProgramInfo = (inputs) => {
        const outputShape = inputs[0].dims;
        const channels = inputs[0].dims[2];
        const outputSize = ShapeUtil.size(outputShape) / 4;
        const dataType = inputs[0].dataType;
        const input = inputVariable("input", dataType, outputShape, 4);
        const bias = inputVariable("bias", dataType, [channels], 4);
        const residual = inputVariable("residual", dataType, outputShape, 4);
        const output = outputVariable("output", dataType, outputShape, 4);
        const getShaderSource = (shaderHelper) => `
  const channels = ${channels}u / 4;
  ${shaderHelper.declareVariables(input, bias, residual, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let value = ${input.getByOffset("global_idx")}
      + ${bias.getByOffset("global_idx % channels")} + ${residual.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", "value")}
  }`;
        return {
          name: "BiasAdd",
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) }
          }),
          getShaderSource
        };
      };
      biasAdd = (context) => {
        validateInputs5(context.inputs);
        context.compute(createBiasAddProgramInfo(context.inputs));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/unary-op.ts
  var createElementwiseProgramShader, createElementwiseProgramInfo, abs, acos, acosh, asin, asinh, atan, atanh, parseCastAttributes, cast, generateClipAttributesFromInputs, clip, ceil, cos, cosh, parseAlphaAttributes, elu, erfImpl, erf, exp, floor, gelu, leakyRelu, not, neg, reciprocal, relu, sigmoid, parseHardSigmoidAttributes, hardSigmoid, sin, sinh, sqrt, tan, tanhExpression, tanh, fastGeluImpl, fastGeluExpression, fastGelu, thresholdedRelu, log, quickGeluImpl, quickGeluExpression, quickgelu;
  var init_unary_op = __esm({
    "web/lib/wasm/jsep/webgpu/ops/unary-op.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      createElementwiseProgramShader = (shaderHelper, datasize, inputDataType, outputDataType, funcCall, additionalImplementation, additionalUniformsType) => {
        const vecSize = Math.ceil(datasize / 4);
        let expression = "";
        if (typeof funcCall === "string") {
          expression = `${funcCall}(a)`;
        } else {
          expression = funcCall("a");
        }
        const input = inputVariable("inputData", inputDataType, [vecSize], 4);
        const output = outputVariable("outputData", outputDataType, [vecSize], 4);
        const uniforms = [{ name: "vec_size", type: "u32" }];
        if (additionalUniformsType) {
          uniforms.push(...additionalUniformsType);
        }
        return `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}

  ${additionalImplementation ?? ""}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${input.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", expression)}
  }`;
      };
      createElementwiseProgramInfo = (input, name, funcCall, additionalImplementation, cacheKey, outputDataType = input.dataType, additionalUniforms, additionalUniformsType) => {
        const programUniforms = [
          { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(input.dims) / 4) }
        ];
        if (additionalUniforms) {
          programUniforms.push(...additionalUniforms);
        }
        return {
          name,
          shaderCache: { hint: cacheKey, inputDependencies: ["type"] },
          getShaderSource: (shaderHelper) => createElementwiseProgramShader(
            shaderHelper,
            ShapeUtil.size(input.dims),
            input.dataType,
            outputDataType,
            funcCall,
            additionalImplementation,
            additionalUniformsType
          ),
          getRunData: (inputTensors) => ({
            outputs: [{ dims: input.dims, dataType: outputDataType }],
            dispatchGroup: {
              x: Math.ceil(
                ShapeUtil.size(inputTensors[0].dims) / 64 / 4
                /* vec size */
              )
            },
            programUniforms
          })
        };
      };
      abs = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Abs", "abs"));
      };
      acos = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Acos", "acos"));
      };
      acosh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Acosh", "acosh"));
      };
      asin = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Asin", "asin"));
      };
      asinh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Asinh", "asinh"));
      };
      atan = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Atan", "atan"));
      };
      atanh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Atanh", "atanh"));
      };
      parseCastAttributes = (attributes) => createAttributeWithCacheKey(attributes);
      cast = (context, attributes) => {
        let func;
        switch (attributes.to) {
          case 10 /* float16 */:
            func = "vec4<f16>";
            break;
          case 1 /* float */:
            func = "vec4<f32>";
            break;
          case 12 /* uint32 */:
            func = "vec4<u32>";
            break;
          case 6 /* int32 */:
            func = "vec4<i32>";
            break;
          case 9 /* bool */:
            func = "vec4<bool>";
            break;
          default:
            throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${attributes.to}`);
        }
        context.compute(
          createElementwiseProgramInfo(context.inputs[0], "Cast", func, void 0, attributes.cacheKey, attributes.to)
        );
      };
      generateClipAttributesFromInputs = (inputs) => {
        let min;
        let max;
        const hasMin = inputs.length >= 2 && inputs[1].data !== 0;
        const hasMax = inputs.length >= 3 && inputs[2].data !== 0;
        switch (inputs[0].dataType) {
          case 1 /* float */:
            min = hasMin ? inputs[1].getFloat32Array()[0] : -34028234663852886e22;
            max = hasMax ? inputs[2].getFloat32Array()[0] : 34028234663852886e22;
            break;
          case 10 /* float16 */:
            min = hasMin ? inputs[1].getUint16Array()[0] : 64511;
            max = hasMax ? inputs[2].getUint16Array()[0] : 31743;
            break;
          default:
            throw new Error("Unsupport data type");
        }
        return createAttributeWithCacheKey({ min, max });
      };
      clip = (context, clipAttributes) => {
        const attributes = clipAttributes ? clipAttributes : generateClipAttributesFromInputs(context.inputs);
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "Clip",
            (a) => `clamp(${a}, vec4<${dataType}>(uniforms.min), vec4<${dataType}>(uniforms.max))`,
            void 0,
            attributes.cacheKey,
            void 0,
            [
              { type: context.inputs[0].dataType, data: attributes.min },
              { type: context.inputs[0].dataType, data: attributes.max }
            ],
            [
              { name: "min", type: dataType },
              { name: "max", type: dataType }
            ]
          ),
          { inputs: [0] }
        );
      };
      ceil = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Ceil", "ceil"));
      };
      cos = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Cos", "cos"));
      };
      cosh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Cosh", "cosh"));
      };
      parseAlphaAttributes = (attributes) => createAttributeWithCacheKey(attributes);
      elu = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "Elu",
            (a) => `elu_vf32(${a})`,
            `
  const elu_alpha_ = ${dataType}(${attributes.alpha});

  fn elu_f32(a: ${dataType}) -> ${dataType} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${dataType}>) -> vec4<${dataType}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,
            attributes.cacheKey
          )
        );
      };
      erfImpl = (varType = "f32") => `
const r0: ${varType} = 0.3275911;
const r1: ${varType} = 0.254829592;
const r2: ${varType} = -0.284496736;
const r3: ${varType} = 1.421413741;
const r4: ${varType} = -1.453152027;
const r5: ${varType} = 1.061405429;

fn erf_vf32(v: vec4<${varType}>) -> vec4<${varType}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`;
      erf = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Erf", (a) => `erf_vf32(${a})`, erfImpl(dataType)));
      };
      exp = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Exp", "exp"));
      };
      floor = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Floor", "floor"));
      };
      gelu = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "Gelu",
            (a) => `0.5 * ${a} * (1.0 + erf_vf32(${a} * 0.7071067811865475))`,
            erfImpl(dataType)
          )
        );
      };
      leakyRelu = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "LeakyRelu",
            (a) => `select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<${dataType}>(0.0))`,
            `const leaky_relu_alpha_ = ${dataType}(${attributes.alpha});`,
            attributes.cacheKey
          )
        );
      };
      not = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Not", (a) => `!${a}`));
      };
      neg = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Neg", (a) => `-${a}`));
      };
      reciprocal = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Reciprocal", (a) => `1.0/${a}`));
      };
      relu = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "Relu",
            (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > vec4<${dataType}>(0.0))`
          )
        );
      };
      sigmoid = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sigmoid", (a) => `(1.0 / (1.0 + exp(-${a})))`));
      };
      parseHardSigmoidAttributes = (attributes) => createAttributeWithCacheKey(
        attributes
      );
      hardSigmoid = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "HardSigmoid",
            (a) => `max(vec4<${dataType}>(0.0), min(vec4<${dataType}>(1.0), ${attributes.alpha} * ${a} + vec4<${dataType}>(${attributes.beta})))`,
            void 0,
            attributes.cacheKey
          )
        );
      };
      sin = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sin", "sin"));
      };
      sinh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sinh", "sinh"));
      };
      sqrt = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sqrt", "sqrt"));
      };
      tan = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Tan", "tan"));
      };
      tanhExpression = (a) => `sign(${a}) * (1 - exp(-2 * abs(${a}))) / (1 + exp(-2 * abs(${a})))`;
      tanh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Tanh", tanhExpression));
      };
      fastGeluImpl = (varType = "f32") => `
const fast_gelu_a: ${varType} = 0.5;
const fast_gelu_b: ${varType} = 0.7978845608028654;
const fast_gelu_c: ${varType} = 0.035677408136300125;

fn tanh_v(v: vec4<${varType}>) -> vec4<${varType}> {
  return ${tanhExpression("v")};
}
`;
      fastGeluExpression = (x) => `(fast_gelu_a + fast_gelu_a * tanh_v(${x} * (fast_gelu_c * ${x} * ${x} + fast_gelu_b))) * ${x}`;
      fastGelu = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "FastGelu",
            fastGeluExpression,
            fastGeluImpl(dataType),
            void 0,
            context.inputs[0].dataType
          )
        );
      };
      thresholdedRelu = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "ThresholdedRelu",
            (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,
            `const thresholded_relu_alpha_ = vec4<${dataType}>(${attributes.alpha});`,
            attributes.cacheKey
          )
        );
        return 0;
      };
      log = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Log", "log"));
      };
      quickGeluImpl = (varType, alpha) => `
const alpha = vec4<${varType}>(${alpha});
const one = ${varType}(1.0);
const zero = ${varType}(0.0);

fn quick_gelu_impl(x: vec4<${varType}>) -> vec4<${varType}> {
  let v = x *alpha;
  var x1 : vec4<${varType}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`;
      quickGeluExpression = (x) => `quick_gelu_impl(${x})`;
      quickgelu = (context, attributes) => {
        const dType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "QuickGelu",
            quickGeluExpression,
            quickGeluImpl(dType, attributes.alpha),
            attributes.cacheKey,
            context.inputs[0].dataType
          )
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts
  var validateInputs6, createBiasSplitGeluProgramInfo, biasSplitGelu;
  var init_bias_split_gelu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts"() {
      "use strict";
      init_util();
      init_common();
      init_unary_op();
      validateInputs6 = (inputs) => {
        if (inputs[0].dims.length !== 3) {
          throw new Error("input should have 3 dimensions");
        }
        if (![2560, 5120, 10240].includes(inputs[0].dims[2])) {
          throw new Error("hidden state should be 2560, 5120 or 10240");
        }
        if (inputs[1].dims.length !== 1) {
          throw new Error("bias is expected to have 1 dimensions");
        }
        if (inputs[0].dims[2] !== inputs[1].dims[0]) {
          throw new Error("last dimension of input and bias are not the same");
        }
      };
      createBiasSplitGeluProgramInfo = (inputs) => {
        const outputShape = inputs[0].dims.slice();
        outputShape[2] = outputShape[2] / 2;
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims, 4);
        const bias = inputVariable("bias", inputs[0].dataType, [inputs[0].dims[2]], 4);
        const output = outputVariable("output", inputs[0].dataType, outputShape, 4);
        const outputSize = ShapeUtil.size(outputShape) / 4;
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const getShaderSource = (shaderHelper) => `
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${inputs[0].dims[2] / 4 / 2}u;

  ${shaderHelper.declareVariables(input, bias, output)}

  ${erfImpl(dataType)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${output.setByOffset("global_idx", "valueLeft * geluRight")}
  }`;
        return {
          name: "BiasSplitGelu",
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) }
          }),
          getShaderSource
        };
      };
      biasSplitGelu = (context) => {
        validateInputs6(context.inputs);
        context.compute(createBiasSplitGeluProgramInfo(context.inputs));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/binary-op.ts
  var createBinaryOpProgramShader, createBinaryOpProgramInfo, runBinaryOp, add, div, equal, mul, pow, sub, greater, less, greaterOrEqual, lessOrEqual;
  var init_binary_op = __esm({
    "web/lib/wasm/jsep/webgpu/ops/binary-op.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      createBinaryOpProgramShader = (shaderHelper, dimsA, dimsB, dimsOutput, vectorize, doBroadcast, sharedDimensionDivisibleBy4, funcCall, typeA, typeB, typeOutput, additionalImplementation) => {
        let expressionScalar;
        let expressionVector;
        if (typeof funcCall === "string") {
          expressionScalar = expressionVector = (a2, b2) => `${funcCall}((${a2}),(${b2}))`;
        } else if (typeof funcCall === "function") {
          expressionScalar = expressionVector = funcCall;
        } else {
          expressionScalar = funcCall.scalar;
          expressionVector = funcCall.vector;
        }
        const output = outputVariable("outputData", typeOutput, dimsOutput.length, 4);
        const a = inputVariable("aData", typeA, dimsA.length, 4);
        const b = inputVariable("bData", typeB, dimsB.length, 4);
        let assignment;
        if (vectorize) {
          if (doBroadcast) {
            const isAOneElement = ShapeUtil.size(dimsA) === 1;
            const isBOneElement = ShapeUtil.size(dimsB) === 1;
            const aLastDimDivisibleBy4 = dimsA.length > 0 && dimsA[dimsA.length - 1] % 4 === 0;
            const bLastDimDivisibleBy4 = dimsB.length > 0 && dimsB[dimsB.length - 1] % 4 === 0;
            if (isAOneElement || isBOneElement) {
              assignment = output.setByOffset(
                "global_idx",
                expressionVector(
                  isAOneElement ? `${a.type.value}(${a.getByOffset("0")}.x)` : a.getByOffset("global_idx"),
                  isBOneElement ? `${b.type.value}(${b.getByOffset("0")}.x)` : b.getByOffset("global_idx")
                )
              );
            } else {
              assignment = `
            let outputIndices = ${output.offsetToIndices("global_idx * 4u")};
            let offsetA = ${a.broadcastedIndicesToOffset("outputIndices", output)};
            let offsetB = ${b.broadcastedIndicesToOffset("outputIndices", output)};
            ${output.setByOffset(
                "global_idx",
                expressionVector(
                  sharedDimensionDivisibleBy4 || aLastDimDivisibleBy4 ? a.getByOffset("offsetA / 4u") : `${a.type.value}(${a.getByOffset("offsetA / 4u")}[offsetA % 4u])`,
                  sharedDimensionDivisibleBy4 || bLastDimDivisibleBy4 ? b.getByOffset("offsetB / 4u") : `${b.type.value}(${b.getByOffset("offsetB / 4u")}[offsetB % 4u])`
                )
              )}
          `;
            }
          } else {
            assignment = output.setByOffset(
              "global_idx",
              expressionVector(a.getByOffset("global_idx"), b.getByOffset("global_idx"))
            );
          }
        } else {
          if (!doBroadcast) {
            throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");
          }
          const singleAssignment = (resStr, x, typeCast = "") => {
            const expressionA = `aData[indexA${x}][componentA${x}]`;
            const expressionB = `bData[indexB${x}][componentB${x}]`;
            return `
            let outputIndices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offsetA${x} = ${a.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let offsetB${x} = ${b.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let indexA${x} = offsetA${x} / 4u;
            let indexB${x} = offsetB${x} / 4u;
            let componentA${x} = offsetA${x} % 4u;
            let componentB${x} = offsetB${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expressionScalar(expressionA, expressionB)});
          `;
          };
          if (typeOutput === 9 /* bool */) {
            assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
          } else {
            assignment = `
            ${singleAssignment("outputData[global_idx]", 0)}
            ${singleAssignment("outputData[global_idx]", 1)}
            ${singleAssignment("outputData[global_idx]", 2)}
            ${singleAssignment("outputData[global_idx]", 3)}
          `;
          }
        }
        return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(a, b, output)}

        ${additionalImplementation ?? ""}

        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
      };
      createBinaryOpProgramInfo = (name, cacheKey, a, b, funcCall, additionalImplementation, outputDataType = a.dataType) => {
        const aDims = a.dims.map((x) => Number(x) ?? 1);
        const bDims = b.dims.map((x) => Number(x) ?? 1);
        const isBroadcast = !ShapeUtil.areEqual(aDims, bDims);
        let outputShape = aDims;
        let outputSize = ShapeUtil.size(aDims);
        let vectorize = false;
        let sharedDimensionDivisibleBy4 = false;
        const cacheKeyAux = [isBroadcast];
        if (isBroadcast) {
          const calculatedShape = BroadcastUtil.calcShape(aDims, bDims, false);
          if (!calculatedShape) {
            throw new Error("Can't perform binary op on the given tensors");
          }
          outputShape = calculatedShape.slice();
          outputSize = ShapeUtil.size(outputShape);
          const isAOneElement = ShapeUtil.size(aDims) === 1;
          const isBOneElement = ShapeUtil.size(bDims) === 1;
          const aLastDimDivisibleBy4 = aDims.length > 0 && aDims[aDims.length - 1] % 4 === 0;
          const bLastDimDivisibleBy4 = bDims.length > 0 && bDims[bDims.length - 1] % 4 === 0;
          cacheKeyAux.push(isAOneElement);
          cacheKeyAux.push(isBOneElement);
          cacheKeyAux.push(aLastDimDivisibleBy4);
          cacheKeyAux.push(bLastDimDivisibleBy4);
          let sharedDimension = 1;
          for (let i = 1; i < outputShape.length; i++) {
            const dimA = aDims[aDims.length - i];
            const dimB = bDims[bDims.length - i];
            if (dimA === dimB) {
              sharedDimension *= dimA;
            } else {
              break;
            }
          }
          if (sharedDimension % 4 === 0) {
            sharedDimensionDivisibleBy4 = true;
            vectorize = true;
          } else if (isAOneElement || isBOneElement || aLastDimDivisibleBy4 || bLastDimDivisibleBy4) {
            vectorize = true;
          }
        } else {
          vectorize = true;
        }
        cacheKeyAux.push(vectorize);
        return {
          name,
          shaderCache: {
            hint: cacheKey + cacheKeyAux.map((x) => x.toString()).join("_"),
            inputDependencies: ["rank", "rank"]
          },
          getShaderSource: (shaderHelper) => createBinaryOpProgramShader(
            shaderHelper,
            aDims,
            bDims,
            outputShape,
            vectorize,
            isBroadcast,
            sharedDimensionDivisibleBy4,
            funcCall,
            a.dataType,
            b.dataType,
            outputDataType,
            additionalImplementation
          ),
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64 / 4
              /* component size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(outputShape) / 4) },
              ...createTensorShapeVariables(aDims, bDims, outputShape)
            ]
          })
        };
      };
      runBinaryOp = (context, name, funcCall, additionalImplementation, cacheKey, outputDataType) => {
        context.compute(
          createBinaryOpProgramInfo(
            name,
            cacheKey ?? "",
            context.inputs[0],
            context.inputs[1],
            funcCall,
            additionalImplementation,
            outputDataType
          )
        );
      };
      add = (context) => {
        runBinaryOp(context, "Add", (a, b) => `${a}+${b}`);
      };
      div = (context) => {
        runBinaryOp(context, "Div", (a, b) => `${a}/${b}`);
      };
      equal = (context) => {
        runBinaryOp(
          context,
          "Equal",
          { scalar: (a, b) => `u32(${a}==${b})`, vector: (a, b) => `vec4<u32>(${a}==${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      mul = (context) => {
        runBinaryOp(context, "Mul", (a, b) => `${a}*${b}`);
      };
      pow = (context) => {
        const type = inputVariable("input", context.inputs[0].dataType, context.inputs[0].dims).type.value;
        const roundStr = type === "i32" ? "round" : "";
        runBinaryOp(
          context,
          "Pow",
          { scalar: (a, b) => `pow_custom(${a},${b})`, vector: (a, b) => `pow_vector_custom(${a},${b})` },
          `
    fn pow_custom(a : ${type}, b : ${type}) -> ${type} {
      if (b == ${type}(0.0)) {
        return ${type}(1.0);
      } else if (a < ${type}(0.0) && f32(b) != floor(f32(b))) {
        return ${type}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${type}(1.0), round(f32(abs(b) % ${type}(2.0))) != 1.0) * ${type}(${roundStr}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${type}>, b : vec4<${type}>) -> vec4<${type}> {
      // TODO: implement vectorized pow
      return vec4<${type}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `
        );
      };
      sub = (context) => {
        runBinaryOp(context, "Sub", (a, b) => `${a}-${b}`);
      };
      greater = (context) => {
        runBinaryOp(
          context,
          "Greater",
          { scalar: (a, b) => `u32(${a}>${b})`, vector: (a, b) => `vec4<u32>(${a}>${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      less = (context) => {
        runBinaryOp(
          context,
          "Less",
          { scalar: (a, b) => `u32(${a}<${b})`, vector: (a, b) => `vec4<u32>(${a}<${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      greaterOrEqual = (context) => {
        runBinaryOp(
          context,
          "GreaterOrEqual",
          { scalar: (a, b) => `u32(${a}>=${b})`, vector: (a, b) => `vec4<u32>(${a}>=${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      lessOrEqual = (context) => {
        runBinaryOp(
          context,
          "LessOrEqual",
          { scalar: (a, b) => `u32(${a}<=${b})`, vector: (a, b) => `vec4<u32>(${a}<=${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/concat.ts
  var validateInputs7, calculateInputIndexImpl, assignOutputData, createConcatProgramInfo, concat, parseConcatAttributes;
  var init_concat = __esm({
    "web/lib/wasm/jsep/webgpu/ops/concat.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs7 = (inputs, axis) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("too few inputs");
        }
        const referenceIndex = 0;
        const referenceInput = inputs[referenceIndex];
        const inputType = referenceInput.dataType;
        const inputRank = referenceInput.dims.length;
        inputs.forEach((input, i) => {
          if (i === referenceIndex) {
            return;
          }
          if (input.dataType !== inputType) {
            throw new Error("input tensors should be one type");
          }
          if (input.dims.length !== inputRank) {
            throw new Error("input tensors should have the same shape");
          }
          input.dims.forEach((dim, i2) => {
            if (i2 !== axis && dim !== referenceInput.dims[i2]) {
              throw new Error("non concat dimensions must match");
            }
          });
        });
      };
      calculateInputIndexImpl = (numberOfTensors, sizeInConcatAxisStr) => `
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${numberOfTensors}u>(${sizeInConcatAxisStr});
    for (var i: u32 = 0u; i < ${numberOfTensors}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${numberOfTensors}u;
  }`;
      assignOutputData = (inputs, output) => {
        const numberOfTensors = inputs.length;
        const codeLines = [];
        for (let i = 0; i < numberOfTensors; ++i) {
          const returnSnippet = output.setByOffset("global_idx", inputs[i].getByIndices("indices"));
          if (numberOfTensors === 1) {
            codeLines.push(returnSnippet);
          } else if (i === 0) {
            codeLines.push(`if (inputIndex == ${i}u) { ${returnSnippet} }`);
          } else if (i === numberOfTensors - 1) {
            codeLines.push(`else { ${returnSnippet} }`);
          } else {
            codeLines.push(`else if (inputIndex == ${i}) { ${returnSnippet} }`);
          }
        }
        return codeLines.join("\n");
      };
      createConcatProgramInfo = (inputs, adjustedAxis, outputShape, dataType) => {
        const outputSize = ShapeUtil.size(outputShape);
        const sizeInConcatAxis = new Array(inputs.length);
        const inputVars = new Array(inputs.length);
        let previousSum = 0;
        const inputDependencies = [];
        const inputRanks = [];
        const programUniforms = [{ type: 12 /* uint32 */, data: outputSize }];
        for (let i = 0; i < inputs.length; ++i) {
          previousSum += inputs[i].dims[adjustedAxis];
          sizeInConcatAxis[i] = previousSum;
          inputRanks.push(inputs[i].dims.length);
          inputVars[i] = inputVariable(`input${i}`, dataType, inputRanks[i]);
          inputDependencies.push("rank");
          programUniforms.push({ type: 12 /* uint32 */, data: sizeInConcatAxis[i] });
        }
        for (let i = 0; i < inputs.length; ++i) {
          programUniforms.push(...createTensorShapeVariables(inputs[i].dims));
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const output = outputVariable("output", dataType, outputShape.length);
        const indicesAxis = output.indicesGet("indices", adjustedAxis);
        const sizeInConcatAxisStr = Array.from(Array(sizeInConcatAxis.length).keys()).map((i) => `uniforms.sizeInConcatAxis${i}`).join(",");
        const getShaderSource = (shaderHelper) => `

  ${(() => {
          shaderHelper.registerUniform("outputSize", "u32");
          for (let i = 0; i < inputs.length; i++) {
            shaderHelper.registerUniform(`sizeInConcatAxis${i}`, "u32");
          }
          return shaderHelper.declareVariables(...inputVars, output);
        })()}

  ${calculateInputIndexImpl(sizeInConcatAxis.length, sizeInConcatAxisStr)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${output.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${indicesAxis});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${sizeInConcatAxis.length}u>(${sizeInConcatAxisStr});
      ${indicesAxis} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${assignOutputData(inputVars, output)}
  }`;
        return {
          name: "Concat",
          shaderCache: { hint: `${adjustedAxis}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      concat = (context, attributes) => {
        const inputs = context.inputs;
        const inputShape = inputs[0].dims;
        const adjustedAxis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
        validateInputs7(inputs, adjustedAxis);
        const outputShape = inputShape.slice();
        outputShape[adjustedAxis] = inputs.reduce(
          (sum, input) => sum + (input.dims.length > adjustedAxis ? input.dims[adjustedAxis] : 0),
          0
        );
        const nonEmptyInputs = inputs.filter((input) => ShapeUtil.size(input.dims) > 0);
        context.compute(createConcatProgramInfo(nonEmptyInputs, adjustedAxis, outputShape, inputs[0].dataType), {
          inputs: nonEmptyInputs
        });
      };
      parseConcatAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts
  var getActivationSnippet, appendActivationUniformsData, appendActivationUniforms, parseInternalActivationAttributes;
  var init_fuse_utils = __esm({
    "web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      getActivationSnippet = (attributes, valueType, baseType = "f32") => {
        switch (attributes.activation) {
          case "Relu":
            return `value = max(value, ${valueType}(0.0));`;
          case "Sigmoid":
            return `value = (${valueType}(1.0) / (${valueType}(1.0) + exp(-value)));`;
          case "Clip":
            return `value = clamp(value, ${valueType}(${baseType}(uniforms.clip_min)), ${valueType}(${baseType}(uniforms.clip_max)));`;
          case "HardSigmoid":
            return `value = max(${valueType}(0.0), min(${valueType}(1.0), ${baseType}(uniforms.alpha) * value + ${baseType}(uniforms.beta)));`;
          case "LeakyRelu":
            return `value = select(${baseType}(uniforms.alpha) * value, value, value >= ${valueType}(0.0));`;
          case "Tanh":
            return `let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;
          case "":
            return "";
          // TODO: adding other activations that can be fused.
          default:
            throw new Error(`Unsupported activation ${attributes.activation}`);
        }
      };
      appendActivationUniformsData = (attributes, programUniform) => {
        if (attributes.activation === "Clip") {
          programUniform.push(
            { type: 1 /* float */, data: attributes.clipMax },
            { type: 1 /* float */, data: attributes.clipMin }
          );
        } else if (attributes.activation === "HardSigmoid") {
          programUniform.push(
            { type: 1 /* float */, data: attributes.alpha },
            { type: 1 /* float */, data: attributes.beta }
          );
        } else if (attributes.activation === "LeakyRelu") {
          programUniform.push({ type: 1 /* float */, data: attributes.alpha });
        }
      };
      appendActivationUniforms = (attributes, uniforms) => {
        if (attributes.activation === "Clip") {
          uniforms.push({ name: "clip_max", type: "f32" }, { name: "clip_min", type: "f32" });
        } else if (attributes.activation === "HardSigmoid") {
          uniforms.push({ name: "alpha", type: "f32" }, { name: "beta", type: "f32" });
        } else if (attributes.activation === "LeakyRelu") {
          uniforms.push({ name: "alpha", type: "f32" });
        }
      };
      parseInternalActivationAttributes = (attributes) => {
        const activation = attributes?.activation || "";
        if (activation === "HardSigmoid") {
          const [alpha, beta] = attributes?.activation_params || [0.2, 0.5];
          return { activation, alpha, beta };
        } else if (activation === "Clip") {
          const [clipMin, clipMax] = attributes?.activation_params || [MIN_CLIP, MAX_CLIP];
          return { activation, clipMax, clipMin };
        } else if (activation === "LeakyRelu") {
          const [alpha] = attributes?.activation_params || [0.01];
          return { activation, alpha };
        }
        return { activation };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts
  var typeSnippet, biasSnippet;
  var init_activation_util = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts"() {
      "use strict";
      typeSnippet = (component, dataType) => {
        switch (component) {
          case 1:
            return dataType;
          case 2:
            return `vec2<${dataType}>`;
          case 3:
            return `vec3<${dataType}>`;
          case 4:
            return `vec4<${dataType}>`;
          default:
            throw new Error(`${component}-component is not supported.`);
        }
      };
      biasSnippet = (hasBias) => `
      ${hasBias ? "value = value + getBiasByOutputCoords(coords);" : ""}
      `;
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts
  var utilFunctions;
  var init_conv_util = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts"() {
      "use strict";
      utilFunctions = (strideStr) => `
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${strideStr}.x), i32(${strideStr}.y), i32(${strideStr}.z), 1));
}
`;
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/matmul-shaders.ts
  var convertOutputBatchIndicesToInputBatchIndices, createNaiveMatmulProgramInfo;
  var init_matmul_shaders = __esm({
    "web/lib/wasm/jsep/webgpu/ops/matmul-shaders.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_fuse_utils();
      convertOutputBatchIndicesToInputBatchIndices = (targetIndicesName, inputVariable2, inputBatchRank, outputBatchRank, batchIndicesName) => {
        const extendingInputRank = outputBatchRank - inputBatchRank;
        return `
      ${Array.from({ length: inputBatchRank }).map(
          (_, i) => `
      if (${getElementAt(inputVariable2.shape, i, inputVariable2.rank)} != 1) {
        ${inputVariable2.indicesSet(targetIndicesName, i, getElementAt(batchIndicesName, i + extendingInputRank, outputBatchRank))}
      } else {
        ${inputVariable2.indicesSet(targetIndicesName, i, 0)}
      }`
        ).join("")}
`;
      };
      createNaiveMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false, squeezeOutputShapeFunction) => {
        const aShape = inputs[0].dims;
        const bShape = inputs[1].dims;
        const M = aShape[aShape.length - 2];
        const N = bShape[bShape.length - 1];
        const K = aShape[aShape.length - 1];
        const components = getMaxComponents(N);
        const aComponents = getMaxComponents(K);
        const outputNumber = getMaxComponents(M);
        const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
        const hasBias = inputs.length > 2;
        const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
        const batchSize = ShapeUtil.size(outerDims);
        const outputShapeInShader = [batchSize, M, N];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: M },
          { type: 12 /* uint32 */, data: N },
          { type: 12 /* uint32 */, data: K }
        ];
        appendActivationUniformsData(activationAttributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(outerDims, aShape, bShape));
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        }
        programUniforms.push(...createTensorShapeVariables(outputShapeInShader));
        const getShaderSource = (shaderHelper) => {
          const batchDims = internalVariable("batch_dims", inputs[0].dataType, outerDims.length);
          const a = inputVariable("a", inputs[0].dataType, aShape.length, aComponents);
          const b = inputVariable("b", inputs[1].dataType, bShape.length, components);
          const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
          const inputVariables = [a, b];
          let processBias = "";
          if (hasBias) {
            const biasComponents = isChannelsLast ? components : 1;
            inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
            processBias = `${isChannelsLast ? `value += bias[col / ${biasComponents}];` : `value += ${output.type.value}(bias[row + i]);`}`;
          }
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "M", type: "u32" },
            { name: "N", type: "u32" },
            { name: "K", type: "u32" }
          ];
          appendActivationUniforms(activationAttributes, uniforms);
          const calcResult = () => {
            let calcStr = `var a_data: ${a.type.value};`;
            for (let i = 0; i < aComponents; i++) {
              calcStr += `
              let b_data${i} = b[(b_offset + (k + ${i}) * uniforms.N + col) / ${components}];`;
            }
            for (let i = 0; i < outputNumber; i++) {
              calcStr += `a_data = a[(a_offset + (row + ${i}) * uniforms.K + k) / ${aComponents}];`;
              for (let j = 0; j < aComponents; j++) {
                calcStr += `
            values[${i}] = fma(${b.type.value}(a_data${aComponents === 1 ? "" : `[${j}]`}), b_data${j}, values[${i}]);
`;
              }
            }
            return calcStr;
          };
          return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(...inputVariables, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${components})) * ${components};
    var index1 = global_idx / (uniforms.N / ${components});
    let stride1 = uniforms.M / ${outputNumber};
    let row = (index1 % stride1) * ${outputNumber};
    let batch = index1 / stride1;

    ${outputShape.length === 2 ? "" : `let batch_indices = ${batchDims.offsetToIndices("batch")};`}

    var a_indices: ${a.type.indices};
    ${convertOutputBatchIndicesToInputBatchIndices("a_indices", a, a.rank - 2, batchDims.rank, "batch_indices")}
    ${a.indicesSet("a_indices", a.rank - 2, 0)}
    ${a.indicesSet("a_indices", a.rank - 1, 0)}
    let a_offset = ${a.indicesToOffset("a_indices")};

    var b_indices: ${b.type.indices};
    ${convertOutputBatchIndicesToInputBatchIndices("b_indices", b, b.rank - 2, batchDims.rank, "batch_indices")}
    ${b.indicesSet("b_indices", b.rank - 2, 0)}
    ${b.indicesSet("b_indices", b.rank - 1, 0)}
    let b_offset = ${b.indicesToOffset("b_indices")};
    var values: array<${output.type.value}, ${outputNumber}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${aComponents}) {
      ${calcResult()}
    }
    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      let cur_indices = ${output.type.indices}(batch, row + i, col);
      let offset = ${output.indicesToOffset("cur_indices")};
      ${output.setByOffset(`offset / ${components}`, "value")};
    }
  }
  `;
        };
        return {
          name: "MatMulNaive",
          shaderCache: {
            hint: `${activationAttributes.activation};${components};${aComponents};${outputNumber};${isChannelsLast}`,
            inputDependencies: hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"]
          },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts
  var writeDataToSubAVec4Snippet, calculateResultSnippet, makeMatMulPackedVec4Source, writeDataToSubASnippet, readDataFromSubASnippet, makeMatMulPackedSource, matMulReadWriteFnSource, createMatmulProgramInfo;
  var init_matmul_packed_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_fuse_utils();
      init_matmul_shaders();
      init_activation_util();
      writeDataToSubAVec4Snippet = (transpose2, batchDims) => {
        if (transpose2) {
          return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
        } else {
          return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
        }
      };
      calculateResultSnippet = (transposeA, innerElementSize) => {
        if (transposeA) {
          return `
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${innerElementSize === 3 ? "" : "let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`;
        } else {
          return `
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached.w + acc[i];"}
        }`;
        }
      };
      makeMatMulPackedVec4Source = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32) => {
        const tileAOuter = workgroupSize[1] * workPerThread[1];
        const tileBOuter = workgroupSize[0] * workPerThread[0];
        const tileAWidth = transposeA ? tileAOuter : tileInner;
        const tileAHight = transposeA ? tileInner : tileAOuter;
        const innerElementSize = tileAWidth / workgroupSize[0];
        const rowPerThreadB = tileInner / workgroupSize[1];
        if (!((transposeA && innerElementSize === 4 && workPerThread[1] === 4 || !transposeA && (innerElementSize === 3 || innerElementSize === 4)) && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0 && workPerThread[0] === 4)) {
          throw new Error(`If transposeA ${transposeA} is true, innerElementSize ${innerElementSize} and workPerThread[1] ${workPerThread[1]} must be 4.
      Otherwise, innerElementSize ${innerElementSize} must be 3 or 4.
  tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}. tileInner ${tileInner} must be divisible by workgroupSize[1] ${workgroupSize[1]}. colPerThread ${workPerThread[0]} must be 4.`);
        }
        return `
var<workgroup> mm_Asub: array<array<vec${innerElementSize}<${type}>, ${tileAWidth / innerElementSize}>, ${tileAHight}>;
var<workgroup> mm_Bsub: array<array<vec4<${type}>, ${tileBOuter / workPerThread[0]}>, ${tileInner}>;

const rowPerThread = ${workPerThread[1]};
const colPerThread = ${workPerThread[0]};
const innerElementSize = ${innerElementSize};
const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${splitK ? "0" : "i32(globalId.z)"};
  ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
  let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

  let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

  var acc: array<vec4<${type}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${rowPerThreadB};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${writeDataToSubAVec4Snippet(transposeA, batchDims)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${batchDims ? ", batchIndices" : ""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${innerElementSize === 3 ? "" : "let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${calculateResultSnippet(transposeA, innerElementSize)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;
      };
      writeDataToSubASnippet = (transpose2, batchDims) => {
        if (transpose2) {
          return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
        } else {
          return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
        }
      };
      readDataFromSubASnippet = (transposeA) => transposeA ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];";
      makeMatMulPackedSource = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32, sequentialAccessByThreads = false) => {
        const tileAOuter = workPerThread[1] * workgroupSize[1];
        const tileBOuter = workPerThread[0] * workgroupSize[0];
        const tileAWidth = transposeA ? tileAOuter : tileInner;
        const tileAHight = transposeA ? tileInner : tileAOuter;
        if (!(tileAHight % workgroupSize[1] === 0 && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0)) {
          throw new Error(
            `tileAHight ${tileAHight} must be divisible by workgroupSize[1]${workgroupSize[1]}, tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}, tileInner ${tileInner} must be divisible by workgroupSize[1]${workgroupSize[1]}`
          );
        }
        const rowPerThreadA = tileAHight / workgroupSize[1];
        const colPerThreadA = tileAWidth / workgroupSize[0];
        const rowPerThreadB = tileInner / workgroupSize[1];
        const matmulSnippet = sequentialAccessByThreads ? `
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${tileAOuter};
    let globalColStart = i32(workgroupId.x) * ${tileBOuter};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${tileAHight}; inputRow = inputRow + ${workgroupSize[1]}) {
        for (var inputCol = localCol; inputCol < ${tileAWidth}; inputCol = inputCol + ${workgroupSize[0]}) {
          ${writeDataToSubASnippet(transposeA, batchDims)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${tileInner}; inputRow = inputRow + ${workgroupSize[1]}) {
            for (var inputCol = localCol; inputCol < ${tileBOuter}; inputCol = inputCol + ${workgroupSize[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${batchDims ? ", batchIndices" : ""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${type}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${workgroupSize[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${transposeA ? `mm_Asub[k][localRow + innerRow * ${workgroupSize[1]}];` : `mm_Asub[localRow + innerRow * ${workgroupSize[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${workgroupSize[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${workgroupSize[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    ` : `
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

let tileRowA = i32(localId.y) * ${rowPerThreadA};
let tileColA = i32(localId.x) * ${colPerThreadA};
let tileRowB = i32(localId.y) * ${rowPerThreadB};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadA}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${colPerThreadA}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${writeDataToSubASnippet(transposeA, batchDims)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${batchDims ? ", batchIndices" : ""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${type}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${readDataFromSubASnippet(transposeA)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;
        return `
  var<workgroup> mm_Asub : array<array<${type}, ${tileAWidth}>, ${tileAHight}>;
  var<workgroup> mm_Bsub : array<array<${type}, ${tileBOuter}>, ${tileInner}>;
  const rowPerThread = ${workPerThread[1]};
  const colPerThread = ${workPerThread[0]};
  const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${splitK ? "0" : "i32(globalId.z)"};
    ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
    let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

    var acc : array<array<${type}, colPerThread>, rowPerThread>;
    ${matmulSnippet}
  }
`;
      };
      matMulReadWriteFnSource = (component, hasBias, applyActivation, variables, isChannelsLast = false) => {
        const [batchVariable, aVariable, bVariable, outputVariable2] = variables;
        const dataType = tensorTypeToWsglStorageType(variables[0].type.tensor);
        const source = `
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(
          component,
          dataType
        )} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${aVariable.type.indices};
        ${convertOutputBatchIndicesToInputBatchIndices(
          "aIndices",
          aVariable,
          aVariable.rank - 2,
          batchVariable.rank,
          "batchIndices"
        )}
        ${aVariable.indicesSet("aIndices", aVariable.rank - 2, "u32(row)")}
        ${aVariable.indicesSet("aIndices", aVariable.rank - 1, "u32(colIn)")}
        value = ${aVariable.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(
          component,
          dataType
        )} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${bVariable.type.indices};
        ${convertOutputBatchIndicesToInputBatchIndices(
          "bIndices",
          bVariable,
          bVariable.rank - 2,
          batchVariable.rank,
          "batchIndices"
        )}
        ${bVariable.indicesSet("bIndices", bVariable.rank - 2, "u32(row)")}
        ${bVariable.indicesSet("bIndices", bVariable.rank - 1, "u32(colIn)")}
        value = ${bVariable.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${typeSnippet(component, dataType)}) {
      let col = colIn * ${component};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${hasBias ? `value = value + ${isChannelsLast ? "bias[colIn]" : `${typeSnippet(component, dataType)}(bias[row])`};` : ""}
        ${applyActivation}
        ${outputVariable2.setByIndices("vec3<u32>(coords)", "value")}
      }
    }
    `;
        return source;
      };
      createMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false, squeezeOutputShapeFunction) => {
        const aShape = inputs[0].dims;
        const bShape = inputs[1].dims;
        const outerDimsA = aShape.slice(0, -2);
        const outerDimsB = bShape.slice(0, -2);
        const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
        const batchSize = ShapeUtil.size(outerDims);
        const dimAOuter = aShape[aShape.length - 2];
        const dimInner = aShape[aShape.length - 1];
        const dimBOuter = bShape[bShape.length - 1];
        const isVec4 = dimInner % 4 === 0 && dimBOuter % 4 === 0;
        const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
        const workgroupSize = [8, 8, 1];
        const dispatch = [
          Math.ceil(dimBOuter / workgroupSize[0] / elementsPerThread[0]),
          Math.ceil(dimAOuter / workgroupSize[1] / elementsPerThread[1]),
          Math.ceil(batchSize / workgroupSize[2] / elementsPerThread[2])
        ];
        const components = isVec4 ? 4 : 1;
        const aShapeTemp = [...outerDimsA, dimAOuter, dimInner / components];
        const aRank = aShapeTemp.length;
        const bShapeTemp = [...outerDimsB, dimInner, dimBOuter / components];
        const bRank = bShapeTemp.length;
        const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
        const programUniforms = [
          { type: 6 /* int32 */, data: dimAOuter },
          { type: 6 /* int32 */, data: dimBOuter },
          { type: 6 /* int32 */, data: dimInner }
        ];
        appendActivationUniformsData(activationAttributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(outerDims, aShapeTemp, bShapeTemp));
        const inputDependencies = ["rank", "rank"];
        const hasBias = inputs.length > 2;
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
        const getShaderSource = (shaderHelper) => {
          const batchRank = outerDims.length;
          const batchDims = internalVariable("batchDims", inputs[0].dataType, batchRank, 1);
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const A = inputVariable("a", inputs[0].dataType, aRank, components);
          const B = inputVariable("b", inputs[1].dataType, bRank, components);
          const output = outputVariable("result", inputs[0].dataType, outputShapeTemp.length, components);
          const inputVariables = [A, B];
          if (hasBias) {
            const biasComponents = isChannelsLast ? components : 1;
            inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
          }
          const uniforms = [
            { name: "dim_a_outer", type: "i32" },
            { name: "dim_b_outer", type: "i32" },
            { name: "dim_inner", type: "i32" }
          ];
          appendActivationUniforms(activationAttributes, uniforms);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
          const declareFunctions = matMulReadWriteFnSource(
            components,
            hasBias,
            applyActivation,
            [batchDims, A, B, output],
            isChannelsLast
          );
          return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(...inputVariables, output)}
  ${declareFunctions}
  ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workgroupSize, dataType, batchDims) : makeMatMulPackedSource(elementsPerThread, workgroupSize, dataType, batchDims)}
                   `;
        };
        return {
          name: "MatMul",
          shaderCache: {
            hint: `${elementsPerThread};${activationAttributes.activation};${isVec4};${isChannelsLast}`,
            inputDependencies
          },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts
  var conv2dCommonSnippet, createConv2DMatMulProgramInfo;
  var init_conv2d_mm_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_common();
      init_fuse_utils();
      init_activation_util();
      init_conv_util();
      init_matmul_packed_webgpu();
      conv2dCommonSnippet = (isChannelsLast, fitAOuter, fitBOuter, fitInner, addBias = false, attributes, innerElementSizeX = 4, innerElementSizeW = 4, innerElementSize = 4, dataType = "f32") => {
        const getXSnippet = (innerElementSize2) => {
          switch (innerElementSize2) {
            case 1:
              return "resData = x[xIndex];";
            case 3:
              return `resData = vec3<${dataType}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;
            case 4:
              return "resData = x[xIndex / 4];";
            default:
              throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
          }
        };
        const getWSnippet = (innerElementSize2) => {
          switch (innerElementSize2) {
            case 1:
              return "return w[row * i32(uniforms.w_shape[3]) + colIn];";
            case 4:
              return "return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";
            default:
              throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
          }
        };
        const coordASnippet = isChannelsLast ? `
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    ` : `
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `;
        const coordResSnippet = isChannelsLast ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `;
        const xHeight = isChannelsLast ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])";
        const xWidth = isChannelsLast ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])";
        const row = isChannelsLast ? "row" : "col";
        const col = isChannelsLast ? "col" : "row";
        const readXSnippet = `
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
    let outRow = ${row} / outWidth;
    let outCol = ${row} % outWidth;

    let WRow = ${col} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${col} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${col} % inChannels;
    var resData = ${typeSnippet(innerElementSizeX, dataType)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${xHeight} && xCol >= 0 && xCol < ${xWidth}) {
      ${coordASnippet}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${getXSnippet(innerElementSizeX)}
    }
    return resData;`;
        const sampleX = isChannelsLast ? fitAOuter && fitInner ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);` : fitInner && fitBOuter ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);`;
        const sampleW = isChannelsLast ? fitInner && fitBOuter ? getWSnippet(innerElementSizeW) : `
    let col = colIn * ${innerElementSizeW};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${getWSnippet(innerElementSizeW)}
    }
    return ${typeSnippet(innerElementSizeW, dataType)}(0.0);` : `
    let col = colIn * ${innerElementSizeW};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${getWSnippet(innerElementSizeW)}
    }
    return ${typeSnippet(innerElementSizeW, dataType)}(0.0);`;
        const resType = typeSnippet(innerElementSize, dataType);
        const aType = isChannelsLast ? typeSnippet(innerElementSizeX, dataType) : typeSnippet(innerElementSizeW, dataType);
        const bType = isChannelsLast ? typeSnippet(innerElementSizeW, dataType) : typeSnippet(innerElementSizeX, dataType);
        const applyActivation = getActivationSnippet(attributes, resType, dataType);
        const userCode = `
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${aType} {
      ${isChannelsLast ? sampleX : sampleW}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${bType} {
      ${isChannelsLast ? sampleW : sampleX}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${resType}) {
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      ${coordResSnippet}
      ${biasSnippet(addBias)}
      ${applyActivation}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`;
        return userCode;
      };
      createConv2DMatMulProgramInfo = (inputs, attributes, outputShape, dimAOuter, dimBOuter, dimInner, hasBias, sequentialAccessByThreads, squeezeOutputShapeFunction) => {
        const isChannelsLast = attributes.format === "NHWC";
        const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];
        const batchSize = outputShape[0];
        const outWidth = isChannelsLast ? outputShape[2] : outputShape[3];
        const outHeight = isChannelsLast ? outputShape[1] : outputShape[2];
        const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];
        const isVec4 = isChannelsLast && (inChannels % 4 === 0 || inChannels % 3 === 0) && outChannels % 4 === 0;
        const dispatchX = isChannelsLast ? outChannels : outWidth * outHeight;
        const dispatchY = isChannelsLast ? outWidth * outHeight : outChannels;
        const workGroupSize = [8, 8, 1];
        const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
        const dispatch = [
          Math.ceil(dispatchX / workGroupSize[0] / elementsPerThread[0]),
          Math.ceil(dispatchY / workGroupSize[1] / elementsPerThread[1]),
          Math.ceil(batchSize / workGroupSize[2] / elementsPerThread[2])
        ];
        LOG_DEBUG("verbose", () => `[conv2d_mm_webgpu] dispatch = ${dispatch}`);
        const innerElementSize = isVec4 ? isChannelsLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
        const tileAOuter = workGroupSize[1] * elementsPerThread[1];
        const tileBOuter = workGroupSize[0] * elementsPerThread[0];
        const tileInner = Math.max(workGroupSize[0] * innerElementSize, workGroupSize[1]);
        const fitAOuter = dimAOuter % tileAOuter === 0;
        const fitBOuter = dimBOuter % tileBOuter === 0;
        const fitInner = dimInner % tileInner === 0;
        const elementsSize = isVec4 ? [innerElementSize, 4, 4] : [1, 1, 1];
        const programUniforms = [
          { type: 6 /* int32 */, data: dimAOuter },
          { type: 6 /* int32 */, data: dimBOuter },
          { type: 6 /* int32 */, data: dimInner },
          { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] },
          { type: 6 /* int32 */, data: attributes.strides },
          { type: 6 /* int32 */, data: attributes.dilations }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
        const inputDependencies = ["rank", "rank"];
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "dim_a_outer", type: "i32" },
            { name: "dim_b_outer", type: "i32" },
            { name: "dim_inner", type: "i32" },
            { name: "pad", type: "i32", length: 2 },
            { name: "stride", type: "i32", length: 2 },
            { name: "dilation", type: "i32", length: 2 }
          ];
          appendActivationUniforms(attributes, uniforms);
          const components = isVec4 ? 4 : 1;
          const t = tensorTypeToWsglStorageType(inputs[0].dataType);
          let declareFunctions = `
      fn setOutputAtIndex(flatIndex : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        result[flatIndex] = ${isVec4 ? `vec4<${t}>` : t}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${isVec4 ? "/ 4" : ""}, value);
      }`;
          const x = inputVariable(
            "x",
            inputs[0].dataType,
            inputs[0].dims.length,
            innerElementSize === 3 ? 1 : innerElementSize
          );
          const w = inputVariable("w", inputs[1].dataType, inputs[1].dims.length, components);
          const inputVariables = [x, w];
          const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
          if (hasBias) {
            const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
            inputVariables.push(bias);
            declareFunctions += `
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
        }`;
          }
          return `
        ${utilFunctions("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${declareFunctions}
        ${conv2dCommonSnippet(
            isChannelsLast,
            fitAOuter,
            fitBOuter,
            fitInner,
            hasBias,
            attributes,
            elementsSize[0],
            elementsSize[1],
            elementsSize[2],
            t
          )}
        ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workGroupSize, t, void 0, !isChannelsLast, tileInner) : makeMatMulPackedSource(
            elementsPerThread,
            workGroupSize,
            t,
            void 0,
            !isChannelsLast,
            tileInner,
            false,
            void 0,
            sequentialAccessByThreads
          )}`;
        };
        return {
          name: "Conv2DMatMul",
          shaderCache: {
            hint: `${attributes.cacheKey};${innerElementSize};${isVec4};${fitAOuter};${fitBOuter};${fitInner};${tileAOuter};${tileBOuter};${tileInner}`,
            inputDependencies
          },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts
  var arrayProduct, parse3TupleParam, getEffectiveFilterSize, computeDefaultPad, computeOutputShape4D, get3DPadAndOutInfo, computeConv3DInfo, createConv3DNaiveProgramInfo;
  var init_conv3d_naive_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_util();
      init_common();
      init_fuse_utils();
      init_activation_util();
      arrayProduct = (arr) => {
        let product = 1;
        for (let i = 0; i < arr.length; i++) {
          product *= arr[i];
        }
        return product;
      };
      parse3TupleParam = (param) => typeof param === "number" ? [param, param, param] : param;
      getEffectiveFilterSize = (filterSize, dilation) => {
        if (dilation <= 1) {
          return filterSize;
        }
        return filterSize + (filterSize - 1) * (dilation - 1);
      };
      computeDefaultPad = (inputShape, fieldSize, stride, dilation = 1) => {
        const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
        return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
      };
      computeOutputShape4D = (inShape, filterShape, outChannels, strides, zeroPad) => {
        if (zeroPad == null) {
          zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);
        }
        const outShape = [0, 0, 0, outChannels];
        for (let index = 0; index < 3; index++) {
          if (inShape[index] + 2 * zeroPad >= filterShape[index]) {
            outShape[index] = Math.trunc((inShape[index] - filterShape[index] + 2 * zeroPad) / strides[index] + 1);
          }
        }
        return outShape;
      };
      get3DPadAndOutInfo = (pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth) => {
        let padInfo;
        let outDepth;
        let outHeight;
        let outWidth;
        if (pad2 === "VALID") {
          pad2 = 0;
        }
        if (typeof pad2 === "number") {
          padInfo = { top: pad2, bottom: pad2, left: pad2, right: pad2, front: pad2, back: pad2 };
          const outShape = computeOutputShape4D(
            [inDepth, inHeight, inWidth, 1],
            [filterDepth, filterHeight, filterWidth],
            1,
            [strideDepth, strideHeight, strideWidth],
            pad2
          );
          outDepth = outShape[0];
          outHeight = outShape[1];
          outWidth = outShape[2];
        } else if (Array.isArray(pad2)) {
          if (!pad2.every((val, _, arr) => val === arr[0])) {
            throw Error(`Unsupported padding parameter: ${pad2}`);
          }
          padInfo = { top: pad2[0], bottom: pad2[1], left: pad2[2], right: pad2[3], front: pad2[4], back: pad2[5] };
          const outShape = computeOutputShape4D(
            [inDepth, inHeight, inWidth, 1],
            [filterDepth, filterHeight, filterWidth],
            1,
            [strideDepth, strideHeight, strideWidth],
            pad2[0]
          );
          outDepth = outShape[0];
          outHeight = outShape[1];
          outWidth = outShape[2];
        } else if (pad2 === "SAME_UPPER") {
          outDepth = Math.ceil(inDepth / strideDepth);
          outHeight = Math.ceil(inHeight / strideHeight);
          outWidth = Math.ceil(inWidth / strideWidth);
          const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
          const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
          const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
          const front = Math.floor(padAlongDepth / 2);
          const back = padAlongDepth - front;
          const top = Math.floor(padAlongHeight / 2);
          const bottom = padAlongHeight - top;
          const left = Math.floor(padAlongWidth / 2);
          const right = padAlongWidth - left;
          padInfo = { top, bottom, left, right, front, back };
        } else {
          throw Error(`Unknown padding parameter: ${pad2}`);
        }
        return { padInfo, outDepth, outHeight, outWidth };
      };
      computeConv3DInfo = (inShape, filterShape, strides, dilations, pad2, depthwise = false, dataFormat = "channelsLast") => {
        let batchSize, inDepth, inHeight, inWidth, inChannels;
        if (dataFormat === "channelsLast") {
          [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
        } else if (dataFormat === "channelsFirst") {
          [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
        } else {
          throw new Error(`Unknown dataFormat ${dataFormat}`);
        }
        const [filterChannels, , filterDepth, filterHeight, filterWidth] = filterShape;
        const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
        const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
        const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
        const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
        const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
        const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(
          pad2,
          inDepth,
          inHeight,
          inWidth,
          strideDepth,
          strideHeight,
          strideWidth,
          effectiveFilterDepth,
          effectiveFilterHeight,
          effectiveFilterWidth
        );
        const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
        let outShape = [0, 0, 0, 0, 0];
        if (dataFormat === "channelsFirst") {
          outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
        } else if (dataFormat === "channelsLast") {
          outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
        }
        return {
          batchSize,
          dataFormat,
          inDepth,
          inHeight,
          inWidth,
          inChannels,
          outDepth,
          outHeight,
          outWidth,
          outChannels,
          padInfo,
          strideDepth,
          strideHeight,
          strideWidth,
          filterDepth,
          filterHeight,
          filterWidth,
          effectiveFilterDepth,
          effectiveFilterHeight,
          effectiveFilterWidth,
          dilationDepth,
          dilationHeight,
          dilationWidth,
          inShape,
          outShape,
          filterShape
        };
      };
      createConv3DNaiveProgramInfo = (inputs, attributes, outputShape, filterDims, pads, dataFormat) => {
        const isChannelLast = dataFormat === "channelsLast";
        const inChannels = isChannelLast ? inputs[0].dims[3] : inputs[0].dims[1];
        const isVec4 = false;
        const workGroupSize = [64, 1, 1];
        const dispatchLayout = { x: outputShape.map((_, i) => i) };
        const dispatch = [Math.ceil(arrayProduct(dispatchLayout.x.map((d) => outputShape[d])) / workGroupSize[0]), 1, 1];
        LOG_DEBUG("verbose", () => `[conv3d_naive_webgpu] dispatch = ${dispatch}`);
        const innerElementSize = isVec4 ? isChannelLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: filterDims },
          { type: 12 /* uint32 */, data: pads },
          { type: 12 /* uint32 */, data: attributes.strides },
          { type: 12 /* uint32 */, data: attributes.dilations }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
        const inputDependencies = ["rank", "rank"];
        const hasBias = inputs.length === 3;
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "filter_dims", type: "u32", length: filterDims.length },
            { name: "pads", type: "u32", length: pads.length },
            { name: "strides", type: "u32", length: attributes.strides.length },
            { name: "dilations", type: "u32", length: attributes.dilations.length }
          ];
          appendActivationUniforms(attributes, uniforms);
          const components = isVec4 ? 4 : 1;
          const t = tensorTypeToWsglStorageType(inputs[0].dataType);
          const x = inputVariable(
            "x",
            inputs[0].dataType,
            inputs[0].dims.length,
            innerElementSize === 3 ? 1 : innerElementSize
          );
          const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, components);
          const inputVariables = [x, w];
          const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
          let declareFunctions = "";
          if (hasBias) {
            const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
            inputVariables.push(bias);
            declareFunctions += `
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[${isChannelLast ? getElementAt("coords", 4, 5) : getElementAt("coords", 1, 5)}${isVec4 ? "/ 4" : ""}];
        }`;
          }
          const resType = typeSnippet(innerElementSize, t);
          const applyActivation = getActivationSnippet(attributes, resType, t);
          return `
            ${declareFunctions}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${x.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${w.getByIndices("aIndices")};
            }
          ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
          ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${output.offsetToIndices("global_idx")};
              let batch = ${getElementAt("coords", 0, x.rank)};
              let d2 = ${isChannelLast ? getElementAt("coords", x.rank - 1, x.rank) : getElementAt("coords", 1, x.rank)};
              let xFRCCorner = vec3<u32>(${isChannelLast ? getElementAt("coords", 1, x.rank) : getElementAt("coords", 2, x.rank)},
              ${isChannelLast ? getElementAt("coords", 2, x.rank) : getElementAt("coords", 3, x.rank)},
              ${isChannelLast ? getElementAt("coords", 3, x.rank) : getElementAt("coords", 4, x.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${isChannelLast ? getElementAt("uniforms.x_shape", 1, x.rank) : getElementAt("uniforms.x_shape", 2, x.rank)};
              let xShapeZ = ${isChannelLast ? getElementAt("uniforms.x_shape", 2, x.rank) : getElementAt("uniforms.x_shape", 3, x.rank)};
              let xShapeW = ${isChannelLast ? getElementAt("uniforms.x_shape", 3, x.rank) : getElementAt("uniforms.x_shape", 4, x.rank)};
              let xShapeU = ${isChannelLast ? getElementAt("uniforms.x_shape", 4, x.rank) : getElementAt("uniforms.x_shape", 1, x.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${isChannelLast ? `let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            ` : `let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${isChannelLast ? `value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);` : `value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${isChannelLast ? `let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      ` : `let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${isChannelLast ? `let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      ` : `let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${hasBias ? "value = value + getBiasByOutputCoords(coords)" : ""};
              ${applyActivation}
              result[global_idx] = f32(value);
          }`;
        };
        return {
          name: "Conv3DNaive",
          shaderCache: { hint: `${attributes.cacheKey};${isChannelLast};${innerElementSize};${hasBias}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts
  var createGroupedConvProgramInfo, createGroupedConvVectorizeProgramInfo;
  var init_conv_grouped = __esm({
    "web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_fuse_utils();
      createGroupedConvProgramInfo = (inputs, attributes, outputShape, squeezeOutputShapeFunction) => {
        const hasBias = inputs.length > 2;
        const processBias = hasBias ? "value += b[output_channel];" : "";
        const xShape = inputs[0].dims;
        const wShape = inputs[1].dims;
        const isChannelLast = attributes.format === "NHWC";
        const outputChannels = isChannelLast ? outputShape[3] : outputShape[1];
        const outputChannelsPerGroup = outputChannels / attributes.group;
        const components = isChannelLast && outputChannelsPerGroup >= 4 ? getMaxComponents(outputChannels) : 1;
        const outputSize = ShapeUtil.size(outputShape) / components;
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: attributes.dilations },
          { type: 12 /* uint32 */, data: [attributes.strides[0], attributes.strides[1]] },
          { type: 12 /* uint32 */, data: [attributes.pads[0], attributes.pads[1]] },
          { type: 12 /* uint32 */, data: outputChannelsPerGroup }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(
          ...createTensorShapeVariables(xShape, [wShape[0], wShape[1], wShape[2], wShape[3] / components])
        );
        const inputDependencies = hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"];
        programUniforms.push(
          ...createTensorShapeVariables([outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components])
        );
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", inputs[0].dataType, outputShape.length, components);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
          const x = inputVariable("x", inputs[0].dataType, xShape.length);
          const w = inputVariable("w", inputs[1].dataType, wShape.length, components);
          const inputVars = [x, w];
          if (hasBias) {
            inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));
          }
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "dilations", type: "u32", length: attributes.dilations.length },
            { name: "strides", type: "u32", length: 2 },
            { name: "pads", type: "u32", length: 2 },
            { name: "output_channels_per_group", type: "u32" }
          ];
          appendActivationUniforms(attributes, uniforms);
          const calculateResult = isChannelLast ? `
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${x.get("batch", "xHeight", "xWidth", "input_channel")};
            let wVal = ${w.get("wHeight", "wWidth", "wInChannel", "output_channel")};
            value += xVal * wVal;
          }
        }
      }
      ` : `
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${x.get("batch", "input_channel", "xHeight", "xWidth")};
            let wVal = ${w.get("output_channel", "wInChannel", "wHeight", "wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${output.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${isChannelLast ? 3 : 1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${isChannelLast ? 1 : 2}], outputIndices[${isChannelLast ? 2 : 3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${components} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${isChannelLast ? 2 : 1}];

    var value: ${output.type.value} = ${output.type.value}(0);
    ${calculateResult}
    ${processBias}
    ${applyActivation}
    ${output.setByOffset("global_idx", "value")}
  }`;
        };
        return {
          name: "GroupedConv",
          shaderCache: { hint: `${attributes.cacheKey}_${components}`, inputDependencies },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      createGroupedConvVectorizeProgramInfo = (inputs, attributes, outputShape, squeezeOutputShapeFunction) => {
        const hasBias = inputs.length > 2;
        const components = getMaxComponents(outputShape[3]);
        const outputNumber = getMaxComponents(outputShape[2]);
        const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
        const xShape = [inputs[0].dims[0], inputs[0].dims[1], inputs[0].dims[2], inputs[0].dims[3] / components];
        const wShape = [inputs[1].dims[0], inputs[1].dims[1], inputs[1].dims[2], inputs[1].dims[3] / components];
        const outputShapeInShader = [outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: [attributes.strides[0], attributes.strides[1]] },
          { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(xShape, wShape, outputShapeInShader));
        const xNumber = (outputNumber - 1) * attributes.strides[1] + wShape[1];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
          const x = inputVariable("x", inputs[0].dataType, xShape.length, components);
          const w = inputVariable("w", inputs[1].dataType, wShape.length, components);
          const inputVars = [x, w];
          if (hasBias) {
            inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));
          }
          const processBias = hasBias ? "value += b[output_channel];" : "";
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "strides", type: "i32", length: 2 },
            { name: "pads", type: "i32", length: 2 }
          ];
          appendActivationUniforms(attributes, uniforms);
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${outputNumber}u;
    let col = (index1 % width1) * ${outputNumber}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${x.type.value}, ${xNumber}>;
    var values: array<${output.type.value}, ${outputNumber}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${wShape[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${xNumber}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${x.get("batch", "u32(x_height)", "u32(x_width)", "input_channel")};
          } else {
            x_vals[i] = ${x.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${wShape[1]}; w_width++) {
          let w_val = ${w.get("w_height", "w_width", "0", "output_channel")};
          for (var i = 0u; i < ${outputNumber}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      ${output.set("batch", "row", "col + i", "output_channel", "value")};
    }
  }`;
        };
        return {
          name: "GroupedConv-Vectorize",
          shaderCache: {
            hint: `${attributes.cacheKey};${components};${outputNumber};${xNumber};${wShape[0]};${wShape[1]}`,
            inputDependencies: hasBias ? ["rank", "rank", "type"] : ["rank", "rank"]
          },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/conv.ts
  var calculateOutputShape, weightTransposeAttribute, validateInputs8, getAdjustedConvAttributes, parseConvAttributes, conv2d, conv1d, conv3d, conv;
  var init_conv = __esm({
    "web/lib/wasm/jsep/webgpu/ops/conv.ts"() {
      "use strict";
      init_util();
      init_conv2d_mm_webgpu();
      init_conv3d_naive_webgpu();
      init_matmul_packed_webgpu();
      init_conv_grouped();
      init_fuse_utils();
      init_matmul_shaders();
      init_transpose();
      calculateOutputShape = (inputShape, kernelShape, dilations, adjustPads, strides, isChannelLast) => {
        const batchSize = inputShape[0];
        const inputSpatialShape = inputShape.slice(isChannelLast ? 1 : 2, isChannelLast ? 3 : 4);
        const spatialRank = inputSpatialShape.length;
        const outChannels = kernelShape[0];
        const kernelSpatialShape = kernelShape.slice(2);
        const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));
        const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);
        const outputShape = inputSpatialShapeWithPad.map(
          (v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i])
        );
        outputShape.splice(0, 0, batchSize);
        outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
        return outputShape;
      };
      weightTransposeAttribute = [2, 3, 1, 0];
      validateInputs8 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
          throw new Error("Conv requires 2 or 3 inputs");
        }
        if (inputs[0].dims.length > 5) {
          throw new Error("greater than 5D is not supported");
        }
        if (inputs[0].dims.length !== inputs[1].dims.length) {
          throw new Error("filter does not have same dimension as input");
        }
        const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
        const filterInChannel = inputs[1].dims[1] * attributes.group;
        if (dataChannel !== filterInChannel) {
          throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        }
        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {
          throw new Error("invalid bias");
        }
        const spatialRank = inputs[0].dims.length - 2;
        if (attributes.dilations.length !== spatialRank) {
          throw new Error(`dilations should be ${spatialRank}D`);
        }
        if (attributes.strides.length !== spatialRank) {
          throw new Error(`strides should be ${spatialRank}D`);
        }
        if (attributes.pads.length !== spatialRank * 2) {
          throw new Error(`pads should be ${spatialRank * 2}D`);
        }
        if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
          throw new Error("invalid kernel shape");
        }
      };
      getAdjustedConvAttributes = (attributes, inputs) => {
        const kernelShape = attributes.kernelShape.slice();
        if (kernelShape.length < inputs[1].dims.length - 2) {
          kernelShape.push(...Array(inputs[1].dims.length - 2 - kernelShape.length).fill(0));
        }
        for (let i = 2; i < inputs[1].dims.length; ++i) {
          if (kernelShape[i - 2] === 0) {
            kernelShape[i - 2] = inputs[1].dims[i];
          }
        }
        const pads = attributes.pads.slice();
        PoolConvUtil.adjustPadsBasedOnAutoPad(
          inputs[0].dims,
          attributes.strides,
          attributes.dilations,
          kernelShape,
          pads,
          attributes.format === "NHWC",
          attributes.autoPad
        );
        const newAttributes = Object.assign({}, attributes);
        Object.assign(newAttributes, { kernelShape, pads });
        return newAttributes;
      };
      parseConvAttributes = (attributes) => {
        const activationAttributes = parseInternalActivationAttributes(attributes);
        const format = attributes.format;
        const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad];
        const dilations = attributes.dilations;
        const group = attributes.group;
        const kernelShape = attributes.kernel_shape;
        const pads = attributes.pads;
        const strides = attributes.strides;
        const wIsConst = attributes.w_is_const();
        return {
          autoPad,
          format,
          dilations,
          group,
          kernelShape,
          pads,
          strides,
          wIsConst,
          ...activationAttributes,
          cacheKey: `${attributes.format};${activationAttributes.activation};`
        };
      };
      conv2d = (context, inputs, attributes, squeezeOutputShapeFunction) => {
        const isChannelsLast = attributes.format === "NHWC";
        const outputShape = calculateOutputShape(
          inputs[0].dims,
          inputs[1].dims,
          attributes.dilations,
          attributes.pads,
          attributes.strides,
          isChannelsLast
        );
        if (attributes.group !== 1) {
          const convInputs2 = [inputs[0]];
          if (isChannelsLast) {
            const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
              inputs: [1],
              outputs: [attributes.wIsConst ? -2 : -1]
            })[0];
            if (attributes.wIsConst && !context.kernelCustomData.wT) {
              context.kernelCustomData.wT = transposedWeight2;
            }
            convInputs2.push(transposedWeight2);
          } else {
            convInputs2.push(inputs[1]);
          }
          if (inputs.length === 3) {
            convInputs2.push(inputs[2]);
          }
          const enableGroupedConvVectorize = !context.adapterInfo.isArchitecture("ampere");
          if (enableGroupedConvVectorize && isChannelsLast && inputs[1].dims[0] === attributes.group && inputs[1].dims[1] === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1) {
            context.compute(
              createGroupedConvVectorizeProgramInfo(convInputs2, attributes, outputShape, squeezeOutputShapeFunction),
              { inputs: convInputs2 }
            );
          } else {
            context.compute(createGroupedConvProgramInfo(convInputs2, attributes, outputShape, squeezeOutputShapeFunction), {
              inputs: convInputs2
            });
          }
          return;
        }
        const hasBias = inputs.length === 3;
        const inputHeight = inputs[0].dims[isChannelsLast ? 1 : 2];
        const inputWidth = inputs[0].dims[isChannelsLast ? 2 : 3];
        const inputChannels = inputs[0].dims[isChannelsLast ? 3 : 1];
        const weightHeight = inputs[1].dims[2];
        const weightWidth = inputs[1].dims[3];
        const outHeight = outputShape[isChannelsLast ? 1 : 2];
        const outWidth = outputShape[isChannelsLast ? 2 : 3];
        const outChannels = outputShape[isChannelsLast ? 3 : 1];
        const sameSize = isChannelsLast && weightHeight === inputHeight && weightWidth === inputWidth && attributes.pads[0] === 0 && attributes.pads[1] === 0;
        if (sameSize || weightHeight === 1 && weightWidth === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1 && attributes.strides[0] === 1 && attributes.strides[1] === 1 && attributes.pads[0] === 0 && attributes.pads[1] === 0) {
          const batch = outputShape[0];
          let xReshaped, wReshaped, matmulOutputShape;
          const matmulInputs = [];
          if (isChannelsLast) {
            const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
              inputs: [1],
              outputs: [attributes.wIsConst ? -2 : -1]
            })[0];
            if (attributes.wIsConst && !context.kernelCustomData.wT) {
              context.kernelCustomData.wT = transposedWeight2;
            }
            if (sameSize) {
              const sharedDim = inputHeight * inputWidth * inputChannels;
              xReshaped = inputs[0].reshape([1, batch, sharedDim]);
              wReshaped = transposedWeight2.reshape([1, sharedDim, outChannels]);
              matmulOutputShape = [1, batch, outChannels];
            } else {
              xReshaped = inputs[0].reshape([batch, inputHeight * inputWidth, inputChannels]);
              wReshaped = transposedWeight2.reshape([1, inputChannels, outChannels]);
              matmulOutputShape = [batch, outHeight * outWidth, outChannels];
            }
            matmulInputs.push(xReshaped);
            matmulInputs.push(wReshaped);
          } else {
            xReshaped = inputs[0].reshape([batch, inputChannels, inputHeight * inputWidth]);
            wReshaped = inputs[1].reshape([1, outChannels, inputChannels]);
            matmulOutputShape = [batch, outChannels, outHeight * outWidth];
            matmulInputs.push(wReshaped);
            matmulInputs.push(xReshaped);
          }
          if (hasBias) {
            matmulInputs.push(inputs[2]);
          }
          const N = matmulOutputShape[2];
          const K = matmulInputs[0].dims[matmulInputs[0].dims.length - 1];
          if (N < 8 && K < 8) {
            context.compute(
              createNaiveMatmulProgramInfo(
                matmulInputs,
                attributes,
                outputShape,
                matmulOutputShape,
                isChannelsLast,
                squeezeOutputShapeFunction
              ),
              { inputs: matmulInputs }
            );
          } else {
            context.compute(
              createMatmulProgramInfo(
                matmulInputs,
                attributes,
                outputShape,
                matmulOutputShape,
                isChannelsLast,
                squeezeOutputShapeFunction
              ),
              { inputs: matmulInputs }
            );
          }
          return;
        }
        const sequentialAccessByThreads = (
          /* backend.adapterInfo.isIntel() */
          true
        );
        const transposedWeight = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
          inputs: [1],
          outputs: [attributes.wIsConst ? -2 : -1]
        })[0];
        if (attributes.wIsConst && !context.kernelCustomData.wT) {
          context.kernelCustomData.wT = transposedWeight;
        }
        const convInputs = [inputs[0], transposedWeight];
        if (hasBias) {
          convInputs.push(inputs[2]);
        }
        const dimAOuter = isChannelsLast ? outHeight * outWidth : outChannels;
        const dimBOuter = isChannelsLast ? outChannels : outHeight * outWidth;
        const dimInner = weightHeight * weightWidth * inputChannels;
        context.compute(
          createConv2DMatMulProgramInfo(
            convInputs,
            attributes,
            outputShape,
            dimAOuter,
            dimBOuter,
            dimInner,
            hasBias,
            sequentialAccessByThreads,
            squeezeOutputShapeFunction
          ),
          { inputs: convInputs }
        );
      };
      conv1d = (context, attributes) => {
        const isChannelLast = attributes.format === "NHWC";
        const inputs = [
          context.inputs[0].reshape(
            isChannelLast ? (
              // [N, W, C] -> [N, H=1, W, C]
              [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
            ) : (
              // [N, C, W] -> [N, C, H=1, W]
              [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
            )
          ),
          //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
          context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
        ];
        if (context.inputs.length === 3) {
          inputs.push(context.inputs[2]);
        }
        const pads = [0, attributes.pads[0], 0, attributes.pads[1]];
        const strides = [1].concat(attributes.strides);
        const dilations = [1].concat(attributes.dilations);
        const kernelShape = [1].concat(attributes.kernelShape);
        const adjustedAttributes = getAdjustedConvAttributes(
          { ...attributes, pads, strides, dilations, kernelShape },
          inputs
        );
        conv2d(
          context,
          inputs,
          adjustedAttributes,
          (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]
        );
      };
      conv3d = (context, inputs, attributes) => {
        const format = attributes.format === "NHWC" ? "channelsLast" : "channelsFirst";
        const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);
        const pads = attributes.autoPad === "NOTSET" ? attributes.pads : attributes.autoPad;
        const convInfo = computeConv3DInfo(
          inputs[0].dims,
          inputs[1].dims,
          attributes.strides,
          attributes.dilations,
          pads,
          false,
          format
        );
        context.compute(
          createConv3DNaiveProgramInfo(
            inputs,
            adjustedAttributes,
            convInfo.outShape,
            [convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth],
            [convInfo.padInfo.front, convInfo.padInfo.top, convInfo.padInfo.left],
            format
          )
        );
      };
      conv = (context, attributes) => {
        validateInputs8(context.inputs, attributes);
        if (context.inputs[0].dims.length === 3) {
          conv1d(context, attributes);
        } else if (context.inputs[0].dims.length === 5) {
          conv3d(context, context.inputs, attributes);
        } else {
          const adjustedAttributes = getAdjustedConvAttributes(attributes, context.inputs);
          conv2d(context, context.inputs, adjustedAttributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts
  var createConvTranspose2DProgramInfo;
  var init_conv_backprop_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_util();
      init_common();
      createConvTranspose2DProgramInfo = (inputs, attributes, squeezeOutputShapeFunction) => {
        const hasBias = inputs.length > 2;
        const outputShape = attributes.outputShape;
        const isChannelsLast = attributes.format === "NHWC";
        const group = attributes.group;
        const wShape = inputs[1].dims;
        const inputChannelsPerGroup = wShape[2] / group;
        const outputChannelsPerGroup = wShape[3];
        const aComponents = isChannelsLast ? getMaxComponents(inputChannelsPerGroup) : 1;
        const packInputAs4 = isChannelsLast && outputChannelsPerGroup === 1 && inputChannelsPerGroup >= 4;
        const inputChannelsPerGroupInt = packInputAs4 ? Math.floor(inputChannelsPerGroup / 4) * 4 : Math.floor(inputChannelsPerGroup / aComponents) * aComponents;
        const inputChannelsRemainder = inputChannelsPerGroup - inputChannelsPerGroupInt;
        const components = isChannelsLast ? getMaxComponents(outputChannelsPerGroup) : 1;
        const bComponents = isChannelsLast ? outputChannelsPerGroup === 1 ? aComponents : components : 1;
        const outputSize = ShapeUtil.size(outputShape) / components;
        const dispatch = [Math.ceil(outputSize / 64), 1, 1];
        LOG_DEBUG("verbose", () => `[conv2d_backprop_webgpu] dispatch = ${dispatch}`);
        const inputDependencies = ["rank", "rank"];
        const strides = [attributes.strides[0], attributes.strides[1]];
        const filterDims = [attributes.kernelShape[isChannelsLast ? 1 : 2], attributes.kernelShape[isChannelsLast ? 2 : 3]];
        const dilations = [attributes.dilations[0], attributes.dilations[1]];
        const effectiveFilterDims = [
          filterDims[0] + (attributes.dilations[0] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 1 : 2] - 1) * (attributes.dilations[0] - 1)),
          filterDims[1] + (attributes.dilations[1] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 2 : 3] - 1) * (attributes.dilations[1] - 1))
        ];
        const pads = [
          effectiveFilterDims[0] - 1 - Math.floor((attributes.pads[0] + attributes.pads[2]) / 2),
          effectiveFilterDims[1] - 1 - Math.floor((attributes.pads[1] + attributes.pads[3]) / 2)
        ];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: strides },
          { type: 12 /* uint32 */, data: filterDims },
          { type: 12 /* uint32 */, data: dilations },
          { type: 12 /* uint32 */, data: effectiveFilterDims },
          { type: 6 /* int32 */, data: pads },
          { type: 12 /* uint32 */, data: inputChannelsPerGroupInt },
          { type: 12 /* uint32 */, data: inputChannelsPerGroup },
          { type: 12 /* uint32 */, data: outputChannelsPerGroup },
          ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims)
        ];
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "strides", type: "u32", length: strides.length },
            { name: "filter_dims", type: "u32", length: filterDims.length },
            { name: "dilations", type: "u32", length: filterDims.length },
            { name: "effective_filter_dims", type: "u32", length: effectiveFilterDims.length },
            { name: "pads", type: "i32", length: pads.length },
            { name: "input_channels_per_group_int", type: "u32" },
            { name: "input_channels_per_group", type: "u32" },
            { name: "output_channels_per_group", type: "u32" }
          ];
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const rowDim = isChannelsLast ? 1 : 2;
          const colDim = isChannelsLast ? 2 : 3;
          const channelDim = isChannelsLast ? 3 : 1;
          const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, bComponents);
          const dy = inputVariable("Dy", inputs[0].dataType, inputs[0].dims.length, aComponents);
          const inputVariables = [dy, w];
          if (hasBias) {
            inputVariables.push(inputVariable("bias", inputs[2].dataType, [outputShape[channelDim]].length, components));
          }
          const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
          const calculateResult = () => {
            let calcStr = "";
            if (packInputAs4) {
              if (aComponents === 4) {
                calcStr += `
        let xValue = ${dy.getByOffset("x_offset")};
        let wValue = ${w.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`;
              } else if (aComponents === 2) {
                calcStr += `
          dotProd = dotProd + dot(vec4<${dataType}>(${dy.getByOffset("x_offset")}, ${dy.getByOffset("x_offset + 1u")}), vec4<${dataType}>(${w.getByOffset("w_offset")}, ${w.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`;
              } else if (aComponents === 1) {
                calcStr += `
          dotProd = dotProd + dot(vec4<${dataType}>(${dy.getByOffset("x_offset")}, ${dy.getByOffset("x_offset + 1u")}, ${dy.getByOffset("x_offset + 2u")}, ${dy.getByOffset("x_offset + 3u")}), vec4<${dataType}>(${w.getByOffset("w_offset")}, ${w.getByOffset("w_offset + 1u")}, ${w.getByOffset("w_offset + 2u")}, ${w.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`;
              }
            } else {
              calcStr += `
                  let xValue = ${isChannelsLast ? dy.getByOffset(
                `${dy.indicesToOffset(`${dy.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${aComponents}`
              ) : dy.get("batch", "inputChannel", "idyR", "idyC")};
        `;
              if (aComponents === 1) {
                calcStr += `
          let w_offset = ${w.indicesToOffset(`${w.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${w.getByOffset(`w_offset / ${bComponents}`)};
          dotProd = dotProd + xValue * wValue;`;
              } else {
                for (let c = 0; c < aComponents; c++) {
                  calcStr += `
            let wValue${c} = ${w.getByOffset(`${w.indicesToOffset(`${w.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${c}, wOutChannel)`)} / ${bComponents}`)};
            dotProd = dotProd + xValue[${c}] * wValue${c};`;
                }
              }
            }
            return calcStr;
          };
          const calculateRemainder = () => {
            if (inputChannelsRemainder === 0) {
              return "";
            }
            if (!packInputAs4) {
              throw new Error(`packInputAs4 ${packInputAs4} is not true.`);
            }
            let calcStr = "";
            if (aComponents === 1) {
              calcStr += "dotProd = dotProd";
              for (let i = 0; i < inputChannelsRemainder; i++) {
                calcStr += `
            + ${dy.getByOffset(`x_offset + ${i}`)} * ${w.getByOffset(`w_offset + ${i}`)}`;
              }
              calcStr += ";";
            } else if (aComponents === 2) {
              if (inputChannelsRemainder !== 2) {
                throw new Error(`Invalid inputChannelsRemainder ${inputChannelsRemainder}.`);
              }
              calcStr += `
          let xValue = ${dy.getByOffset("x_offset")};
          let wValue = ${w.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`;
            }
            return calcStr;
          };
          const codeSnippet = `
            let outputIndices = ${output.offsetToIndices(`global_idx * ${components}`)};
            let batch = ${output.indicesGet("outputIndices", 0)};
            let d1 = ${output.indicesGet("outputIndices", channelDim)};
            let r = ${output.indicesGet("outputIndices", rowDim)};
            let c = ${output.indicesGet("outputIndices", colDim)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${output.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${dataType}(dyRCorner) + ${dataType}(wR)) / ${dataType}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${dataType}(uniforms.Dy_shape[${rowDim}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${dataType}(dyCCorner) + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${dataType}(uniforms.Dy_shape[${colDim}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${packInputAs4 ? `
                var x_offset = ${dy.indicesToOffset(`${dy.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${aComponents};
                var w_offset = ${w.indicesToOffset(`${w.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${bComponents};
                  ` : ""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${packInputAs4 ? 4 : aComponents}) {
                  ${calculateResult()}
                  inputChannel = inputChannel + ${packInputAs4 ? 4 : aComponents};
                }
                ${calculateRemainder()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${hasBias ? ` + bias[d1 / ${components}]` : ""};
            ${output.setByOffset("global_idx", "value")};
          `;
          return `
    ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${codeSnippet}}`;
        };
        return {
          name: "ConvTranspose2D",
          shaderCache: {
            hint: `${attributes.cacheKey};${aComponents}${bComponents}${components}${packInputAs4}${inputChannelsRemainder}`,
            inputDependencies
          },
          getRunData: () => ({
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts
  var computeTotalPad, distributePadding, calculateOutputShapeAndPads, getAdjustedConvTransposeAttributes, parseConvTransposeAttributes, validateInputs9, convTranspose2d, convTranspose1d, convTranspose;
  var init_conv_transpose = __esm({
    "web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts"() {
      "use strict";
      init_conv_backprop_webgpu();
      init_fuse_utils();
      init_transpose();
      computeTotalPad = (inDim, stride, adj, kernel, dilation, outSize) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;
      distributePadding = (totalPad, autoPad, pads, head, tail) => {
        const smallPad = Math.floor(totalPad / 2);
        if (autoPad === "SAME_UPPER") {
          pads[head] = smallPad;
          pads[tail] = totalPad - smallPad;
        } else if (autoPad === "SAME_LOWER") {
          pads[head] = totalPad - smallPad;
          pads[tail] = smallPad;
        }
      };
      calculateOutputShapeAndPads = (inputShape, kernelShape, dilations, autoPad, group, pads, strides, isChannelLast, outputPadding, outputShape) => {
        const spatialRank = inputShape.length - 2;
        const updateOutputShape = outputShape.length === 0;
        if (outputPadding.length < spatialRank) {
          outputPadding.push(...Array(spatialRank - outputPadding.length).fill(0));
        }
        const batchSize = inputShape[0];
        const outChannels = kernelShape[isChannelLast ? 3 : 1] * group;
        for (let i = 0, j = inputShape.length - spatialRank - (isChannelLast ? 1 : 0); i < spatialRank; ++i, ++j) {
          const inSize = inputShape[j];
          const outSize = updateOutputShape ? inSize * strides[i] : outputShape[i];
          const totalPad = computeTotalPad(inSize, strides[i], pads[i], kernelShape[j], dilations[i], outSize);
          distributePadding(totalPad, autoPad, pads, i, i + spatialRank);
          if (updateOutputShape) {
            outputShape.push(
              strides[i] * (inSize - 1) + outputPadding[i] + (kernelShape[j] - 1) * dilations[i] + 1 - pads[i] - pads[i + spatialRank]
            );
          }
        }
        outputShape.splice(0, 0, batchSize);
        outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
      };
      getAdjustedConvTransposeAttributes = (attributes, inputs) => {
        const kernelShape = attributes.kernelShape.slice();
        if (attributes.kernelShape.length === 0 || attributes.kernelShape.reduce((a, b) => a * b, 1) === 0) {
          kernelShape.length = 0;
          for (let i = 2; i < inputs[1].dims.length; ++i) {
            kernelShape.push(inputs[1].dims[i]);
          }
        }
        const isChannelsLast = attributes.format === "NHWC";
        kernelShape.splice(0, 0, inputs[1].dims[0]);
        kernelShape.splice(isChannelsLast ? 3 : 1, 0, inputs[1].dims[1]);
        const pads = attributes.pads.slice();
        const outputShape = attributes.outputShape.slice();
        const outputPadding = attributes.outputPadding.slice();
        const inputShape = inputs[0].dims;
        let dilations = attributes.dilations.slice();
        if (dilations.reduce((a, b) => a + b, 0) === 0) {
          const spatialRank = inputs[0].dims.length - 2;
          dilations = new Array(spatialRank).fill(1);
        }
        let strides = attributes.strides.slice();
        if (strides.reduce((a, b) => a + b, 0) === 0) {
          const spatialRank = inputs[0].dims.length - 2;
          strides = new Array(spatialRank).fill(1);
        }
        calculateOutputShapeAndPads(
          inputShape,
          kernelShape,
          dilations,
          attributes.autoPad,
          attributes.group,
          pads,
          strides,
          isChannelsLast,
          outputPadding,
          outputShape
        );
        const newAttributes = Object.assign({}, attributes);
        Object.assign(newAttributes, { kernelShape, pads, outputPadding, outputShape, dilations, strides });
        return newAttributes;
      };
      parseConvTransposeAttributes = (attributes) => {
        const activationAttributes = parseInternalActivationAttributes(attributes);
        const format = attributes.format;
        const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][typeof attributes.autoPad == "undefined" ? 0 : attributes.autoPad];
        const dilations = attributes.dilations;
        const group = attributes.group;
        const kernelShape = attributes.kernelShape;
        const pads = attributes.pads;
        const strides = attributes.strides;
        const wIsConst = attributes.wIsConst();
        const outputPadding = attributes.outputPadding;
        const outputShape = attributes.outputShape;
        return {
          autoPad,
          format,
          dilations,
          group,
          kernelShape,
          outputPadding,
          outputShape,
          pads,
          strides,
          wIsConst,
          ...activationAttributes,
          cacheKey: `${attributes.format};${activationAttributes.activation};`
        };
      };
      validateInputs9 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
          throw new Error("Conv requires 2 or 3 inputs");
        }
        if (inputs[0].dims.length !== 4 && inputs[0].dims.length !== 3) {
          throw new Error("currently only support 2-dimensional conv");
        }
        if (inputs[0].dims.length !== inputs[1].dims.length) {
          throw new Error("filter does not have same dimension as input");
        }
        const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
        const filterInChannel = inputs[1].dims[0];
        if (dataChannel !== filterInChannel) {
          throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        }
        const featureMaps = inputs[1].dims[1] * attributes.group;
        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {
          throw new Error("invalid bias");
        }
        const spatialRank = inputs[0].dims.length - 2;
        const dilationsSet = attributes.dilations.reduce((a, b) => a + b, 0) > 0;
        if (dilationsSet && attributes.dilations.length !== spatialRank) {
          throw new Error(`dilations should be ${spatialRank}D`);
        }
        const stridesSet = attributes.strides.reduce((a, b) => a + b, 0) > 0;
        if (stridesSet && attributes.strides.length !== spatialRank) {
          throw new Error(`strides should be ${spatialRank}D`);
        }
        const padsSet = attributes.pads.reduce((a, b) => a + b, 0) > 0;
        if (padsSet && attributes.pads.length !== spatialRank * 2) {
          throw new Error(`pads should be ${spatialRank * 2}D`);
        }
        if (attributes.outputPadding.length !== spatialRank && attributes.outputPadding.length !== 0) {
          throw new Error(`output_padding should be ${spatialRank}D`);
        }
        const kernelShapeSet = attributes.kernelShape.reduce((a, b) => a + b, 0) > 0;
        if (kernelShapeSet && attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
          throw new Error("invalid kernel shape");
        }
        if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {
          throw new Error("invalid output shape");
        }
      };
      convTranspose2d = (context, inputs, attributes, squeezeOutputShapeFunction) => {
        const transposedWeight = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], [2, 3, 0, 1]), {
          inputs: [1],
          outputs: [attributes.wIsConst ? -2 : -1]
        })[0];
        if (attributes.wIsConst && !context.kernelCustomData.wT) {
          context.kernelCustomData.wT = transposedWeight;
        }
        const convTransposeInputs = [inputs[0], transposedWeight];
        if (inputs.length === 3) {
          convTransposeInputs.push(inputs[2]);
        }
        context.compute(createConvTranspose2DProgramInfo(convTransposeInputs, attributes, squeezeOutputShapeFunction), {
          inputs: convTransposeInputs
        });
      };
      convTranspose1d = (context, attributes) => {
        const isChannelLast = attributes.format === "NHWC";
        const inputs = [
          context.inputs[0].reshape(
            isChannelLast ? (
              // [N, W, C] -> [N, H=1, W, C]
              [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
            ) : (
              // [N, C, W] -> [N, C, H=1, W]
              [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
            )
          ),
          //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
          context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
        ];
        if (context.inputs.length === 3) {
          inputs.push(context.inputs[2]);
        }
        let kernelShape = attributes.kernelShape;
        if (kernelShape.length === 0 || kernelShape[0] === 0) {
          kernelShape = [context.inputs[1].dims[2]];
        }
        let dilations = attributes.dilations;
        if (dilations.length === 0 || dilations[0] === 0) {
          dilations = [1];
        }
        let strides = attributes.strides;
        if (strides.length === 0 || strides[0] === 0) {
          strides = [1];
        }
        let pads = attributes.pads;
        if (pads.length === 0) {
          pads = [0, 0];
        }
        pads = [0, pads[0], 0, pads[1]];
        strides = [1].concat(strides);
        dilations = [1].concat(dilations);
        kernelShape = [1].concat(kernelShape);
        let outputPadding = attributes.outputPadding;
        outputPadding = [0].concat(outputPadding);
        const adjustedAttributes = getAdjustedConvTransposeAttributes(
          { ...attributes, pads, strides, dilations, kernelShape, outputPadding },
          inputs
        );
        convTranspose2d(
          context,
          inputs,
          adjustedAttributes,
          (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]
        );
      };
      convTranspose = (context, attributes) => {
        validateInputs9(context.inputs, attributes);
        if (context.inputs[0].dims.length === 3) {
          convTranspose1d(context, attributes);
        } else {
          const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, context.inputs);
          convTranspose2d(context, context.inputs, adjustedAttributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/cumsum.ts
  var createCumsumProgramInfo, cumsum, parseCumSumAttributes;
  var init_cumsum = __esm({
    "web/lib/wasm/jsep/webgpu/ops/cumsum.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      createCumsumProgramInfo = (inputType, inputShape, axisInput, attributes) => {
        const outputSize = ShapeUtil.size(inputShape);
        const rank = inputShape.length;
        const input = inputVariable("input", inputType, rank);
        const output = outputVariable("output", inputType, rank);
        const axisValue = axisInput.dataType === 6 /* int32 */ ? axisInput.getInt32Array()[0] : Number(axisInput.getBigInt64Array()[0]);
        const axis = ShapeUtil.normalizeAxis(axisValue, rank);
        const getShaderSource = (shaderHelper) => {
          const index = ` i32(${input.indicesGet("inputIndices", "uniforms.axis")}) `;
          const max = getElementAt("uniforms.input_shape", "uniforms.axis", rank);
          const lowerLimit = attributes.reverse ? index + (attributes.exclusive ? " + 1" : "") : "0";
          const upperLimit = attributes.reverse ? max : index + (attributes.exclusive ? "" : " + 1");
          return `
                ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axis", "u32").declareVariables(input, output)}
                ${shaderHelper.mainStart()}
                  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${output.offsetToIndices("global_idx")};
                  var sum = ${output.type.value}(0);
                  let first : i32 = ${lowerLimit};
                  let last : i32 = ${upperLimit};
                  for (var i : i32 = first; i < last; i++) {
                    ${input.indicesSet("inputIndices", "uniforms.axis", "u32(i)")};
                    sum = sum + ${input.getByIndices("inputIndices")};
                  }
                  ${output.setByOffset("global_idx", "sum")};
                }`;
        };
        return {
          name: "CumSum",
          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          getRunData: () => ({
            outputs: [{ dims: inputShape, dataType: inputType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              { type: 12 /* uint32 */, data: axis },
              ...createTensorShapeVariables(inputShape, inputShape)
            ]
          }),
          getShaderSource
        };
      };
      cumsum = (context, attributes) => {
        const inputShape = context.inputs[0].dims;
        const inputType = context.inputs[0].dataType;
        const axis = context.inputs[1];
        context.compute(createCumsumProgramInfo(inputType, inputShape, axis, attributes), { inputs: [0] });
      };
      parseCumSumAttributes = (attributes) => {
        const exclusive = attributes.exclusive === 1;
        const reverse = attributes.reverse === 1;
        return createAttributeWithCacheKey({ exclusive, reverse });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts
  var validateInputs10, permFunctionBody2, createDepthToSpaceProgramInfo, depthToSpace, parseDepthToSpaceAttributes;
  var init_depth_to_space = __esm({
    "web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs10 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("DepthToSpace requires 1 input.");
        }
        if (inputs[0].dims.length !== 4) {
          throw new Error("DepthToSpace requires 4D input.");
        }
      };
      permFunctionBody2 = (perm, rank, input, output) => {
        const reverseFunc = [];
        reverseFunc.push(`fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`);
        for (let i = 0; i < rank; ++i) {
          reverseFunc.push(input.indicesSet("a", perm[i], `i[${i}]`));
        }
        reverseFunc.push("return a;}");
        return reverseFunc.join("\n");
      };
      createDepthToSpaceProgramInfo = (inputTensor, attributes) => {
        let n, h, w, c;
        let shape;
        let perm;
        const isChannelLast = attributes.format === "NHWC";
        const blocksize = attributes.blocksize;
        const isDCRmode = attributes.mode === "DCR";
        if (isChannelLast) {
          [n, h, w, c] = inputTensor.dims;
          shape = isDCRmode ? [n, h, w, blocksize, blocksize, c / blocksize ** 2] : [n, h, w, c / blocksize ** 2, blocksize, blocksize];
          perm = isDCRmode ? [0, 1, 3, 2, 4, 5] : [0, 1, 4, 2, 5, 3];
        } else {
          [n, h, w, c] = [inputTensor.dims[0], inputTensor.dims[2], inputTensor.dims[3], inputTensor.dims[1]];
          shape = isDCRmode ? [n, blocksize, blocksize, c / blocksize ** 2, h, w] : [n, c / blocksize ** 2, blocksize, blocksize, h, w];
          perm = isDCRmode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];
        }
        const reshapedInputTensor = inputTensor.reshape(shape);
        const reshapedInputRank = reshapedInputTensor.dims.length;
        const inputDataType = inputTensor.dataType;
        const reshapedInput = inputVariable("a", inputDataType, reshapedInputRank);
        const permedOutput = outputVariable("output", inputDataType, reshapedInputRank);
        const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(reshapedInput, permedOutput)}

  ${permFunctionBody2(perm, reshapedInputRank, reshapedInput, permedOutput)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${permedOutput.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${permedOutput.setByOffset("global_idx", reshapedInput.getByIndices("aIndices"))}
  }`;
        return {
          name: "DepthToSpace",
          shaderCache: {
            hint: `${inputTensor.dims};${attributes.blocksize};${attributes.mode}`,
            inputDependencies: ["rank"]
          },
          getRunData: (inputs) => {
            const outputShape = isChannelLast ? [n, h * blocksize, w * blocksize, c / blocksize ** 2] : [n, c / blocksize ** 2, h * blocksize, w * blocksize];
            const outputSize = ShapeUtil.size(outputShape);
            const shapeBeforePerm = reshapedInputTensor.dims;
            const shapeAfterPerm = ShapeUtil.sortBasedOnPerm(shapeBeforePerm, perm);
            return {
              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms: [
                { type: 12 /* uint32 */, data: outputSize },
                ...createTensorShapeVariables(shapeBeforePerm, shapeAfterPerm)
              ]
            };
          },
          getShaderSource
        };
      };
      depthToSpace = (context, attributes) => {
        validateInputs10(context.inputs);
        context.compute(createDepthToSpaceProgramInfo(context.inputs[0], attributes));
      };
      parseDepthToSpaceAttributes = (attributes) => createAttributeWithCacheKey({
        blocksize: attributes.blocksize,
        mode: attributes.mode,
        format: attributes.format
      });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/einsum.ts
  var symbolPattern, termPattern, termPatternOnly, lhsPattern, lhsPatternOnly, EinsumTerm, EinsumEquation, appendMax, createEinsumProgramInfo, einsum, parseEinsumAttributes;
  var init_einsum = __esm({
    "web/lib/wasm/jsep/webgpu/ops/einsum.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      symbolPattern = "[a-zA-Z]|\\.\\.\\.";
      termPattern = "(" + symbolPattern + ")+";
      termPatternOnly = "^" + termPattern + "$";
      lhsPattern = "(" + termPattern + ",)*" + termPattern;
      lhsPatternOnly = "^" + lhsPattern + "$";
      EinsumTerm = class {
        constructor(inputIndex = -1) {
          this.symbolToIndices = /* @__PURE__ */ new Map();
          this.inputIndex = inputIndex;
        }
        // Add a symbol to the term
        addSymbol(symbol, index) {
          let value = this.symbolToIndices.get(symbol);
          if (value === void 0) {
            value = [index];
          } else {
            value.push(index);
          }
          this.symbolToIndices.set(symbol, value);
        }
        // -1 for output and 0, 1, 2, ... for inputs
      };
      EinsumEquation = class {
        constructor(inputs, equation) {
          this.equation = equation;
          this.hasEllipsis = false;
          this.symbolToInfo = /* @__PURE__ */ new Map();
          this.lhs = new Array();
          this.outputDims = [];
          let [lhs, rhs] = equation.includes("->") ? equation.split("->", 2) : [equation, ""];
          if (!lhs.match(RegExp(lhsPatternOnly))) {
            throw new Error("Invalid LHS term");
          }
          const inputTerms = lhs.split(",");
          inputTerms.forEach((inputTerm, index) => {
            const dims = inputs[index].dims.slice();
            if (!inputTerm.match(RegExp(termPatternOnly))) {
              throw new Error("Invalid LHS term");
            }
            const einsumTerm = this.processTerm(inputTerm, true, dims, index);
            this.lhs.push(einsumTerm);
          });
          if (rhs === "") {
            rhs += [...this.symbolToInfo.entries()].filter(([sym, info]) => info.count === 1 || sym === "...").map(([sym]) => sym).join("");
          } else {
            if (!rhs.match(RegExp(termPattern))) {
              throw new Error("Invalid RHS");
            }
          }
          const rhsSymbols = rhs.match(RegExp(symbolPattern, "g"));
          rhsSymbols?.forEach((symbol) => {
            if (symbol === "...") {
              this.outputDims = this.outputDims.concat(this.ellipsisDims);
            } else {
              const info = this.symbolToInfo.get(symbol);
              if (info === void 0) {
                throw new Error("Invalid RHS symbol");
              }
              this.outputDims.push(info.dimValue);
            }
          });
          this.rhs = this.processTerm(rhs, false, this.outputDims);
        }
        // End of EinsumEqation constructor
        // Add a symbol to the equation
        addSymbol(symbol, dimValue, inputIndex) {
          let info = this.symbolToInfo.get(symbol);
          if (info !== void 0) {
            if (info.dimValue !== dimValue && info.count !== 1) {
              throw new Error("Dimension mismatch");
            } else {
              info.count++;
              info.inputIndices.push(inputIndex);
            }
          } else {
            info = { count: 1, dimValue, inputIndices: [inputIndex] };
          }
          this.symbolToInfo.set(symbol, info);
        }
        // Process one input/output term
        processTerm(term, isInput, dims, index = -1) {
          const rank = dims.length;
          let ellipsis = false;
          let ellipsisDims = [];
          let nextDim = 0;
          if (!term.match(RegExp(termPatternOnly)) && !isInput && term !== "") {
            throw new Error("Invalid LHS term");
          }
          const indexSymbols = term.match(RegExp(symbolPattern, "g"));
          const einsumTerm = new EinsumTerm(index);
          indexSymbols?.forEach((symbol, i) => {
            if (symbol === "...") {
              if (ellipsis) {
                throw new Error("Only one ellipsis is allowed per input term");
              }
              ellipsis = true;
              const ellipsisDimLength = rank - indexSymbols.length + 1;
              if (ellipsisDimLength < 0) {
                throw new Error("Ellipsis out of bounds");
              }
              ellipsisDims = dims.slice(nextDim, nextDim + ellipsisDimLength);
              if (this.hasEllipsis) {
                if (this.ellipsisDims.length !== ellipsisDims.length || this.ellipsisDims.toString() !== ellipsisDims.toString()) {
                  throw new Error("Ellipsis dimensions mismatch");
                }
              } else if (isInput) {
                this.hasEllipsis = true;
                this.ellipsisDims = ellipsisDims;
              } else {
                throw new Error("Ellipsis must be specified in the LHS");
              }
              for (let j = 0; j < ellipsisDims.length; j++) {
                const symbol2 = String.fromCharCode("0".charCodeAt(0) + j);
                einsumTerm.addSymbol(symbol2, i + j);
                this.addSymbol(symbol2, dims[nextDim++], index);
              }
            } else {
              einsumTerm.addSymbol(symbol, i + (this.hasEllipsis ? this.ellipsisDims.length - 1 : 0));
              this.addSymbol(symbol, dims[nextDim++], index);
            }
          });
          return einsumTerm;
        }
        // Output dimensions of the equation
      };
      appendMax = (name) => name + "_max";
      createEinsumProgramInfo = (inputShapes, dataType, einsumEquation, outputShape) => {
        const ranks = inputShapes.map((dims) => dims.length);
        const inputVars = ranks.map((rank, index) => inputVariable(`input${index}`, dataType, rank));
        const outputSize = ShapeUtil.size(outputShape);
        const output = outputVariable("output", dataType, outputShape.length);
        const uniformsSymbols = [...einsumEquation.symbolToInfo.keys()].filter(
          (symbol) => !einsumEquation.rhs.symbolToIndices.has(symbol)
        );
        const getShaderSource = (shaderHelper) => {
          const idxCopy = [];
          const initProd = "var prod = 1.0;";
          const initSum = "var sum = 0.0;";
          const updateSum = "sum += prod;";
          const reduceOpsSetIndices = [];
          const reduceOpsLoopHeaders = [];
          const reduceOpsLoopFooters = [];
          const reduceOpCompute = [];
          const isReduceOpsWithoutLoop = einsumEquation.symbolToInfo.size === einsumEquation.rhs.symbolToIndices.size;
          einsumEquation.symbolToInfo.forEach((info, symbol) => {
            if (einsumEquation.rhs.symbolToIndices.has(symbol)) {
              const outputIndex = einsumEquation.rhs.symbolToIndices.get(symbol)?.[0];
              if (outputIndex !== void 0) {
                einsumEquation.lhs.forEach((term, i) => {
                  if (info.inputIndices.includes(i)) {
                    const indices = term.symbolToIndices.get(symbol);
                    if (indices === void 0) {
                      throw new Error("Invalid symbol error");
                    }
                    indices.forEach((index) => {
                      idxCopy.push(
                        `${inputVars[i].indicesSet(
                          `input${i}Indices`,
                          index,
                          output.indicesGet("outputIndices", outputIndex)
                        )}`
                      );
                    });
                  }
                });
              }
            } else {
              einsumEquation.lhs.forEach((term, i) => {
                if (info.inputIndices.includes(i)) {
                  const indices = term.symbolToIndices.get(symbol);
                  if (indices === void 0) {
                    throw new Error("Invalid symbol error");
                  }
                  indices.forEach((index) => {
                    reduceOpsSetIndices.push(`${inputVars[i].indicesSet(`input${i}Indices`, index, `${symbol}`)}`);
                  });
                  reduceOpCompute.push(`prod *= ${inputVars[i].getByIndices(`input${i}Indices`)};`);
                }
              });
              reduceOpsLoopHeaders.push(
                `for(var ${symbol}: u32 = 0; ${symbol} < uniforms.${appendMax(symbol)}; ${symbol}++) {`
              );
              reduceOpsLoopFooters.push("}");
            }
          });
          const reduceOps2 = isReduceOpsWithoutLoop ? [
            ...idxCopy,
            `let sum = ${inputVars.map((inputVar, i) => inputVar.getByIndices(`input${i}Indices`)).join(" * ")};`
          ] : [
            ...idxCopy,
            initSum,
            ...reduceOpsLoopHeaders,
            ...reduceOpsSetIndices,
            initProd,
            ...reduceOpCompute,
            updateSum,
            ...reduceOpsLoopFooters
          ];
          return `
            ${shaderHelper.registerUniforms(uniformsSymbols.map((symbol) => ({ name: `${appendMax(symbol)}`, type: "u32" }))).registerUniform("outputSize", "u32").declareVariables(...inputVars, output)}

            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${output.offsetToIndices("global_idx")};
            ${inputVars.map((_var, i) => `var input${i}Indices: ${inputVars[i].type.indices};`).join("\n")}
            ${reduceOps2.join("\n")};
            ${output.setByOffset("global_idx", "sum")};
          }`;
        };
        return {
          name: "Einsum",
          shaderCache: { hint: einsumEquation.equation, inputDependencies: inputShapes.map(() => "rank") },
          getRunData: () => {
            const programUniformsInit = uniformsSymbols.filter((symbol) => einsumEquation.symbolToInfo.has(symbol)).map((symbol) => ({ type: 12 /* uint32 */, data: einsumEquation.symbolToInfo.get(symbol)?.dimValue || 0 }));
            programUniformsInit.push({ type: 12 /* uint32 */, data: outputSize });
            const programUniforms = inputShapes.map((dims, _) => [...createTensorShapeVariables(dims)]).reduce((acc, inputProgramUniforms) => acc.concat(inputProgramUniforms), programUniformsInit);
            programUniforms.push(...createTensorShapeVariables(outputShape));
            return {
              outputs: [{ dims: outputShape, dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms
            };
          },
          getShaderSource
        };
      };
      einsum = (context, attributes) => {
        const einsumEquation = new EinsumEquation(context.inputs, attributes.equation);
        const outputShape = einsumEquation.outputDims;
        const inputShapes = context.inputs.map((input, _) => input.dims);
        context.compute(createEinsumProgramInfo(inputShapes, context.inputs[0].dataType, einsumEquation, outputShape));
      };
      parseEinsumAttributes = (attributes) => {
        const equation = attributes.equation.replace(/\s+/g, "");
        return createAttributeWithCacheKey({ equation });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/expand.ts
  var validateInputs11, getAdjustedShape, calculateOutputShape2, createExpandProgramInfo, expand;
  var init_expand = __esm({
    "web/lib/wasm/jsep/webgpu/ops/expand.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs11 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Expand requires 2 input.");
        }
        const inputShape = inputs[0].dims;
        const shape = Array.from(inputs[1].getBigInt64Array(), Number);
        let shapeIndex = shape.length < inputShape.length ? 0 : shape.length - inputShape.length;
        let inputShapeIndex = inputShape.length < shape.length ? 0 : inputShape.length - shape.length;
        for (; shapeIndex < shape.length && inputShapeIndex < inputShape.length; ++shapeIndex, ++inputShapeIndex) {
          if (shape[shapeIndex] !== inputShape[inputShapeIndex] && shape[shapeIndex] !== 1 && inputShape[inputShapeIndex] !== 1) {
            throw new Error("Expand requires shape to be broadcastable to input");
          }
        }
      };
      getAdjustedShape = (shape1, shape2) => {
        const diff = shape1.length - shape2.length;
        const shape = [];
        for (let i = 0; i < diff; ++i) {
          shape.push(shape1[i]);
        }
        for (let i = 0; i < shape2.length; ++i) {
          shape.push(shape2[i] === 1 ? shape1[i + diff] : shape2[i]);
        }
        return shape;
      };
      calculateOutputShape2 = (inputShape, shape) => inputShape.length > shape.length ? getAdjustedShape(inputShape, shape) : getAdjustedShape(shape, inputShape);
      createExpandProgramInfo = (inputs) => {
        const inputShape = inputs[0].dims;
        const shape = Array.from(inputs[1].getBigInt64Array(), Number);
        const outputShape = calculateOutputShape2(inputShape, shape);
        const dataType = inputs[0].dataType;
        const isBoolOrScalar = dataType === 9 /* bool */ || ShapeUtil.size(inputShape) === 1;
        const iComponents = dataType === 9 /* bool */ ? 4 : inputShape.length > 0 && inputShape[inputShape.length - 1] % 4 === 0 ? 4 : 1;
        const components = isBoolOrScalar ? 4 : outputShape.length > 0 && outputShape[outputShape.length - 1] % 4 === 0 ? 4 : 1;
        const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
        const getShaderSource = (shaderHelper) => {
          const input = inputVariable("input", dataType, inputShape.length, iComponents);
          const output = outputVariable("output", dataType, outputShape.length, components);
          let assignment;
          if (dataType === 9 /* bool */) {
            const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          let offset${x} = ${input.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${input.getByOffset(`index${x}`)}[component${x}]);
        `;
            assignment = `
        let outputOffset = global_idx * ${components};
        var data = vec4<u32>(0);
        ${singleAssignment("data", 0, "u32")}
        ${singleAssignment("data", 1, "u32")}
        ${singleAssignment("data", 2, "u32")}
        ${singleAssignment("data", 3, "u32")}
        ${output.setByOffset("global_idx", "data")}
      }`;
          } else {
            assignment = `
        let outputIndices = ${output.offsetToIndices(`global_idx * ${components}`)};
        let inputOffset = ${input.broadcastedIndicesToOffset("outputIndices", output)};
        let data = ${output.type.value}(${input.getByOffset(`inputOffset / ${iComponents}`)});
        ${output.setByOffset("global_idx", "data")}
      }`;
          }
          return `
    ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(input, output)}
    ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${assignment}`;
        };
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          ...createTensorShapeVariables(inputShape, outputShape)
        ];
        return {
          name: "Expand",
          shaderCache: { hint: `${outputShape.length};${iComponents}${components}`, inputDependencies: ["rank"] },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      expand = (context) => {
        validateInputs11(context.inputs);
        context.compute(createExpandProgramInfo(context.inputs), { inputs: [0] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts
  var createFastGeluProgramInfo, fastGelu2;
  var init_fast_gelu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_unary_op();
      createFastGeluProgramInfo = (inputTensors) => {
        const dataType = inputTensors[0].dataType;
        const outputSize = ShapeUtil.size(inputTensors[0].dims);
        const biasLength = ShapeUtil.size(inputTensors[1].dims);
        const useVec4 = biasLength % 4 === 0;
        const getShaderSource = (shaderHelper) => {
          const x = inputVariable("x", dataType, [1], 4);
          const bias = inputVariable("bias", dataType, [1], 4);
          const y = outputVariable("y", dataType, [1], 4);
          const uniforms = [
            { name: "output_vec_size", type: "u32" },
            { name: "bias_size", type: "u32" }
          ];
          const singleElementBias = (i) => `
      let bias${i}_offset: u32 = (global_idx * 4 + ${i}) % uniforms.bias_size;
      let bias${i} = ${bias.getByOffset(`bias${i}_offset / 4`)}[bias${i}_offset % 4];`;
          const biasGetExpression = useVec4 ? `
      let bias = ${bias.getByOffset("global_idx % (uniforms.bias_size / 4)")};` : `${singleElementBias(0)}${singleElementBias(1)}${singleElementBias(2)}${singleElementBias(3)}
      let bias = ${x.type.value}(bias0, bias1, bias2, bias3);`;
          return `${shaderHelper.registerUniforms(uniforms).declareVariables(x, bias, y)}

    ${fastGeluImpl(tensorTypeToWsglValueType(dataType))}

    ${shaderHelper.mainStart(WORKGROUP_SIZE)}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${x.getByOffset("global_idx")};
      ${biasGetExpression}
      let x_in = x + bias;
      ${y.setByOffset("global_idx", fastGeluExpression("x_in"))}
    }`;
        };
        return {
          name: "FastGeluWithBias",
          shaderCache: { hint: `${useVec4}`, inputDependencies: ["type", "type"] },
          getShaderSource,
          getRunData: (inputs) => ({
            outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
            programUniforms: [
              { type: 12 /* uint32 */, data: Math.ceil(outputSize / 4) },
              { type: 12 /* uint32 */, data: biasLength }
            ],
            dispatchGroup: { x: Math.ceil(outputSize / WORKGROUP_SIZE / 4) }
          })
        };
      };
      fastGelu2 = (context) => {
        if (context.inputs.length < 2 || ShapeUtil.size(context.inputs[1].dims) === 0) {
          fastGelu(context);
        } else {
          context.compute(createFastGeluProgramInfo(context.inputs));
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gather.ts
  var validateInputs12, createGatherProgramInfo, parseGatherAttributes, gather;
  var init_gather = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gather.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs12 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Gather requires 2 inputs.");
        }
      };
      createGatherProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const indicesShape = inputs[1].dims;
        const inputRank = inputShape.length;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
        const outputShape = inputShape.slice(0);
        outputShape.splice(axis, 1, ...indicesShape);
        const axisDimLimit = inputShape[axis];
        const components = inputs[0].dataType === 9 /* bool */ ? 4 : 1;
        const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: axisDimLimit },
          { type: 12 /* uint32 */, data: axis },
          ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const data = inputVariable("data", inputs[0].dataType, inputs[0].dims.length, components);
          const indices = inputVariable("inputIndices", inputs[1].dataType, inputs[1].dims.length);
          const output = outputVariable("output", inputs[0].dataType, outputShape.length, components);
          const calcDataIndices = (x) => {
            const indicesRank = indicesShape.length;
            let calcStr = `var indicesIndices${x}  = ${indices.type.indices}(0);`;
            for (let i = 0; i < indicesRank; i++) {
              calcStr += `${indicesRank > 1 ? `indicesIndices${x}[${i}]` : `indicesIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[uniforms.axis + ${i}]` : `outputIndices${x}`};`;
            }
            calcStr += `
          var idx${x} = ${indices.getByIndices(`indicesIndices${x}`)};
          if (idx${x} < 0) {
            idx${x} = idx${x} + uniforms.axisDimLimit;
          }
          var dataIndices${x} : ${data.type.indices};
        `;
            for (let i = 0, j = 0; i < inputRank; i++) {
              if (i === axis) {
                calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = u32(idx${x});`;
                j += indicesRank;
              } else {
                calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[${j}]` : `outputIndices${x}`};`;
                j++;
              }
            }
            return calcStr;
          };
          let assignment;
          if (inputs[0].dataType === 9 /* bool */) {
            const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          ${calcDataIndices(x)};
          let offset${x} = ${data.indicesToOffset(`dataIndices${x}`)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${data.getByOffset(`index${x}`)}[component${x}]);
        `;
            assignment = `
        let outputOffset = global_idx * ${components};
        var value = vec4<u32>(0);
        ${singleAssignment("value", 0, "u32")}
        ${singleAssignment("value", 1, "u32")}
        ${singleAssignment("value", 2, "u32")}
        ${singleAssignment("value", 3, "u32")}
        ${output.setByOffset("global_idx", "value")}
      `;
          } else {
            assignment = `
      let outputIndices = ${output.offsetToIndices("global_idx")};
      ${calcDataIndices("")};
      let value = ${data.getByIndices("dataIndices")};
      ${output.setByOffset("global_idx", "value")};
      `;
          }
          return `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(data, indices, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${assignment}
      }`;
        };
        return {
          name: "Gather",
          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank", "rank"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      parseGatherAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
      gather = (context, attributes) => {
        const inputs = context.inputs;
        validateInputs12(inputs);
        context.compute(createGatherProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gather-nd.ts
  var computeSliceOffsets, gatherND, parseGatherNDAttributes;
  var init_gather_nd = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gather-nd.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      computeSliceOffsets = (context, indicesData, sizesFromSliceDimsData, batchDims, inputDims, numSlices, numSlicesPerBatch, inputBatchStride, numSliceDims) => {
        const programUniforms = [
          { type: 12 /* uint32 */, data: numSlices },
          { type: 12 /* uint32 */, data: batchDims },
          { type: 12 /* uint32 */, data: inputDims },
          { type: 12 /* uint32 */, data: sizesFromSliceDimsData },
          { type: 12 /* uint32 */, data: numSlicesPerBatch },
          { type: 12 /* uint32 */, data: inputBatchStride },
          { type: 12 /* uint32 */, data: numSliceDims }
        ];
        const outputShape = [numSlices];
        programUniforms.push(...createTensorShapeVariables(indicesData.dims, outputShape));
        const getShaderSource = (shaderHelper) => {
          const indices = inputVariable("indices_data", indicesData.dataType, indicesData.dims.length);
          const output = outputVariable("input_slice_offsets_data", 12 /* uint32 */, 1, 1);
          const variables = [indices, output];
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "batch_dims", type: "u32" },
            { name: "input_dims", type: "u32", length: inputDims.length },
            { name: "sizes_from_slice_dims_data", type: "u32", length: sizesFromSliceDimsData.length },
            { name: "num_slices_per_batch", type: "u32" },
            { name: "input_batch_stride", type: "u32" },
            { name: "num_slice_dims", type: "u32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${inputDims.length === 1 ? "index += i32(uniforms.input_dims);" : "index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${sizesFromSliceDimsData.length === 1 ? "relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);" : "relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`;
        };
        return context.compute(
          {
            name: "computeSliceOffsets",
            shaderCache: { hint: `${inputDims.length}_${sizesFromSliceDimsData.length}`, inputDependencies: ["rank"] },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: context.inputs[1].dataType }],
              dispatchGroup: { x: Math.ceil(numSlices / 64) },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [indicesData], outputs: [-1] }
        )[0];
      };
      gatherND = (context, attributes) => {
        const inputs = context.inputs;
        const inputShape = inputs[0].dims;
        const inputType = inputs[0].dataType;
        const indicesShape = inputs[1].dims;
        const numSliceDims = indicesShape[indicesShape.length - 1];
        const numSlices = ShapeUtil.sizeToDimension(indicesShape, indicesShape.length - 1);
        const sliceSize = ShapeUtil.sizeFromDimension(inputShape, attributes.batchDims + numSliceDims);
        const numBatches = ShapeUtil.sizeToDimension(inputShape, attributes.batchDims);
        const inputBatchStride = ShapeUtil.sizeFromDimension(inputShape, attributes.batchDims);
        const numSlicesPerBatch = numSlices / numBatches;
        const sizesFromSliceDims = new Array(numSliceDims);
        let runningProduct = sliceSize;
        for (let i = 0; i < numSliceDims; ++i) {
          sizesFromSliceDims[numSliceDims - 1 - i] = runningProduct;
          runningProduct *= inputShape[attributes.batchDims + numSliceDims - 1 - i];
        }
        const inputSliceOffsets = computeSliceOffsets(
          context,
          inputs[1],
          sizesFromSliceDims,
          attributes.batchDims,
          inputShape,
          numSlices,
          numSlicesPerBatch,
          inputBatchStride,
          numSliceDims
        );
        const lastIndicesDimension = attributes.batchDims + numSliceDims;
        if (lastIndicesDimension > inputShape.length) {
          throw new Error("last dimension of indices must not be larger than rank of input tensor");
        }
        const outputShape = indicesShape.slice(0, -1).concat(inputShape.slice(lastIndicesDimension));
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: sliceSize },
          ...createTensorShapeVariables(inputs[0].dims, inputSliceOffsets.dims, outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const input = inputVariable("data", inputs[0].dataType, inputs[0].dims.length);
          const indices = inputVariable("slice_offsets", 12 /* uint32 */, inputSliceOffsets.dims.length);
          const output = outputVariable("output", inputs[0].dataType, outputShape.length);
          return `
          ${shaderHelper.registerUniform("output_size", "u32").registerUniform("slice_size", "u32").declareVariables(input, indices, output)}
            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`;
        };
        context.compute(
          {
            name: "GatherND",
            shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank", "rank"] },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: inputType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [inputs[0], inputSliceOffsets] }
        );
      };
      parseGatherNDAttributes = (attributes) => {
        const batchDims = attributes.batch_dims;
        return {
          batchDims,
          cacheKey: ""
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gather-block-quantized.ts
  var validateInputs13, createGatherBlockQuantizedProgramInfo, gatherBlockQuantized, parseGatherBlockQuantizedAttributes;
  var init_gather_block_quantized = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gather-block-quantized.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs13 = (inputs, attributes) => {
        if (inputs.length < 3 || inputs.length > 4) {
          throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");
        }
        const quantizeAxis = ShapeUtil.normalizeAxis(attributes.quantizeAxis, inputs[0].dims.length);
        const blockSize = attributes.blockSize;
        const data = inputs[0];
        const scales = inputs[2];
        const zeroPoint = inputs.length === 4 ? inputs[3] : void 0;
        if (scales.dims.length !== data.dims.length || !data.dims.map((d, i) => i === quantizeAxis ? Math.ceil(d / blockSize) === scales.dims[i] : d === scales.dims[i]).reduce((a, b) => a && b, true)) {
          throw new Error(
            "Scales must have the same rank as the input tensor and the dims should match except on gatherAxis."
          );
        }
        if (zeroPoint) {
          if (zeroPoint.dataType !== data.dataType) {
            throw new Error("Zero point must have the same data type as the input tensor.");
          }
          if (zeroPoint.dims.length !== scales.dims.length || !zeroPoint.dims.map((d, i) => d === scales.dims[i]).reduce((a, b) => a && b, true)) {
            throw new Error(
              "Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis."
            );
          }
        }
      };
      createGatherBlockQuantizedProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const indicesShape = inputs[1].dims;
        const inputRank = inputShape.length;
        const gatherAxis = ShapeUtil.normalizeAxis(attributes.gatherAxis, inputRank);
        const quantizeAxis = ShapeUtil.normalizeAxis(attributes.quantizeAxis, inputRank);
        const outputShape = inputShape.slice(0);
        outputShape.splice(gatherAxis, 1, ...indicesShape);
        const outputSize = ShapeUtil.size(outputShape);
        const outputType = inputs[2].dataType;
        const inputType = inputs[0].dataType;
        const isSigned = inputType === 22 /* int4 */;
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: quantizeAxis },
          { type: 12 /* uint32 */, data: gatherAxis },
          { type: 12 /* uint32 */, data: attributes.blockSize },
          ...createTensorShapeVariables(...inputs.map((input, _) => input.dims), outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const data = inputVariable("data", inputs[0].dataType, inputs[0].dims.length);
          const indices = inputVariable("inputIndices", inputs[1].dataType, inputs[1].dims.length);
          const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
          const zeroPoint = inputs.length > 3 ? inputVariable("zeroPoint", inputs[3].dataType, inputs[3].dims.length) : void 0;
          const output = outputVariable("output", outputType, outputShape.length);
          const inputVariables = [data, indices, scales];
          if (zeroPoint) {
            inputVariables.push(zeroPoint);
          }
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "quantize_axis", type: "u32" },
            { name: "gather_axis", type: "u32" },
            { name: "block_size", type: "u32" }
          ];
          return `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart()}
        let output_indices = ${output.offsetToIndices("global_idx")};
        var indices_indices = ${indices.type.indices}(0);
        ${(() => {
            if (indicesShape.length > 1) {
              return `
          for (var i: u32 = 0; i < ${indicesShape.length}; i++) {
            let index = ${output.indicesGet("output_indices", "uniforms.gather_axis + i")};
            ${indices.indicesSet("indices_indices", "i", "index")};
          }`;
            } else {
              return `indices_indices = ${output.indicesGet("output_indices", "uniforms.gather_axis")};`;
            }
          })()};
        var data_indices = ${data.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${output.indicesGet("output_indices", "i")};
          ${data.indicesSet("data_indices", "i", "index")};
        }
        var index_from_indices = ${indices.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${inputShape[gatherAxis]};
        }
        ${data.indicesSet("data_indices", "uniforms.gather_axis", "u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${outputShape.length}; i++) {
          let index = ${output.indicesGet("output_indices", `i + ${indicesShape.length} - 1`)};
          ${data.indicesSet("data_indices", "i", "index")};
        }
        let data_offset = ${data.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${data.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${isSigned ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${scales.indicesGet("data_indices", "uniforms.quantize_axis")} / uniforms.block_size;
        ${scales.indicesSet("scale_indices", "uniforms.quantize_axis", "quantize_axis_index")};
        var scale = ${scales.getByIndices("scale_indices")};
        ${(() => {
            if (!zeroPoint) {
              return "var zero_point = 0";
            } else {
              return `
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${zeroPoint.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${zeroPoint.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${isSigned ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`;
            }
          })()};
        let dequantized_data = ${tensorTypeToWsglValueType(outputType)}(quantized_data - zero_point) * scale;
        ${output.setByOffset("global_idx", "dequantized_data")};
    }`;
        };
        return {
          name: "GatherBlockQuantized",
          shaderCache: {
            hint: `${attributes.cacheKey};${inputs.filter((_, i) => i !== 1).map((input) => input.dims.join("_")).join(";")}`,
            inputDependencies: Array.from({ length: inputs.length }, (_v, _i) => "rank")
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      gatherBlockQuantized = (context, attributes) => {
        const inputs = context.inputs;
        validateInputs13(inputs, attributes);
        context.compute(createGatherBlockQuantizedProgramInfo(context.inputs, attributes));
      };
      parseGatherBlockQuantizedAttributes = (attributes) => createAttributeWithCacheKey({
        blockSize: attributes.blockSize,
        gatherAxis: attributes.gatherAxis,
        quantizeAxis: attributes.quantizeAxis
      });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gather-elements.ts
  var validateInputs14, createGatherElementsProgramInfo, parseGatherElementsAttributes, gatherElements;
  var init_gather_elements = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gather-elements.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs14 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("GatherElements requires 2 inputs.");
        }
        if (inputs[0].dims.length < 1) {
          throw new Error("GatherElements requires that the data input be rank >= 1.");
        }
        if (inputs[0].dims.length !== inputs[1].dims.length) {
          throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`);
        }
      };
      createGatherElementsProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const inputOutputDataType = inputs[0].dataType;
        const inputRank = inputShape.length;
        const indicesShape = inputs[1].dims;
        const indicesDataType = inputs[1].dataType;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
        const axisDimLimit = inputShape[axis];
        const outputShape = indicesShape.slice(0);
        const outputSize = ShapeUtil.size(outputShape);
        const input = inputVariable("input", inputOutputDataType, inputRank);
        const indices = inputVariable("indicesInput", indicesDataType, indicesShape.length);
        const output = outputVariable("output", inputOutputDataType, outputShape.length);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: axisDimLimit },
          { type: 12 /* uint32 */, data: axis }
        ];
        programUniforms.push(...createTensorShapeVariables(inputShape, indicesShape, outputShape));
        const inputDependencies = ["rank", "rank"];
        const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(input, indices, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${output.offsetToIndices("global_idx")};

      var idx = ${indices.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${input.type.indices}(outputIndices);
      ${input.indicesSet("inputIndices", "uniforms.axis", "u32(idx)")};
      let value = ${input.getByIndices("inputIndices")};

      ${output.setByOffset("global_idx", "value")};
  }`;
        return {
          name: "GatherElements",
          shaderCache: { inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      parseGatherElementsAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
      gatherElements = (context, attributes) => {
        const inputs = context.inputs;
        validateInputs14(inputs);
        context.compute(createGatherElementsProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gemm.ts
  var validateInputs15, createGemmProgramInfo, parseGemmAttributes, gemm;
  var init_gemm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gemm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs15 = (inputs) => {
        if (!inputs) {
          throw new Error("Input is missing");
        }
        if (inputs.length < 2 || inputs.length > 3) {
          throw new Error("Invaid input number.");
        }
        if (inputs.length === 3 && inputs[2].dims.length > 2) {
          throw new Error("Invalid input shape of C");
        }
        if (inputs[0].dataType !== inputs[1].dataType || inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {
          throw new Error("Input types are mismatched");
        }
      };
      createGemmProgramInfo = (inputs, attributes) => {
        const aShape = inputs[0].dims.slice();
        const bShape = inputs[1].dims.slice();
        const [M, N, K] = GemmUtil.getShapeOfGemmResult(
          aShape,
          attributes.transA,
          bShape,
          attributes.transB,
          inputs.length === 3 ? inputs[2].dims : void 0
        );
        const outputShape = [M, N];
        if (!outputShape) {
          throw new Error("Can't use gemm on the given tensors");
        }
        const tileSize = 16;
        const numTileN = Math.ceil(N / tileSize);
        const numTileM = Math.ceil(M / tileSize);
        const useShared = true;
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: useShared ? numTileN : outputSize },
          { type: 12 /* uint32 */, data: M },
          { type: 12 /* uint32 */, data: N },
          { type: 12 /* uint32 */, data: K },
          { type: 1 /* float */, data: attributes.alpha },
          { type: 1 /* float */, data: attributes.beta }
        ];
        const inputDependencies = ["type", "type"];
        if (inputs.length === 3) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          let line = "";
          if (attributes.transA && attributes.transB) {
            line = "value += a[k * uniforms.M + m] * b[n * uniforms.K + k];";
          } else if (attributes.transA && !attributes.transB) {
            line = "value += a[k * uniforms.M + m] * b[k * uniforms.N + n];";
          } else if (!attributes.transA && attributes.transB) {
            line = "value += a[m * uniforms.K + k] * b[n * uniforms.K + k];";
          } else if (!attributes.transA && !attributes.transB) {
            line = "value += a[m * uniforms.K + k] * b[k * uniforms.N + n];";
          }
          const calculateAlpha = attributes.alpha === 1 ? "" : "value *= uniforms.alpha;";
          const a = inputVariable("a", inputs[0].dataType, inputs[0].dims);
          const b = inputVariable("b", inputs[1].dataType, inputs[1].dims);
          const dataType = a.type.value;
          let c = null;
          const variables = [a, b];
          if (inputs.length === 3) {
            c = inputVariable("c", inputs[2].dataType, inputs[2].dims.length);
            variables.push(c);
          }
          const output = outputVariable("output", inputs[0].dataType, outputShape.length);
          variables.push(output);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "M", type: "u32" },
            { name: "N", type: "u32" },
            { name: "K", type: "u32" },
            { name: "alpha", type: "f32" },
            { name: "beta", type: "f32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${dataType}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${line}
    }

    ${calculateAlpha}
    ${(() => {
            if (c != null) {
              return `let cOffset = ${c.broadcastedIndicesToOffset("vec2(m, n)", output)}; value += ${dataType}(uniforms.beta) * ${c.getByOffset("cOffset")};`;
            }
            return "";
          })()}
    output[global_idx] = value;
  }`;
        };
        const getShaderSourceShared = (shaderHelper) => {
          const a = inputVariable("a", inputs[0].dataType, inputs[0].dims);
          const b = inputVariable("b", inputs[1].dataType, inputs[1].dims);
          let c = null;
          const variables = [a, b];
          if (inputs.length === 3) {
            c = inputVariable("c", inputs[2].dataType, inputs[2].dims.length);
            variables.push(c);
          }
          const output = outputVariable("output", inputs[0].dataType, outputShape.length);
          variables.push(output);
          const uniforms = [
            { name: "num_tile_n", type: "u32" },
            { name: "M", type: "u32" },
            { name: "N", type: "u32" },
            { name: "K", type: "u32" },
            { name: "alpha", type: "f32" },
            { name: "beta", type: "f32" }
          ];
          let calcResult = "";
          let fillWorkgroupMemory = "";
          if (attributes.transA && attributes.transB) {
            fillWorkgroupMemory = `
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
            calcResult = `value += tile_a[k][local_id.y] * tile_b[local_id.x][k];`;
          } else if (attributes.transA && !attributes.transB) {
            fillWorkgroupMemory = `
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
            calcResult = `value += tile_a[k][local_id.y] * tile_b[k][local_id.x];`;
          } else if (!attributes.transA && attributes.transB) {
            fillWorkgroupMemory = `
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
            calcResult = `value += tile_a[local_id.y][k] * tile_b[local_id.x][k];`;
          } else if (!attributes.transA && !attributes.transB) {
            fillWorkgroupMemory = `
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
            calcResult = `value += tile_a[local_id.y][k] * tile_b[k][local_id.x];`;
          }
          const calculateAlpha = attributes.alpha === 1 ? "" : "value *= uniforms.alpha;";
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  var<workgroup> tile_a: array<array<${a.type.storage}, ${tileSize}>, ${tileSize}>;
  var<workgroup> tile_b: array<array<${b.type.storage}, ${tileSize}>, ${tileSize}>;
  ${shaderHelper.mainStart([tileSize, tileSize, 1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${tileSize};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${tileSize};
    let num_tiles = (uniforms.K - 1) / ${tileSize} + 1;
    var k_start = 0u;
    var value = ${output.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${fillWorkgroupMemory}
      k_start = k_start + ${tileSize};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${tileSize}; k++) {
        ${calcResult}
      }
      workgroupBarrier();
    }

    ${calculateAlpha}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${(() => {
            if (c != null) {
              return `let cOffset = ${c.broadcastedIndicesToOffset("vec2(m, n)", output)}; value += ${output.type.value}(uniforms.beta) * ${c.getByOffset("cOffset")};`;
            }
            return "";
          })()}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`;
        };
        if (useShared) {
          return {
            name: "GemmShared",
            shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
              dispatchGroup: { x: numTileN * numTileM },
              programUniforms
            }),
            getShaderSource: getShaderSourceShared
          };
        }
        return {
          name: "Gemm",
          shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      parseGemmAttributes = (attributes) => {
        const transA = attributes.transA;
        const transB = attributes.transB;
        const alpha = attributes.alpha;
        const beta = attributes.beta;
        return {
          transA,
          transB,
          alpha,
          beta,
          cacheKey: `${attributes.transA};${attributes.transB};${attributes.alpha === 1}`
        };
      };
      gemm = (context, attributes) => {
        validateInputs15(context.inputs);
        context.compute(createGemmProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/grid-sample.ts
  var idxN, idxC, idxH, idxW, validateInputs16, gsGetCubicCoeffs, gsBicubicInterpolate, gsDenormalize, gsReflect, pixelAtGrid, computePixel, createGridSampleProgramInfo, gridSample, parseGridSampleAttributes;
  var init_grid_sample = __esm({
    "web/lib/wasm/jsep/webgpu/ops/grid-sample.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      [idxN, idxC, idxH, idxW] = [0, 1, 2, 3];
      validateInputs16 = (inputs) => {
        if (inputs[0].dims.length !== 4) {
          throw new Error("only 4-D tensor is supported.");
        }
        if (inputs[0].dims.length !== inputs[1].dims.length) {
          throw new Error("input dimensions must be equal to grid dimensions");
        }
        if (inputs[0].dims.length - 2 !== inputs[1].dims[inputs[1].dims.length - 1]) {
          throw new Error(`last dimension of grid must be equal to ${inputs[0].dims.length - 2}`);
        }
        if (inputs[0].dims[0] !== inputs[1].dims[0]) {
          throw new Error("grid batch size must match input batch size");
        }
      };
      gsGetCubicCoeffs = `
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`;
      gsBicubicInterpolate = (dataType) => `
  fn gs_bicubic_interpolate(p: mat4x4<${dataType}>, x: f32, y: f32) -> ${dataType} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${dataType}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`;
      gsDenormalize = (attributes) => `
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${attributes.alignCorners === 0 ? `
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    ` : `
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`;
      gsReflect = (attributes) => `
  ${attributes.paddingMode === "reflection" ? `
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }` : ""}
`;
      pixelAtGrid = (input, dataType, attributes) => `
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${dataType} {
     var pixel = ${dataType}(0);
     var indices = vec4<u32>(0);
     indices[${idxN}] = batch;
     indices[${idxC}] = channel;` + (() => {
        switch (attributes.paddingMode) {
          case "zeros":
            return `
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${idxH}] = u32(r);
            indices[${idxW}] = u32(c);
          } else {
            return ${dataType}(0);
          }
        `;
          case "border":
            return `
          indices[${idxH}] = u32(clamp(r, 0, H - 1));
          indices[${idxW}] = u32(clamp(c, 0, W - 1));
        `;
          case "reflection":
            return `
          indices[${idxH}] = gs_reflect(r, border[1], border[3]);
          indices[${idxW}] = gs_reflect(c, border[0], border[2]);
        `;
          default:
            throw new Error(`padding mode ${attributes.paddingMode} is not supported`);
        }
      })() + `
    return ${input.getByIndices("indices")};
  }
`;
      computePixel = (output, dataType, attributes) => (() => {
        switch (attributes.mode) {
          case "nearest":
            return `
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${idxN}], indices[${idxC}], border);
        `;
          case "bilinear":
            return `
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${idxN}], indices[${idxC}], border);

          let dx2 = ${dataType}(f32(x2) - x);
          let dx1 = ${dataType}(x - f32(x1));
          let dy2 = ${dataType}(f32(y2) - y);
          let dy1 = ${dataType}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;
          case "bicubic":
            return `
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${dataType}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;
          default:
            throw new Error(`mode ${attributes.mode} is not supported`);
        }
      })() + `${output.setByOffset("global_idx", "result")}`;
      createGridSampleProgramInfo = (inputs, attributes) => {
        const x = inputVariable("x", inputs[0].dataType, inputs[0].dims.length);
        const gridShape = [inputs[1].dims[0], inputs[1].dims[1], inputs[1].dims[2]];
        const grid = inputVariable("grid", inputs[1].dataType, gridShape.length, 2);
        let outputShape = [inputs[0].dims[0], inputs[0].dims[1], inputs[1].dims[1], inputs[1].dims[2]];
        if (attributes.format === "NHWC") {
          outputShape = [inputs[0].dims[0], inputs[1].dims[1], inputs[1].dims[2], inputs[0].dims[3]];
          [idxN, idxC, idxH, idxW] = [0, 3, 1, 2];
        }
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        const dataType = x.type.value;
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          ...createTensorShapeVariables(inputs[0].dims, gridShape, outputShape)
        ];
        const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(x, grid, output)}
  ${gsGetCubicCoeffs}
  ${gsBicubicInterpolate(dataType)}
  ${gsDenormalize(attributes)}
  ${gsReflect(attributes)}
  ${pixelAtGrid(x, dataType, attributes)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${idxH}]);
      let W_in = i32(uniforms.x_shape[${idxW}]);

      ${attributes.alignCorners === 0 ? `
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      ` : `
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${output.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${idxN}], indices[${idxH}], indices[${idxW}]);
      let nxy = ${grid.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${computePixel(output, dataType, attributes)}
  }`;
        return {
          name: "GridSample",
          shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies: ["type", "type"] },
          getRunData: (inputs2) => {
            const outputSize2 = ShapeUtil.size(outputShape);
            return {
              outputs: [{ dims: outputShape, dataType: inputs2[0].dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize2 / 64
                /* workgroup size */
              ) },
              programUniforms
            };
          },
          getShaderSource
        };
      };
      gridSample = (context, attributes) => {
        validateInputs16(context.inputs);
        context.compute(createGridSampleProgramInfo(context.inputs, attributes));
      };
      parseGridSampleAttributes = (attributes) => createAttributeWithCacheKey({
        alignCorners: attributes.align_corners,
        mode: attributes.mode,
        paddingMode: attributes.padding_mode,
        format: attributes.format
      });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts
  var getInput, validateInputs17, parseMultiHeadAttentionAttributes, weightTransposeAttribute2, addBiasTranspose, maybeTransposeToBNSHAndAddBias, multiHeadAttention;
  var init_multihead_attention = __esm({
    "web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_types();
      init_attention();
      init_common();
      init_transpose();
      getInput = (inputs, i) => inputs.length > i && inputs[i].dims.length > 0 ? inputs[i] : void 0;
      validateInputs17 = (inputs, attributes) => {
        const query = inputs[0];
        const key = getInput(inputs, 1);
        const value = getInput(inputs, 2);
        const bias = getInput(inputs, 3);
        const keyPaddingMask = getInput(inputs, 4);
        const attentionBias = getInput(inputs, 5);
        const pastKey = getInput(inputs, 6);
        const pastValue = getInput(inputs, 7);
        if (query.dims.length !== 3 && query.dims.length !== 5) {
          throw new Error("Input query is expected to have 3 or 5 dimensions");
        }
        const batchSize = query.dims[0];
        const sequenceLength = query.dims[1];
        const hiddenSize = query.dims.length === 3 ? query.dims[2] : attributes.numHeads * query.dims[4];
        let kvSequenceLength = sequenceLength;
        let pastSequenceLength = 0;
        let maxSequenceLength = 0;
        const headSize = Math.floor(hiddenSize / attributes.numHeads);
        if (pastKey && pastValue && ShapeUtil.size(pastKey.dims) && ShapeUtil.size(pastValue.dims)) {
          if (pastKey.dims.length !== 4) {
            throw new Error('Input "past_key" is expected to have 4 dimensions');
          }
          if (pastKey.dims[0] !== batchSize || pastKey.dims[1] !== attributes.numHeads || pastKey.dims[3] !== headSize) {
            throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');
          }
          if (pastValue.dims[0] !== batchSize || pastValue.dims[1] !== attributes.numHeads || pastValue.dims[3] !== headSize) {
            throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');
          }
          if (pastKey.dims[2] !== pastValue.dims[2]) {
            throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');
          }
          if (pastValue.dims.length !== 4) {
            throw new Error('Input "past_value" is expected to have 4 dimensions');
          }
          pastSequenceLength = pastKey.dims[2];
          maxSequenceLength = pastKey.dims[2];
        } else if (pastKey && ShapeUtil.size(pastKey.dims) || pastValue && ShapeUtil.size(pastValue.dims)) {
          throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
        }
        let qkvFormat;
        if (key && ShapeUtil.size(key.dims) > 0) {
          if (query.dims.length !== 3) {
            throw new Error('Input "query" is expected to have 3 dimensions when key is given');
          }
          if (key.dims.length < 3 || key.dims.length > 5) {
            throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
          }
          if (query.dims[0] !== key.dims[0]) {
            throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
          }
          if (key.dims.length === 3) {
            if (key.dims[2] !== query.dims[2]) {
              throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');
            }
            qkvFormat = 2 /* qkvBSNH */;
            kvSequenceLength = key.dims[1];
          } else if (key.dims.length === 5) {
            if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
            }
            if (value) {
              throw new Error('Expect "value" be none when "key" has packed kv format.');
            }
            qkvFormat = 5 /* qKvBSNHxBSN2H */;
            kvSequenceLength = key.dims[1];
          } else {
            if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
            }
            qkvFormat = 0 /* unknown */;
            kvSequenceLength = key.dims[2];
          }
        } else {
          if (query.dims.length !== 5) {
            throw new Error('Input "query" is expected to have 5 dimensions when key is empty');
          }
          if (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3) {
            throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
          }
          qkvFormat = 3 /* qkvBSN3H */;
        }
        if (bias && ShapeUtil.size(bias.dims) > 0) {
          if (bias.dims.length !== 1) {
            throw new Error('Input "bias" is expected to have 1 dimension');
          }
          if (key) {
            if (key.dims.length === 5 && key.dims[3] === 2) {
              throw new Error("bias is not allowed for packed kv.");
            }
          }
        }
        const totalSequenceLength = pastSequenceLength + kvSequenceLength;
        let maskType = 0 /* none */;
        if (keyPaddingMask && ShapeUtil.size(keyPaddingMask.dims) > 0) {
          maskType = 8 /* maskUnknown */;
          const maskDims = keyPaddingMask.dims;
          if (maskDims.length === 1) {
            if (maskDims[0] === batchSize) {
              maskType = 1 /* mask1dKeySeqLen */;
            } else if (maskDims[0] === 3 * batchSize + 2) {
              maskType = 3 /* mask1DKeySeqLenStart */;
            }
          } else if (maskDims.length === 2 && maskDims[0] === batchSize && maskDims[1] === totalSequenceLength) {
            maskType = 5 /* mask2dKeyPadding */;
          }
          if (maskType === 8 /* maskUnknown */) {
            throw new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)');
          }
          throw new Error("Mask not supported");
        }
        let passPastInKv = false;
        let vHiddenSize = hiddenSize;
        if (value && ShapeUtil.size(value.dims) > 0) {
          if (value.dims.length !== 3 && value.dims.length !== 4) {
            throw new Error('Input "value" is expected to have 3 or 4 dimensions');
          }
          if (query.dims[0] !== value.dims[0]) {
            throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
          }
          if (value.dims.length === 3) {
            if (kvSequenceLength !== value.dims[1]) {
              throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[2];
          } else {
            if (kvSequenceLength !== value.dims[2]) {
              throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[1] * value.dims[3];
            passPastInKv = true;
          }
        }
        const broadcastResPosBias = false;
        if (keyPaddingMask && ShapeUtil.size(keyPaddingMask.dims) > 0) {
          throw new Error("Key padding mask is not supported");
        }
        if (attentionBias && ShapeUtil.size(attentionBias.dims) > 0) {
          if (attentionBias.dims.length !== 4) {
            throw new Error('Input "attention_bias" is expected to have 4 dimensions');
          }
          if (attentionBias.dims[0] !== batchSize || attentionBias.dims[1] !== attributes.numHeads || attentionBias.dims[2] !== sequenceLength || attentionBias.dims[3] !== totalSequenceLength) {
            throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
          }
        }
        return {
          batchSize,
          sequenceLength,
          pastSequenceLength,
          kvSequenceLength,
          totalSequenceLength,
          maxSequenceLength,
          inputHiddenSize: 0,
          hiddenSize,
          vHiddenSize,
          headSize,
          vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
          numHeads: attributes.numHeads,
          isUnidirectional: false,
          pastPresentShareBuffer: false,
          maskFilterValue: attributes.maskFilterValue,
          maskType,
          scale: attributes.scale,
          broadcastResPosBias,
          passPastInKv,
          qkvFormat
        };
      };
      parseMultiHeadAttentionAttributes = (attributes) => createAttributeWithCacheKey({ ...attributes });
      weightTransposeAttribute2 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
      addBiasTranspose = (context, qkv, bias, batchSize, sequenceLength, hiddenSize, biasOffset) => {
        const outputShape = [batchSize, sequenceLength, hiddenSize];
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: biasOffset },
          { type: 12 /* uint32 */, data: hiddenSize }
        ];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("qkv_with_bias", qkv.dataType, outputShape);
          const qkvInput = inputVariable("qkv", qkv.dataType, outputShape);
          const biasInput = inputVariable("bias", bias.dataType, outputShape);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "bias_offset", type: "u32" },
            { name: "hidden_size", type: "u32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(qkvInput, biasInput, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`;
        };
        return context.compute(
          {
            name: "MultiHeadAttentionAddBias",
            shaderCache: { inputDependencies: ["type", "type"] },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: qkv.dataType, gpuDataType: 0 /* default */ }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [qkv, bias], outputs: [-1] }
        )[0];
      };
      maybeTransposeToBNSHAndAddBias = (context, batchSize, numHeads, sequenceLength, headSize, input, bias, biasOffset) => {
        let reshapedInput = input;
        if (!(bias && ShapeUtil.size(bias.dims) > 0)) {
          if (input.dims.length === 3) {
            reshapedInput = input.reshape([batchSize, sequenceLength, numHeads, headSize]);
          }
          if (numHeads === 1 || sequenceLength === 1) {
            return reshapedInput;
          }
          return context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm), {
            inputs: [reshapedInput],
            outputs: [-1]
          })[0];
        } else {
          if (sequenceLength === 1) {
            throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");
          } else {
            reshapedInput = addBiasTranspose(
              context,
              input,
              bias,
              batchSize,
              sequenceLength,
              numHeads * headSize,
              biasOffset
            );
            reshapedInput = reshapedInput.reshape([batchSize, sequenceLength, numHeads, headSize]);
            if (numHeads === 1 || sequenceLength === 1) {
              return reshapedInput;
            }
            return context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm), {
              inputs: [reshapedInput],
              outputs: [-1]
            })[0];
          }
        }
      };
      multiHeadAttention = (context, attributes) => {
        const params = validateInputs17(context.inputs, attributes);
        const query = context.inputs[0];
        const key = getInput(context.inputs, 1);
        const value = getInput(context.inputs, 2);
        const bias = getInput(context.inputs, 3);
        const keyPaddingMask = getInput(context.inputs, 4);
        const attentionBias = getInput(context.inputs, 5);
        const pastKey = getInput(context.inputs, 6);
        const pastValue = getInput(context.inputs, 7);
        if (query.dims.length === 5) {
          throw new Error("Packed QKV is not implemented");
        }
        if (key?.dims.length === 5) {
          throw new Error("Packed KV is not implemented");
        }
        const kvBNSH = key && value && key.dims.length === 4 && value.dims.length === 4;
        const Q = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.sequenceLength,
          params.headSize,
          query,
          bias,
          0
        );
        if (kvBNSH) {
          return applyAttention(context, Q, key, value, keyPaddingMask, void 0, pastKey, pastValue, attentionBias, params);
        }
        if (!key || !value) {
          throw new Error("key and value must be provided");
        }
        const K = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.kvSequenceLength,
          params.headSize,
          key,
          bias,
          params.hiddenSize
        );
        const V = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.kvSequenceLength,
          params.vHeadSize,
          value,
          bias,
          2 * params.hiddenSize
        );
        applyAttention(context, Q, K, V, keyPaddingMask, void 0, pastKey, pastValue, attentionBias, params);
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/split.ts
  var validateInputs18, createSplitAttributesFromInputs, calculateOutputIndexImpl, writeBufferDataImpl, createSplitProgramInfo, split, parseSplitAttributes;
  var init_split = __esm({
    "web/lib/wasm/jsep/webgpu/ops/split.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs18 = (inputs) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("too few inputs");
        }
      };
      createSplitAttributesFromInputs = (inputs, attributes) => {
        const splitSizes = [];
        let numOutputs = attributes.numOutputs;
        if (inputs[1].dims[0] > 0) {
          inputs[1].getBigInt64Array().forEach((v) => splitSizes.push(Number(v)));
          numOutputs = splitSizes.length;
        }
        return createAttributeWithCacheKey({ numOutputs, axis: attributes.axis, splitSizes });
      };
      calculateOutputIndexImpl = (numberOfTensors) => `
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${numberOfTensors}u; i += 1u ) {
    if (index < ${getElementAt("uniforms.size_in_split_axis", "i", numberOfTensors)}) {
        return i;
    }
    }
    return ${numberOfTensors}u;
}`;
      writeBufferDataImpl = (outputs) => {
        const numberOfTensors = outputs.length;
        const codeLines = [];
        for (let i = 0; i < numberOfTensors; ++i) {
          const returnSnippet = outputs[i].setByIndices("indices", "input[global_idx]");
          if (numberOfTensors === 1) {
            codeLines.push(returnSnippet);
          } else if (i === 0) {
            codeLines.push(`if (output_number == ${i}u) { ${returnSnippet} }`);
          } else if (i === numberOfTensors - 1) {
            codeLines.push(`else { ${returnSnippet} }`);
          } else {
            codeLines.push(`else if (output_number == ${i}) { ${returnSnippet} }`);
          }
        }
        return `
      fn writeBufferData(output_number: u32, indices: ${outputs[0].type.indices}, global_idx: u32) {
        ${codeLines.join("\n")}
      }`;
      };
      createSplitProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const inputSize = ShapeUtil.size(inputShape);
        const dataType = inputs[0].dataType;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
        const outputs = new Array(attributes.numOutputs);
        const input = inputVariable("input", dataType, inputShape.length);
        const sizeInSplitAxis = new Array(attributes.numOutputs);
        const outputsTensorInfo = [];
        const outputShapes = [];
        let previousSum = 0;
        const programUniforms = [{ type: 12 /* uint32 */, data: inputSize }];
        for (let i = 0; i < attributes.numOutputs; i++) {
          previousSum += attributes.splitSizes[i];
          sizeInSplitAxis[i] = previousSum;
          const outputShape = inputShape.slice();
          outputShape[axis] = attributes.splitSizes[i];
          outputShapes.push(outputShape);
          outputs[i] = outputVariable(`output${i}`, dataType, outputShape.length);
          outputsTensorInfo.push({ dims: outputShapes[i], dataType: inputs[0].dataType });
        }
        programUniforms.push(
          { type: 12 /* uint32 */, data: sizeInSplitAxis },
          ...createTensorShapeVariables(inputShape, ...outputShapes)
        );
        const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("input_size", "u32").registerUniform("size_in_split_axis", "u32", sizeInSplitAxis.length).declareVariables(input, ...outputs)}
  ${calculateOutputIndexImpl(sizeInSplitAxis.length)}
  ${writeBufferDataImpl(outputs)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${input.offsetToIndices("global_idx")};
    var index = ${input.indicesGet("indices", axis)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${getElementAt("uniforms.size_in_split_axis", "output_number - 1u", sizeInSplitAxis.length)};
      ${input.indicesSet("indices", axis, "index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;
        return {
          name: "Split",
          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          getShaderSource,
          getRunData: () => ({
            outputs: outputsTensorInfo,
            dispatchGroup: { x: Math.ceil(
              inputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      split = (context, attributes) => {
        validateInputs18(context.inputs);
        const updatedAttributes = context.inputs.length === 1 ? attributes : createSplitAttributesFromInputs(context.inputs, attributes);
        context.compute(createSplitProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
      };
      parseSplitAttributes = (attributes) => {
        const axis = attributes.axis;
        const splitSizes = attributes.splitSizes;
        const numOutputs = attributes.numOutputs < 0 ? splitSizes.length : attributes.numOutputs;
        if (numOutputs !== splitSizes.length) {
          throw new Error("numOutputs and splitSizes length must be equal");
        }
        return createAttributeWithCacheKey({ axis, numOutputs, splitSizes });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts
  var validateInputs19, createRotaryEmbeddingProgramInfo, rotaryEmbedding;
  var init_rotary_embedding = __esm({
    "web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs19 = (inputs, attributes) => {
        const [input, positionIds, cosCache, sinCache] = inputs;
        const { numHeads, rotaryEmbeddingDim } = attributes;
        if (input.dims.length !== 3 && input.dims.length !== 4) {
          throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${input.dims.length}`);
        }
        if (!ShapeUtil.areEqual(positionIds.dims, []) && !ShapeUtil.areEqual(positionIds.dims, [1]) && positionIds.dims.length !== 2) {
          throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${positionIds.dims.length}`);
        }
        if (cosCache.dims.length !== 2) {
          throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${cosCache.dims.length}`);
        }
        if (sinCache.dims.length !== 2) {
          throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${sinCache.dims.length}`);
        }
        if (!ShapeUtil.areEqual(cosCache.dims, sinCache.dims)) {
          throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");
        }
        if (rotaryEmbeddingDim > 0 && numHeads === 0) {
          throw new Error("num_heads must be provided if rotary_embedding_dim is specified");
        }
        const batchSize = input.dims[0];
        const sequenceLength = input.dims[input.dims.length - 2];
        const maxSequenceLength = cosCache.dims[0];
        const hiddenSize = ShapeUtil.sizeFromDimension(input.dims, 1) / sequenceLength;
        const headSize = rotaryEmbeddingDim === 0 ? cosCache.dims[1] * 2 : hiddenSize / numHeads;
        if (rotaryEmbeddingDim > headSize) {
          throw new Error("rotary_embedding_dim must be less than or equal to head_size");
        }
        if (positionIds.dims.length === 2) {
          if (batchSize !== positionIds.dims[0]) {
            throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${positionIds.dims[0]}`);
          }
          if (sequenceLength !== positionIds.dims[1]) {
            throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${positionIds.dims[1]}`);
          }
        }
        if (headSize / 2 !== cosCache.dims[1] && rotaryEmbeddingDim / 2 !== cosCache.dims[1]) {
          throw new Error(
            `Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${cosCache.dims[1]}`
          );
        }
        if (sequenceLength > maxSequenceLength) {
          throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported");
        }
      };
      createRotaryEmbeddingProgramInfo = (inputs, attributes) => {
        const { interleaved, numHeads, rotaryEmbeddingDim, scale } = attributes;
        const batchSize = inputs[0].dims[0];
        const batchStride = ShapeUtil.sizeFromDimension(inputs[0].dims, 1);
        const sequenceLength = inputs[0].dims[inputs[0].dims.length - 2];
        const hiddenSize = batchStride / sequenceLength;
        const halfRotaryEmbeddingDim = inputs[2].dims[1];
        const headSize = rotaryEmbeddingDim === 0 ? halfRotaryEmbeddingDim * 2 : hiddenSize / numHeads;
        const globalShape = new Array(
          batchSize,
          sequenceLength,
          hiddenSize / headSize,
          headSize - halfRotaryEmbeddingDim
        );
        const globalStrides = ShapeUtil.computeStrides(globalShape);
        const programUniforms = [
          { type: 1 /* float */, data: scale },
          { type: 12 /* uint32 */, data: globalShape },
          { type: 12 /* uint32 */, data: globalStrides },
          // strides for addressing the input/output tensor, in permutated order to align with the unfolded global index,
          // i.e. BSNH
          ...inputs[0].dims.length === 3 ? new Array({ type: 12 /* uint32 */, data: [batchStride, hiddenSize, headSize, 1] }) : [],
          ...inputs[0].dims.length === 4 ? new Array({
            type: 12 /* uint32 */,
            data: [batchStride, headSize, sequenceLength * headSize, 1]
          }) : [],
          ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, inputs[2].dims, inputs[3].dims, inputs[0].dims)
        ];
        const getShaderSource = (shaderHelper) => {
          const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
          const positionIds = inputVariable("position_ids", inputs[1].dataType, inputs[1].dims.length);
          const cosCache = inputVariable("cos_cache", inputs[2].dataType, inputs[2].dims.length);
          const sinCache = inputVariable("sin_cache", inputs[3].dataType, inputs[3].dims.length);
          const output = outputVariable("output", inputs[0].dataType, inputs[0].dims.length);
          shaderHelper.registerUniforms([
            { name: "scale", type: "f32" },
            { name: "global_shape", type: "u32", length: globalShape.length },
            { name: "global_strides", type: "u32", length: globalStrides.length },
            { name: "input_output_strides", type: "u32", length: globalStrides.length }
          ]);
          return `
        ${shaderHelper.declareVariables(input, positionIds, cosCache, sinCache, output)}

        ${shaderHelper.mainStart(WORKGROUP_SIZE)}
          let half_rotary_emb_dim = uniforms.${cosCache.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${positionIds.broadcastedIndicesToOffset("bsnh.xy", outputVariable("", positionIds.type.tensor, 2))};
            let position_id =
                u32(${positionIds.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${interleaved});
            let j = i + select(half_rotary_emb_dim, 1, ${interleaved});
            let re = ${input.getByOffset("i")} * ${cosCache.get("position_id", "bsnh[3]")} -
                ${input.getByOffset("j")} * ${sinCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("i", "re")}
            let im = ${input.getByOffset("i")} * ${sinCache.get("position_id", "bsnh[3]")} +
                ${input.getByOffset("j")} * ${cosCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("j", "im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${output.setByOffset("k", input.getByOffset("k"))}
          }
        }`;
        };
        return {
          name: "RotaryEmbedding",
          shaderCache: {
            hint: createAttributeWithCacheKey({
              interleaved
            }).cacheKey,
            inputDependencies: ["rank", "rank", "rank", "rank"]
          },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(ShapeUtil.size(globalShape) / WORKGROUP_SIZE) },
            programUniforms
          })
        };
      };
      rotaryEmbedding = (context, attributes) => {
        validateInputs19(context.inputs, attributes);
        context.compute(createRotaryEmbeddingProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts
  var validateInputs20, weightTransposeAttribute3, maybeTransposeToBNSH, generatePositionIdsProgramInfo, groupQueryAttention;
  var init_group_query_attention = __esm({
    "web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_wasm_common();
      init_attention();
      init_multihead_attention();
      init_split();
      init_transpose();
      init_rotary_embedding();
      init_common();
      validateInputs20 = (inputs, attributes) => {
        if (attributes.doRotary && inputs.length <= 7) {
          throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");
        }
        const query = inputs[0];
        const key = inputs[1];
        const value = inputs[2];
        const pastKey = inputs[3];
        const pastValue = inputs[4];
        if (attributes.doRotary !== 0 && inputs.length <= 7) {
          throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");
        }
        if (attributes.localWindowSize !== -1) {
          throw new Error("Local attention is not supported");
        }
        if (attributes.softcap !== 0) {
          throw new Error("Softcap is not supported");
        }
        if (attributes.rotaryInterleaved !== 0) {
          throw new Error("Rotary interleaved is not supported");
        }
        if (attributes.smoothSoftmax) {
          throw new Error("Smooth softmax is not supported");
        }
        if (query.dims.length !== 3 && query.dims.length !== 5) {
          throw new Error("Input query is expected to have 3 or 5 dimensions");
        }
        const dmmhaPacking = false;
        const batchSize = query.dims[0];
        const sequenceLength = query.dims[1];
        let hiddenSize = query.dims.length === 3 ? dmmhaPacking ? query.dims[2] / 3 : query.dims[2] : attributes.numHeads * query.dims[4];
        let kvSequenceLength = sequenceLength;
        let pastSequenceLength = 0;
        const packedQKV = !key || key.dims.length === 0;
        const headSize = !packedQKV ? Math.floor(hiddenSize / attributes.numHeads) : Math.floor(hiddenSize / (attributes.numHeads + 2 * attributes.kvNumHeads));
        if (packedQKV) {
          hiddenSize = headSize * attributes.numHeads;
        }
        const hasPastKey = pastKey && pastKey.dims.length !== 0;
        const hasPastValue = pastValue && pastValue.dims.length !== 0;
        const isPastkvBSNH = hasPastKey && pastKey.dims.length === 4 && pastKey.dims[0] === batchSize && pastKey.dims[1] !== attributes.kvNumHeads && pastKey.dims[2] === attributes.kvNumHeads && pastKey.dims[3] === headSize;
        if (isPastkvBSNH) {
          throw new Error("BSNH pastKey/pastValue is not supported");
        }
        if (hasPastKey && hasPastValue) {
          if (pastKey.dims.length !== 4) {
            throw new Error('Input "past_key" is expected to have 4 dimensions');
          }
          if (pastValue.dims.length !== 4) {
            throw new Error('Input "past_value" is expected to have 4 dimensions');
          }
          pastSequenceLength = pastKey.dims[2];
        } else if (hasPastKey || hasPastValue) {
          throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
        }
        let qkvFormat = 1 /* qkvBNSH */;
        if (key && key.dims.length > 0) {
          if (query.dims.length !== 3) {
            throw new Error('Input "query" is expected to have 3 dimensions when key is given');
          }
          if (key.dims.length < 3 || key.dims.length > 5) {
            throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
          }
          if (query.dims[0] !== key.dims[0]) {
            throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
          }
          if (key.dims.length === 3) {
            if (query.dims[2] % key.dims[2] !== 0) {
              throw new Error('Dimension 2 of "query" should be a multiple of "key"');
            }
            kvSequenceLength = key.dims[1];
          } else if (key.dims.length === 5) {
            if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
            }
            if (value) {
              throw new Error('Expect "value" be none when "key" has packed kv format.');
            }
            kvSequenceLength = key.dims[1];
          } else {
            if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
            }
            kvSequenceLength = key.dims[2];
          }
        } else {
          if (query.dims.length !== 3 && query.dims.length !== 5) {
            throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');
          }
          if (query.dims.length === 5 && (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3)) {
            throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
          }
          qkvFormat = 3 /* qkvBSN3H */;
        }
        const maskType = 0 /* none */;
        let passPastInKv = false;
        let vHiddenSize = attributes.kvNumHeads ? headSize * attributes.kvNumHeads : hiddenSize;
        if (value && value.dims.length > 0) {
          if (value.dims.length !== 3 && value.dims.length !== 4) {
            throw new Error('Input "value" is expected to have 3 or 4 dimensions');
          }
          if (query.dims[0] !== value.dims[0]) {
            throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
          }
          if (value.dims.length === 3) {
            if (kvSequenceLength !== value.dims[1]) {
              throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[2];
          } else {
            if (kvSequenceLength !== value.dims[2]) {
              throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[1] * value.dims[3];
            passPastInKv = true;
          }
        }
        const seqlLens = inputs.length > 4 ? inputs[5] : void 0;
        if (seqlLens && seqlLens.dims.length !== 1 && seqlLens.dims[0] !== batchSize) {
          throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');
        }
        const totalSequenceLength = -1;
        const maxSequenceLength = -1;
        const broadcastResPosBias = false;
        return {
          batchSize,
          sequenceLength,
          pastSequenceLength,
          kvSequenceLength,
          totalSequenceLength,
          maxSequenceLength,
          inputHiddenSize: 0,
          hiddenSize,
          vHiddenSize,
          headSize,
          vHeadSize: Math.floor(vHiddenSize / attributes.kvNumHeads),
          numHeads: attributes.numHeads,
          kvNumHeads: attributes.kvNumHeads,
          nReps: attributes.numHeads / attributes.kvNumHeads,
          pastPresentShareBuffer: false,
          maskType,
          scale: attributes.scale,
          broadcastResPosBias,
          passPastInKv,
          qkvFormat
        };
      };
      weightTransposeAttribute3 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
      maybeTransposeToBNSH = (context, input, params) => {
        let reshapedInput = input;
        const numHeads = params.kvNumHeads;
        if (input.dims.length === 3 && params.kvSequenceLength !== 0) {
          reshapedInput = input.reshape([params.batchSize, params.kvSequenceLength, numHeads, params.headSize]);
          reshapedInput = context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute3.perm), {
            inputs: [reshapedInput],
            outputs: [-1]
          })[0];
        }
        return reshapedInput;
      };
      generatePositionIdsProgramInfo = (batchSize, sequenceLength, seqLens, totalSeqLen) => {
        const outputDataType = 7 /* int64 */;
        const inputDependencies = ["type", "type"];
        const outputShape = [batchSize * sequenceLength];
        const outputSize = batchSize * sequenceLength;
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: sequenceLength },
          { type: 12 /* uint32 */, data: batchSize }
        ];
        const getShaderSource = (shaderHelper) => {
          const seqLensInputHelper = inputVariable("seq_lens", seqLens.dataType, seqLens.dims);
          const totalSeqLenInputHelper = inputVariable("total_seq_lens", totalSeqLen.dataType, totalSeqLen.dims);
          const positionIdsHelper = outputVariable("pos_ids", outputDataType, outputShape);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "sequence_length", type: "u32" },
            { name: "batch_size", type: "u32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(seqLensInputHelper, totalSeqLenInputHelper, positionIdsHelper)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${totalSeqLenInputHelper.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${seqLensInputHelper.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${positionIdsHelper.setByOffset("global_idx", "pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${positionIdsHelper.setByOffset("global_idx", "pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${positionIdsHelper.setByOffset("global_idx", "seqlen")}
    };
  }
  `;
        };
        return {
          name: "GeneratePositionIds",
          shaderCache: { hint: `${batchSize};${sequenceLength}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      groupQueryAttention = (context, attributes) => {
        const params = validateInputs20(context.inputs, attributes);
        if (context.inputs[0].dims.length === 5) {
          throw new Error("Packed QKV is not implemented");
        }
        if (context.inputs[1]?.dims.length === 5) {
          throw new Error("Packed KV is not implemented");
        }
        const q = context.inputs[0];
        const k = context.inputs[1] && context.inputs[1].dims.length > 0 ? context.inputs[1] : void 0;
        const v = context.inputs[2] && context.inputs[2].dims.length > 0 ? context.inputs[2] : void 0;
        const pastKey = context.inputs[3] && context.inputs[3].dims.length !== 0 ? context.inputs[3] : void 0;
        const pastValue = context.inputs[4] && context.inputs[4].dims.length !== 0 ? context.inputs[4] : void 0;
        const seqLens = context.inputs.length > 4 ? context.inputs[5] : void 0;
        const totalSequenceLengthInput = context.inputs.length > 5 ? context.inputs[6] : void 0;
        const kvNumHeads = params.kvNumHeads ? params.kvNumHeads : params.numHeads;
        const splitAttributes = createAttributeWithCacheKey({
          axis: 2,
          numOutputs: 3,
          splitSizes: [params.numHeads * params.headSize, kvNumHeads * params.headSize, kvNumHeads * params.headSize]
        });
        const [query, key, value] = !k && !v ? context.compute(createSplitProgramInfo([q], splitAttributes), { inputs: [q], outputs: [-1, -1, -1] }) : [q, k, v];
        let qRotary;
        let kRotary;
        if (attributes.doRotary) {
          const posIds = context.compute(
            generatePositionIdsProgramInfo(params.batchSize, params.sequenceLength, seqLens, totalSequenceLengthInput),
            { inputs: [seqLens, totalSequenceLengthInput], outputs: [-1] }
          )[0];
          const cosCache = context.inputs[7];
          const sinCache = context.inputs[8];
          const qRotaryEmbeddingAttributes = createAttributeWithCacheKey({
            interleaved: attributes.rotaryInterleaved !== 0,
            numHeads: params.numHeads,
            rotaryEmbeddingDim: 0,
            scale: attributes.scale
          });
          const inputs = [query, posIds, cosCache, sinCache];
          const outputs = [-1];
          qRotary = context.compute(createRotaryEmbeddingProgramInfo(inputs, qRotaryEmbeddingAttributes), {
            inputs,
            outputs
          })[0];
          inputs.splice(0, 1, key);
          const kRotaryEmbeddingAttributes = createAttributeWithCacheKey({
            interleaved: attributes.rotaryInterleaved !== 0,
            numHeads: params.kvNumHeads,
            rotaryEmbeddingDim: 0,
            scale: attributes.scale
          });
          kRotary = context.compute(createRotaryEmbeddingProgramInfo(inputs, kRotaryEmbeddingAttributes), {
            inputs,
            outputs
          })[0];
        }
        const Q = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.sequenceLength,
          params.headSize,
          attributes.doRotary ? qRotary : query,
          void 0,
          0
        );
        const K = maybeTransposeToBNSH(context, attributes.doRotary ? kRotary : key, params);
        const V = maybeTransposeToBNSH(context, value, params);
        applyAttention(
          context,
          Q,
          K,
          V,
          void 0,
          void 0,
          pastKey,
          pastValue,
          void 0,
          params,
          seqLens,
          totalSequenceLengthInput
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/instance-norm.ts
  var computeChannelScaleShift, createInstanceNormProgramInfo, createInstanceNormNHWCProgramInfo, instanceNorm;
  var init_instance_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/instance-norm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_transpose();
      init_common();
      computeChannelScaleShift = (context, input, scale, bias, n, h, c, epsilon) => {
        const components = getMaxComponents(h);
        const f32Type = components === 1 ? "f32" : `vec${components}f`;
        const wgType = components === 1 ? "vec2f" : `mat2x${components}f`;
        const unitsOfWork = n * c;
        let workgroupSize = 64;
        if (unitsOfWork === 1) {
          workgroupSize = 256;
        }
        const inputShape = [n, c, h / components];
        const outputShape = [n, c, 2];
        const inputDependencies = ["rank", "type", "type"];
        const programUniforms = [];
        programUniforms.push(...createTensorShapeVariables(inputShape, outputShape));
        const getShaderSource = (shaderHelper) => {
          const x = inputVariable("x", input.dataType, 3, components);
          const s = inputVariable("scale", scale.dataType, scale.dims);
          const b = inputVariable("bias", bias.dataType, bias.dims);
          const output = outputVariable("output", 1 /* float */, 3, 2);
          const variables = [x, s, b, output];
          return `
  var<workgroup> workgroup_shared : array<${wgType}, ${workgroupSize}>;
  const workgroup_size = ${workgroupSize}u;
  ${shaderHelper.declareVariables(...variables)}
  ${shaderHelper.mainStart(workgroupSize)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${f32Type}(0);
    var squared_sum = ${f32Type}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${f32Type}(${x.get("batch", "channel", "h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${wgType}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${sumVector("workgroup_shared[0][0]", components)} / f32(hight * ${components});
      let squared_sum_final = ${sumVector("workgroup_shared[0][1]", components)} / f32(hight * ${components});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${epsilon}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`;
        };
        return context.compute(
          {
            name: "InstanceNormComputeChannelScaleShift",
            // TODO: use epsilon as uniform. Currently epsilon as uniform fails test_instancenorm_epsilon.
            shaderCache: { hint: `${components};${epsilon};${workgroupSize}`, inputDependencies },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: 1 /* float */ }],
              dispatchGroup: { x: unitsOfWork },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [input, scale, bias], outputs: [-1] }
        )[0];
      };
      createInstanceNormProgramInfo = (context, inputs, attributes) => {
        const xShape = inputs[0].dims;
        const outputShape = xShape;
        const axis = 2;
        const N = xShape[0];
        const C = xShape[1];
        const H = ShapeUtil.sizeFromDimension(xShape, axis);
        const components = getMaxComponents(H);
        const outputSize = ShapeUtil.size(outputShape) / components;
        const channelScaleShift = computeChannelScaleShift(
          context,
          inputs[0],
          inputs[1],
          inputs[2],
          N,
          H,
          C,
          attributes.epsilon
        );
        const inputShape = [N, C, H / components];
        const scaleShape = [N, C];
        const inputDependencies = ["type", "none"];
        const getShaderSource = (shaderHelper) => {
          const x = inputVariable("x", inputs[0].dataType, inputShape.length, components);
          const scale = inputVariable("scale_shift", 1 /* float */, scaleShape.length, 2);
          const output = outputVariable("output", inputs[0].dataType, inputShape.length, components);
          const variables = [x, scale, output];
          return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(...variables)}
  ${shaderHelper.mainStart()}
  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${output.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${scale.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${x.getByOffset("global_idx")} * ${output.type.value}(scale_shift.x) + ${output.type.value}(scale_shift.y);
      ${output.setByOffset("global_idx", "value")};
  }`;
        };
        context.compute(
          {
            name: "InstanceNormalization",
            shaderCache: { hint: `${components}`, inputDependencies },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms: [
                { type: 12 /* uint32 */, data: outputSize },
                ...createTensorShapeVariables(inputShape, scaleShape, inputShape)
              ]
            }),
            getShaderSource
          },
          { inputs: [inputs[0], channelScaleShift] }
        );
      };
      createInstanceNormNHWCProgramInfo = (context, inputs, attributes) => {
        const xShape = inputs[0].dims;
        const outputShape = xShape;
        const N = xShape[0];
        const C = xShape[xShape.length - 1];
        const H = ShapeUtil.sizeFromDimension(xShape, 1) / C;
        const components = getMaxComponents(C);
        const outputSize = ShapeUtil.size(outputShape) / components;
        const programUniforms = [
          { type: 12 /* uint32 */, data: H },
          { type: 12 /* uint32 */, data: Math.floor(C / components) }
        ];
        const inputDependencies = ["type", "type"];
        let needTranspose = false;
        const transposedXPerm = [0, xShape.length - 1];
        for (let i = 0; i < xShape.length - 2; i++) {
          needTranspose = needTranspose || xShape[i + 1] !== 1;
          transposedXPerm.push(i + 1);
        }
        needTranspose = needTranspose && xShape[xShape.length - 1] !== 1;
        const transposedX = needTranspose ? context.compute(createTransposeProgramInfo(context.inputs[0], transposedXPerm), {
          inputs: [context.inputs[0]],
          outputs: [-1]
        })[0] : context.inputs[0].reshape(Array.from({ length: xShape.length }, (_, i) => xShape[transposedXPerm[i]]));
        const channelScaleShift = computeChannelScaleShift(
          context,
          transposedX,
          inputs[1],
          inputs[2],
          N,
          H,
          C,
          attributes.epsilon
        );
        const getShaderSource = (shaderHelper) => {
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const scaleType = components === 1 ? "vec2f" : `mat${components}x2f`;
          const scaleData = (num) => {
            const index = num === 0 ? "x" : "y";
            const f32Type = components === 1 ? "f32" : `vec${components}f`;
            switch (components) {
              case 1:
                return `${dataType}(${f32Type}(scale.${index}))`;
              case 2:
                return `vec2<${dataType}>(${f32Type}(scale[0].${index}, scale[1].${index}))`;
              case 4:
                return `vec4<${dataType}>(${f32Type}(scale[0].${index}, scale[1].${index}, scale[2].${index}, scale[3].${index}))`;
              default:
                throw new Error(`Not supported compoents ${components}`);
            }
          };
          const inputHelper = inputVariable("input", inputs[0].dataType, inputs[0].dims, components);
          const outputHelper = outputVariable("output", inputs[0].dataType, outputShape, components);
          return `
  @group(0) @binding(0) var<storage, read> input : array<${inputHelper.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${scaleType}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${outputHelper.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${shaderHelper.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${scaleData(0)}, ${scaleData(1)});
  }`;
        };
        context.compute(
          {
            name: "InstanceNormalizationNHWC",
            shaderCache: { hint: `${components}`, inputDependencies },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [inputs[0], channelScaleShift] }
        );
      };
      instanceNorm = (context, attributes) => {
        if (attributes.format === "NHWC") {
          createInstanceNormNHWCProgramInfo(context, context.inputs, attributes);
        } else {
          createInstanceNormProgramInfo(context, context.inputs, attributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/layer-norm.ts
  var validateInputs21, createLayerNormProgramInfo, layerNorm;
  var init_layer_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/layer-norm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs21 = (inputs) => {
        if (!inputs || inputs.length < 2) {
          throw new Error("layerNorm requires at least 2 inputs.");
        }
      };
      createLayerNormProgramInfo = (inputs, attributes, outputCount) => {
        const simplified = attributes.simplified;
        const xShape = inputs[0].dims;
        const scale = inputs[1];
        const bias = !simplified && inputs[2];
        const outputShape = xShape;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, xShape.length);
        const normCount = ShapeUtil.sizeToDimension(xShape, axis);
        const normSize = ShapeUtil.sizeFromDimension(xShape, axis);
        const scaleSize = ShapeUtil.size(scale.dims);
        const biasSize = bias ? ShapeUtil.size(bias.dims) : 0;
        if (scaleSize !== normSize || bias && biasSize !== normSize) {
          throw new Error(`Size of X.shape()[axis:] == ${normSize}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${scaleSize} and bias size of ${biasSize}`);
        }
        const meanInvStdDevDim = [];
        for (let i = 0; i < xShape.length; ++i) {
          if (i < axis) {
            meanInvStdDevDim.push(xShape[i]);
          } else {
            meanInvStdDevDim.push(1);
          }
        }
        const components = getMaxComponents(normSize);
        const inputDependencies = ["type", "type"];
        const programUniforms = [
          { type: 12 /* uint32 */, data: normCount },
          { type: 1 /* float */, data: normSize },
          { type: 12 /* uint32 */, data: Math.floor(normSize / components) },
          { type: 1 /* float */, data: attributes.epsilon }
        ];
        if (bias) {
          inputDependencies.push("type");
        }
        const hasMeanDataOutput = outputCount > 1;
        const hasInvStdOutput = outputCount > 2;
        const getShaderSource = (shaderHelper) => {
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const variables = [
            inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
            inputVariable("scale", scale.dataType, scale.dims, components)
          ];
          if (bias) {
            variables.push(inputVariable("bias", bias.dataType, bias.dims, components));
          }
          variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
          if (hasMeanDataOutput) {
            variables.push(outputVariable("mean_data_output", 1 /* float */, meanInvStdDevDim));
          }
          if (hasInvStdOutput) {
            variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
          }
          const uniforms = [
            { name: "norm_count", type: "u32" },
            { name: "norm_size", type: "f32" },
            { name: "norm_size_vectorized", type: "u32" },
            { name: "epsilon", type: "f32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${fillVector("f32", components)};
    var mean_square_vector = ${fillVector("f32", components)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${castToF32(dataType, components, "x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${sumVector("mean_vector", components)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${sumVector("mean_square_vector", components)} / uniforms.norm_size ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${castToF32(dataType, components, "x[j + offset]")};
      let f32scale = ${castToF32(dataType, components, "scale[j]")};
      output[j + offset] = ${variables[0].type.value}((f32input ${simplified ? "" : "- mean"}) * inv_std_dev * f32scale
        ${bias ? `+ ${castToF32(dataType, components, "bias[j]")}` : ""}
      );
    }

    ${hasMeanDataOutput ? "mean_data_output[global_idx] = mean" : ""};
    ${hasInvStdOutput ? "inv_std_output[global_idx] = inv_std_dev" : ""};
  }`;
        };
        const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
        if (hasMeanDataOutput) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        if (hasInvStdOutput) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        return {
          name: "LayerNormalization",
          shaderCache: { hint: `${components};${outputCount};${simplified}`, inputDependencies },
          getRunData: () => ({
            outputs,
            dispatchGroup: { x: Math.ceil(
              normCount / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      layerNorm = (context, attributes) => {
        validateInputs21(context.inputs);
        context.compute(createLayerNormProgramInfo(context.inputs, attributes, context.outputCount));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/matmul.ts
  var validateInputs22, matMul;
  var init_matmul = __esm({
    "web/lib/wasm/jsep/webgpu/ops/matmul.ts"() {
      "use strict";
      init_util();
      init_matmul_shaders();
      init_matmul_packed_webgpu();
      validateInputs22 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("MatMul requires 2 inputs.");
        }
        if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {
          throw new Error("shared dimension does not match.");
        }
      };
      matMul = (context) => {
        validateInputs22(context.inputs);
        const outputShape = BroadcastUtil.calcShape(context.inputs[0].dims, context.inputs[1].dims, true);
        if (!outputShape) {
          throw new Error("Can't use matmul on the given tensors");
        }
        const N = outputShape[outputShape.length - 1];
        const K = context.inputs[0].dims[context.inputs[0].dims.length - 1];
        if (N < 8 && K < 8) {
          context.compute(createNaiveMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
        } else {
          const M = outputShape[outputShape.length - 2];
          const batchA = ShapeUtil.size(context.inputs[0].dims.slice(0, -2));
          const batchB = ShapeUtil.size(context.inputs[1].dims.slice(0, -2));
          if (batchA !== 1 && M === 1 && batchB === 1) {
            const reshapedA = context.inputs[0].reshape([1, batchA, K]);
            const reshapedB = context.inputs[1].reshape([1, K, N]);
            const matmulOutputShape = [1, batchA, N];
            const matmulInputs = [reshapedA, reshapedB];
            context.compute(createMatmulProgramInfo(matmulInputs, { activation: "" }, outputShape, matmulOutputShape), {
              inputs: matmulInputs
            });
          } else {
            context.compute(createMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
          }
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts
  var validateInputs23, createMatMulNBitsProgramInfo, createMatMulNBitsBlockSize32ProgramInfo, matMulNBits, parseMatMulNBitsAttributes;
  var init_matmulnbits = __esm({
    "web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs23 = (inputs, attributes) => {
        if (inputs.length < 3 || inputs.length > 4) {
          throw new Error("MatMulNBits requires 3 or 4 inputs");
        }
        const a = inputs[0];
        const aRank = a.dims.length;
        if (a.dims[aRank - 1] !== attributes.k) {
          throw new Error("The last dim of input shape does not match the k value");
        }
        const nBlocksPerCol = Math.floor((attributes.k + attributes.blockSize - 1) / attributes.blockSize);
        const blobSize = attributes.blockSize / 8 * attributes.bits;
        const b = inputs[1];
        if (!ShapeUtil.areEqual(b.dims, [attributes.n, nBlocksPerCol, blobSize])) {
          throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");
        }
        const scales = inputs[2];
        const scalesShape = scales.dims;
        if (ShapeUtil.size(scalesShape) !== attributes.n * nBlocksPerCol) {
          throw new Error("scales input size error.");
        }
        if (inputs.length === 4) {
          const zeroPoints = inputs[3];
          const zeroPointsShape = zeroPoints.dims;
          const expectedZeroPointsSize = attributes.n * (attributes.bits === 8 ? nBlocksPerCol : Math.floor((nBlocksPerCol * attributes.bits + 7) / 8));
          if (ShapeUtil.size(zeroPointsShape) !== expectedZeroPointsSize) {
            throw new Error("zeroPoints input size error.");
          }
        }
      };
      createMatMulNBitsProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const aRank = inputShape.length;
        const dimAOuter = inputShape[aRank - 2];
        const dimInner = attributes.k;
        const dimBOuter = attributes.n;
        const batchDims = inputShape.slice(0, aRank - 2);
        const batchSize = ShapeUtil.size(batchDims);
        const blobSize = inputs[1].dims[2];
        const blobSizeInWords = blobSize / 4;
        const dataType = inputs[0].dataType;
        const aComponents = getMaxComponents(attributes.k);
        const bComponents = getMaxComponents(blobSizeInWords);
        const components = getMaxComponents(dimBOuter);
        const outputShape = batchDims.concat([dimAOuter, dimBOuter]);
        const outputNumber = dimAOuter > 1 && dimBOuter / components % 2 === 0 ? 2 : 1;
        const dispatchSize = ShapeUtil.size(outputShape) / components / outputNumber;
        const workgroupSize = 64;
        const programUniforms = [];
        const inputShapeTemp = [batchSize, dimAOuter, dimInner / aComponents];
        const bShape = ShapeUtil.convertShape(inputs[1].dims).slice();
        bShape.splice(-1, 1, blobSizeInWords / bComponents);
        programUniforms.push(...createTensorShapeVariables(inputShapeTemp));
        programUniforms.push(...createTensorShapeVariables(bShape));
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        if (inputs.length === 4) {
          programUniforms.push(...createTensorShapeVariables(ShapeUtil.convertShape(inputs[3].dims)));
        }
        const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
        programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
        const getShaderSource = (shaderHelper) => {
          const inputRank = inputShapeTemp.length;
          const a = inputVariable("a", inputs[0].dataType, inputRank, aComponents);
          const b = inputVariable("b", 12 /* uint32 */, bShape.length, bComponents);
          const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
          const inputVariables = [a, b, scales];
          const zeroPoints = inputs.length === 4 ? inputVariable("zero_points", 12 /* uint32 */, inputs[3].dims.length) : void 0;
          if (zeroPoints) {
            inputVariables.push(zeroPoints);
          }
          const outputRank = outputShapeTemp.length;
          const output = outputVariable("output", inputs[0].dataType, outputRank, components);
          const dataType2 = tensorTypeToWsglStorageType(inputs[0].dataType);
          const qDqDataType = (() => {
            switch (aComponents) {
              case 1:
                return `array<${dataType2}, 8>`;
              case 2:
                return `mat4x2<${dataType2}>`;
              case 4:
                return `mat2x4<${dataType2}>`;
              default:
                throw new Error(`${aComponents}-component is not supported.`);
            }
          })();
          const processOneWord = () => {
            let calcStr = `
          // reuse a data
            var input_offset = ${a.indicesToOffset(`${a.type.indices}(batch, row, word_offset)`)};
            var a_data: ${qDqDataType};
            for (var j: u32 = 0; j < ${8 / aComponents}; j++) {
              a_data[j] = ${a.getByOffset("input_offset")};
              input_offset++;
            }
          `;
            for (let c = 0; c < components * outputNumber; c++) {
              calcStr += `
            b_value = ${bComponents === 1 ? `b${c}_data` : `b${c}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${qDqDataType}(${Array.from(
                { length: 4 },
                (_, i) => `${dataType2}(b_value_lower[${i}]), ${dataType2}(b_value_upper[${i}])`
              ).join(", ")});
            b_dequantized_values = ${(() => {
                if (aComponents === 1) {
                  return `${qDqDataType}(${Array.from(
                    { length: 8 },
                    (_, i) => `(b_quantized_values[${i}] - ${zeroPoints ? `zero_point${c}` : "zero_point"}) * scale${c}`
                  ).join(", ")});`;
                } else {
                  return `(b_quantized_values - ${qDqDataType}(${Array(8).fill(`${zeroPoints ? `zero_point${c}` : "zero_point"}`).join(",")})) * scale${c};`;
                }
              })()};
            workgroup_shared[local_id.x * ${outputNumber} + ${Math.floor(c / components)}]${components > 1 ? `[${c % components}]` : ""} += ${Array.from(
                { length: 8 / aComponents },
                (_, i) => `${aComponents === 1 ? `a_data[${i}] * b_dequantized_values[${i}]` : `dot(a_data[${i}], b_dequantized_values[${i}])`}`
              ).join(" + ")};
          `;
            }
            return calcStr;
          };
          const prepareScaleAndZeroPoint = () => {
            let calcStr = `
            var col_index = col * ${components};
            ${zeroPoints ? `
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;` : `
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${dataType2}(${8});`}
            `;
            for (let c = 0; c < components * outputNumber; c++) {
              calcStr += `
            let scale${c} = ${scales.getByOffset(`col_index * nBlocksPerCol + block`)};
            ${zeroPoints ? `
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${zeroPoints.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${c} = ${dataType2}((zero_point_word) & 0xFu);` : ""}
            col_index += 1;`;
            }
            return calcStr;
          };
          const prepareBData = () => {
            let calcStr = `col_index = col * ${components};`;
            for (let c = 0; c < components * outputNumber; c++) {
              calcStr += `
            let b${c}_data = ${b.getByIndices(`${b.type.indices}(col_index, block, word)`)};
            col_index += 1;`;
            }
            calcStr += `
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${qDqDataType};
            var b_dequantized_values: ${qDqDataType};`;
            return calcStr;
          };
          return `
        var<workgroup> workgroup_shared: array<${output.type.value}, ${outputNumber * workgroupSize}>;
        ${shaderHelper.declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart([workgroupSize, 1, 1])}
          let output_indices = ${output.offsetToIndices(`(global_idx / ${workgroupSize}) * ${outputNumber}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${workgroupSize}) {
            //process one block
            var word_offset: u32 = block * ${attributes.blockSize / aComponents};
            ${prepareScaleAndZeroPoint()}
            for (var word: u32 = 0; word < ${blobSizeInWords}; word += ${bComponents}) {
              ${prepareBData()}
              for (var i: u32 = 0; i < ${bComponents}; i++) {
                ${processOneWord()}
                word_offset += ${8 / aComponents};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${outputNumber}) {
            var output_value: ${output.type.value} = ${output.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${workgroupSize}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${outputNumber};
            }
            ${output.setByIndices(`${output.type.indices}(batch, row, col + local_id.x)`, "output_value")};
          }
        }`;
        };
        return {
          name: "MatMulNBits",
          shaderCache: {
            hint: `${attributes.blockSize};${attributes.bits};${aComponents};${bComponents};${components};${outputNumber};${workgroupSize}`,
            inputDependencies: Array(inputs.length).fill("rank")
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: dispatchSize },
            programUniforms
          }),
          getShaderSource
        };
      };
      createMatMulNBitsBlockSize32ProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const aRank = inputShape.length;
        const dimAOuter = inputShape[aRank - 2];
        const dimInner = attributes.k;
        const dimBOuter = attributes.n;
        const batchDims = inputShape.slice(0, aRank - 2);
        const batchSize = ShapeUtil.size(batchDims);
        const blobSize = inputs[1].dims[2];
        const blobSizeInWords = blobSize / 4;
        const dataType = inputs[0].dataType;
        const aComponents = getMaxComponents(attributes.k);
        const bComponents = getMaxComponents(blobSizeInWords);
        const outputShape = batchDims.concat([dimAOuter, dimBOuter]);
        const workgroupSize = 128;
        const workgroupY = dimBOuter % 8 === 0 ? 8 : dimBOuter % 4 === 0 ? 4 : 1;
        const workgroupX = workgroupSize / workgroupY;
        const tileSize = workgroupX * bComponents * 8;
        const aLengthPerTile = tileSize / aComponents;
        const blocksPerTile = tileSize / attributes.blockSize;
        const dispatchSize = ShapeUtil.size(outputShape) / workgroupY;
        const programUniforms = [];
        const inputShapeTemp = [batchSize, dimAOuter, dimInner / aComponents];
        const bShape = ShapeUtil.convertShape(inputs[1].dims).slice();
        bShape.splice(-1, 1, blobSizeInWords / bComponents);
        programUniforms.push(...createTensorShapeVariables(inputShapeTemp));
        programUniforms.push(...createTensorShapeVariables(bShape));
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        if (inputs.length === 4) {
          programUniforms.push(...createTensorShapeVariables(ShapeUtil.convertShape(inputs[3].dims)));
        }
        const outputShapeTemp = [batchSize, dimAOuter, dimBOuter];
        programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
        const getShaderSource = (shaderHelper) => {
          const inputRank = inputShapeTemp.length;
          const a = inputVariable("a", inputs[0].dataType, inputRank, aComponents);
          const b = inputVariable("b", 12 /* uint32 */, bShape.length, bComponents);
          const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
          const inputVariables = [a, b, scales];
          const zeroPoints = inputs.length === 4 ? inputVariable("zero_points", 12 /* uint32 */, inputs[3].dims.length) : void 0;
          if (zeroPoints) {
            inputVariables.push(zeroPoints);
          }
          const outputRank = outputShapeTemp.length;
          const output = outputVariable("output", inputs[0].dataType, outputRank);
          const dataType2 = tensorTypeToWsglStorageType(inputs[0].dataType);
          const readA = () => {
            switch (aComponents) {
              case 1:
                return `
          let a_data0 = vec4<${dataType2}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${dataType2}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;
              case 2:
                return `
          let a_data0 = vec4<${dataType2}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${dataType2}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;
              case 4:
                return `
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;
              default:
                throw new Error(`${aComponents}-component is not supported.`);
            }
          };
          return `
        var<workgroup> sub_a: array<${a.type.value}, ${aLengthPerTile}>;
        var<workgroup> inter_results: array<array<${output.type.value}, ${workgroupX}>, ${workgroupY}>;
        ${shaderHelper.declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart([workgroupX, workgroupY, 1])}
          let output_indices = ${output.offsetToIndices(`workgroup_index * ${workgroupY}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${blocksPerTile} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${aLengthPerTile};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${aLengthPerTile}; a_offset += ${workgroupSize})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${a.getByIndices(`${a.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${a.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${blocksPerTile} + local_id.x;
            ${zeroPoints ? `
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${zeroPoints.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${dataType2}((zero_point_word) & 0xFu);` : `
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${dataType2}(${8});`}
            let scale = ${scales.getByOffset(`b_row * n_blocks_per_col + block`)};
            let b_data = ${b.getByIndices(`${b.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${attributes.blockSize / aComponents};
            for (var i: u32 = 0; i < ${bComponents}; i++) {
              ${readA()}
              let b_value = ${bComponents === 1 ? `b_data` : `b_data[i]`};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${dataType2}>(${Array.from(
            { length: 4 },
            (_, i) => `${dataType2}(b_value_lower[${i}]), ${dataType2}(b_value_upper[${i}])`
          ).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${dataType2}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from(
            { length: 2 },
            (_, i) => `${`dot(a_data${i}, b_dequantized_values[${i}])`}`
          ).join(" + ")};
              word_offset += ${8 / aComponents};
            }
            workgroupBarrier();
          }

          if (local_idx < ${workgroupY}) {
            var output_value: ${output.type.value} = ${output.type.value}(0);
            for (var b = 0u; b < ${workgroupX}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${output.setByIndices(`${output.type.indices}(batch, row, col + local_idx)`, "output_value")}
            }
          }
        }`;
        };
        return {
          name: "BlockwiseMatMulNBits32",
          shaderCache: {
            hint: `${attributes.blockSize};${aComponents};${bComponents};${workgroupX};${workgroupY}`,
            inputDependencies: Array(inputs.length).fill("rank")
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: dispatchSize },
            programUniforms
          }),
          getShaderSource
        };
      };
      matMulNBits = (context, attributes) => {
        validateInputs23(context.inputs, attributes);
        if (attributes.blockSize === 32 && context.adapterInfo.isVendor("intel") && context.adapterInfo.isArchitecture("gen-12lp")) {
          context.compute(createMatMulNBitsBlockSize32ProgramInfo(context.inputs, attributes));
        } else {
          context.compute(createMatMulNBitsProgramInfo(context.inputs, attributes));
        }
      };
      parseMatMulNBitsAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/pad.ts
  var validateInputs24, getPadConstant, getPadReflect, getPadEdge, getPadWrap, getPadSnippet, createPadProgramInfo, createPadAttributesFromInputs, pad;
  var init_pad = __esm({
    "web/lib/wasm/jsep/webgpu/ops/pad.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs24 = (inputs) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("Too few inputs");
        }
        if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */) {
          throw new Error("Input type must be float or float16.");
        }
        if (inputs.length >= 2) {
          let validPads = inputs[0].dims.length * 2 === inputs[1].dims[0];
          if (inputs.length === 4) {
            validPads = inputs[3].dims[0] * 2 === inputs[1].dims[0];
          }
          if (!validPads) {
            throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].");
          }
        }
      };
      getPadConstant = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
            k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
              break;
            }
            offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
        `;
        }
        return `
          value = ${output.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${block}
            value = x[offset];
          }
      `;
      };
      getPadReflect = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
        }
        return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
      };
      getPadEdge = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k = i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1;
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
        }
        return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
      };
      getPadWrap = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0)  {
                  k += i32(${getElementAt("uniforms.x_shape", i, inputRank)}]);
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k -= i32(${getElementAt("uniforms.x_shape", i, inputRank)});
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
        }
        return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
      };
      getPadSnippet = (output, inputRank, attributes) => {
        switch (attributes.mode) {
          case 0:
            return getPadConstant(output, inputRank, attributes.pads.length);
          case 1:
            return getPadReflect(output, inputRank, attributes.pads.length);
          case 2:
            return getPadEdge(output, inputRank, attributes.pads.length);
          case 3:
            return getPadWrap(output, inputRank, attributes.pads.length);
          default:
            throw new Error("Invalid mode");
        }
      };
      createPadProgramInfo = (inputs, attributes) => {
        const outputShape = ShapeUtil.padShape(inputs[0].dims.slice(), attributes.pads);
        const inputDims = inputs[0].dims;
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: attributes.pads }
        ];
        const isValueFromInput = inputs.length >= 3 && inputs[2].data;
        if (attributes.mode === 0) {
          programUniforms.push({ type: isValueFromInput ? inputs[2].dataType : 1 /* float */, data: attributes.value });
        }
        programUniforms.push(...createTensorShapeVariables(inputs[0].dims, outputShape));
        const inputDependencies = ["rank"];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", inputs[0].dataType, outputShape.length);
          const input = inputVariable("x", inputs[0].dataType, inputDims.length);
          const dataType = input.type.value;
          const padSnippet = getPadSnippet(output, inputDims.length, attributes);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "pads", type: "i32", length: attributes.pads.length }
          ];
          if (attributes.mode === 0) {
            uniforms.push({ name: "constant_value", type: isValueFromInput ? dataType : "f32" });
          }
          return `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${output.offsetToIndices("global_idx")};

            var value = ${dataType}(0);
            ${padSnippet}
            output[global_idx] = value;
        }`;
        };
        return {
          name: "Pad",
          shaderCache: { hint: `${attributes.mode}${isValueFromInput}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              ShapeUtil.size(outputShape) / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      createPadAttributesFromInputs = (inputs, attributes) => {
        if (inputs.length > 1) {
          const bigInt64Pads = inputs[1].getBigInt64Array();
          const value = inputs.length >= 3 && inputs[2].data ? inputs[2].dataType === 10 /* float16 */ ? inputs[2].getUint16Array()[0] : inputs[2].getFloat32Array()[0] : 0;
          const inputRank = inputs[0].dims.length;
          const updatePads = new Int32Array(2 * inputRank).fill(0);
          if (inputs.length >= 4) {
            const axes = inputs[3].getBigInt64Array();
            for (let i = 0; i < axes.length; i++) {
              updatePads[Number(axes[i])] = Number(bigInt64Pads[i]);
              updatePads[Number(axes[i]) + inputRank] = Number(bigInt64Pads[i + axes.length]);
            }
          } else {
            bigInt64Pads.forEach((v, i) => updatePads[Number(i)] = Number(v));
          }
          const pads = [];
          updatePads.forEach((v) => pads.push(v));
          return { mode: attributes.mode, value, pads };
        } else {
          return attributes;
        }
      };
      pad = (context, attributes) => {
        validateInputs24(context.inputs);
        const updatedAttributes = createPadAttributesFromInputs(context.inputs, attributes);
        context.compute(createPadProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/pool.ts
  var validateInputs25, getAdjustedPoolAttributesAndOutputShape, getUniformAndPadInfo, generatePoolingCode, createShaderKeyFromAttributes, createAveragePoolShaderKeyFromAttributes, createMaxPoolShaderKeyFromAttributes, parsePoolCommonAttributes, createAveragePoolProgramInfo, parseAveragePoolAttributes, averagePool, globalPoolAttributes, parseGlobalAveragePoolAttributes, globalAveragePool, createMaxPoolProgramInfo, maxPool, parseMaxPoolAttributes, parseGlobalMaxPoolAttributes, globalMaxPool;
  var init_pool = __esm({
    "web/lib/wasm/jsep/webgpu/ops/pool.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_util();
      init_common();
      validateInputs25 = (inputs) => {
        if (env2.webgpu.validateInputContent && (!inputs || inputs.length !== 1)) {
          throw new Error("Pool ops requires 1 input.");
        }
      };
      getAdjustedPoolAttributesAndOutputShape = (input, attributes, isGlobalOperator) => {
        const isChannelsLast = attributes.format === "NHWC";
        const inputShapeAsChannelFirst = input.dims.slice();
        if (isChannelsLast) {
          inputShapeAsChannelFirst.splice(1, 0, inputShapeAsChannelFirst.pop());
        }
        const hasDilations = Object.hasOwnProperty.call(attributes, "dilations");
        const kernelShape = attributes.kernelShape.slice();
        const strides = attributes.strides.slice();
        const dilations = hasDilations ? attributes.dilations.slice() : [];
        const pads = attributes.pads.slice();
        PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShapeAsChannelFirst, kernelShape, strides, dilations, pads);
        const outputShapeAsChannelFirst = PoolConvUtil.computePoolOutputShape(
          isGlobalOperator,
          inputShapeAsChannelFirst,
          strides,
          dilations,
          kernelShape,
          pads,
          attributes.autoPad
        );
        const newAttributes = Object.assign({}, attributes);
        if (hasDilations) {
          Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });
        } else {
          Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });
        }
        const outputShapeAsChannelLast = outputShapeAsChannelFirst.slice();
        outputShapeAsChannelLast.push(outputShapeAsChannelLast.splice(1, 1)[0]);
        return [newAttributes, isChannelsLast ? outputShapeAsChannelLast : outputShapeAsChannelFirst];
      };
      getUniformAndPadInfo = (outputShape, attributes) => {
        const isChannelsLast = attributes.format === "NHWC";
        const outputSize = ShapeUtil.size(outputShape);
        const kernelSize = ShapeUtil.size(attributes.kernelShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: kernelSize }
        ];
        const uniforms = [
          { name: "outputSize", type: "u32" },
          { name: "kernelSize", type: "u32" }
        ];
        if (attributes.kernelShape.length <= 2) {
          const kw = attributes.kernelShape[attributes.kernelShape.length - 1];
          const sw = attributes.strides[attributes.strides.length - 1];
          const pwStart = attributes.pads[attributes.pads.length / 2 - 1];
          const pwEnd = attributes.pads[attributes.pads.length - 1];
          const pwStartEndNotZero = !!(pwStart + pwEnd);
          programUniforms.push(
            { type: 12 /* uint32 */, data: kw },
            { type: 12 /* uint32 */, data: sw },
            { type: 12 /* uint32 */, data: pwStart },
            { type: 12 /* uint32 */, data: pwEnd }
          );
          uniforms.push(
            { name: "kw", type: "u32" },
            { name: "sw", type: "u32" },
            { name: "pwStart", type: "u32" },
            { name: "pwEnd", type: "u32" }
          );
          let phStartEndNotZero = false;
          if (attributes.kernelShape.length === 2) {
            const kh = attributes.kernelShape[attributes.kernelShape.length - 2];
            const sh = attributes.strides[attributes.strides.length - 2];
            const phStart = attributes.pads[attributes.pads.length / 2 - 2];
            const phEnd = attributes.pads[attributes.pads.length - 2];
            phStartEndNotZero = !!(phStart + phEnd);
            programUniforms.push(
              { type: 12 /* uint32 */, data: kh },
              { type: 12 /* uint32 */, data: sh },
              { type: 12 /* uint32 */, data: phStart },
              { type: 12 /* uint32 */, data: phEnd }
            );
            uniforms.push(
              { name: "kh", type: "u32" },
              { name: "sh", type: "u32" },
              { name: "phStart", type: "u32" },
              { name: "phEnd", type: "u32" }
            );
          }
          return [programUniforms, uniforms, true, pwStartEndNotZero, phStartEndNotZero];
        } else {
          if (isChannelsLast) {
            throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
          }
          const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);
          programUniforms.push(
            { type: 12 /* uint32 */, data: kernelStrides },
            { type: 12 /* uint32 */, data: attributes.pads },
            { type: 12 /* uint32 */, data: attributes.strides }
          );
          uniforms.push(
            { name: "kernelStrides", type: "u32", length: kernelStrides.length },
            { name: "pads", type: "u32", length: attributes.pads.length },
            { name: "strides", type: "u32", length: attributes.strides.length }
          );
          const hasPads = attributes.pads.reduce((sum, cur) => sum + cur);
          return [programUniforms, uniforms, !!hasPads, false, false];
        }
      };
      generatePoolingCode = (shaderHelper, x, rank, outputShapeRank, attributes, op1, op2, start, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero) => {
        const isChannelsLast = attributes.format === "NHWC";
        const dataType = x.type.value;
        const output = outputVariable("output", x.type.tensor, outputShapeRank);
        if (attributes.kernelShape.length <= 2) {
          let codeW = "";
          let codeH = "";
          let codeHEnd = "";
          const dimIdxW = rank - (isChannelsLast ? 2 : 1);
          if (pwStartEndNotZero) {
            codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${dimIdxW}] < 0 || xIndices[${dimIdxW}]
                      >= uniforms.x_shape[${dimIdxW}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
          } else {
            codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
          }
          if (attributes.kernelShape.length === 2) {
            const dimIdxH = rank - (isChannelsLast ? 3 : 2);
            if (phStartEndNotZero) {
              codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${dimIdxH}] < 0 || xIndices[${dimIdxH}] >= uniforms.x_shape[${dimIdxH}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `;
            } else {
              codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                `;
            }
            codeHEnd = `
              }
            `;
          }
          const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var value = ${dataType}(${start});
              var pad = 0;
              ${codeH}
              ${codeW}
              ${codeHEnd}
              ${op2}

              output[global_idx] = value;
            }`;
          return poolingCode;
        } else {
          if (isChannelsLast) {
            throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
          }
          const stridesRank = attributes.kernelShape.length;
          const padsRank = attributes.pads.length;
          let padCode = "";
          if (hasPads) {
            padCode = `
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${x.indicesToOffset("xIndices")}];
                ${op1}
              }`;
          } else {
            padCode = `
              }
              let x_val = x[${x.indicesToOffset("xIndices")}];
              ${op1}
            `;
          }
          const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var offsets: array<u32, ${stridesRank}>;

              var value = ${dataType}(${start});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${stridesRank - 1}u; j++) {
                  offsets[j] = offset / ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                  offset -= offsets[j] * ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                }
                offsets[${stridesRank - 1}] = offset;

                isPad = false;
                for (var j = ${rank - stridesRank}u; j < ${rank}u; j++) {
                  xIndices[j] = indices[j] * ${getElementAt(
            "uniforms.strides",
            `j - ${rank - stridesRank}u`,
            stridesRank
          )}
                    + offsets[j - ${rank - stridesRank}u] - ${getElementAt("uniforms.pads", "j - 2u", padsRank)};
                  ${padCode}
              }
              ${op2}

              output[global_idx] = value;
            }`;
          return poolingCode;
        }
      };
      createShaderKeyFromAttributes = (attributes) => `${attributes.format};${attributes.ceilMode};${attributes.autoPad};${attributes.kernelShape.length}`;
      createAveragePoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.countIncludePad}`;
      createMaxPoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.storageOrder};${attributes.dilations}`;
      parsePoolCommonAttributes = (attributes) => ({
        format: attributes.format,
        autoPad: ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad],
        ceilMode: attributes.ceil_mode,
        kernelShape: attributes.kernel_shape,
        strides: attributes.strides,
        pads: attributes.pads
      });
      createAveragePoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
        const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
          input,
          attributes,
          isGlobalOperator
        );
        const x = inputVariable("x", input.dataType, input.dims.length);
        const dataType = x.type.value;
        const op1 = "value += x_val;";
        let op2 = "";
        if (adjustedAttributes.countIncludePad) {
          op2 += `value /= ${dataType}(uniforms.kernelSize);`;
        } else {
          op2 += `value /= ${dataType}(i32(uniforms.kernelSize) - pad);`;
        }
        const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(
          outputShape,
          adjustedAttributes
        );
        programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
        const inputDependencies = ["rank"];
        return {
          name,
          shaderCache: {
            hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`,
            inputDependencies
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: input.dataType }],
            dispatchGroup: { x: Math.ceil(
              ShapeUtil.size(outputShape) / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource: (shaderHelper) => generatePoolingCode(
            shaderHelper,
            x,
            input.dims.length,
            outputShape.length,
            adjustedAttributes,
            op1,
            op2,
            0,
            uniforms,
            hasPads,
            pwStartEndNotZero,
            phStartEndNotZero
          )
        };
      };
      parseAveragePoolAttributes = (attributes) => {
        const countIncludePad = attributes.count_include_pad === 0 ? false : true;
        const attr = parsePoolCommonAttributes(attributes);
        if (attr.ceilMode !== 0) {
          throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
        }
        const averagePoolAttributes = { countIncludePad, ...attr, cacheKey: "" };
        return { ...averagePoolAttributes, cacheKey: createAveragePoolShaderKeyFromAttributes(averagePoolAttributes) };
      };
      averagePool = (context, attributes) => {
        validateInputs25(context.inputs);
        context.compute(createAveragePoolProgramInfo("AveragePool", context.inputs[0], false, attributes));
      };
      globalPoolAttributes = {
        autoPad: "",
        ceilMode: 0,
        countIncludePad: false,
        kernelShape: [],
        strides: [],
        pads: [],
        storageOrder: 0,
        dilations: []
      };
      parseGlobalAveragePoolAttributes = (attributes) => {
        const format = attributes.format;
        return { format, ...globalPoolAttributes, cacheKey: format };
      };
      globalAveragePool = (context, attributes) => {
        validateInputs25(context.inputs);
        context.compute(createAveragePoolProgramInfo("GlobalAveragePool", context.inputs[0], true, attributes));
      };
      createMaxPoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
        const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
          input,
          attributes,
          isGlobalOperator
        );
        const op1 = `
      value = max(x_val, value);
    `;
        const op2 = "";
        const x = inputVariable("x", input.dataType, input.dims.length);
        const inputDependencies = ["rank"];
        const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(
          outputShape,
          adjustedAttributes
        );
        programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
        return {
          name,
          shaderCache: {
            hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`,
            inputDependencies
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: input.dataType }],
            dispatchGroup: { x: Math.ceil(
              ShapeUtil.size(outputShape) / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource: (shaderHelper) => generatePoolingCode(
            shaderHelper,
            x,
            input.dims.length,
            outputShape.length,
            adjustedAttributes,
            op1,
            op2,
            input.dataType === 10 /* float16 */ ? -65504 : -1e5,
            uniforms,
            hasPads,
            pwStartEndNotZero,
            phStartEndNotZero
          )
        };
      };
      maxPool = (context, attributes) => {
        validateInputs25(context.inputs);
        context.compute(createMaxPoolProgramInfo("MaxPool", context.inputs[0], false, attributes));
      };
      parseMaxPoolAttributes = (attributes) => {
        const storageOrder = attributes.storage_order;
        const dilations = attributes.dilations;
        const attr = parsePoolCommonAttributes(attributes);
        if (storageOrder !== 0) {
          throw new Error("column major storage order is not yet supported for MaxPool");
        }
        if (attr.ceilMode !== 0) {
          throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
        }
        const maxPoolAttributes = { storageOrder, dilations, ...attr, cacheKey: "" };
        return { ...maxPoolAttributes, cacheKey: createMaxPoolShaderKeyFromAttributes(maxPoolAttributes) };
      };
      parseGlobalMaxPoolAttributes = (attributes) => {
        const format = attributes.format;
        return { format, ...globalPoolAttributes, cacheKey: format };
      };
      globalMaxPool = (context, attributes) => {
        validateInputs25(context.inputs);
        context.compute(createMaxPoolProgramInfo("GlobalMaxPool", context.inputs[0], true, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/quantize-linear.ts
  var validateInputs26, createDequantizeLinearProgramInfo, dequantizeLinear, parseDequantizeLinearAttributes;
  var init_quantize_linear = __esm({
    "web/lib/wasm/jsep/webgpu/ops/quantize-linear.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs26 = (inputs, attributes) => {
        if (inputs.length < 2 || inputs.length > 3) {
          throw new Error("DequantizeLinear requires 2 or 3 inputs.");
        }
        if (inputs.length === 3 && inputs[1].dims === inputs[2].dims) {
          throw new Error("x-scale and x-zero-point must have the same shape.");
        }
        if (inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {
          throw new Error("x and x-zero-point must have the same data type.");
        }
        if (inputs[0].dataType === 6 /* int32 */ && inputs.length > 2) {
          throw new Error("In the case of dequantizing int32 there is no zero point.");
        }
        if (inputs[1].dims.length !== 0 && inputs[1].dims.length !== 1 && inputs[1].dims.length !== inputs[0].dims.length) {
          throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");
        }
        if (inputs.length > 2) {
          if (inputs[0].dataType !== inputs[2].dataType) {
            throw new Error("x and x-zero-point must have the same data type.");
          }
          if (inputs[1].dims.length !== inputs[2].dims.length) {
            throw new Error("scale and zero-point inputs must have the same rank.");
          }
          if (!inputs[1].dims.map((d, i) => d === inputs[2].dims[i]).reduce((a, b) => a && b, true)) {
            throw new Error("scale and zero-point inputs must have the same shape.");
          }
        }
        if (attributes.blockSize > 0) {
          if (inputs[1].dims.length === 0 || inputs[1].dims.length === 1 && inputs[1].dims[0] === 1) {
            throw new Error("blockSize must be set only for block quantization.");
          }
          if (!inputs[1].dims.map((d, i) => i === attributes.axis || d === inputs[0].dims[i]).reduce((a, b) => a && b, true)) {
            throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");
          }
          if (inputs[1].dims.length !== inputs[0].dims.length) {
            throw new Error("For block qunatization the scale input rank must be the same as the x rank.");
          }
          const dI = inputs[0].dims[attributes.axis];
          const si = inputs[1].dims[attributes.axis];
          if (attributes.blockSize < Math.ceil(dI / si) || attributes.blockSize > Math.ceil(dI / (si - 1) - 1)) {
            throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].");
          }
        }
      };
      createDequantizeLinearProgramInfo = (inputs, attributes) => {
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputs[0].dims.length);
        const inputType = inputs[0].dataType;
        const isSigned = inputType === 3 /* int8 */;
        const outputShape = inputs[0].dims;
        const dataType = inputs[1].dataType;
        const outputSize = ShapeUtil.size(outputShape);
        const isPacked = inputType === 3 /* int8 */ || inputType === 2 /* uint8 */;
        const inputShape = isPacked ? [Math.ceil(ShapeUtil.size(inputs[0].dims) / 4)] : inputs[0].dims;
        const scaleShape = inputs[1].dims;
        const zeroPointInput = inputs.length > 2 ? inputs[2] : void 0;
        const zeroPointShape = zeroPointInput ? isPacked ? [Math.ceil(ShapeUtil.size(zeroPointInput.dims) / 4)] : zeroPointInput.dims : void 0;
        const perLayerQuantization = scaleShape.length === 0 || scaleShape.length === 1 && scaleShape[0] === 1;
        const perAxisQuantization = perLayerQuantization === false && scaleShape.length === 1;
        const maxComponents = getMaxComponents(outputSize);
        const useComponents = perLayerQuantization && (!isPacked || maxComponents === 4);
        const components = useComponents ? maxComponents : 1;
        const inputComponent = useComponents && !isPacked ? maxComponents : 1;
        const input = inputVariable("input", isPacked ? 12 /* uint32 */ : inputType, inputShape.length, inputComponent);
        const scale = inputVariable("scale", dataType, scaleShape.length);
        const zeroPoint = zeroPointInput ? inputVariable("zero_point", isPacked ? 12 /* uint32 */ : inputType, zeroPointShape.length) : void 0;
        const output = outputVariable("output", dataType, outputShape.length, components);
        const inputVariables = [input, scale];
        if (zeroPoint) {
          inputVariables.push(zeroPoint);
        }
        const inputShapes = [inputShape, scaleShape];
        if (zeroPointInput) {
          inputShapes.push(zeroPointShape);
        }
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize / components },
          { type: 12 /* uint32 */, data: axis },
          { type: 12 /* uint32 */, data: attributes.blockSize },
          ...createTensorShapeVariables(...inputShapes, outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "axis", type: "u32" },
            { name: "block_size", type: "u32" }
          ];
          return `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
      ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${output.offsetToIndices("global_idx")};

          // Set input x
          ${(() => {
            if (isPacked) {
              return `
            let input = ${input.getByOffset("global_idx / 4")};
            let x_vec = ${isSigned ? "unpack4xI8(input)" : "unpack4xU8(input)"};
            let x_value = ${components === 1 ? "x_vec[global_idx % 4]" : "x_vec"};`;
            } else {
              return `let x_value = ${input.getByOffset("global_idx")};`;
            }
          })()};

          // Set scale input
          ${(() => {
            if (perLayerQuantization) {
              return `let scale_value= ${scale.getByOffset("0")}`;
            } else if (perAxisQuantization) {
              return `
            let scale_index = ${output.indicesGet("output_indices", "uniforms.axis")};
            let scale_value= ${scale.getByOffset("scale_index")};`;
            } else {
              return `
            var scale_indices: ${scale.type.indices} = output_indices;
            let index = ${scale.indicesGet("scale_indices", "uniforms.axis")} / uniforms.block_size;
            ${scale.indicesSet("scale_indices", "uniforms.axis", "index")};
            let scale_value= ${scale.getByIndices("scale_indices")};`;
            }
          })()};

          // Set zero-point input
          ${(() => {
            if (zeroPoint) {
              if (perLayerQuantization) {
                if (isPacked) {
                  return `
                let zero_point_input = ${zeroPoint.getByOffset("0")};
                let zero_point_vec =  ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`;
                } else {
                  return `let zero_point_value = ${zeroPoint.getByOffset("0")}`;
                }
              } else if (perAxisQuantization) {
                if (isPacked) {
                  return `
                let zero_point_index = ${output.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_input = ${zeroPoint.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`;
                } else {
                  return `
                let zero_point_index = ${output.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_value = ${zeroPoint.getByOffset("zero_point_index")};`;
                }
              } else {
                if (isPacked) {
                  return `
                let zero_point_offset = ${scale.indicesToOffset("scale_indices")};
                let zero_point_input = ${zeroPoint.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`;
                } else {
                  return `let zero_point_value = ${zeroPoint.getByIndices("scale_indices")};`;
                }
              }
            } else {
              return `let zero_point_value = ${isPacked ? isSigned ? "i32" : "u32" : input.type.value}(0);`;
            }
          })()};
      // Compute and write output
      ${output.setByOffset("global_idx", `${output.type.value}(x_value - zero_point_value) * scale_value`)};
      }`;
        };
        return {
          name: "DequantizeLinear",
          shaderCache: {
            hint: attributes.cacheKey,
            inputDependencies: zeroPoint ? ["rank", "rank", "rank"] : ["rank", "rank"]
          },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(outputSize / components / 64), y: 1, z: 1 },
            programUniforms
          })
        };
      };
      dequantizeLinear = (context, attributes) => {
        validateInputs26(context.inputs, attributes);
        context.compute(createDequantizeLinearProgramInfo(context.inputs, attributes));
      };
      parseDequantizeLinearAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis, blockSize: attributes.blockSize });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/range.ts
  var validateInputsContent, createRangeProgramInfo, range;
  var init_range = __esm({
    "web/lib/wasm/jsep/webgpu/ops/range.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_common();
      validateInputsContent = (start, limit, delta) => {
        const sameStartLimit = start === limit;
        const increasingRangeNegativeStep = start < limit && delta < 0;
        const decreasingRangePositiveStep = start > limit && delta > 0;
        if (sameStartLimit || increasingRangeNegativeStep || decreasingRangePositiveStep) {
          throw new Error("Range these inputs' contents are invalid.");
        }
      };
      createRangeProgramInfo = (start, limit, delta, dataType) => {
        const numElements = Math.abs(Math.ceil((limit - start) / delta));
        const outputShape = [numElements];
        const outputSize = numElements;
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: dataType, data: start },
          { type: dataType, data: delta },
          ...createTensorShapeVariables(outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", dataType, outputShape.length);
          const wgslType = output.type.value;
          const uniforms = [
            { name: "outputSize", type: "u32" },
            { name: "start", type: wgslType },
            { name: "delta", type: wgslType }
          ];
          return `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${wgslType}(global_idx) * uniforms.delta;
      }`;
        };
        return {
          name: "Range",
          shaderCache: { hint: `${dataType}` },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      range = (context) => {
        let start = 0;
        let limit = 0;
        let delta = 0;
        if (context.inputs[0].dataType === 6 /* int32 */) {
          start = context.inputs[0].getInt32Array()[0];
          limit = context.inputs[1].getInt32Array()[0];
          delta = context.inputs[2].getInt32Array()[0];
        } else if (context.inputs[0].dataType === 1 /* float */) {
          start = context.inputs[0].getFloat32Array()[0];
          limit = context.inputs[1].getFloat32Array()[0];
          delta = context.inputs[2].getFloat32Array()[0];
        }
        if (env2.webgpu.validateInputContent) {
          validateInputsContent(start, limit, delta);
        }
        context.compute(createRangeProgramInfo(start, limit, delta, context.inputs[0].dataType), { inputs: [] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/scatter-nd.ts
  var atomicReductionSnippet, createScatterNDProgramInfo, parseScatterNDAttributes, scatterND;
  var init_scatter_nd = __esm({
    "web/lib/wasm/jsep/webgpu/ops/scatter-nd.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      atomicReductionSnippet = (reduction, ptr, v, type) => {
        if (reduction !== "none" && type !== "i32" && type !== "u32" && type !== "f32") {
          throw new Error(`Input ${type} is not supported with reduction ${reduction}.`);
        }
        const floatStart = `{
                var oldValue = 0;
                loop {
                  let newValueF32 =`;
        const floatEnd = `;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${ptr}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;
        switch (reduction) {
          case "none":
            return `${ptr}=${v};`;
          case "add":
            if (type === "i32" || type === "u32") {
              return `atomicAdd(&${ptr}, bitcast<${type}>(${v}));`;
            } else {
              return `
              ${floatStart}bitcast<${type}>(oldValue) + (${v})${floatEnd}`;
            }
          case "max":
            if (type === "i32" || type === "u32") {
              return `atomicMax(&${ptr}, bitcast<${type}>(${v}));`;
            } else {
              return `
                ${floatStart}max(bitcast<f32>(oldValue), (${v}))${floatEnd}`;
            }
          case "min":
            if (type === "i32" || type === "u32") {
              return `atomicMin(&${ptr}, bitcast<${type}>(${v}));`;
            } else {
              return `${floatStart}min(bitcast<${type}>(oldValue), (${v}))${floatEnd}`;
            }
          case "mul":
            return `${floatStart}(bitcast<${type}>(oldValue) * (${v}))${floatEnd}`;
          default:
            throw new Error(`Reduction ${reduction} is not supported.`);
        }
      };
      createScatterNDProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const indicesShape = inputs[1].dims;
        const outputShape = inputShape;
        const components = 1;
        const outputSize = Math.ceil(ShapeUtil.sizeToDimension(indicesShape, indicesShape.length - 1) / components);
        const lastIndexDimension = indicesShape[indicesShape.length - 1];
        const numUpdatesElements = ShapeUtil.sizeFromDimension(inputShape, lastIndexDimension);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: lastIndexDimension },
          { type: 12 /* uint32 */, data: numUpdatesElements },
          ...createTensorShapeVariables(inputs[1].dims, inputs[2].dims, outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const indices = inputVariable("indices", inputs[1].dataType, inputs[1].dims.length);
          const updates = inputVariable("updates", inputs[2].dataType, inputs[2].dims.length, components);
          const output = attributes.reduction !== "none" && attributes.reduction !== "" ? atomicOutputVariable("output", inputs[0].dataType, outputShape.length) : outputVariable("output", inputs[0].dataType, outputShape.length, components);
          return `
      ${shaderHelper.registerUniform("output_size", "u32").registerUniform("last_index_dimension", "u32").registerUniform("num_updates_elements", "u32").declareVariables(indices, updates, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var data_offset = 0u;
  let indices_start = uniforms.last_index_dimension * global_idx;
  let indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${inputs[0].dims.length === 1 ? `
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;` : `
    let element_count_dim = uniforms.output_strides[i - indices_start];
    let dim_value = uniforms.output_shape[i - indices_start];`}
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));
  }

  for (var i = 0u; i < uniforms.num_updates_elements; i++) {
    let value = updates[uniforms.num_updates_elements * global_idx + i];
    ${atomicReductionSnippet(
            attributes.reduction,
            "output[data_offset + i]",
            "value",
            output.type.value
          )}
  }

      }`;
        };
        return {
          name: "ScatterND",
          shaderCache: {
            hint: `${attributes.cacheKey}_${attributes.reduction}`,
            inputDependencies: ["rank", "rank"]
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      parseScatterNDAttributes = (attributes) => createAttributeWithCacheKey({ reduction: attributes.reduction });
      scatterND = (context, attributes) => {
        context.compute(createScatterNDProgramInfo(context.inputs, attributes), {
          inputs: [context.inputs[1], context.inputs[2]],
          outputs: []
        });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/resize.ts
  var validateScales, updateScales, validateInputs27, getSafeIntegerDivision, getOriginalCoordinateFromResizedCoordinate, getNearestPixelFromOriginal, updateRoI, initOutputShape, adjustOutputShape, calculateOriginalIndicesFromOutputIndices, calculateInputIndicesFromOutputIndices, checkInputIndices, setChannelAndBatchIndices, bilinearInterpolation, bicubicInterpolation, trilinearInterpolation, createResizeProgramInfo, getOpsetVersionFromCustomDataBuffer, resize, parseResizeAttributes;
  var init_resize = __esm({
    "web/lib/wasm/jsep/webgpu/ops/resize.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateScales = (scales, attributes) => {
        scales.every(
          (value) => value > 0 || (() => {
            throw new Error("Resize requires scales input values to be positive");
          })
        );
        if (scales.length > 0) {
          if (attributes.mode === "linear") {
            if (!(scales.length === 2 || scales.length === 3 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1 || scales.length === 5 && scales[0] === 1 && scales[1] === 1)) {
              throw new Error(
                `For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`
              );
            }
          } else if (attributes.mode === "cubic") {
            if (!(scales.length === 2 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1)) {
              throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode");
            }
          }
        }
      };
      updateScales = (scales, axes, rank) => {
        axes.every(
          (value) => value >= 0 && value < rank || (() => {
            throw new Error("Resize requires axes input values to be positive and less than rank");
          })
        );
        const newScales = new Array(rank).fill(1);
        axes.forEach((value, index) => newScales[value] = scales[index]);
        return newScales;
      };
      validateInputs27 = (inputs, attributes, opsetVersion, scales, sizes, roi) => {
        const [roiInputIndex, scalesInputIndex, sizesInputIndex] = opsetVersion > 10 ? [1, 2, 3] : [-1, inputs.length > 1 ? 1 : -1, -1];
        const rank = inputs[0].dims.length;
        if (roiInputIndex > 0 && inputs.length > roiInputIndex && inputs[roiInputIndex].dims.length > 0) {
          inputs[roiInputIndex].getFloat32Array().forEach((value) => roi.push(value));
        } else if (attributes.coordinateTransformMode === "tf_crop_and_resize") {
          throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");
        }
        if (scalesInputIndex > 0 && inputs.length > scalesInputIndex && inputs[scalesInputIndex].dims.length === 1 && inputs[scalesInputIndex].dims[0] > 0) {
          inputs[scalesInputIndex].getFloat32Array().forEach((value) => scales.push(value));
          if (scales.length !== 0 && scales.length !== rank && opsetVersion >= 18 && scales.length !== attributes.axes.length) {
            throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");
          }
          validateScales(scales, attributes);
          if (attributes.axes.length > 0) {
            updateScales(scales, attributes.axes, rank).forEach((value, index) => scales[index] = value);
          }
        }
        if (sizesInputIndex > 0 && inputs.length > sizesInputIndex && inputs[sizesInputIndex].dims.length === 1 && inputs[sizesInputIndex].dims[0] > 0) {
          inputs[sizesInputIndex].getBigInt64Array().forEach((value) => sizes.push(Number(value)));
          if (sizes.length !== 0 && sizes.length !== rank && opsetVersion >= 18 && sizes.length !== attributes.axes.length) {
            throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");
          }
        }
        if (attributes.axes.length > 0) {
          if (scales.length !== 0 && scales.length !== attributes.axes.length) {
            throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');
          }
          if (sizes.length !== 0 && sizes.length !== attributes.axes.length) {
            throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified');
          }
        }
        if (typeof scales !== "undefined" && typeof sizes !== "undefined" && scales.length > 0 && sizes.length > rank) {
          throw new Error("Resize requires only of scales or sizes to be specified");
        }
      };
      getSafeIntegerDivision = (a, b, c, dType) => `
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${a}) * (${b});
  let whole = ${dType}(big / (${c}));
  let fract = ${dType}(big % (${c})) / ${dType}(${c});
  return whole + fract;
`;
      getOriginalCoordinateFromResizedCoordinate = (coordinateTransferMode, dType) => `fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${dType} { ` + (() => {
        switch (coordinateTransferMode) {
          case "asymmetric":
            return `
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${dType}(xResized) / ${dType}(xScale);
          } else {
            ${getSafeIntegerDivision("xResized", "lengthOriginal", "lengthResized", dType)}
          }
        `;
          case "pytorch_half_pixel":
            return `if (lengthResized > 1) {
                    return (${dType}(xResized) + 0.5) / ${dType}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;
          case "tf_half_pixel_for_nn":
            return `return (${dType}(xResized) + 0.5) / ${dType}(xScale);`;
          case "align_corners":
            return `if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${getSafeIntegerDivision("xResized", "lengthOriginal - 1", "lengthResized - 1", dType)}
                  }`;
          case "tf_crop_and_resize":
            return `if (lengthResized > 1) {
                    return ${dType}(roiStart) * ${dType}(lengthOriginal - 1) +
                        (${dType}(xResized) * ${dType}(roiEnd - roiStart) * ${dType}(lengthOriginal - 1)) /
                        ${dType}(lengthResized - 1);
                  } else {
                    return 0.5 * ${dType}(roiStart + roiEnd) * ${dType}(lengthOriginal - 1);
                  }`;
          case "half_pixel_symmetric":
            return `const outputWidth = ${dType}xScale * ${dType}(lengthResized);
                  const adjustment = ${dType}(lengthResized) / outputWidth;
                  const center = ${dType}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
          case "half_pixel":
            return `return ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
          default:
            throw new Error(`Coordinate transform mode ${coordinateTransferMode} is not supported`);
        }
      })() + "}";
      getNearestPixelFromOriginal = (nearestMode, opsetVersion, dType) => `fn getNearestPixelFromOriginal(xOriginal: ${dType}, isDownSample: bool) -> ${dType} {` + (() => {
        switch (nearestMode) {
          case "round_prefer_ceil":
            return "if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";
          case "floor":
            return "return floor(xOriginal);";
          case "ceil":
            return "return ceil(xOriginal);";
          case "round_prefer_floor":
            return "if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";
          case "simple":
          default:
            if (opsetVersion < 11) {
              return "if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";
            }
            throw new Error(`Nearest mode ${nearestMode} is not supported`);
        }
      })() + "}";
      updateRoI = (roi, axes, rank) => {
        const roiTmp = new Array(rank).fill(0).concat(new Array(rank).fill(1));
        const roiLocal = roi.length === 0 ? roiTmp : roi.slice();
        if (axes.length > 0) {
          axes.forEach((v, i) => {
            roiTmp[v] = roiLocal[i];
            roiTmp[i + rank] = roiLocal[axes.length + i];
          });
          return roiTmp;
        }
        return roiLocal;
      };
      initOutputShape = (inputShape, scales, sizes, axes) => {
        let outputShape = [];
        if (sizes.length > 0) {
          if (axes.length > 0) {
            inputShape.forEach((v) => outputShape.push(v));
            if (Math.max(...axes) > inputShape.length) {
              throw new Error("axes is out of bound");
            }
            axes.forEach((v, i) => outputShape[v] = sizes[i]);
          } else {
            sizes.forEach((v) => outputShape.push(v));
          }
        } else {
          if (scales.length === 0) {
            throw new Error("Resize requires either scales or sizes.");
          } else {
            outputShape = inputShape.map((value, index) => Math.round(value * scales[index]));
          }
        }
        return outputShape;
      };
      adjustOutputShape = (inputShape, scales, attributes) => {
        const scaleInPolicy = (() => {
          switch (attributes.keepAspectRatioPolicy) {
            case "not_larger":
              return attributes.axes.length > 0 ? Math.min(...attributes.axes.map((i) => scales[i]), Number.MAX_VALUE) : Math.min(...scales, Number.MAX_VALUE);
            case "not_smaller":
              return attributes.axes.length > 0 ? Math.max(...attributes.axes.map((i) => scales[i]), Number.MIN_VALUE) : Math.max(...scales, Number.MIN_VALUE);
            default:
              throw new Error(`Keep aspect ratio policy ${attributes.keepAspectRatioPolicy} is not supported`);
          }
        })();
        scales.fill(1, 0, scales.length);
        const adjustedOutputShape = inputShape.slice();
        if (attributes.axes.length > 0) {
          attributes.axes.forEach((v) => scales[v] = scaleInPolicy);
          attributes.axes.forEach((v) => adjustedOutputShape[v] = Math.round(inputShape[v] * scales[v]));
        } else {
          scales.fill(scaleInPolicy, 0, scales.length);
          adjustedOutputShape.forEach((v, i) => adjustedOutputShape[i] = Math.round(v * scales[i]));
        }
        return adjustedOutputShape;
      };
      calculateOriginalIndicesFromOutputIndices = (output, inputShape, outputShape, scalesLength, roiLength) => `
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> array<${output.type.value}, ${outputShape.length}> {
      var original_indices: array<${output.type.value}, ${outputShape.length}>;
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
        var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
        if (scale == 1.0) {
          original_indices[i] = ${output.type.value}(output_index);
        } else {
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`;
      calculateInputIndicesFromOutputIndices = (input, output, inputShape, outputShape, scalesLength, roiLength, useExtrapolation) => `
    fn calculateInputIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
      var input_indices: ${input.type.indices};
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var input_index: u32;
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
          var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${useExtrapolation} || (original_idx >= 0 && original_idx < ${output.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${output.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${input.indicesSet("input_indices", "i", "input_index")}
      }
      return input_indices;
    }`;
      checkInputIndices = (input, inputShape) => `
    fn checkInputIndices(input_indices: ${input.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${inputShape.length}; i++) {
        var input_index = ${input.indicesGet("input_indices", "i")};
        if (input_index < 0 || input_index >= ${getElementAt("uniforms.input_shape", "i", inputShape.length)}) {
          return false;
        }
      }
      return true;
    }`;
      setChannelAndBatchIndices = (input, channelIdx, batchIdx, spacialDims) => input.rank > spacialDims ? `
    ${input.indicesSet("input_indices", channelIdx, "channel")};
    ${input.indicesSet("input_indices", batchIdx, "batch")};
` : "";
      bilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
        const isNchw = true;
        const [batchIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 2 ? [-1, 0, 1, -1] : isNchw ? [0, 2, 3, 1] : [0, 1, 2, 3];
        const dType = input.type.value;
        return `
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(row, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(col, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 2)}
      return ${input.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${dType} = originalIndices[${heightIdx}];
      var col:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (row < 0 || row > (${inputShape[heightIdx]} - 1) || col < 0 || col > (${inputShape[widthIdx]} - 1)) {
        return ${extrapolationValue};
      }` : ""};
      row = max(0, min(row, ${inputShape[heightIdx]} - 1));
      col = max(0, min(col, ${inputShape[widthIdx]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${inputShape.length > 2 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 2 ? `u32(originalIndices[${batchIdx}])` : "0"};
      var x11: ${dType} = getInputValue(batch, channel, row1, col1);
      var x12: ${dType} = getInputValue(batch, channel, row1, col2);
      var x21: ${dType} = getInputValue(batch, channel, row2, col1);
      var x22: ${dType} = getInputValue(batch, channel, row2, col2);
      var dx1: ${dType} = abs(row - ${dType}(row1));
      var dx2: ${dType} = abs(${dType}(row2) - row);
      var dy1: ${dType} = abs(col - ${dType}(col1));
      var dy2: ${dType} = abs(${dType}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`;
      };
      bicubicInterpolation = (input, output, inputShape, outputShape, scales, roi, cubicCoeffA, useExtrapolation, extrapolationValue, excludeOutside) => {
        const is2D = inputShape.length === 2;
        const isNchw = true;
        const [heightIdx, widthIdx] = is2D ? [0, 1] : isNchw ? [2, 3] : [1, 2];
        const dType = input.type.value;
        const createCubicInterpolationFunction = (idx) => {
          const direction = idx === heightIdx ? "row" : "col";
          return `
      fn ${direction}CubicInterpolation(input_indices: ${input.type.indices}, output_indices: ${output.type.indices}) -> ${dType} {
        var output_index = ${output.indicesGet("output_indices", idx)};
        var originalIdx: ${dType} = getOriginalCoordinateFromResizedCoordinate(output_index, ${scales[idx]},
        ${outputShape[idx]}, ${inputShape[idx]}, ${roi[idx]}, ${roi[idx]} + ${inputShape.length});
        var fractOriginalIdx: ${dType} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${useExtrapolation} && (originalIdx < 0 || originalIdx > (${inputShape[idx]} - 1))) {
          return ${extrapolationValue};
        }
        var data: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${direction}: ${dType} = originalIdx + ${dType}(i);
          if (${direction} < 0 || ${direction} >= ${inputShape[idx]}) {
            ${(() => {
            if (excludeOutside) {
              return `coefs[i + 1] = 0.0;
                        continue;`;
            } else if (useExtrapolation) {
              return `return ${extrapolationValue};`;
            } else {
              return `${direction} = max(0, min(${direction}, ${inputShape[idx]} - 1));`;
            }
          })()};
          }
        var input_indices_copy: ${input.type.indices} = input_indices;
          ${input.indicesSet("input_indices_copy", idx, `u32(${direction})`)};
          data[i + 1] = ${idx === heightIdx ? input.getByIndices("input_indices_copy") : "rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`;
        };
        return `
    ${createCubicInterpolationFunction(heightIdx)};
    ${createCubicInterpolationFunction(widthIdx)};
  fn getCubicInterpolationCoefs(s: ${dType}) -> array<${dType}, 4> {
    var absS = abs(s);
    var coeffs: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${dType} = 1.0 - absS;
    var twoMinusAbsS: ${dType} = 2.0 - absS;
    var onePlusAbsS: ${dType} = 1.0 + absS;
    coeffs[0] = ((${cubicCoeffA} * onePlusAbsS - 5 * ${cubicCoeffA}) * onePlusAbsS + 8 * ${cubicCoeffA}) * onePlusAbsS - 4 * ${cubicCoeffA};
    coeffs[1] = ((${cubicCoeffA} + 2) * absS - (${cubicCoeffA} + 3)) * absS * absS + 1;
    coeffs[2] = ((${cubicCoeffA} + 2) * oneMinusAbsS - (${cubicCoeffA} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${cubicCoeffA} * twoMinusAbsS - 5 * ${cubicCoeffA}) * twoMinusAbsS + 8 * ${cubicCoeffA}) * twoMinusAbsS - 4 * ${cubicCoeffA};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${dType}, 4>, coefs: array<${dType}, 4>) -> ${dType} {
    var coefsSum: ${dType} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
    var input_indices: ${input.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `;
      };
      trilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
        const isNchw = true;
        const [batchIdx, depthIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 3 ? [-1, 0, 1, 2, -1] : isNchw ? [0, 2, 3, 4, 1] : [0, 1, 2, 3, 4];
        const dType = input.type.value;
        return `
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", depthIdx, `max(0, min(depth, ${inputShape[depthIdx]} - 1))`)};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(height, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(width, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 3)}
      return ${input.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${dType} = originalIndices[${depthIdx}];
      var height:${dType} = originalIndices[${heightIdx}];
      var width:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (depth < 0 || depth > (${inputShape[depthIdx]} - 1) || height < 0 || height > (${inputShape[heightIdx]} - 1) || width < 0 || (width > ${inputShape[widthIdx]} - 1)) {
      return ${extrapolationValue};
        }` : ""};

    depth = max(0, min(depth, ${inputShape[depthIdx]} - 1));
      height = max(0, min(height, ${inputShape[heightIdx]} - 1));
      width = max(0, min(width, ${inputShape[widthIdx]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${inputShape.length > 3 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 3 ? `u32(originalIndices[${batchIdx}])` : "0"};

      var x111: ${dType} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${dType} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${dType} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${dType} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${dType} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${dType} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${dType} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${dType} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${dType} = abs(depth - ${dType}(depth1));
      var dx2: ${dType} = abs(${dType}(depth2) - depth);
      var dy1: ${dType} = abs(height - ${dType}(height1));
      var dy2: ${dType} = abs(${dType}(height2) - height);
      var dz1: ${dType} = abs(width - ${dType}(width1));
      var dz2: ${dType} = abs(${dType}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`;
      };
      createResizeProgramInfo = (inputTensor, attributes, opsetVersion, scalesInput, sizes, roiInput) => {
        const inputShape = inputTensor.dims;
        const roi = updateRoI(roiInput, attributes.axes, inputShape.length);
        let outputShape = initOutputShape(inputShape, scalesInput, sizes, attributes.axes);
        let scales = scalesInput.slice();
        if (scalesInput.length === 0) {
          scales = inputShape.map((value, index) => value === 0 ? 1 : outputShape[index] / value);
          if (attributes.keepAspectRatioPolicy !== "stretch") {
            outputShape = adjustOutputShape(inputShape, scales, attributes);
          }
        }
        const output = outputVariable("output", inputTensor.dataType, outputShape.length);
        const input = inputVariable("input", inputTensor.dataType, inputShape.length);
        const outputSize = ShapeUtil.size(outputShape);
        const noScale = inputShape.length === outputShape.length && inputShape.every((d, i) => d === outputShape[i]);
        const useExtrapolation = attributes.coordinateTransformMode === "tf_crop_and_resize";
        const extrapolationValue = attributes.extrapolationValue;
        const dataType = input.type.value;
        const getShaderSource = (shaderHelper) => `
      ${noScale ? "" : `
      ${getOriginalCoordinateFromResizedCoordinate(attributes.coordinateTransformMode, dataType)};
      ${(() => {
          switch (attributes.mode) {
            case "nearest":
              return `
              ${checkInputIndices(input, inputShape)};
              ${getNearestPixelFromOriginal(attributes.nearestMode, opsetVersion, dataType)};
              ${calculateInputIndicesFromOutputIndices(
                input,
                output,
                inputShape,
                outputShape,
                scales.length,
                roi.length,
                useExtrapolation
              )};
              `;
            case "linear":
              return `
              ${calculateOriginalIndicesFromOutputIndices(output, inputShape, outputShape, scales.length, roi.length)};
              ${(() => {
                if (inputShape.length === 2 || inputShape.length === 4) {
                  return `${bilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
                } else if (inputShape.length === 3 || inputShape.length === 5) {
                  return `${trilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
                } else {
                  throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.");
                }
              })()};
            `;
            case "cubic":
              return `
            ${(() => {
                if (inputShape.length === 2 || inputShape.length === 4) {
                  return `${bicubicInterpolation(
                    input,
                    output,
                    inputShape,
                    outputShape,
                    scales,
                    roi,
                    attributes.cubicCoeffA,
                    useExtrapolation,
                    attributes.extrapolationValue,
                    attributes.excludeOutside
                  )}`;
                } else {
                  throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.");
                }
              })()};
            `;
            default:
              throw Error("Invalid resize mode");
          }
        })()};
      `}
      ${shaderHelper.registerUniform("output_size", "u32").registerUniform("scales", "f32", scales.length).registerUniform("roi", "f32", roi.length).declareVariables(input, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${noScale ? "output[global_idx] = input[global_idx];" : `
        let output_indices = ${output.offsetToIndices("global_idx")};
        var input_indices: ${input.type.indices};
        ${(() => {
          switch (attributes.mode) {
            case "nearest":
              return `input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${input.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${attributes.extrapolationValue};
                }`;
            case "linear":
              return `output[global_idx] = ${inputShape.length === 2 || inputShape.length === 4 ? "bilinearInterpolation" : "trilinearInterpolation"}(output_indices);`;
            case "cubic":
              return "output[global_idx] = bicubicInterpolation(output_indices);";
            default:
              throw Error(`Unsupported resize mode: ${attributes.mode}`);
          }
        })()};
`}
      }`;
        return {
          name: "Resize",
          shaderCache: {
            hint: `${attributes.cacheKey}|${opsetVersion}|${scales.length > 0 ? attributes.mode === "cubic" ? scales : scales.length : ""}|${sizes.length > 0 ? sizes : ""}|${roi.length > 0 ? roi : ""}|${noScale}|${attributes.mode === "nearest" ? inputShape.length : inputShape}`,
            inputDependencies: ["rank"]
          },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              { type: 1 /* float */, data: scales },
              { type: 1 /* float */, data: roi },
              ...createTensorShapeVariables(inputShape, outputShape)
            ]
          })
        };
      };
      getOpsetVersionFromCustomDataBuffer = (context) => {
        const customDataBuffer = context.customDataBuffer;
        const customDataBuffer32 = new Uint32Array(customDataBuffer, customDataBuffer.byteOffset, 1);
        const opsetVersion = customDataBuffer32[0];
        return opsetVersion;
      };
      resize = (context, attributes) => {
        const scales = [];
        const sizes = [];
        const roi = [];
        const opsetVersion = getOpsetVersionFromCustomDataBuffer(context);
        if (attributes.antialias !== 0) {
          throw Error("Only default value (0) for Antialias attribute is supported");
        }
        validateInputs27(context.inputs, attributes, opsetVersion, scales, sizes, roi);
        context.compute(createResizeProgramInfo(context.inputs[0], attributes, opsetVersion, scales, sizes, roi), {
          inputs: [0]
        });
      };
      parseResizeAttributes = (attributes) => {
        const antialias = attributes.antialias;
        const axes = attributes.axes;
        const coordinateTransformMode = attributes.coordinateTransformMode;
        const cubicCoeffA = attributes.cubicCoeffA;
        const excludeOutside = attributes.excludeOutside !== 0;
        const extrapolationValue = attributes.extrapolationValue;
        const keepAspectRatioPolicy = attributes.keepAspectRatioPolicy;
        const mode = attributes.mode;
        const nearestMode = attributes.nearestMode === "" ? "simple" : attributes.nearestMode;
        return createAttributeWithCacheKey({
          antialias,
          axes,
          coordinateTransformMode,
          cubicCoeffA,
          excludeOutside,
          extrapolationValue,
          keepAspectRatioPolicy,
          mode,
          nearestMode
        });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts
  var validateInputs28, createSkipLayerNormProgramInfo, skipLayerNorm;
  var init_skip_layer_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs28 = (inputs) => {
        if (!inputs || inputs.length < 3) {
          throw new Error("layerNorm requires at least 3 inputs.");
        }
        const input = inputs[0];
        const skip = inputs[1];
        const gamma = inputs[2];
        if (input.dataType !== skip.dataType || input.dataType !== gamma.dataType) {
          throw new Error("All inputs must have the same data type");
        }
        if (input.dims.length !== 3 && input.dims.length !== 2) {
          throw new Error("Input must be 2D or 3D");
        }
        if (skip.dims.length !== 3 && skip.dims.length !== 2) {
          throw new Error("Skip must be 2D or 3D");
        }
        const hiddenSize = input.dims[input.dims.length - 1];
        const sequenceLength = input.dims[input.dims.length - 2];
        if (skip.dims[skip.dims.length - 1] !== hiddenSize) {
          throw new Error("Skip must have the same hidden size as input");
        }
        if (skip.dims[skip.dims.length - 2] !== sequenceLength) {
          throw new Error("Skip must have the same sequence length as input");
        }
        if (gamma.dims.length !== 1) {
          throw new Error("Gamma must be 1D");
        }
        if (gamma.dims[gamma.dims.length - 1] !== hiddenSize) {
          throw new Error("Gamma must have the same hidden size as input");
        }
        if (inputs.length > 3) {
          const beta = inputs[3];
          if (beta.dims.length !== 1) {
            throw new Error("Beta must be 1D");
          }
          if (beta.dims[beta.dims.length - 1] !== hiddenSize) {
            throw new Error("Beta must have the same hidden size as input");
          }
        }
        if (inputs.length > 4) {
          const bias = inputs[4];
          if (bias.dims.length !== 1) {
            throw new Error("Bias must be 1D");
          }
          if (bias.dims[bias.dims.length - 1] !== hiddenSize) {
            throw new Error("Bias must have the same hidden size as input");
          }
        }
      };
      createSkipLayerNormProgramInfo = (inputs, attributes, outputCount, isTraining) => {
        const simplified = attributes.simplified;
        const inputShape = inputs[0].dims;
        const inputSize = ShapeUtil.size(inputShape);
        const outputShape = inputShape;
        const outputSize = inputSize;
        const hiddenSize = inputShape.slice(-1)[0];
        const meanInvStdDevDim = isTraining ? inputShape.slice(0, -1).concat(1) : [];
        const hasBetaInput = !simplified && inputs.length > 3;
        const hasBiasInput = inputs.length > 4;
        const hasMeanOutput = isTraining && outputCount > 1;
        const hasInvStdDevOutput = isTraining && outputCount > 2;
        const hasInputSkipBiasSumOutput = outputCount > 3;
        const workgroupSize = 64;
        const components = getMaxComponents(hiddenSize);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: components },
          { type: 12 /* uint32 */, data: hiddenSize },
          { type: 1 /* float */, data: attributes.epsilon }
        ];
        const getShaderSource = (shaderHelper) => {
          const uniformsArray = [
            { name: "output_size", type: "u32" },
            { name: "components", type: "u32" },
            { name: "hidden_size", type: "u32" },
            { name: "epsilon", type: "f32" }
          ];
          const variables = [
            inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
            inputVariable("skip", inputs[1].dataType, inputs[1].dims, components),
            inputVariable("gamma", inputs[2].dataType, inputs[2].dims, components)
          ];
          if (hasBetaInput) {
            variables.push(inputVariable("beta", inputs[3].dataType, inputs[3].dims, components));
          }
          if (hasBiasInput) {
            variables.push(inputVariable("bias", inputs[4].dataType, inputs[4].dims, components));
          }
          variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
          if (hasMeanOutput) {
            variables.push(outputVariable("mean_output", 1 /* float */, meanInvStdDevDim));
          }
          if (hasInvStdDevOutput) {
            variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
          }
          if (hasInputSkipBiasSumOutput) {
            variables.push(outputVariable("input_skip_bias_sum", inputs[0].dataType, outputShape, components));
          }
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const vecDataType = tensorTypeToWsglStorageType(1 /* float */, components);
          return `

      ${shaderHelper.registerUniforms(uniformsArray).declareVariables(...variables)}
      var<workgroup> sum_shared : array<${vecDataType}, ${workgroupSize}>;
      var<workgroup> sum_squared_shared : array<${vecDataType}, ${workgroupSize}>;

      ${shaderHelper.mainStart([workgroupSize, 1, 1])}
        let ix = local_id.x;
        let iy = global_id.x / ${workgroupSize};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${workgroupSize};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${workgroupSize - 1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${hasBiasInput ? "bias[offset1d + i]" : dataType + "(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${hasInputSkipBiasSumOutput ? "input_skip_bias_sum[offset + i] = value;" : ""}
          output[offset + i] = value;
          let f32_value = ${castToF32(dataType, components, "value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${workgroupSize};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${sumVector("sum", components)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${sumVector("square_sum", components)} / f32(uniforms.hidden_size) ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);
        ${hasMeanOutput ? "mean_output[global_idx] = mean;" : ""}
        ${hasInvStdDevOutput ? "inv_std_output[global_idx] = inv_std_dev;" : ""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${simplified ? "" : `- ${dataType}(mean)`}) *
            ${dataType}(inv_std_dev) * gamma[offset1d + i]
            ${hasBetaInput ? "+ beta[offset1d + i]" : ""};
        }
      }`;
        };
        const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
        if (outputCount > 1) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        if (outputCount > 2) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        if (outputCount > 3) {
          outputs.push({ dims: inputShape, dataType: inputs[0].dataType });
        }
        return {
          name: "SkipLayerNormalization",
          shaderCache: {
            hint: `${components};${hasMeanOutput};${hasInvStdDevOutput};${hasInputSkipBiasSumOutput}`,
            inputDependencies: inputs.map((_input, _index) => "type")
          },
          getShaderSource,
          getRunData: () => ({
            outputs,
            dispatchGroup: {
              x: Math.ceil(outputSize / hiddenSize)
            },
            programUniforms
          })
        };
      };
      skipLayerNorm = (context, attributes) => {
        const isTraining = false;
        validateInputs28(context.inputs);
        const outputs = [0];
        if (context.outputCount > 1) {
          outputs.push(isTraining ? 1 : -3);
        }
        if (context.outputCount > 2) {
          outputs.push(isTraining ? 2 : -3);
        }
        if (context.outputCount > 3) {
          outputs.push(3);
        }
        context.compute(createSkipLayerNormProgramInfo(context.inputs, attributes, context.outputCount, isTraining), {
          outputs
        });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/slice.ts
  var validateInputs29, readInput, createSliceAttributesFromInputs, fixStartEndValues, calculateInputIndicesImpl, createSliceProgramInfo, slice, parseSliceAttributes;
  var init_slice = __esm({
    "web/lib/wasm/jsep/webgpu/ops/slice.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs29 = (inputs, attributes) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("too few inputs");
        }
        if (attributes.axes.length !== 0) {
          if (attributes.axes.length !== attributes.starts.length || attributes.axes.length !== attributes.ends.length) {
            throw new Error("axes, starts and ends must have the same length");
          }
        } else if (attributes.starts.length !== attributes.ends.length) {
          throw new Error("starts and ends must have the same length");
        }
        inputs.slice(1).forEach((_, idx) => {
          if (inputs[idx + 1].dataType !== 6 /* int32 */ && inputs[idx + 1].dataType !== 7 /* int64 */) {
            throw new Error(`Input ${idx} must be an array of int32 or int64`);
          }
        });
      };
      readInput = (inputs, idx) => {
        const input = [];
        if (inputs.length > idx) {
          if (inputs[idx].dataType === 7 /* int64 */) {
            inputs[idx].getBigInt64Array().forEach((v) => input.push(Number(v)));
          } else if (inputs[idx].dataType === 6 /* int32 */) {
            inputs[idx].getInt32Array().forEach((v) => input.push(Number(v)));
          } else {
            throw new Error(`Input ${idx} must be an array of int32 or int64`);
          }
        }
        return input;
      };
      createSliceAttributesFromInputs = (inputs, attributes) => {
        if (inputs.length > 1) {
          const starts = readInput(inputs, 1);
          const ends = readInput(inputs, 2);
          let axes = readInput(inputs, 3);
          if (axes.length === 0) {
            axes = [...Array(inputs[0].dims.length).keys()];
          }
          return createAttributeWithCacheKey({ starts, ends, axes });
        } else {
          return attributes;
        }
      };
      fixStartEndValues = (value, index, inputShape, axes, steps) => {
        let newValue = value;
        if (value < 0) {
          newValue += inputShape[axes[index]];
        }
        if (steps[index] < 0) {
          return Math.max(0, Math.min(newValue, inputShape[axes[index]] - 1));
        } else {
          return Math.max(0, Math.min(newValue, inputShape[axes[index]]));
        }
      };
      calculateInputIndicesImpl = (input, output, inputShape) => `fn calculateInputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
          var input_indices: ${input.type.indices};
          var carry = 0u;
          for (var i = ${inputShape.length - 1}; i >= 0; i--) {
            let input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
            let steps_i = ${getElementAt("uniforms.steps", "i", inputShape.length)};
            let signs_i = ${getElementAt("uniforms.signs", "i", inputShape.length)};
            let starts_i = ${getElementAt("uniforms.starts", "i", inputShape.length)};
            var output_index = ${output.indicesGet("output_indices", "i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${input.indicesSet("input_indices", "i", "input_index")};
          }
          return input_indices;
      }`;
      createSliceProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const inputSize = ShapeUtil.size(inputShape);
        const axes = attributes.axes.length > 0 ? ShapeUtil.normalizeAxes(attributes.axes, inputShape.length) : [...Array(inputShape.length).keys()];
        let steps = readInput(inputs, 4);
        steps.forEach(
          (step) => step !== 0 || (() => {
            throw new Error("step cannot be 0");
          })
        );
        if (steps.length === 0) {
          steps = Array(axes.length).fill(1);
        }
        const starts = attributes.starts.map((start, i) => fixStartEndValues(start, i, inputShape, axes, steps));
        const ends = attributes.ends.map((end, i) => fixStartEndValues(end, i, inputShape, axes, steps));
        if (axes.length !== starts.length || axes.length !== ends.length) {
          throw new Error("start, ends and axes should have the same number of elements");
        }
        if (axes.length !== inputShape.length) {
          for (let i = 0; i < inputShape.length; ++i) {
            if (!axes.includes(i)) {
              starts.splice(i, 0, 0);
              ends.splice(i, 0, inputShape[i]);
              steps.splice(i, 0, 1);
            }
          }
        }
        const signs = steps.map((step) => Math.sign(step));
        steps.forEach((step, i, array) => {
          if (step < 0) {
            const numSteps = (ends[i] - starts[i]) / step;
            const newEnd = starts[i];
            const newStart = newEnd + numSteps * steps[i];
            starts[i] = newStart;
            ends[i] = newEnd;
            array[i] = -step;
          }
        });
        const outputShape = inputShape.slice(0);
        axes.forEach((axis, _) => {
          outputShape[axis] = Math.ceil((ends[axis] - starts[axis]) / steps[axis]);
        });
        const outputTensorInfo = { dims: outputShape, dataType: inputs[0].dataType };
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
        const outputSize = ShapeUtil.size(outputShape);
        const uniforms = [
          { name: "outputSize", type: "u32" },
          { name: "starts", type: "u32", length: starts.length },
          { name: "signs", type: "i32", length: signs.length },
          { name: "steps", type: "u32", length: steps.length }
        ];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: starts },
          { type: 6 /* int32 */, data: signs },
          { type: 12 /* uint32 */, data: steps },
          ...createTensorShapeVariables(inputs[0].dims, outputShape)
        ];
        const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
        ${calculateInputIndicesImpl(input, output, inputShape)}
        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${output.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
      }`;
        return {
          name: "Slice",
          shaderCache: { hint: `${signs.length}_${starts.length}_${steps.length}`, inputDependencies: ["rank"] },
          getShaderSource,
          getRunData: () => ({
            outputs: [outputTensorInfo],
            dispatchGroup: { x: Math.ceil(
              inputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      slice = (context, attributes) => {
        validateInputs29(context.inputs, attributes);
        const updatedAttributes = createSliceAttributesFromInputs(context.inputs, attributes);
        context.compute(createSliceProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
      };
      parseSliceAttributes = (attributes) => {
        const starts = attributes.starts;
        const ends = attributes.ends;
        const axes = attributes.axes;
        return createAttributeWithCacheKey({ starts, ends, axes });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/softmax.ts
  var validateInputs30, createSoftmaxProgramInfo, softmax, parseSoftmaxAttributes;
  var init_softmax = __esm({
    "web/lib/wasm/jsep/webgpu/ops/softmax.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_transpose();
      init_common();
      validateInputs30 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Softmax op requires 1 input.");
        }
      };
      createSoftmaxProgramInfo = (context, attributes) => {
        const input = context.inputs[0];
        const inputShape = input.dims;
        const outputSize = ShapeUtil.size(inputShape);
        const inputRank = inputShape.length;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
        const isTransposeRequired = axis < inputShape.length - 1;
        let transposedInput;
        let perm = [];
        if (isTransposeRequired) {
          perm = Array.from({ length: inputRank }, (_, i) => i);
          perm[axis] = inputRank - 1;
          perm[inputRank - 1] = axis;
          transposedInput = context.compute(createTransposeProgramInfo(input, perm), {
            inputs: [input],
            outputs: [-1]
          })[0];
        } else {
          transposedInput = input;
        }
        const transposedInputShape = transposedInput.dims;
        const cols = transposedInputShape[inputRank - 1];
        const rows = outputSize / cols;
        const components = getMaxComponents(cols);
        const packedCols = cols / components;
        let WG = 64;
        if (rows === 1) {
          WG = 256;
        }
        const maxVector = (name, components2) => {
          if (components2 === 4) {
            return `max(max(${name}.x, ${name}.y), max(${name}.z, ${name}.w))`;
          } else if (components2 === 2) {
            return `max(${name}.x, ${name}.y)`;
          } else if (components2 === 3) {
            return `max(max(${name}.x, ${name}.y), ${name}.z)`;
          }
          return name;
        };
        const x = inputVariable("x", transposedInput.dataType, transposedInput.dims, components);
        const output = outputVariable("result", transposedInput.dataType, transposedInput.dims, components);
        const valueType = x.type.value;
        const threadMaxDecl = tensorTypeToWsglStorageType(transposedInput.dataType) === "f32" ? `var threadMax = ${valueType}(-3.402823e+38f);` : `var threadMax = ${valueType}(-65504.0h);`;
        const getShaderSource = (shaderHelper) => `
      var<workgroup> rowMaxShared : ${valueType};
      var<workgroup> rowSumShared : ${valueType};
      var<workgroup> threadShared : array<${valueType}, ${WG}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${valueType} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${valueType}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${shaderHelper.registerUniform("packedCols", "i32").declareVariables(x, output)}
      ${shaderHelper.mainStart(WG)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${WG};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${threadMaxDecl}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${valueType}(${maxVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${valueType}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${valueType}(${sumVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          var value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          // max operation protects against NaN since all values should be >=0
          value = max(value, ${valueType}(0.0));
          setValue(row, col, row_stride, value);
        }
      }`;
        const result = context.compute(
          {
            name: "Softmax",
            // Note that in JSEP, WG size is not included in cache by default, but WebGPU EP it is.
            shaderCache: { hint: `${components};${WG}`, inputDependencies: ["type"] },
            getRunData: () => ({
              outputs: [{ dims: transposedInputShape, dataType: transposedInput.dataType }],
              dispatchGroup: { x: rows },
              programUniforms: [{ type: 6 /* int32 */, data: packedCols }]
            }),
            getShaderSource
          },
          {
            inputs: [transposedInput],
            outputs: [isTransposeRequired ? -1 : 0]
          }
        )[0];
        if (isTransposeRequired) {
          context.compute(createTransposeProgramInfo(result, perm), {
            inputs: [result]
          });
        }
      };
      softmax = (context, attributes) => {
        validateInputs30(context.inputs);
        createSoftmaxProgramInfo(context, attributes);
      };
      parseSoftmaxAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/tile.ts
  var getRepeats, validateInputs31, getOutputShape2, createTileProgramInfo, tile;
  var init_tile = __esm({
    "web/lib/wasm/jsep/webgpu/ops/tile.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      getRepeats = (repeatsTensorView) => Array.from(repeatsTensorView.getBigInt64Array(), Number);
      validateInputs31 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Tile requires 2 inputs.");
        }
        if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */ && inputs[0].dataType !== 6 /* int32 */ && inputs[0].dataType !== 12 /* uint32 */) {
          throw new Error("Tile only support float, float16, int32, and uint32 data types");
        }
        if (inputs[1].dataType !== 7 /* int64 */) {
          throw new Error("Tile `repeats` input should be of int64 data type");
        }
        if (inputs[1].dims.length !== 1) {
          throw new Error("Tile `repeats` input should be 1-D");
        }
        const repeats = getRepeats(inputs[1]);
        if (repeats.length !== inputs[0].dims.length) {
          throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor");
        }
      };
      getOutputShape2 = (inputShape, repeats) => {
        const outputShape = [];
        for (let i = 0; i < inputShape.length; ++i) {
          outputShape.push(inputShape[i] * repeats[i]);
        }
        return outputShape;
      };
      createTileProgramInfo = (inputs, shape) => {
        const inputShape = inputs[0].dims;
        const repeats = shape == null ? getRepeats(inputs[1]) : shape;
        const outputShape = getOutputShape2(inputShape, repeats);
        const outputSize = ShapeUtil.size(outputShape);
        const dataType = inputs[0].dataType;
        const input = inputVariable("input", dataType, inputShape.length);
        const output = outputVariable("output", dataType, outputShape.length);
        const getShaderSource = (shaderHelper) => `
      const inputShape = ${input.indices(...inputShape)};
      ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${output.offsetToIndices("global_idx")};
      var input_indices: ${input.type.indices};
      for (var i = 0; i < ${inputShape.length}; i++) {
        let input_dim_i = ${input.indicesGet("uniforms.input_shape", "i")};
        let input_dim_value = ${output.indicesGet("output_indices", "i")}  % input_dim_i;

        ${input.indicesSet("input_indices", "i", "input_dim_value")}
      }
      ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
    }`;
        return {
          name: "Tile",
          shaderCache: { hint: `${repeats}`, inputDependencies: ["rank"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(inputs[0].dims, outputShape)
            ]
          }),
          getShaderSource
        };
      };
      tile = (context) => {
        validateInputs31(context.inputs);
        context.compute(createTileProgramInfo(context.inputs), { inputs: [0] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/where.ts
  var createWhereOpProgramShader, createWhereOpProgramInfo, where;
  var init_where = __esm({
    "web/lib/wasm/jsep/webgpu/ops/where.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      createWhereOpProgramShader = (shaderHelper, inputs, dimsOutput, isBroadcast, typeOutput) => {
        const output = outputVariable("output_data", typeOutput, dimsOutput.length, 4);
        const a = inputVariable("a_data", inputs[1].dataType, inputs[1].dims.length, 4);
        const b = inputVariable("b_data", inputs[2].dataType, inputs[2].dims.length, 4);
        const c = inputVariable("c_data", inputs[0].dataType, inputs[0].dims.length, 4);
        let assignment;
        const expression = (a2, b2, c2) => `select(${b2}, ${a2}, ${c2})`;
        if (!isBroadcast) {
          assignment = output.setByOffset(
            "global_idx",
            expression(a.getByOffset("global_idx"), b.getByOffset("global_idx"), c.getByOffset("global_idx"))
          );
        } else {
          const singleAssignment = (resStr, x, typeCast = "") => {
            const expressionA = `a_data[index_a${x}][component_a${x}]`;
            const expressionB = `b_data[index_b${x}][component_b${x}]`;
            const expressionC = `bool(c_data[index_c${x}] & (0xffu << (component_c${x} * 8)))`;
            return `
            let output_indices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offset_a${x} = ${a.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_b${x} = ${b.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_c${x} = ${c.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let index_a${x} = offset_a${x} / 4u;
            let index_b${x} = offset_b${x} / 4u;
            let index_c${x} = offset_c${x} / 4u;
            let component_a${x} = offset_a${x} % 4u;
            let component_b${x} = offset_b${x} % 4u;
            let component_c${x} = offset_c${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expression(expressionA, expressionB, expressionC)});
          `;
          };
          if (typeOutput === 9 /* bool */) {
            assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
          } else {
            assignment = `
            ${singleAssignment("output_data[global_idx]", 0)}
            ${singleAssignment("output_data[global_idx]", 1)}
            ${singleAssignment("output_data[global_idx]", 2)}
            ${singleAssignment("output_data[global_idx]", 3)}
          `;
          }
        }
        return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(c, a, b, output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
      };
      createWhereOpProgramInfo = (inputs) => {
        const dimsA = inputs[1].dims;
        const dimsB = inputs[2].dims;
        const dimsC = inputs[0].dims;
        const outputDataType = inputs[1].dataType;
        const isBroadcast = !(ShapeUtil.areEqual(dimsA, dimsB) && ShapeUtil.areEqual(dimsB, dimsC));
        let outputShape = dimsA;
        let outputSize = ShapeUtil.size(dimsA);
        if (isBroadcast) {
          const calculatedShape = BroadcastUtil.calcShape(BroadcastUtil.calcShape(dimsA, dimsB, false), dimsC, false);
          if (!calculatedShape) {
            throw new Error("Can't perform where op on the given tensors");
          }
          outputShape = calculatedShape;
          outputSize = ShapeUtil.size(outputShape);
        }
        const vecSize = Math.ceil(outputSize / 4);
        return {
          name: "Where",
          shaderCache: { inputDependencies: ["rank", "rank", "rank"] },
          getShaderSource: (shaderHelper) => createWhereOpProgramShader(shaderHelper, inputs, outputShape, isBroadcast, outputDataType),
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64 / 4
              /* vec size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: vecSize },
              ...createTensorShapeVariables(dimsC, dimsA, dimsB, outputShape)
            ]
          })
        };
      };
      where = (context) => {
        context.compute(createWhereOpProgramInfo(context.inputs));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/op-resolve-rules.ts
  var WEBGPU_OP_RESOLVE_RULES;
  var init_op_resolve_rules = __esm({
    "web/lib/wasm/jsep/webgpu/op-resolve-rules.ts"() {
      "use strict";
      init_argminmax();
      init_attention();
      init_batch_norm();
      init_bias_add();
      init_bias_split_gelu();
      init_binary_op();
      init_concat();
      init_conv();
      init_conv_transpose();
      init_cumsum();
      init_depth_to_space();
      init_einsum();
      init_expand();
      init_fast_gelu();
      init_gather();
      init_gather_nd();
      init_gather_block_quantized();
      init_gather_elements();
      init_gemm();
      init_grid_sample();
      init_group_query_attention();
      init_instance_norm();
      init_layer_norm();
      init_matmul();
      init_matmulnbits();
      init_multihead_attention();
      init_pad();
      init_pool();
      init_quantize_linear();
      init_range();
      init_scatter_nd();
      init_reduce();
      init_resize();
      init_rotary_embedding();
      init_skip_layer_norm();
      init_slice();
      init_softmax();
      init_split();
      init_tile();
      init_transpose();
      init_unary_op();
      init_where();
      WEBGPU_OP_RESOLVE_RULES = /* @__PURE__ */ new Map([
        ["Abs", [abs]],
        ["Acos", [acos]],
        ["Acosh", [acosh]],
        ["Add", [add]],
        ["ArgMax", [argMax, parseArgMinMaxAttributes]],
        ["ArgMin", [argMin, parseArgMinMaxAttributes]],
        ["Asin", [asin]],
        ["Asinh", [asinh]],
        ["Atan", [atan]],
        ["Atanh", [atanh]],
        ["Attention", [attention]],
        // TODO: support new attributes for AveragePool-10
        ["AveragePool", [averagePool, parseAveragePoolAttributes]],
        ["BatchNormalization", [batchNorm]],
        ["BiasAdd", [biasAdd]],
        ["BiasSplitGelu", [biasSplitGelu]],
        ["Cast", [cast, parseCastAttributes]],
        ["Ceil", [ceil]],
        ["Clip", [clip]],
        ["Concat", [concat, parseConcatAttributes]],
        ["Conv", [conv, parseConvAttributes]],
        ["ConvTranspose", [convTranspose, parseConvTransposeAttributes]],
        ["Cos", [cos]],
        ["Cosh", [cosh]],
        ["CumSum", [cumsum, parseCumSumAttributes]],
        ["DepthToSpace", [depthToSpace, parseDepthToSpaceAttributes]],
        ["DequantizeLinear", [dequantizeLinear, parseDequantizeLinearAttributes]],
        ["Div", [div]],
        ["Einsum", [einsum, parseEinsumAttributes]],
        ["Elu", [elu, parseAlphaAttributes]],
        ["Equal", [equal]],
        ["Erf", [erf]],
        ["Exp", [exp]],
        ["Expand", [expand]],
        ["FastGelu", [fastGelu2]],
        ["Floor", [floor]],
        ["FusedConv", [conv, parseConvAttributes]],
        ["Gather", [gather, parseGatherAttributes]],
        ["GatherElements", [gatherElements, parseGatherElementsAttributes]],
        ["GatherBlockQuantized", [gatherBlockQuantized, parseGatherBlockQuantizedAttributes]],
        ["GatherND", [gatherND, parseGatherNDAttributes]],
        ["Gelu", [gelu]],
        ["Gemm", [gemm, parseGemmAttributes]],
        ["GlobalAveragePool", [globalAveragePool, parseGlobalAveragePoolAttributes]],
        ["GlobalMaxPool", [globalMaxPool, parseGlobalMaxPoolAttributes]],
        ["Greater", [greater]],
        ["GreaterOrEqual", [greaterOrEqual]],
        ["GridSample", [gridSample, parseGridSampleAttributes]],
        ["GroupQueryAttention", [groupQueryAttention]],
        ["HardSigmoid", [hardSigmoid, parseHardSigmoidAttributes]],
        ["InstanceNormalization", [instanceNorm]],
        ["LayerNormalization", [layerNorm]],
        ["LeakyRelu", [leakyRelu, parseAlphaAttributes]],
        ["Less", [less]],
        ["LessOrEqual", [lessOrEqual]],
        ["Log", [log]],
        ["MatMul", [matMul]],
        ["MatMulNBits", [matMulNBits, parseMatMulNBitsAttributes]],
        // TODO: support new attributes for MaxPool-8 and MaxPool-10
        ["MaxPool", [maxPool, parseMaxPoolAttributes]],
        ["Mul", [mul]],
        ["MultiHeadAttention", [multiHeadAttention, parseMultiHeadAttentionAttributes]],
        ["Neg", [neg]],
        ["Not", [not]],
        ["Pad", [pad]],
        ["Pow", [pow]],
        ["QuickGelu", [quickgelu, parseAlphaAttributes]],
        ["Range", [range]],
        ["Reciprocal", [reciprocal]],
        ["ReduceMin", [reduceMin]],
        ["ReduceMean", [reduceMean]],
        ["ReduceMax", [reduceMax]],
        ["ReduceSum", [reduceSum]],
        ["ReduceProd", [reduceProd]],
        ["ReduceL1", [reduceL1]],
        ["ReduceL2", [reduceL2]],
        ["ReduceLogSum", [reduceLogSum]],
        ["ReduceLogSumExp", [reduceLogSumExp]],
        ["ReduceSumSquare", [reduceSumSquare]],
        ["Relu", [relu]],
        ["Resize", [resize, parseResizeAttributes]],
        ["RotaryEmbedding", [rotaryEmbedding]],
        ["ScatterND", [scatterND, parseScatterNDAttributes]],
        ["Sigmoid", [sigmoid]],
        ["Sin", [sin]],
        ["Sinh", [sinh]],
        ["Slice", [slice, parseSliceAttributes]],
        ["SkipLayerNormalization", [skipLayerNorm]],
        ["Split", [split, parseSplitAttributes]],
        ["Sqrt", [sqrt]],
        ["Softmax", [softmax, parseSoftmaxAttributes]],
        ["Sub", [sub]],
        ["Tan", [tan]],
        ["Tanh", [tanh]],
        ["ThresholdedRelu", [thresholdedRelu, parseAlphaAttributes]],
        ["Tile", [tile]],
        ["Transpose", [transpose, parseTransposeAttributes]],
        ["Where", [where]]
      ]);
    }
  });

  // web/lib/wasm/jsep/webgpu/program-manager.ts
  var ProgramManager;
  var init_program_manager = __esm({
    "web/lib/wasm/jsep/webgpu/program-manager.ts"() {
      "use strict";
      init_esm();
      init_log();
      init_common();
      ProgramManager = class {
        constructor(backend) {
          this.backend = backend;
          this.repo = /* @__PURE__ */ new Map();
          this.attributesBound = false;
        }
        getArtifact(key) {
          return this.repo.get(key);
        }
        setArtifact(key, artifact) {
          this.repo.set(key, artifact);
        }
        run(buildArtifact, inputs, outputs, dispatchGroup, uniformBufferBinding) {
          TRACE_FUNC_BEGIN(buildArtifact.programInfo.name);
          const device = this.backend.device;
          const computePassEncoder = this.backend.getComputePassEncoder();
          this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2);
          const entries = [];
          for (const input of inputs) {
            entries.push({ binding: entries.length, resource: { buffer: input.buffer } });
          }
          for (const output of outputs) {
            entries.push({ binding: entries.length, resource: { buffer: output.buffer } });
          }
          if (uniformBufferBinding) {
            entries.push({ binding: entries.length, resource: uniformBufferBinding });
          }
          const bindGroup = device.createBindGroup({
            layout: buildArtifact.computePipeline.getBindGroupLayout(0),
            entries,
            label: buildArtifact.programInfo.name
          });
          if (this.backend.sessionStatus === "capturing") {
            const commandInfo = {
              kernelId: this.backend.currentKernelId,
              computePipeline: buildArtifact.computePipeline,
              bindGroup,
              dispatchGroup
            };
            const sessionCommandList = this.backend.capturedCommandList.get(this.backend.currentSessionId);
            sessionCommandList.push(commandInfo);
          }
          computePassEncoder.setPipeline(buildArtifact.computePipeline);
          computePassEncoder.setBindGroup(0, bindGroup);
          computePassEncoder.dispatchWorkgroups(...dispatchGroup);
          this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2 + 1);
          this.backend.pendingDispatchNumber++;
          if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber || this.backend.queryType === "at-passes") {
            this.backend.endComputePass();
          }
          if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber) {
            this.backend.flush();
          }
          TRACE_FUNC_END(buildArtifact.programInfo.name);
        }
        dispose() {
        }
        build(programInfo, normalizedDispatchGroupSize) {
          TRACE_FUNC_BEGIN(programInfo.name);
          const device = this.backend.device;
          const enableDirectives = [];
          const extensionsInfo = [
            { feature: "shader-f16", extension: "f16" },
            { feature: "subgroups", extension: "subgroups" }
          ];
          extensionsInfo.forEach((info) => {
            if (device.features.has(info.feature)) {
              enableDirectives.push(`enable ${info.extension};`);
            }
          });
          const shaderHelper = createShaderHelper(normalizedDispatchGroupSize, this.backend.device.limits);
          const userCode = programInfo.getShaderSource(shaderHelper);
          const code = `${enableDirectives.join("\n")}
${shaderHelper.additionalImplementations}
${userCode}`;
          const shaderModule = device.createShaderModule({ code, label: programInfo.name });
          LOG_DEBUG("verbose", () => `[WebGPU] ${programInfo.name} shader code: ${code}`);
          const computePipeline = device.createComputePipeline({
            compute: { module: shaderModule, entryPoint: "main" },
            layout: "auto",
            label: programInfo.name
          });
          TRACE_FUNC_END(programInfo.name);
          return { programInfo, computePipeline, uniformVariablesInfo: shaderHelper.variablesInfo };
        }
        normalizeDispatchGroupSize(dispatchGroup) {
          const x = typeof dispatchGroup === "number" ? dispatchGroup : dispatchGroup.x;
          const y = typeof dispatchGroup === "number" ? 1 : dispatchGroup.y || 1;
          const z = typeof dispatchGroup === "number" ? 1 : dispatchGroup.z || 1;
          const limitPerDimension = this.backend.device.limits.maxComputeWorkgroupsPerDimension;
          if (x <= limitPerDimension && y <= limitPerDimension && z <= limitPerDimension) {
            return [x, y, z];
          }
          const size = x * y * z;
          let dispatchAverage = Math.ceil(Math.sqrt(size));
          if (dispatchAverage > limitPerDimension) {
            dispatchAverage = Math.ceil(Math.cbrt(size));
            if (dispatchAverage > limitPerDimension) {
              throw new Error("Total dispatch size exceeds WebGPU maximum.");
            }
            return [dispatchAverage, dispatchAverage, dispatchAverage];
          } else {
            return [dispatchAverage, dispatchAverage, 1];
          }
        }
      };
    }
  });

  // web/lib/wasm/jsep/backend-webgpu.ts
  var backend_webgpu_exports = {};
  __export(backend_webgpu_exports, {
    WebGpuBackend: () => WebGpuBackend
  });
  var getProgramInputTensorInfoDependencyKey, getProgramInfoUniqueKey, AdapterInfoImpl, WebGpuBackend;
  var init_backend_webgpu = __esm({
    "web/lib/wasm/jsep/backend-webgpu.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_log();
      init_tensor_view();
      init_gpu_data_manager();
      init_op_resolve_rules();
      init_program_manager();
      getProgramInputTensorInfoDependencyKey = (inputTensors, inputDependencies) => {
        if (inputDependencies.length !== inputTensors.length) {
          throw new Error(
            `inputDependencies length ${inputDependencies.length} is not equal to inputTensors length ${inputTensors.length}.`
          );
        }
        const inputInfos = [];
        for (let i = 0; i < inputTensors.length; ++i) {
          const type = inputTensors[i].dataType;
          switch (inputDependencies[i]) {
            case "none": {
              inputInfos.push("");
              break;
            }
            case "type": {
              inputInfos.push(`${type}`);
              break;
            }
            case "rank": {
              const rank = inputTensors[i].dims.length;
              inputInfos.push(`${type};${rank}`);
              break;
            }
            case "dims": {
              const dims = inputTensors[i].dims.join(",");
              inputInfos.push(`${type};${dims}`);
              break;
            }
            default:
              throw new Error(`unsupported input dependency: ${inputDependencies[i]}`);
          }
        }
        return inputInfos.join("|");
      };
      getProgramInfoUniqueKey = (programInfo, inputTensors, is1DimensionDispatch) => {
        let key = programInfo.name;
        if (programInfo.shaderCache?.hint) {
          key += "[" + programInfo.shaderCache.hint + "]";
        }
        key += ":" + is1DimensionDispatch + `:${getProgramInputTensorInfoDependencyKey(
          inputTensors,
          programInfo.shaderCache?.inputDependencies ?? new Array(inputTensors.length).fill("dims")
        )}`;
        return key;
      };
      AdapterInfoImpl = class {
        constructor(adapterInfo) {
          if (adapterInfo) {
            this.architecture = adapterInfo.architecture;
            this.vendor = adapterInfo.vendor;
          }
        }
        isArchitecture(architecture) {
          return this.architecture === architecture;
        }
        isVendor(vendor) {
          return this.vendor === vendor;
        }
      };
      WebGpuBackend = class {
        constructor() {
          /**
           * representing the session ID of which is currently being run.
           * `null` means no session is being run.
           * only valid when session.run is executed.
           */
          this.currentSessionId = null;
          /**
           * representing the kernel ID of which is currently being computed (CPU code perspective).
           * `null` means no kernel is being computed.
           * only one kernel can be computed at a moment.
           */
          this.currentKernelId = null;
          this.commandEncoder = null;
          this.computePassEncoder = null;
          this.maxDispatchNumber = 16;
          this.pendingDispatchNumber = 0;
          // info of kernels pending submission for a single batch
          this.pendingKernels = [];
          // queryReadBuffer -> pendingKernels mapping for all the batches
          this.pendingQueries = /* @__PURE__ */ new Map();
          this.sessionStatus = "default";
          /**
           * a SessionID -> CommandInfo[] mapping. It's used to record all GPU commands for corresponding session.
           */
          this.capturedCommandList = /* @__PURE__ */ new Map();
          /**
           * a SessionID -> PendingKernelInfo[] mapping for profiling.
           */
          this.capturedPendingKernels = /* @__PURE__ */ new Map();
          /**
           * a SessionID -> a Map of (InputOutputIndex -> [ID, GPUBuffer]) mapping.
           */
          this.sessionExternalDataMapping = /* @__PURE__ */ new Map();
        }
        /**
         * get the custom data of the current kernel
         */
        get currentKernelCustomData() {
          if (this.currentKernelId === null) {
            throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");
          }
          let data = this.kernelCustomData.get(this.currentKernelId);
          if (!data) {
            data = {};
            this.kernelCustomData.set(this.currentKernelId, data);
          }
          return data;
        }
        async initialize(env3, adapter) {
          this.env = env3;
          const requiredFeatures = [];
          const deviceDescriptor = {
            requiredLimits: {
              maxComputeWorkgroupStorageSize: adapter.limits.maxComputeWorkgroupStorageSize,
              maxComputeWorkgroupsPerDimension: adapter.limits.maxComputeWorkgroupsPerDimension,
              maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,
              maxBufferSize: adapter.limits.maxBufferSize,
              maxComputeInvocationsPerWorkgroup: adapter.limits.maxComputeInvocationsPerWorkgroup,
              maxComputeWorkgroupSizeX: adapter.limits.maxComputeWorkgroupSizeX,
              maxComputeWorkgroupSizeY: adapter.limits.maxComputeWorkgroupSizeY,
              maxComputeWorkgroupSizeZ: adapter.limits.maxComputeWorkgroupSizeZ
            },
            requiredFeatures
          };
          const requireFeatureIfAvailable = (feature) => adapter.features.has(feature) && requiredFeatures.push(feature) && true;
          if (!requireFeatureIfAvailable("chromium-experimental-timestamp-query-inside-passes")) {
            requireFeatureIfAvailable("timestamp-query");
          }
          requireFeatureIfAvailable("shader-f16");
          requireFeatureIfAvailable("subgroups");
          this.device = await adapter.requestDevice(deviceDescriptor);
          this.adapterInfo = new AdapterInfoImpl(adapter.info || await adapter.requestAdapterInfo());
          this.gpuDataManager = createGpuDataManager(this);
          this.programManager = new ProgramManager(this);
          this.kernels = /* @__PURE__ */ new Map();
          this.kernelPersistentData = /* @__PURE__ */ new Map();
          this.kernelCustomData = /* @__PURE__ */ new Map();
          configureLogger(env3.logLevel, !!env3.debug);
          this.device.onuncapturederror = (ev) => {
            if (ev.error instanceof GPUValidationError) {
              console.error(`An uncaught WebGPU validation error was raised: ${ev.error.message}`);
            }
          };
          Object.defineProperty(this.env.webgpu, "device", {
            value: this.device,
            writable: false,
            enumerable: true,
            configurable: false
          });
          Object.defineProperty(this.env.webgpu, "adapter", {
            value: adapter,
            writable: false,
            enumerable: true,
            configurable: false
          });
          this.setQueryType();
        }
        dispose() {
          if (typeof this.querySet !== "undefined") {
            this.querySet.destroy();
          }
          this.gpuDataManager.dispose();
        }
        getCommandEncoder() {
          if (!this.commandEncoder) {
            this.commandEncoder = this.device.createCommandEncoder();
          }
          return this.commandEncoder;
        }
        getComputePassEncoder() {
          if (!this.computePassEncoder) {
            const commandEncoder = this.getCommandEncoder();
            const computePassDescriptor = {};
            if (this.queryType === "at-passes") {
              computePassDescriptor.timestampWrites = {
                querySet: this.querySet,
                beginningOfPassWriteIndex: this.pendingDispatchNumber * 2,
                endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1
              };
            }
            this.computePassEncoder = commandEncoder.beginComputePass(computePassDescriptor);
          }
          return this.computePassEncoder;
        }
        endComputePass() {
          if (this.computePassEncoder) {
            this.computePassEncoder.end();
            this.computePassEncoder = null;
          }
        }
        flush() {
          if (!this.commandEncoder) {
            return;
          }
          TRACE_FUNC_BEGIN();
          this.endComputePass();
          let queryReadBuffer;
          if (this.queryType !== "none") {
            this.commandEncoder.resolveQuerySet(
              this.querySet,
              0,
              this.pendingDispatchNumber * 2,
              this.queryResolveBuffer,
              0
            );
            queryReadBuffer = this.device.createBuffer(
              // eslint-disable-next-line no-bitwise
              { size: this.pendingDispatchNumber * 2 * 8, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST }
            );
            this.pendingQueries.set(queryReadBuffer, this.pendingKernels);
            this.pendingKernels = [];
            this.commandEncoder.copyBufferToBuffer(
              this.queryResolveBuffer,
              0,
              queryReadBuffer,
              0,
              this.pendingDispatchNumber * 2 * 8
            );
          }
          this.device.queue.submit([this.commandEncoder.finish()]);
          this.gpuDataManager.refreshPendingBuffers();
          this.commandEncoder = null;
          this.pendingDispatchNumber = 0;
          if (this.queryType !== "none") {
            void queryReadBuffer.mapAsync(GPUMapMode.READ).then(() => {
              const mappedData = new BigUint64Array(queryReadBuffer.getMappedRange());
              const pendingKernels = this.pendingQueries.get(queryReadBuffer);
              for (let i = 0; i < mappedData.length / 2; i++) {
                const pendingKernelInfo = pendingKernels[i];
                const kernelId = pendingKernelInfo.kernelId;
                const kernelInfo = this.kernels.get(kernelId);
                const kernelType = kernelInfo.kernelType;
                const kernelName = kernelInfo.kernelName;
                const programName = pendingKernelInfo.programName;
                const inputTensorViews = pendingKernelInfo.inputTensorViews;
                const outputTensorViews = pendingKernelInfo.outputTensorViews;
                const startTimeU64 = mappedData[i * 2];
                const endTimeU64 = mappedData[i * 2 + 1];
                if (typeof this.queryTimeBase === "undefined") {
                  this.queryTimeBase = startTimeU64;
                }
                const startTime = Number(startTimeU64 - this.queryTimeBase);
                const endTime = Number(endTimeU64 - this.queryTimeBase);
                if (!Number.isSafeInteger(startTime) || !Number.isSafeInteger(endTime)) {
                  throw new RangeError("incorrect timestamp range");
                }
                if (this.env.webgpu.profiling?.ondata) {
                  this.env.webgpu.profiling.ondata({
                    version: 1,
                    inputsMetadata: inputTensorViews.map((value) => ({
                      dims: value.dims,
                      dataType: tensorDataTypeEnumToString(value.dataType)
                    })),
                    outputsMetadata: outputTensorViews.map((value) => ({
                      dims: value.dims,
                      dataType: tensorDataTypeEnumToString(value.dataType)
                    })),
                    kernelId,
                    kernelType,
                    kernelName,
                    programName,
                    startTime,
                    endTime
                  });
                } else {
                  let inputShapes = "";
                  inputTensorViews.forEach((value, i2) => {
                    inputShapes += `input[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                  });
                  let outputShapes = "";
                  outputTensorViews.forEach((value, i2) => {
                    outputShapes += `output[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                  });
                  console.log(
                    `[profiling] kernel "${kernelId}|${kernelType}|${kernelName}|${programName}" ${inputShapes}${outputShapes}start time: ${startTime} ns, execution time: ${endTime - startTime} ns`
                  );
                }
                TRACE("GPU", `${programName}::${startTimeU64}::${endTimeU64}`);
              }
              queryReadBuffer.unmap();
              this.pendingQueries.delete(queryReadBuffer);
            });
          }
          TRACE_FUNC_END();
        }
        /**
         * run a WebGPU program.
         * @param program a ProgramInfo instance
         * @param inputTensorViews a TensorView array. each element represents a value already exists in GPU.
         * @param outputIndices an indices array. each element can be either -1 (temporary data), -2 (persistent data) or an
         * index to the kernel's output.
         * @param createKernelOutput a callback function that create a value to kernel's output with the given index
         * @param createIntermediateOutput a callback function that create a value as a intermediate value, either temporary
         * or persistent (owned by the current kernel)
         * @returns a TensorView array representing the result.
         */
        run(program, inputTensorViews, outputIndices, createKernelOutput, createIntermediateOutput, outputCount) {
          TRACE_FUNC_BEGIN(program.name);
          const inputDatas = [];
          for (let i = 0; i < inputTensorViews.length; ++i) {
            const data = inputTensorViews[i].data;
            if (data === 0) {
              continue;
            }
            const gpuData = this.gpuDataManager.get(data);
            if (!gpuData) {
              throw new Error(`no GPU data for input: ${data}`);
            }
            inputDatas.push(gpuData);
          }
          const { outputs, dispatchGroup, programUniforms } = program.getRunData(inputTensorViews);
          const validatedOutputIndices = outputIndices.length === 0 ? outputs.map((_, i) => i) : outputIndices;
          if (validatedOutputIndices.length !== outputs.length) {
            throw new Error(`Output size ${validatedOutputIndices.length} must be equal to ${outputs.length}.`);
          }
          const outputTensorViews = [];
          const outputDatas = [];
          for (let i = 0; i < outputs.length; ++i) {
            if (!Number.isInteger(validatedOutputIndices[i]) || validatedOutputIndices[i] < -3 || validatedOutputIndices[i] >= outputCount) {
              throw new Error(`Invalid output index: ${validatedOutputIndices[i]}`);
            }
            if (validatedOutputIndices[i] === -3) {
              continue;
            }
            const isTemporary = validatedOutputIndices[i] === -1;
            const isPersistent = validatedOutputIndices[i] === -2;
            const tensorView = isTemporary || isPersistent ? createIntermediateOutput(outputs[i].dataType, outputs[i].dims) : createKernelOutput(validatedOutputIndices[i], outputs[i].dataType, outputs[i].dims);
            outputTensorViews.push(tensorView);
            if (tensorView.data === 0) {
              continue;
            }
            const gpuData = this.gpuDataManager.get(tensorView.data);
            if (!gpuData) {
              throw new Error(`no GPU data for output: ${tensorView.data}`);
            }
            if (isTemporary) {
              this.temporaryData.push(gpuData);
            }
            if (isPersistent) {
              let persistentData = this.kernelPersistentData.get(this.currentKernelId);
              if (!persistentData) {
                persistentData = [];
                this.kernelPersistentData.set(this.currentKernelId, persistentData);
              }
              persistentData.push(gpuData);
            }
            outputDatas.push(gpuData);
          }
          if (inputDatas.length !== inputTensorViews.length || outputDatas.length !== outputTensorViews.length) {
            if (outputDatas.length === 0) {
              TRACE_FUNC_END(program.name);
              return outputTensorViews;
            }
            throw new Error(
              `Program ${program.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`
            );
          }
          let uniformBufferBinding;
          if (programUniforms) {
            let currentOffset = 0;
            const offsets = [];
            programUniforms.forEach((v) => {
              const data = typeof v.data === "number" ? [v.data] : v.data;
              if (data.length === 0) {
                return;
              }
              const sizeOfElement = v.type === 10 /* float16 */ ? 2 : 4;
              let sizeOfVecOrMat;
              let baseAlignment;
              if (v.type === 10 /* float16 */) {
                baseAlignment = data.length > 4 ? 16 : data.length > 2 ? 8 : data.length * sizeOfElement;
                sizeOfVecOrMat = data.length > 4 ? 16 : sizeOfElement * data.length;
              } else {
                baseAlignment = data.length <= 2 ? data.length * sizeOfElement : 16;
                sizeOfVecOrMat = 16;
              }
              currentOffset = Math.ceil(currentOffset / baseAlignment) * baseAlignment;
              offsets.push(currentOffset);
              const elementPerVecOrMat = v.type === 10 /* float16 */ ? 8 : 4;
              currentOffset += data.length > 4 ? Math.ceil(data.length / elementPerVecOrMat) * sizeOfVecOrMat : data.length * sizeOfElement;
            });
            const maxAlignmentOfField = 16;
            currentOffset = Math.ceil(currentOffset / maxAlignmentOfField) * maxAlignmentOfField;
            const arrayBuffer = new ArrayBuffer(currentOffset);
            programUniforms.forEach((v, i) => {
              const offset = offsets[i];
              const data = typeof v.data === "number" ? [v.data] : v.data;
              if (v.type === 6 /* int32 */) {
                new Int32Array(arrayBuffer, offset, data.length).set(data);
              } else if (v.type === 12 /* uint32 */) {
                new Uint32Array(arrayBuffer, offset, data.length).set(data);
              } else if (v.type === 10 /* float16 */) {
                new Uint16Array(arrayBuffer, offset, data.length).set(data);
              } else if (v.type === 1 /* float */) {
                new Float32Array(arrayBuffer, offset, data.length).set(data);
              } else {
                throw new Error(`Unsupported uniform type: ${tensorDataTypeEnumToString(v.type)}`);
              }
            });
            const uniformBufferData = (
              // eslint-disable-next-line no-bitwise
              this.gpuDataManager.create(currentOffset, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM)
            );
            this.device.queue.writeBuffer(uniformBufferData.buffer, 0, arrayBuffer, 0, currentOffset);
            this.gpuDataManager.release(uniformBufferData.id);
            uniformBufferBinding = { offset: 0, size: currentOffset, buffer: uniformBufferData.buffer };
          }
          const normalizedDispatchGroup = this.programManager.normalizeDispatchGroupSize(dispatchGroup);
          const is1DimensionDispatch = normalizedDispatchGroup[1] === 1 && normalizedDispatchGroup[2] === 1;
          const key = getProgramInfoUniqueKey(program, inputTensorViews, is1DimensionDispatch);
          let artifact = this.programManager.getArtifact(key);
          if (!artifact) {
            artifact = this.programManager.build(program, normalizedDispatchGroup);
            this.programManager.setArtifact(key, artifact);
            LOG_DEBUG("info", () => `[artifact] key: ${key}, programName: ${program.name}`);
          }
          if (programUniforms && artifact.uniformVariablesInfo) {
            if (programUniforms.length !== artifact.uniformVariablesInfo.length) {
              throw new Error(
                `Uniform variables count mismatch: expect ${artifact.uniformVariablesInfo.length}, got ${programUniforms.length} in program "${artifact.programInfo.name}".`
              );
            }
            for (let i = 0; i < programUniforms.length; i++) {
              const uniform = programUniforms[i];
              const actualType = uniform.type;
              const actualLength = typeof uniform.data === "number" ? 1 : uniform.data.length;
              const [type, length] = artifact.uniformVariablesInfo[i];
              if (actualType !== type || actualLength !== length) {
                throw new Error(
                  `Uniform variable ${i} mismatch: expect type ${type} with size ${length}, got type ${actualType} with size ${actualLength} in program "${artifact.programInfo.name}".`
                );
              }
            }
          }
          LOG_DEBUG(
            "info",
            () => `[ProgramManager] run "${program.name}" (key=${key}) with ${normalizedDispatchGroup[0]}x${normalizedDispatchGroup[1]}x${normalizedDispatchGroup[2]}`
          );
          if (this.queryType !== "none" || this.sessionStatus === "capturing") {
            const pendingKernelInfo = {
              kernelId: this.currentKernelId,
              programName: artifact.programInfo.name,
              inputTensorViews,
              outputTensorViews
            };
            this.pendingKernels.push(pendingKernelInfo);
            if (this.sessionStatus === "capturing") {
              const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
              sessionPendingKernels.push(pendingKernelInfo);
            }
          }
          this.programManager.run(artifact, inputDatas, outputDatas, normalizedDispatchGroup, uniformBufferBinding);
          TRACE_FUNC_END(program.name);
          return outputTensorViews;
        }
        upload(gpuDataId, data) {
          this.gpuDataManager.upload(gpuDataId, data);
        }
        memcpy(src, dst) {
          this.gpuDataManager.memcpy(src, dst);
        }
        async download(gpuDataId, getTargetBuffer) {
          await this.gpuDataManager.download(gpuDataId, getTargetBuffer);
        }
        alloc(size) {
          return this.gpuDataManager.create(size).id;
        }
        free(ptr) {
          return this.gpuDataManager.release(ptr);
        }
        createKernel(kernelType, kernelId, attribute, kernelName) {
          const op = WEBGPU_OP_RESOLVE_RULES.get(kernelType);
          if (!op) {
            throw new Error(`kernel not implemented: ${kernelType}`);
          }
          const kernelInfo = {
            kernelType,
            kernelName,
            kernelEntry: op[0],
            attributes: [op[1], attribute]
          };
          this.kernels.set(kernelId, kernelInfo);
        }
        releaseKernel(kernelId) {
          const persistentData = this.kernelPersistentData.get(kernelId);
          if (persistentData) {
            for (const data of persistentData) {
              this.gpuDataManager.release(data.id);
            }
            this.kernelPersistentData.delete(kernelId);
          }
          this.kernelCustomData.delete(kernelId);
          this.kernels.delete(kernelId);
        }
        computeKernel(kernelId, context, errors) {
          const kernel = this.kernels.get(kernelId);
          if (!kernel) {
            throw new Error(`kernel not created: ${kernelId}`);
          }
          const kernelType = kernel.kernelType;
          const kernelName = kernel.kernelName;
          const kernelEntry = kernel.kernelEntry;
          const attributes = kernel.attributes;
          if (this.currentKernelId !== null) {
            throw new Error(`kernel "[${kernelType}] ${kernelName}" is not allowed to be called recursively`);
          }
          this.currentKernelId = kernelId;
          if (attributes[0]) {
            attributes[1] = attributes[0](attributes[1]);
            attributes[0] = void 0;
          }
          LOG_DEBUG("info", () => `[WebGPU] Start to run kernel "[${kernelType}] ${kernelName}"...`);
          const useErrorScope = this.env.debug;
          this.temporaryData = [];
          try {
            if (useErrorScope) {
              this.device.pushErrorScope("validation");
            }
            kernelEntry(context, attributes[1]);
            return 0;
          } catch (e) {
            errors.push(Promise.resolve(`[WebGPU] Kernel "[${kernelType}] ${kernelName}" failed. ${e}`));
            return 1;
          } finally {
            if (useErrorScope) {
              errors.push(
                this.device.popErrorScope().then(
                  (err) => err ? `GPU validation error for kernel "[${kernelType}] ${kernelName}": ${err.message}` : null
                )
              );
            }
            for (const data of this.temporaryData) {
              this.gpuDataManager.release(data.id);
            }
            this.temporaryData = [];
            this.currentKernelId = null;
          }
        }
        // #region external buffer
        registerBuffer(sessionId, index, buffer, size) {
          let sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
          if (!sessionInputOutputMapping) {
            sessionInputOutputMapping = /* @__PURE__ */ new Map();
            this.sessionExternalDataMapping.set(sessionId, sessionInputOutputMapping);
          }
          const previousBuffer = sessionInputOutputMapping.get(index);
          const id = this.gpuDataManager.registerExternalBuffer(buffer, size, previousBuffer);
          sessionInputOutputMapping.set(index, [id, buffer]);
          return id;
        }
        unregisterBuffers(sessionId) {
          const sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
          if (sessionInputOutputMapping) {
            sessionInputOutputMapping.forEach((bufferInfo) => this.gpuDataManager.unregisterExternalBuffer(bufferInfo[0]));
            this.sessionExternalDataMapping.delete(sessionId);
          }
        }
        getBuffer(gpuDataId) {
          const gpuData = this.gpuDataManager.get(gpuDataId);
          if (!gpuData) {
            throw new Error(`no GPU data for buffer: ${gpuDataId}`);
          }
          return gpuData.buffer;
        }
        createDownloader(gpuBuffer, size, type) {
          return async () => {
            const data = await downloadGpuData(this, gpuBuffer, size);
            return createView(data.buffer, type);
          };
        }
        // #endregion
        writeTimestamp(index) {
          if (this.queryType !== "inside-passes") {
            return;
          }
          this.computePassEncoder.writeTimestamp(this.querySet, index);
        }
        setQueryType() {
          this.queryType = "none";
          if (this.env.webgpu.profiling?.mode === "default" || (typeof this.env.trace === "undefined" ? this.env.wasm.trace : this.env.trace)) {
            if (this.device.features.has("chromium-experimental-timestamp-query-inside-passes")) {
              this.queryType = "inside-passes";
            } else if (this.device.features.has("timestamp-query")) {
              this.queryType = "at-passes";
            }
            if (this.queryType !== "none" && typeof this.querySet === "undefined") {
              this.querySet = this.device.createQuerySet({
                type: "timestamp",
                count: this.maxDispatchNumber * 2
              });
              this.queryResolveBuffer = this.device.createBuffer(
                // eslint-disable-next-line no-bitwise
                { size: this.maxDispatchNumber * 2 * 8, usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE }
              );
            }
          }
        }
        captureBegin() {
          LOG_DEBUG("info", "captureBegin");
          if (!this.capturedCommandList.get(this.currentSessionId)) {
            this.capturedCommandList.set(this.currentSessionId, []);
          }
          if (!this.capturedPendingKernels.get(this.currentSessionId)) {
            this.capturedPendingKernels.set(this.currentSessionId, []);
          }
          this.flush();
          this.sessionStatus = "capturing";
        }
        captureEnd() {
          LOG_DEBUG("info", "captureEnd");
          this.flush();
          this.sessionStatus = "default";
        }
        replay() {
          LOG_DEBUG("info", "replay");
          this.sessionStatus = "replaying";
          const sessionCommandList = this.capturedCommandList.get(this.currentSessionId);
          const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
          const length = sessionCommandList.length;
          this.pendingKernels = [];
          for (let i = 0; i < length; i++) {
            const computePassEncoder = this.getComputePassEncoder();
            const command = sessionCommandList[i];
            this.writeTimestamp(this.pendingDispatchNumber * 2);
            computePassEncoder.setPipeline(command.computePipeline);
            computePassEncoder.setBindGroup(0, command.bindGroup);
            computePassEncoder.dispatchWorkgroups(...command.dispatchGroup);
            this.writeTimestamp(this.pendingDispatchNumber * 2 + 1);
            this.pendingDispatchNumber++;
            if (this.queryType !== "none") {
              this.pendingKernels.push(sessionPendingKernels[i]);
            }
            if (this.pendingDispatchNumber >= this.maxDispatchNumber || this.queryType === "at-passes") {
              this.endComputePass();
            }
            if (this.pendingDispatchNumber >= this.maxDispatchNumber) {
              this.flush();
            }
          }
          this.flush();
          this.sessionStatus = "default";
        }
        onCreateSession() {
          this.gpuDataManager.onCreateSession();
        }
        onReleaseSession(sessionId) {
          this.unregisterBuffers(sessionId);
          if (this.capturedCommandList.has(sessionId)) {
            this.capturedCommandList.delete(sessionId);
          }
          if (this.capturedPendingKernels.has(sessionId)) {
            this.capturedPendingKernels.delete(sessionId);
          }
          this.gpuDataManager.onReleaseSession(sessionId);
        }
        onRunStart(sessionId) {
          this.currentSessionId = sessionId;
          this.setQueryType();
        }
      };
    }
  });

  // web/lib/wasm/jsep/init.ts
  var init_exports = {};
  __export(init_exports, {
    init: () => init
  });
  var TensorViewImpl, ComputeContextImpl, init;
  var init_init = __esm({
    "web/lib/wasm/jsep/init.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_util();
      init_backend_webnn();
      TensorViewImpl = class _TensorViewImpl {
        constructor(module, dataType, data, dims) {
          this.module = module;
          this.dataType = dataType;
          this.data = data;
          this.dims = dims;
        }
        getFloat32Array() {
          if (this.dataType !== 1 /* float */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new Float32Array() : new Float32Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        getBigInt64Array() {
          if (this.dataType !== 7 /* int64 */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new BigInt64Array() : new BigInt64Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        getInt32Array() {
          if (this.dataType !== 6 /* int32 */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new Int32Array() : new Int32Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        getUint16Array() {
          if (this.dataType !== 10 /* float16 */ && this.dataType !== 4 /* uint16 */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new Uint16Array() : new Uint16Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        reshape(newDims) {
          if (ShapeUtil.size(newDims) !== ShapeUtil.size(this.dims)) {
            throw new Error("Invalid new shape");
          }
          return new _TensorViewImpl(this.module, this.dataType, this.data, newDims);
        }
      };
      ComputeContextImpl = class {
        constructor(module, backend, contextDataOffset) {
          this.module = module;
          this.backend = backend;
          this.customDataOffset = 0;
          this.customDataSize = 0;
          this.adapterInfo = backend.adapterInfo;
          const ptrSize = module.PTR_SIZE;
          let dataIndex = contextDataOffset / module.PTR_SIZE;
          const type = ptrSize === 4 ? "i32" : "i64";
          this.opKernelContext = Number(module.getValue(ptrSize * dataIndex++, type));
          const inputCount = Number(module.getValue(ptrSize * dataIndex++, type));
          this.outputCount = Number(module.getValue(ptrSize * dataIndex++, type));
          this.customDataOffset = Number(module.getValue(ptrSize * dataIndex++, "*"));
          this.customDataSize = Number(module.getValue(ptrSize * dataIndex++, type));
          const inputs = [];
          for (let i = 0; i < inputCount; i++) {
            const dataType = Number(module.getValue(ptrSize * dataIndex++, type));
            const data = Number(module.getValue(ptrSize * dataIndex++, "*"));
            const dim = Number(module.getValue(ptrSize * dataIndex++, type));
            const dims = [];
            for (let d = 0; d < dim; d++) {
              dims.push(Number(module.getValue(ptrSize * dataIndex++, type)));
            }
            inputs.push(new TensorViewImpl(module, dataType, data, dims));
          }
          this.inputs = inputs;
        }
        get kernelCustomData() {
          return this.backend.currentKernelCustomData;
        }
        get customDataBuffer() {
          return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);
        }
        compute(program, inputsOutputsMapping) {
          const mappedInputs = inputsOutputsMapping?.inputs?.map((i) => typeof i === "number" ? this.inputs[i] : i) ?? this.inputs;
          const outputIndices = inputsOutputsMapping?.outputs ?? [];
          const createKernelOutput = (index, dataType, dims) => new TensorViewImpl(this.module, dataType, this.output(index, dims), dims);
          const createTemporaryOutput = (dataType, dims) => {
            const bufferSize = calculateTensorSizeInBytes(dataType, dims);
            if (!bufferSize) {
              throw new Error(`Unsupported data type: ${dataType}`);
            }
            const gpuDataId = bufferSize > 0 ? this.backend.gpuDataManager.create(bufferSize).id : 0;
            return new TensorViewImpl(this.module, dataType, gpuDataId, dims);
          };
          return this.backend.run(
            program,
            mappedInputs,
            outputIndices,
            createKernelOutput,
            createTemporaryOutput,
            this.outputCount
          );
        }
        output(index, dims) {
          const stack = this.module.stackSave();
          try {
            const ptrSize = this.module.PTR_SIZE;
            const type = ptrSize === 4 ? "i32" : "i64";
            const data = this.module.stackAlloc(
              (1 + dims.length) * ptrSize
              /* sizeof(size_t) */
            );
            this.module.setValue(data, dims.length, type);
            for (let i = 0; i < dims.length; i++) {
              this.module.setValue(data + ptrSize * (i + 1), dims[i], type);
            }
            return this.module._JsepOutput(this.opKernelContext, index, data);
          } catch (e) {
            throw new Error(
              `Failed to generate kernel's output[${index}] with dims [${dims}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${e}`
            );
          } finally {
            this.module.stackRestore(stack);
          }
        }
      };
      init = async (name, module, env3, gpuAdapter) => {
        const jsepInit = module.jsepInit;
        if (!jsepInit) {
          throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");
        }
        if (name === "webgpu") {
          const webGpuBackendImpl = (init_backend_webgpu(), __toCommonJS(backend_webgpu_exports)).WebGpuBackend;
          const backend = new webGpuBackendImpl();
          await backend.initialize(env3, gpuAdapter);
          jsepInit("webgpu", [
            // backend
            backend,
            // jsepAlloc()
            (size) => backend.alloc(Number(size)),
            // jsepFree()
            (ptr) => backend.free(ptr),
            // jsepCopy(src, dst, size, isSourceGpu)
            (src, dst, size, isSourceGpu = false) => {
              if (isSourceGpu) {
                LOG_DEBUG(
                  "verbose",
                  () => `[WebGPU] jsepCopyGpuToGpu: src=${Number(src)}, dst=${Number(dst)}, size=${Number(size)}`
                );
                backend.memcpy(Number(src), Number(dst));
              } else {
                LOG_DEBUG(
                  "verbose",
                  () => `[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(src)}, gpuDataId=${Number(dst)}, size=${Number(size)}`
                );
                const data = module.HEAPU8.subarray(Number(src >>> 0), Number(src >>> 0) + Number(size));
                backend.upload(Number(dst), data);
              }
            },
            // jsepCopyAsync(src, dst, size)
            async (gpuDataId, dataOffset, size) => {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] jsepCopyGpuToCpu: gpuDataId=${gpuDataId}, dataOffset=${dataOffset}, size=${size}`
              );
              await backend.download(
                Number(gpuDataId),
                () => module.HEAPU8.subarray(Number(dataOffset) >>> 0, Number(dataOffset + size) >>> 0)
              );
            },
            // jsepCreateKernel
            (kernelType, kernelId, attribute) => backend.createKernel(
              kernelType,
              Number(kernelId),
              attribute,
              module.UTF8ToString(module._JsepGetNodeName(Number(kernelId)))
            ),
            // jsepReleaseKernel
            (kernel) => backend.releaseKernel(kernel),
            // jsepRun
            (kernel, contextDataOffset, sessionHandle, errors) => {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] jsepRun: sessionHandle=${sessionHandle}, kernel=${kernel}, contextDataOffset=${contextDataOffset}`
              );
              const context = new ComputeContextImpl(module, backend, Number(contextDataOffset));
              return backend.computeKernel(Number(kernel), context, errors);
            },
            // jsepCaptureBegin
            () => backend.captureBegin(),
            // jsepCaptureEnd
            () => backend.captureEnd(),
            // jsepReplay
            () => backend.replay()
          ]);
        } else {
          const backend = new WebNNBackend(env3);
          jsepInit("webnn", [
            backend,
            // webnnReserveTensorId
            () => backend.reserveTensorId(),
            // webnnReleaseTensorId
            (tensorId) => backend.releaseTensorId(tensorId),
            // webnnEnsureTensor
            async (sessionId, tensorId, onnxDataType, shape, copyOld) => backend.ensureTensor(sessionId, tensorId, onnxDataType, shape, copyOld),
            // webnnUploadTensor
            (tensorId, data) => {
              backend.uploadTensor(tensorId, data);
            },
            // webnnDownloadTensor
            async (tensorId, dstBuffer) => backend.downloadTensor(tensorId, dstBuffer),
            // webnnRegisterMLContext
            (sessionId, mlContext) => backend.registerMLContext(sessionId, mlContext),
            // webnnEnableTraceEvent
            !!env3.trace
          ]);
        }
      };
    }
  });

  // web/lib/wasm/wasm-core-impl.ts
  var initOrt, initRuntime, initEp, activeSessions, getSessionInputOutputCount, getSessionInputOutputMetadata, copyFromExternalBuffer, createSession, releaseSession, prepareInputOutputTensor, run, endProfiling, extractTransferableBuffers;
  var init_wasm_core_impl = __esm({
    "web/lib/wasm/wasm-core-impl.ts"() {
      "use strict";
      init_esm();
      init_run_options();
      init_session_options();
      init_wasm_common();
      init_wasm_factory();
      init_wasm_utils();
      init_wasm_utils_load_file();
      initOrt = (numThreads, loggingLevel) => {
        const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);
        if (errorCode !== 0) {
          checkLastError("Can't initialize onnxruntime.");
        }
      };
      initRuntime = async (env3) => {
        initOrt(env3.wasm.numThreads, logLevelStringToEnum(env3.logLevel));
      };
      initEp = async (env3, epName) => {
        getInstance().asyncInit?.();
        let webgpuAdapter = env3.webgpu.adapter;
        if (epName === "webgpu") {
          if (typeof navigator === "undefined" || !navigator.gpu) {
            throw new Error("WebGPU is not supported in current environment");
          }
          if (!webgpuAdapter) {
            const powerPreference = env3.webgpu.powerPreference;
            if (powerPreference !== void 0 && powerPreference !== "low-power" && powerPreference !== "high-performance") {
              throw new Error(`Invalid powerPreference setting: "${powerPreference}"`);
            }
            const forceFallbackAdapter = env3.webgpu.forceFallbackAdapter;
            if (forceFallbackAdapter !== void 0 && typeof forceFallbackAdapter !== "boolean") {
              throw new Error(`Invalid forceFallbackAdapter setting: "${forceFallbackAdapter}"`);
            }
            webgpuAdapter = await navigator.gpu.requestAdapter({ powerPreference, forceFallbackAdapter });
            if (!webgpuAdapter) {
              throw new Error(
                'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.'
              );
            }
          } else {
            if (typeof webgpuAdapter.limits !== "object" || typeof webgpuAdapter.features !== "object" || typeof webgpuAdapter.requestDevice !== "function") {
              throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.");
            }
          }
        }
        if (epName === "webnn") {
          if (typeof navigator === "undefined" || !navigator.ml) {
            throw new Error("WebNN is not supported in current environment");
          }
        }
        if (true) {
          const initJsep = (init_init(), __toCommonJS(init_exports)).init;
          if (epName === "webgpu") {
            await initJsep("webgpu", getInstance(), env3, webgpuAdapter);
          }
          if (epName === "webnn") {
            await initJsep("webnn", getInstance(), env3);
          }
        } else {
          if (false) {
            getInstance().webgpuInit((device) => {
              env3.webgpu.device = device;
            });
          }
          if (epName === "webnn") {
            const backend = new null.WebNNBackend(env3);
            getInstance().webnnInit([
              backend,
              // webnnReserveTensorId
              () => backend.reserveTensorId(),
              // webnnReleaseTensorId,
              (tensorId) => backend.releaseTensorId(tensorId),
              // webnnEnsureTensor
              async (sessionId, tensorId, onnxDataType, shape, copyOld) => backend.ensureTensor(sessionId, tensorId, onnxDataType, shape, copyOld),
              // webnnUploadTensor
              (tensorId, data) => {
                backend.uploadTensor(tensorId, data);
              },
              // webnnDownloadTensor
              async (tensorId, dstBuffer) => backend.downloadTensor(tensorId, dstBuffer),
              // webnnRegisterMLContext
              (sessionId, mlContext) => backend.registerMLContext(sessionId, mlContext),
              // webnnEnableTraceEvent
              !!env3.trace
            ]);
          }
        }
      };
      activeSessions = /* @__PURE__ */ new Map();
      getSessionInputOutputCount = (sessionHandle) => {
        const wasm2 = getInstance();
        const stack = wasm2.stackSave();
        try {
          const ptrSize = wasm2.PTR_SIZE;
          const dataOffset = wasm2.stackAlloc(2 * ptrSize);
          const errorCode = wasm2._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + ptrSize);
          if (errorCode !== 0) {
            checkLastError("Can't get session input/output count.");
          }
          const type = ptrSize === 4 ? "i32" : "i64";
          return [Number(wasm2.getValue(dataOffset, type)), Number(wasm2.getValue(dataOffset + ptrSize, type))];
        } finally {
          wasm2.stackRestore(stack);
        }
      };
      getSessionInputOutputMetadata = (sessionHandle, index) => {
        const wasm2 = getInstance();
        const stack = wasm2.stackSave();
        let metadataOffset = 0;
        try {
          const ptrSize = wasm2.PTR_SIZE;
          const dataOffset = wasm2.stackAlloc(2 * ptrSize);
          const errorCode = wasm2._OrtGetInputOutputMetadata(sessionHandle, index, dataOffset, dataOffset + ptrSize);
          if (errorCode !== 0) {
            checkLastError("Can't get session input/output metadata.");
          }
          const nameOffset = Number(wasm2.getValue(dataOffset, "*"));
          metadataOffset = Number(wasm2.getValue(dataOffset + ptrSize, "*"));
          const elementType = wasm2.HEAP32[metadataOffset / 4];
          if (elementType === 0) {
            return [nameOffset, 0];
          }
          const dimsCount = wasm2.HEAPU32[metadataOffset / 4 + 1];
          const dims = [];
          for (let i = 0; i < dimsCount; i++) {
            const symbolicDimNameOffset = Number(wasm2.getValue(metadataOffset + 8 + i * ptrSize, "*"));
            dims.push(
              symbolicDimNameOffset !== 0 ? wasm2.UTF8ToString(symbolicDimNameOffset) : Number(wasm2.getValue(metadataOffset + 8 + (i + dimsCount) * ptrSize, "*"))
            );
          }
          return [nameOffset, elementType, dims];
        } finally {
          wasm2.stackRestore(stack);
          if (metadataOffset !== 0) {
            wasm2._OrtFree(metadataOffset);
          }
        }
      };
      copyFromExternalBuffer = (model) => {
        const wasm2 = getInstance();
        const modelDataOffset = wasm2._malloc(model.byteLength);
        if (modelDataOffset === 0) {
          throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);
        }
        wasm2.HEAPU8.set(model, modelDataOffset);
        return [modelDataOffset, model.byteLength];
      };
      createSession = async (modelData, options) => {
        let modelDataOffset, modelDataLength;
        const wasm2 = getInstance();
        if (Array.isArray(modelData)) {
          [modelDataOffset, modelDataLength] = modelData;
        } else if (modelData.buffer === wasm2.HEAPU8.buffer) {
          [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];
        } else {
          [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);
        }
        let sessionHandle = 0;
        let sessionOptionsHandle = 0;
        let ioBindingHandle = 0;
        let allocs = [];
        const inputNamesUTF8Encoded = [];
        const outputNamesUTF8Encoded = [];
        try {
          [sessionOptionsHandle, allocs] = await setSessionOptions(options);
          if (options?.externalData && wasm2.mountExternalData) {
            const loadingPromises = [];
            for (const file of options.externalData) {
              const path = typeof file === "string" ? file : file.path;
              loadingPromises.push(
                loadFile(typeof file === "string" ? file : file.data).then((data) => {
                  wasm2.mountExternalData(path, data);
                })
              );
            }
            await Promise.all(loadingPromises);
          }
          for (const provider of options?.executionProviders ?? []) {
            const providerName = typeof provider === "string" ? provider : provider.name;
            if (providerName === "webnn") {
              wasm2.shouldTransferToMLTensor = false;
              if (typeof provider !== "string") {
                const webnnOptions = provider;
                const context = webnnOptions?.context;
                const gpuDevice = webnnOptions?.gpuDevice;
                const deviceType = webnnOptions?.deviceType;
                const powerPreference = webnnOptions?.powerPreference;
                if (context) {
                  wasm2.currentContext = context;
                } else if (gpuDevice) {
                  wasm2.currentContext = await wasm2.webnnCreateMLContext(gpuDevice);
                } else {
                  wasm2.currentContext = await wasm2.webnnCreateMLContext({ deviceType, powerPreference });
                }
              } else {
                wasm2.currentContext = await wasm2.webnnCreateMLContext();
              }
              break;
            }
          }
          sessionHandle = await wasm2._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);
          wasm2.webgpuOnCreateSession?.(sessionHandle);
          if (sessionHandle === 0) {
            checkLastError("Can't create a session.");
          }
          wasm2.jsepOnCreateSession?.();
          if (wasm2.currentContext) {
            wasm2.webnnRegisterMLContext(sessionHandle, wasm2.currentContext);
            wasm2.currentContext = void 0;
            wasm2.shouldTransferToMLTensor = true;
          }
          const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);
          const enableGraphCapture = !!options?.enableGraphCapture;
          const inputNames = [];
          const outputNames = [];
          const inputMetadata = [];
          const outputMetadata = [];
          const outputPreferredLocations = [];
          for (let i = 0; i < inputCount; i++) {
            const [nameOffset, elementType, shape] = getSessionInputOutputMetadata(sessionHandle, i);
            if (nameOffset === 0) {
              checkLastError("Can't get an input name.");
            }
            inputNamesUTF8Encoded.push(nameOffset);
            const name = wasm2.UTF8ToString(nameOffset);
            inputNames.push(name);
            inputMetadata.push(
              elementType === 0 ? { name, isTensor: false } : { name, isTensor: true, type: tensorDataTypeEnumToString(elementType), shape }
            );
          }
          for (let i = 0; i < outputCount; i++) {
            const [nameOffset, elementType, shape] = getSessionInputOutputMetadata(sessionHandle, i + inputCount);
            if (nameOffset === 0) {
              checkLastError("Can't get an output name.");
            }
            outputNamesUTF8Encoded.push(nameOffset);
            const nameString = wasm2.UTF8ToString(nameOffset);
            outputNames.push(nameString);
            outputMetadata.push(
              elementType === 0 ? { name: nameString, isTensor: false } : { name: nameString, isTensor: true, type: tensorDataTypeEnumToString(elementType), shape }
            );
            if (true) {
              if (enableGraphCapture && options?.preferredOutputLocation === void 0) {
                outputPreferredLocations.push("gpu-buffer");
                continue;
              }
              const location2 = typeof options?.preferredOutputLocation === "string" ? options.preferredOutputLocation : options?.preferredOutputLocation?.[nameString] ?? "cpu";
              const isGraphOutput = wasm2.webnnIsGraphOutput;
              if (location2 === "cpu" && isGraphOutput && isGraphOutput(sessionHandle, nameString)) {
                outputPreferredLocations.push("ml-tensor-cpu-output");
                continue;
              }
              if (location2 !== "cpu" && location2 !== "cpu-pinned" && location2 !== "gpu-buffer" && location2 !== "ml-tensor") {
                throw new Error(`Not supported preferred output location: ${location2}.`);
              }
              if (enableGraphCapture && location2 !== "gpu-buffer") {
                throw new Error(
                  `Not supported preferred output location: ${location2}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`
                );
              }
              outputPreferredLocations.push(location2);
            }
          }
          let bindingState = null;
          if (outputPreferredLocations.some((l) => l === "gpu-buffer" || l === "ml-tensor" || l === "ml-tensor-cpu-output")) {
            ioBindingHandle = wasm2._OrtCreateBinding(sessionHandle);
            if (ioBindingHandle === 0) {
              checkLastError("Can't create IO binding.");
            }
            bindingState = {
              handle: ioBindingHandle,
              outputPreferredLocations,
              outputPreferredLocationsEncoded: outputPreferredLocations.map((l) => l === "ml-tensor-cpu-output" ? "ml-tensor" : l).map((l) => dataLocationStringToEnum(l))
            };
          }
          activeSessions.set(sessionHandle, [
            sessionHandle,
            inputNamesUTF8Encoded,
            outputNamesUTF8Encoded,
            bindingState,
            enableGraphCapture,
            false
          ]);
          return [sessionHandle, inputNames, outputNames, inputMetadata, outputMetadata];
        } catch (e) {
          inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
          outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
          if (ioBindingHandle !== 0) {
            if (wasm2._OrtReleaseBinding(ioBindingHandle) !== 0) {
              checkLastError("Can't release IO binding.");
            }
          }
          if (sessionHandle !== 0) {
            if (wasm2._OrtReleaseSession(sessionHandle) !== 0) {
              checkLastError("Can't release session.");
            }
          }
          throw e;
        } finally {
          wasm2._free(modelDataOffset);
          if (sessionOptionsHandle !== 0) {
            if (wasm2._OrtReleaseSessionOptions(sessionOptionsHandle) !== 0) {
              checkLastError("Can't release session options.");
            }
          }
          allocs.forEach((alloc) => wasm2._free(alloc));
          wasm2.unmountExternalData?.();
        }
      };
      releaseSession = (sessionId) => {
        const wasm2 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error(`cannot release session. invalid session id: ${sessionId}`);
        }
        const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture] = session;
        if (ioBindingState) {
          if (enableGraphCapture) {
            if (wasm2._OrtClearBoundOutputs(ioBindingState.handle) !== 0) {
              checkLastError("Can't clear bound outputs.");
            }
          }
          if (wasm2._OrtReleaseBinding(ioBindingState.handle) !== 0) {
            checkLastError("Can't release IO binding.");
          }
        }
        wasm2.jsepOnReleaseSession?.(sessionId);
        wasm2.webnnOnReleaseSession?.(sessionId);
        wasm2.webgpuOnReleaseSession?.(sessionId);
        inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        if (wasm2._OrtReleaseSession(sessionHandle) !== 0) {
          checkLastError("Can't release session.");
        }
        activeSessions.delete(sessionId);
      };
      prepareInputOutputTensor = async (tensor, tensorHandles, allocs, sessionId, tensorNameUTF8Encoded, index, enableGraphCapture = false) => {
        if (!tensor) {
          tensorHandles.push(0);
          return;
        }
        const wasm2 = getInstance();
        const ptrSize = wasm2.PTR_SIZE;
        const dataType = tensor[0];
        const dims = tensor[1];
        const location2 = tensor[3];
        let actualLocation = location2;
        let rawData;
        let dataByteLength;
        if (dataType === "string" && (location2 === "gpu-buffer" || location2 === "ml-tensor")) {
          throw new Error("String tensor is not supported on GPU.");
        }
        if (enableGraphCapture && location2 !== "gpu-buffer") {
          throw new Error(
            `External buffer must be provided for input/output index ${index} when enableGraphCapture is true.`
          );
        }
        if (location2 === "gpu-buffer") {
          const gpuBuffer = tensor[2].gpuBuffer;
          dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
          if (false) {
            const registerBuffer = wasm2.webgpuRegisterBuffer;
            if (!registerBuffer) {
              throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
            }
            rawData = registerBuffer(gpuBuffer, sessionId);
          } else {
            const registerBuffer = wasm2.jsepRegisterBuffer;
            if (!registerBuffer) {
              throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
            }
            rawData = registerBuffer(sessionId, index, gpuBuffer, dataByteLength);
          }
        } else if (location2 === "ml-tensor") {
          const mlTensor = tensor[2].mlTensor;
          dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
          const registerMLTensor = wasm2.webnnRegisterMLTensor;
          if (!registerMLTensor) {
            throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
          }
          rawData = registerMLTensor(sessionId, mlTensor, tensorDataTypeStringToEnum(dataType), dims);
        } else {
          const data = tensor[2];
          if (Array.isArray(data)) {
            dataByteLength = ptrSize * data.length;
            rawData = wasm2._malloc(dataByteLength);
            allocs.push(rawData);
            for (let i = 0; i < data.length; i++) {
              if (typeof data[i] !== "string") {
                throw new TypeError(`tensor data at index ${i} is not a string`);
              }
              wasm2.setValue(rawData + i * ptrSize, allocWasmString(data[i], allocs), "*");
            }
          } else {
            const isGraphInput = wasm2.webnnIsGraphInput;
            const isGraphOutput = wasm2.webnnIsGraphOutput;
            if (dataType !== "string" && isGraphInput && isGraphOutput) {
              const tensorName = wasm2.UTF8ToString(tensorNameUTF8Encoded);
              if (isGraphInput(sessionId, tensorName) || isGraphOutput(sessionId, tensorName)) {
                const dataTypeEnum = tensorDataTypeStringToEnum(dataType);
                dataByteLength = calculateTensorSizeInBytes(dataTypeEnum, dims);
                actualLocation = "ml-tensor";
                const createTemporaryTensor = wasm2.webnnCreateTemporaryTensor;
                const uploadTensor = wasm2.webnnUploadTensor;
                if (!createTemporaryTensor || !uploadTensor) {
                  throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
                }
                const tensorId = await createTemporaryTensor(sessionId, dataTypeEnum, dims);
                uploadTensor(tensorId, new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
                rawData = tensorId;
              } else {
                dataByteLength = data.byteLength;
                rawData = wasm2._malloc(dataByteLength);
                allocs.push(rawData);
                wasm2.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
              }
            } else {
              dataByteLength = data.byteLength;
              rawData = wasm2._malloc(dataByteLength);
              allocs.push(rawData);
              wasm2.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
            }
          }
        }
        const stack = wasm2.stackSave();
        const dimsOffset = wasm2.stackAlloc(4 * dims.length);
        try {
          dims.forEach((d, index2) => wasm2.setValue(dimsOffset + index2 * ptrSize, d, ptrSize === 4 ? "i32" : "i64"));
          const tensor2 = wasm2._OrtCreateTensor(
            tensorDataTypeStringToEnum(dataType),
            rawData,
            dataByteLength,
            dimsOffset,
            dims.length,
            dataLocationStringToEnum(actualLocation)
          );
          if (tensor2 === 0) {
            checkLastError(`Can't create tensor for input/output. session=${sessionId}, index=${index}.`);
          }
          tensorHandles.push(tensor2);
        } finally {
          wasm2.stackRestore(stack);
        }
      };
      run = async (sessionId, inputIndices, inputTensors, outputIndices, outputTensors, options) => {
        const wasm2 = getInstance();
        const ptrSize = wasm2.PTR_SIZE;
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error(`cannot run inference. invalid session id: ${sessionId}`);
        }
        const sessionHandle = session[0];
        const inputNamesUTF8Encoded = session[1];
        const outputNamesUTF8Encoded = session[2];
        const ioBindingState = session[3];
        const enableGraphCapture = session[4];
        const inputOutputBound = session[5];
        const inputCount = inputIndices.length;
        const outputCount = outputIndices.length;
        let runOptionsHandle = 0;
        let runOptionsAllocs = [];
        const inputTensorHandles = [];
        const outputTensorHandles = [];
        const inputOutputAllocs = [];
        const beforeRunStack = wasm2.stackSave();
        const inputValuesOffset = wasm2.stackAlloc(inputCount * ptrSize);
        const inputNamesOffset = wasm2.stackAlloc(inputCount * ptrSize);
        const outputValuesOffset = wasm2.stackAlloc(outputCount * ptrSize);
        const outputNamesOffset = wasm2.stackAlloc(outputCount * ptrSize);
        try {
          [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);
          TRACE_EVENT_BEGIN("wasm prepareInputOutputTensor");
          for (let i = 0; i < inputCount; i++) {
            await prepareInputOutputTensor(
              inputTensors[i],
              inputTensorHandles,
              inputOutputAllocs,
              sessionId,
              inputNamesUTF8Encoded[inputIndices[i]],
              inputIndices[i],
              enableGraphCapture
            );
          }
          for (let i = 0; i < outputCount; i++) {
            await prepareInputOutputTensor(
              outputTensors[i],
              outputTensorHandles,
              inputOutputAllocs,
              sessionId,
              outputNamesUTF8Encoded[outputIndices[i]],
              inputCount + outputIndices[i],
              enableGraphCapture
            );
          }
          TRACE_EVENT_END("wasm prepareInputOutputTensor");
          for (let i = 0; i < inputCount; i++) {
            wasm2.setValue(inputValuesOffset + i * ptrSize, inputTensorHandles[i], "*");
            wasm2.setValue(inputNamesOffset + i * ptrSize, inputNamesUTF8Encoded[inputIndices[i]], "*");
          }
          for (let i = 0; i < outputCount; i++) {
            wasm2.setValue(outputValuesOffset + i * ptrSize, outputTensorHandles[i], "*");
            wasm2.setValue(outputNamesOffset + i * ptrSize, outputNamesUTF8Encoded[outputIndices[i]], "*");
          }
          if (ioBindingState && !inputOutputBound) {
            const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;
            if (inputNamesUTF8Encoded.length !== inputCount) {
              throw new Error(
                `input count from feeds (${inputCount}) is expected to be always equal to model's input count (${inputNamesUTF8Encoded.length}).`
              );
            }
            TRACE_EVENT_BEGIN("wasm bindInputsOutputs");
            for (let i = 0; i < inputCount; i++) {
              const index = inputIndices[i];
              const errorCode2 = await wasm2._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind input[${i}] for session=${sessionId}.`);
              }
            }
            for (let i = 0; i < outputCount; i++) {
              const index = outputIndices[i];
              const location2 = outputTensors[i]?.[3];
              if (location2) {
                const errorCode2 = wasm2._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);
                if (errorCode2 !== 0) {
                  checkLastError(`Can't bind pre-allocated output[${i}] for session=${sessionId}.`);
                }
              } else {
                const errorCode2 = wasm2._OrtBindOutput(
                  handle,
                  outputNamesUTF8Encoded[index],
                  0,
                  outputPreferredLocationsEncoded[index]
                );
                if (errorCode2 !== 0) {
                  checkLastError(`Can't bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);
                }
              }
            }
            TRACE_EVENT_END("wasm bindInputsOutputs");
            activeSessions.set(sessionId, [
              sessionHandle,
              inputNamesUTF8Encoded,
              outputNamesUTF8Encoded,
              ioBindingState,
              enableGraphCapture,
              true
            ]);
          }
          wasm2.jsepOnRunStart?.(sessionHandle);
          wasm2.webnnOnRunStart?.(sessionHandle);
          let errorCode;
          if (ioBindingState) {
            errorCode = await wasm2._OrtRunWithBinding(
              sessionHandle,
              ioBindingState.handle,
              outputCount,
              outputValuesOffset,
              runOptionsHandle
            );
          } else {
            errorCode = await wasm2._OrtRun(
              sessionHandle,
              inputNamesOffset,
              inputValuesOffset,
              inputCount,
              outputNamesOffset,
              outputCount,
              outputValuesOffset,
              runOptionsHandle
            );
          }
          if (errorCode !== 0) {
            checkLastError("failed to call OrtRun().");
          }
          const output = [];
          const outputPromises = [];
          TRACE_EVENT_BEGIN("wasm ProcessOutputTensor");
          for (let i = 0; i < outputCount; i++) {
            const tensor = Number(wasm2.getValue(outputValuesOffset + i * ptrSize, "*"));
            if (tensor === outputTensorHandles[i]) {
              output.push(outputTensors[i]);
              continue;
            }
            const beforeGetTensorDataStack = wasm2.stackSave();
            const tensorDataOffset = wasm2.stackAlloc(4 * ptrSize);
            let keepOutputTensor = false;
            let type, dataOffset = 0;
            try {
              const errorCode2 = wasm2._OrtGetTensorData(
                tensor,
                tensorDataOffset,
                tensorDataOffset + ptrSize,
                tensorDataOffset + 2 * ptrSize,
                tensorDataOffset + 3 * ptrSize
              );
              if (errorCode2 !== 0) {
                checkLastError(`Can't access output tensor data on index ${i}.`);
              }
              const valueType = ptrSize === 4 ? "i32" : "i64";
              const dataType = Number(wasm2.getValue(tensorDataOffset, valueType));
              dataOffset = wasm2.getValue(tensorDataOffset + ptrSize, "*");
              const dimsOffset = wasm2.getValue(tensorDataOffset + ptrSize * 2, "*");
              const dimsLength = Number(wasm2.getValue(tensorDataOffset + ptrSize * 3, valueType));
              const dims = [];
              for (let i2 = 0; i2 < dimsLength; i2++) {
                dims.push(Number(wasm2.getValue(dimsOffset + i2 * ptrSize, valueType)));
              }
              if (wasm2._OrtFree(dimsOffset) !== 0) {
                checkLastError("Can't free memory for tensor dims.");
              }
              const size = dims.reduce((a, b) => a * b, 1);
              type = tensorDataTypeEnumToString(dataType);
              const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];
              if (type === "string") {
                if (preferredLocation === "gpu-buffer" || preferredLocation === "ml-tensor") {
                  throw new Error("String tensor is not supported on GPU.");
                }
                const stringData = [];
                for (let i2 = 0; i2 < size; i2++) {
                  const offset = wasm2.getValue(dataOffset + i2 * ptrSize, "*");
                  const nextOffset = wasm2.getValue(dataOffset + (i2 + 1) * ptrSize, "*");
                  const maxBytesToRead = i2 === size - 1 ? void 0 : nextOffset - offset;
                  stringData.push(wasm2.UTF8ToString(offset, maxBytesToRead));
                }
                output.push([type, dims, stringData, "cpu"]);
              } else {
                if (preferredLocation === "gpu-buffer" && size > 0) {
                  const getBuffer = false ? wasm2.webgpuGetBuffer : wasm2.jsepGetBuffer;
                  if (!getBuffer) {
                    throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
                  }
                  const gpuBuffer = getBuffer(dataOffset);
                  const bufferSize = calculateTensorSizeInBytes(dataType, size);
                  if (bufferSize === void 0 || !isGpuBufferSupportedType(type)) {
                    throw new Error(`Unsupported data type: ${type}`);
                  }
                  keepOutputTensor = true;
                  if (false) {
                    wasm2.webgpuRegisterBuffer(gpuBuffer, sessionId, dataOffset);
                    const downloadDataFunction = wasm2.webgpuCreateDownloader(gpuBuffer, bufferSize, sessionId);
                    output.push([
                      type,
                      dims,
                      {
                        gpuBuffer,
                        download: async () => {
                          const arrayBuffer = await downloadDataFunction();
                          const data = new (tensorTypeToTypedArrayConstructor(type))(arrayBuffer);
                          return data;
                        },
                        dispose: () => {
                          if (wasm2._OrtReleaseTensor(tensor) !== 0) {
                            checkLastError("Can't release tensor.");
                          }
                        }
                      },
                      "gpu-buffer"
                    ]);
                  } else {
                    output.push([
                      type,
                      dims,
                      {
                        gpuBuffer,
                        download: wasm2.jsepCreateDownloader(gpuBuffer, bufferSize, type),
                        dispose: () => {
                          if (wasm2._OrtReleaseTensor(tensor) !== 0) {
                            checkLastError("Can't release tensor.");
                          }
                        }
                      },
                      "gpu-buffer"
                    ]);
                  }
                } else if (preferredLocation === "ml-tensor" && size > 0) {
                  const ensureTensor = wasm2.webnnEnsureTensor;
                  const isGraphInputOutputTypeSupported = wasm2.webnnIsGraphInputOutputTypeSupported;
                  if (!ensureTensor || !isGraphInputOutputTypeSupported) {
                    throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');
                  }
                  const tensorSize = calculateTensorSizeInBytes(dataType, size);
                  if (tensorSize === void 0 || !isMLTensorSupportedType(type)) {
                    throw new Error(`Unsupported data type: ${type}`);
                  }
                  if (!isGraphInputOutputTypeSupported(sessionId, type, false)) {
                    throw new Error(
                      `preferredLocation "ml-tensor" for ${type} output is not supported by current WebNN Context.`
                    );
                  }
                  const mlTensor = await ensureTensor(sessionId, dataOffset, dataType, dims, false);
                  keepOutputTensor = true;
                  output.push([
                    type,
                    dims,
                    {
                      mlTensor,
                      download: wasm2.webnnCreateMLTensorDownloader(dataOffset, type),
                      dispose: () => {
                        wasm2.webnnReleaseTensorId(dataOffset);
                        wasm2._OrtReleaseTensor(tensor);
                      }
                    },
                    "ml-tensor"
                  ]);
                } else if (preferredLocation === "ml-tensor-cpu-output" && size > 0) {
                  const data = wasm2.webnnCreateMLTensorDownloader(dataOffset, type)();
                  const index = output.length;
                  keepOutputTensor = true;
                  outputPromises.push(
                    (async () => {
                      const result = [index, await data];
                      wasm2.webnnReleaseTensorId(dataOffset);
                      wasm2._OrtReleaseTensor(tensor);
                      return result;
                    })()
                  );
                  output.push([type, dims, [], "cpu"]);
                } else {
                  const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);
                  const data = new typedArrayConstructor(size);
                  new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(
                    wasm2.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength)
                  );
                  output.push([type, dims, data, "cpu"]);
                }
              }
            } finally {
              wasm2.stackRestore(beforeGetTensorDataStack);
              if (type === "string" && dataOffset) {
                wasm2._free(dataOffset);
              }
              if (!keepOutputTensor) {
                wasm2._OrtReleaseTensor(tensor);
              }
            }
          }
          if (ioBindingState && !enableGraphCapture) {
            if (wasm2._OrtClearBoundOutputs(ioBindingState.handle) !== 0) {
              checkLastError("Can't clear bound outputs.");
            }
            activeSessions.set(sessionId, [
              sessionHandle,
              inputNamesUTF8Encoded,
              outputNamesUTF8Encoded,
              ioBindingState,
              enableGraphCapture,
              false
            ]);
          }
          for (const [index, data] of await Promise.all(outputPromises)) {
            output[index][2] = data;
          }
          TRACE_EVENT_END("wasm ProcessOutputTensor");
          return output;
        } finally {
          wasm2.webnnOnRunEnd?.(sessionHandle);
          wasm2.stackRestore(beforeRunStack);
          if (false) {
            inputTensors.forEach((t) => {
              if (t && t[3] === "gpu-buffer") {
                wasm2.webgpuUnregisterBuffer(t[2].gpuBuffer);
              }
            });
            outputTensors.forEach((t) => {
              if (t && t[3] === "gpu-buffer") {
                wasm2.webgpuUnregisterBuffer(t[2].gpuBuffer);
              }
            });
          }
          inputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
          outputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
          inputOutputAllocs.forEach((p) => wasm2._free(p));
          if (runOptionsHandle !== 0) {
            wasm2._OrtReleaseRunOptions(runOptionsHandle);
          }
          runOptionsAllocs.forEach((p) => wasm2._free(p));
        }
      };
      endProfiling = (sessionId) => {
        const wasm2 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error("invalid session id");
        }
        const sessionHandle = session[0];
        const profileFileName = wasm2._OrtEndProfiling(sessionHandle);
        if (profileFileName === 0) {
          checkLastError("Can't get an profile file name.");
        }
        wasm2._OrtFree(profileFileName);
      };
      extractTransferableBuffers = (tensors) => {
        const buffers = [];
        for (const tensor of tensors) {
          const data = tensor[2];
          if (!Array.isArray(data) && "buffer" in data) {
            buffers.push(data.buffer);
          }
        }
        return buffers;
      };
    }
  });

  // web/lib/wasm/proxy-wrapper.ts
  var isProxy, proxyWorker, initializing2, initialized2, aborted2, temporaryObjectUrl, initWasmCallbacks, queuedCallbacks, enqueueCallbacks, ensureWorker, onProxyWorkerMessage, initializeWebAssemblyAndOrtRuntime, initializeOrtEp, copyFromExternalBuffer2, createSession2, releaseSession2, run2, endProfiling2;
  var init_proxy_wrapper = __esm({
    "web/lib/wasm/proxy-wrapper.ts"() {
      "use strict";
      init_esm();
      init_wasm_core_impl();
      init_wasm_factory();
      init_wasm_utils_import();
      isProxy = () => !!env2.wasm.proxy && typeof document !== "undefined";
      initializing2 = false;
      initialized2 = false;
      aborted2 = false;
      queuedCallbacks = /* @__PURE__ */ new Map();
      enqueueCallbacks = (type, callbacks) => {
        const queue = queuedCallbacks.get(type);
        if (queue) {
          queue.push(callbacks);
        } else {
          queuedCallbacks.set(type, [callbacks]);
        }
      };
      ensureWorker = () => {
        if (initializing2 || !initialized2 || aborted2 || !proxyWorker) {
          throw new Error("worker not ready");
        }
      };
      onProxyWorkerMessage = (ev) => {
        switch (ev.data.type) {
          case "init-wasm":
            initializing2 = false;
            if (ev.data.err) {
              aborted2 = true;
              initWasmCallbacks[1](ev.data.err);
            } else {
              initialized2 = true;
              initWasmCallbacks[0]();
            }
            if (temporaryObjectUrl) {
              URL.revokeObjectURL(temporaryObjectUrl);
              temporaryObjectUrl = void 0;
            }
            break;
          case "init-ep":
          case "copy-from":
          case "create":
          case "release":
          case "run":
          case "end-profiling": {
            const callbacks = queuedCallbacks.get(ev.data.type);
            if (ev.data.err) {
              callbacks.shift()[1](ev.data.err);
            } else {
              callbacks.shift()[0](ev.data.out);
            }
            break;
          }
          default:
        }
      };
      initializeWebAssemblyAndOrtRuntime = async () => {
        if (initialized2) {
          return;
        }
        if (initializing2) {
          throw new Error("multiple calls to 'initWasm()' detected.");
        }
        if (aborted2) {
          throw new Error("previous call to 'initWasm()' failed.");
        }
        initializing2 = true;
        if (isProxy()) {
          return new Promise((resolve, reject) => {
            proxyWorker?.terminate();
            void importProxyWorker().then(([objectUrl, worker]) => {
              try {
                proxyWorker = worker;
                proxyWorker.onerror = (ev) => reject(ev);
                proxyWorker.onmessage = onProxyWorkerMessage;
                initWasmCallbacks = [resolve, reject];
                const message = { type: "init-wasm", in: env2 };
                if (!message.in.wasm.wasmPaths && objectUrl) {
                  const inferredWasmPathPrefix = inferWasmPathPrefixFromScriptSrc();
                  if (inferredWasmPathPrefix) {
                    message.in.wasm.wasmPaths = inferredWasmPathPrefix;
                  }
                }
                if (false) {
                  message.in.wasm.wasmPaths = {
                    wasm: true ? new URL("ort-wasm-simd-threaded.jsep.wasm", void 0).href : false ? new URL("ort-wasm-simd-threaded.asyncify.wasm", void 0).href : new URL("ort-wasm-simd-threaded.wasm", void 0).href
                  };
                }
                proxyWorker.postMessage(message);
                temporaryObjectUrl = objectUrl;
              } catch (e) {
                reject(e);
              }
            }, reject);
          });
        } else {
          try {
            await initializeWebAssembly(env2.wasm);
            await initRuntime(env2);
            initialized2 = true;
          } catch (e) {
            aborted2 = true;
            throw e;
          } finally {
            initializing2 = false;
          }
        }
      };
      initializeOrtEp = async (epName) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("init-ep", [resolve, reject]);
            const message = { type: "init-ep", in: { epName, env: env2 } };
            proxyWorker.postMessage(message);
          });
        } else {
          await initEp(env2, epName);
        }
      };
      copyFromExternalBuffer2 = async (buffer) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("copy-from", [resolve, reject]);
            const message = { type: "copy-from", in: { buffer } };
            proxyWorker.postMessage(message, [buffer.buffer]);
          });
        } else {
          return copyFromExternalBuffer(buffer);
        }
      };
      createSession2 = async (model, options) => {
        if (isProxy()) {
          if (options?.preferredOutputLocation) {
            throw new Error('session option "preferredOutputLocation" is not supported for proxy.');
          }
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("create", [resolve, reject]);
            const message = { type: "create", in: { model, options: { ...options } } };
            const transferable = [];
            if (model instanceof Uint8Array) {
              transferable.push(model.buffer);
            }
            proxyWorker.postMessage(message, transferable);
          });
        } else {
          return createSession(model, options);
        }
      };
      releaseSession2 = async (sessionId) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("release", [resolve, reject]);
            const message = { type: "release", in: sessionId };
            proxyWorker.postMessage(message);
          });
        } else {
          releaseSession(sessionId);
        }
      };
      run2 = async (sessionId, inputIndices, inputs, outputIndices, outputs, options) => {
        if (isProxy()) {
          if (inputs.some((t) => t[3] !== "cpu")) {
            throw new Error("input tensor on GPU is not supported for proxy.");
          }
          if (outputs.some((t) => t)) {
            throw new Error("pre-allocated output tensor is not supported for proxy.");
          }
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("run", [resolve, reject]);
            const serializableInputs = inputs;
            const message = {
              type: "run",
              in: { sessionId, inputIndices, inputs: serializableInputs, outputIndices, options }
            };
            proxyWorker.postMessage(message, extractTransferableBuffers(serializableInputs));
          });
        } else {
          return run(sessionId, inputIndices, inputs, outputIndices, outputs, options);
        }
      };
      endProfiling2 = async (sessionId) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("end-profiling", [resolve, reject]);
            const message = { type: "end-profiling", in: sessionId };
            proxyWorker.postMessage(message);
          });
        } else {
          endProfiling(sessionId);
        }
      };
    }
  });

  // web/lib/wasm/session-handler-inference.ts
  var encodeTensorMetadata, decodeTensorMetadata, OnnxruntimeWebAssemblySessionHandler;
  var init_session_handler_inference = __esm({
    "web/lib/wasm/session-handler-inference.ts"() {
      "use strict";
      init_esm();
      init_proxy_wrapper();
      init_wasm_common();
      init_wasm_utils_env();
      init_wasm_utils_load_file();
      encodeTensorMetadata = (tensor, getName) => {
        switch (tensor.location) {
          case "cpu":
            return [tensor.type, tensor.dims, tensor.data, "cpu"];
          case "gpu-buffer":
            return [tensor.type, tensor.dims, { gpuBuffer: tensor.gpuBuffer }, "gpu-buffer"];
          case "ml-tensor":
            return [tensor.type, tensor.dims, { mlTensor: tensor.mlTensor }, "ml-tensor"];
          default:
            throw new Error(`invalid data location: ${tensor.location} for ${getName()}`);
        }
      };
      decodeTensorMetadata = (tensor) => {
        switch (tensor[3]) {
          case "cpu":
            return new Tensor2(tensor[0], tensor[2], tensor[1]);
          case "gpu-buffer": {
            const dataType = tensor[0];
            if (!isGpuBufferSupportedType(dataType)) {
              throw new Error(`not supported data type: ${dataType} for deserializing GPU tensor`);
            }
            const { gpuBuffer, download, dispose } = tensor[2];
            return Tensor2.fromGpuBuffer(gpuBuffer, { dataType, dims: tensor[1], download, dispose });
          }
          case "ml-tensor": {
            const dataType = tensor[0];
            if (!isMLTensorSupportedType(dataType)) {
              throw new Error(`not supported data type: ${dataType} for deserializing MLTensor tensor`);
            }
            const { mlTensor, download, dispose } = tensor[2];
            return Tensor2.fromMLTensor(mlTensor, { dataType, dims: tensor[1], download, dispose });
          }
          default:
            throw new Error(`invalid data location: ${tensor[3]}`);
        }
      };
      OnnxruntimeWebAssemblySessionHandler = class {
        async fetchModelAndCopyToWasmMemory(path) {
          return copyFromExternalBuffer2(await loadFile(path));
        }
        async loadModel(pathOrBuffer, options) {
          TRACE_FUNC_BEGIN();
          let model;
          if (typeof pathOrBuffer === "string") {
            if (isNode) {
              model = await loadFile(pathOrBuffer);
            } else {
              model = await this.fetchModelAndCopyToWasmMemory(pathOrBuffer);
            }
          } else {
            model = pathOrBuffer;
          }
          [this.sessionId, this.inputNames, this.outputNames, this.inputMetadata, this.outputMetadata] = await createSession2(
            model,
            options
          );
          TRACE_FUNC_END();
        }
        async dispose() {
          return releaseSession2(this.sessionId);
        }
        async run(feeds, fetches, options) {
          TRACE_FUNC_BEGIN();
          const inputArray = [];
          const inputIndices = [];
          Object.entries(feeds).forEach((kvp) => {
            const name = kvp[0];
            const tensor = kvp[1];
            const index = this.inputNames.indexOf(name);
            if (index === -1) {
              throw new Error(`invalid input '${name}'`);
            }
            inputArray.push(tensor);
            inputIndices.push(index);
          });
          const outputArray = [];
          const outputIndices = [];
          Object.entries(fetches).forEach((kvp) => {
            const name = kvp[0];
            const tensor = kvp[1];
            const index = this.outputNames.indexOf(name);
            if (index === -1) {
              throw new Error(`invalid output '${name}'`);
            }
            outputArray.push(tensor);
            outputIndices.push(index);
          });
          const inputs = inputArray.map(
            (t, i) => encodeTensorMetadata(t, () => `input "${this.inputNames[inputIndices[i]]}"`)
          );
          const outputs = outputArray.map(
            (t, i) => t ? encodeTensorMetadata(t, () => `output "${this.outputNames[outputIndices[i]]}"`) : null
          );
          const results = await run2(this.sessionId, inputIndices, inputs, outputIndices, outputs, options);
          const resultMap = {};
          for (let i = 0; i < results.length; i++) {
            resultMap[this.outputNames[outputIndices[i]]] = outputArray[i] ?? decodeTensorMetadata(results[i]);
          }
          TRACE_FUNC_END();
          return resultMap;
        }
        startProfiling() {
        }
        endProfiling() {
          void endProfiling2(this.sessionId);
        }
      };
    }
  });

  // web/lib/backend-wasm.ts
  var backend_wasm_exports = {};
  __export(backend_wasm_exports, {
    OnnxruntimeWebAssemblyBackend: () => OnnxruntimeWebAssemblyBackend,
    initializeFlags: () => initializeFlags,
    wasmBackend: () => wasmBackend
  });
  var initializeFlags, OnnxruntimeWebAssemblyBackend, wasmBackend;
  var init_backend_wasm = __esm({
    "web/lib/backend-wasm.ts"() {
      "use strict";
      init_esm();
      init_proxy_wrapper();
      init_session_handler_inference();
      initializeFlags = () => {
        if (typeof env2.wasm.initTimeout !== "number" || env2.wasm.initTimeout < 0) {
          env2.wasm.initTimeout = 0;
        }
        const simd = env2.wasm.simd;
        if (typeof simd !== "boolean" && simd !== void 0 && simd !== "fixed" && simd !== "relaxed") {
          console.warn(
            `Property "env.wasm.simd" is set to unknown value "${simd}". Reset it to \`false\` and ignore SIMD feature checking.`
          );
          env2.wasm.simd = false;
        }
        if (typeof env2.wasm.proxy !== "boolean") {
          env2.wasm.proxy = false;
        }
        if (typeof env2.wasm.trace !== "boolean") {
          env2.wasm.trace = false;
        }
        if (typeof env2.wasm.numThreads !== "number" || !Number.isInteger(env2.wasm.numThreads) || env2.wasm.numThreads <= 0) {
          if (typeof self !== "undefined" && !self.crossOriginIsolated) {
            env2.wasm.numThreads = 1;
          } else {
            const numCpuLogicalCores = typeof navigator === "undefined" ? __require("node:os").cpus().length : navigator.hardwareConcurrency;
            env2.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));
          }
        }
      };
      OnnxruntimeWebAssemblyBackend = class {
        /**
         * This function initializes the WebAssembly backend.
         *
         * This function will be called only once for each backend name. It will be called the first time when
         * `ort.InferenceSession.create()` is called with a registered backend name.
         *
         * @param backendName - the registered backend name.
         */
        async init(backendName) {
          initializeFlags();
          await initializeWebAssemblyAndOrtRuntime();
          await initializeOrtEp(backendName);
        }
        async createInferenceSessionHandler(pathOrBuffer, options) {
          const handler = new OnnxruntimeWebAssemblySessionHandler();
          await handler.loadModel(pathOrBuffer, options);
          return handler;
        }
      };
      wasmBackend = new OnnxruntimeWebAssemblyBackend();
    }
  });

  // web/lib/index.ts
  var index_exports = {};
  __export(index_exports, {
    InferenceSession: () => InferenceSession2,
    TRACE: () => TRACE,
    TRACE_EVENT_BEGIN: () => TRACE_EVENT_BEGIN,
    TRACE_EVENT_END: () => TRACE_EVENT_END,
    TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
    TRACE_FUNC_END: () => TRACE_FUNC_END,
    Tensor: () => Tensor2,
    default: () => index_default,
    env: () => env2,
    registerBackend: () => registerBackend
  });
  init_esm();
  init_esm();
  init_esm();

  // web/lib/version.ts
  var version2 = "1.23.0-dev.20250906-ecb26fb775";

  // web/lib/index.ts
  var index_default = esm_exports;
  if (false) {
    const onnxjsBackend = null.onnxjsBackend;
    registerBackend("webgl", onnxjsBackend, -10);
  }
  if (false) {
    throw new Error(
      "The current build is specified to enable both JSEP and WebGPU EP. This is not a valid configuration. JSEP and WebGPU EPs cannot be enabled at the same time."
    );
  }
  if (false) {
    throw new Error(
      "The current build is specified to enable WebNN EP without JSEP or WebGPU EP. This is not a valid configuration. WebNN EP requires either JSEP or WebGPU EP to be enabled."
    );
  }
  if (true) {
    const wasmBackend2 = (init_backend_wasm(), __toCommonJS(backend_wasm_exports)).wasmBackend;
    if (true) {
      registerBackend("webgpu", wasmBackend2, 5);
    }
    if (true) {
      registerBackend("webnn", wasmBackend2, 5);
    }
    registerBackend("cpu", wasmBackend2, 10);
    registerBackend("wasm", wasmBackend2, 10);
  }
  Object.defineProperty(env2.versions, "web", { value: version2, enumerable: true });
  return __toCommonJS(index_exports);
})();
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
typeof exports=="object"&&typeof module=="object"&&(module.exports=ort);
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL2Vudi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvZW52LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLWNvbnZlcnNpb24taW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItaW1wbC10eXBlLW1hcHBpbmcudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItdXRpbHMtaW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdHJhY2UudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5mZXJlbmNlLXNlc3Npb24udHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItY29udmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvb25ueC1tb2RlbC50cyIsICIuLi8uLi9jb21tb24vbGliL29ubngtdmFsdWUudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9pbmRleC50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWVudi50cyIsICIuLi9saWIvd2FzbS9wcm94eS13b3JrZXIvbWFpbi50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50cyIsICIuLi9saWIvd2FzbS93YXNtLWZhY3RvcnkudHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy50cyIsICIuLi9saWIvd2FzbS9ydW4tb3B0aW9ucy50cyIsICIuLi9saWIvd2FzbS9zZXNzaW9uLW9wdGlvbnMudHMiLCAiLi4vbGliL3dhc20vd2FzbS1jb21tb24udHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1sb2FkLWZpbGUudHMiLCAiLi4vbGliL3dhc20vanNlcC9sb2cudHMiLCAiLi4vbGliL3dhc20vanNlcC91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvdGVuc29yLXZpZXcudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJubi90ZW5zb3ItbWFuYWdlci50cyIsICIuLi9saWIvd2FzbS9qc2VwL2JhY2tlbmQtd2Vibm4udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvdHlwZXMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvZ3B1LWRhdGEtbWFuYWdlci50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXkudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2NvbW1vbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvdHJhbnNwb3NlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yZWR1Y2Utc2hhcmVkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yZWR1Y2UudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2FyZ21pbm1heC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYXR0ZW50aW9uLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9iYXRjaC1ub3JtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9iaWFzLWFkZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvdW5hcnktb3AudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2JpYXMtc3BsaXQtZ2VsdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYmluYXJ5LW9wLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb25jYXQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2Z1c2UtdXRpbHMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9hY3RpdmF0aW9uX3V0aWwudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252X3V0aWwudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL21hdG11bC1zaGFkZXJzLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252MmRfbW1fd2ViZ3B1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udjNkX25haXZlX3dlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY29udi1ncm91cGVkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb252LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udl9iYWNrcHJvcF93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2NvbnYtdHJhbnNwb3NlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jdW1zdW0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2RlcHRoLXRvLXNwYWNlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9laW5zdW0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2V4cGFuZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZmFzdC1nZWx1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nYXRoZXIudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dhdGhlci1uZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZ2F0aGVyLWJsb2NrLXF1YW50aXplZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZ2F0aGVyLWVsZW1lbnRzLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nZW1tLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9ncmlkLXNhbXBsZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbXVsdGloZWFkLWF0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc3BsaXQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3JvdGFyeS1lbWJlZGRpbmcudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dyb3VwLXF1ZXJ5LWF0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvaW5zdGFuY2Utbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbGF5ZXItbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbWF0bXVsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9tYXRtdWxuYml0cy50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcGFkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9wb29sLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9xdWFudGl6ZS1saW5lYXIudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3JhbmdlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9zY2F0dGVyLW5kLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yZXNpemUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3NraXAtbGF5ZXItbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc2xpY2UudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3NvZnRtYXgudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3RpbGUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3doZXJlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wLXJlc29sdmUtcnVsZXMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvcHJvZ3JhbS1tYW5hZ2VyLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvYmFja2VuZC13ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC9pbml0LnRzIiwgIi4uL2xpYi93YXNtL3dhc20tY29yZS1pbXBsLnRzIiwgIi4uL2xpYi93YXNtL3Byb3h5LXdyYXBwZXIudHMiLCAiLi4vbGliL3dhc20vc2Vzc2lvbi1oYW5kbGVyLWluZmVyZW5jZS50cyIsICIuLi9saWIvYmFja2VuZC13YXNtLnRzIiwgIi4uL2xpYi9pbmRleC50cyIsICIuLi9saWIvdmVyc2lvbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEJhY2tlbmQgfSBmcm9tICcuL2JhY2tlbmQuanMnO1xuaW1wb3J0IHsgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuXG5pbnRlcmZhY2UgQmFja2VuZEluZm8ge1xuICBiYWNrZW5kOiBCYWNrZW5kO1xuICBwcmlvcml0eTogbnVtYmVyO1xuXG4gIGluaXRQcm9taXNlPzogUHJvbWlzZTx2b2lkPjtcbiAgaW5pdGlhbGl6ZWQ/OiBib29sZWFuO1xuICBhYm9ydGVkPzogYm9vbGVhbjtcbiAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbmNvbnN0IGJhY2tlbmRzOiBNYXA8c3RyaW5nLCBCYWNrZW5kSW5mbz4gPSBuZXcgTWFwKCk7XG5jb25zdCBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHk6IHN0cmluZ1tdID0gW107XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgYXMgYSBrZXkgdG8gbG9va3VwIGFzIGFuIGV4ZWN1dGlvbiBwcm92aWRlci5cbiAqIEBwYXJhbSBiYWNrZW5kIC0gdGhlIGJhY2tlbmQgb2JqZWN0LlxuICogQHBhcmFtIHByaW9yaXR5IC0gYW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBwcmlvcml0eSBvZiB0aGUgYmFja2VuZC4gSGlnaGVyIG51bWJlciBtZWFucyBoaWdoZXIgcHJpb3JpdHkuIGlmIHByaW9yaXR5XG4gKiA8IDAsIGl0IHdpbGwgYmUgY29uc2lkZXJlZCBhcyBhICdiZXRhJyB2ZXJzaW9uIGFuZCB3aWxsIG5vdCBiZSB1c2VkIGFzIGEgZmFsbGJhY2sgYmFja2VuZCBieSBkZWZhdWx0LlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyQmFja2VuZCA9IChuYW1lOiBzdHJpbmcsIGJhY2tlbmQ6IEJhY2tlbmQsIHByaW9yaXR5OiBudW1iZXIpOiB2b2lkID0+IHtcbiAgaWYgKGJhY2tlbmQgJiYgdHlwZW9mIGJhY2tlbmQuaW5pdCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYmFja2VuZC5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGN1cnJlbnRCYWNrZW5kID0gYmFja2VuZHMuZ2V0KG5hbWUpO1xuICAgIGlmIChjdXJyZW50QmFja2VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBiYWNrZW5kcy5zZXQobmFtZSwgeyBiYWNrZW5kLCBwcmlvcml0eSB9KTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRCYWNrZW5kLnByaW9yaXR5ID4gcHJpb3JpdHkpIHtcbiAgICAgIC8vIHNhbWUgbmFtZSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgd2l0aCBhIGhpZ2hlciBwcmlvcml0eS4gc2tpcCByZWdpc3RlcmF0aW9uLlxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPT09IHByaW9yaXR5KSB7XG4gICAgICBpZiAoY3VycmVudEJhY2tlbmQuYmFja2VuZCAhPT0gYmFja2VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWdpc3RlciBiYWNrZW5kIFwiJHtuYW1lfVwiIHVzaW5nIHByaW9yaXR5ICR7cHJpb3JpdHl9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByaW9yaXR5ID49IDApIHtcbiAgICAgIGNvbnN0IGkgPSBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYmFja2VuZHMuZ2V0KGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eVtpXSkhLnByaW9yaXR5IDw9IHByaW9yaXR5KSB7XG4gICAgICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnNwbGljZShpLCAwLCBuYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5wdXNoKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSB2YWxpZCBiYWNrZW5kJyk7XG59O1xuXG4vKipcbiAqIFRyeSB0byByZXNvbHZlIGFuZCBpbml0aWFsaXplIGEgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gYmFja2VuZE5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYmFja2VuZC5cbiAqIEByZXR1cm5zIHRoZSBiYWNrZW5kIGluc3RhbmNlIGlmIHJlc29sdmVkIGFuZCBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHksIG9yIGFuIGVycm9yIG1lc3NhZ2UgaWYgZmFpbGVkLlxuICovXG5jb25zdCB0cnlSZXNvbHZlQW5kSW5pdGlhbGl6ZUJhY2tlbmQgPSBhc3luYyAoYmFja2VuZE5hbWU6IHN0cmluZyk6IFByb21pc2U8QmFja2VuZCB8IHN0cmluZz4gPT4ge1xuICBjb25zdCBiYWNrZW5kSW5mbyA9IGJhY2tlbmRzLmdldChiYWNrZW5kTmFtZSk7XG4gIGlmICghYmFja2VuZEluZm8pIHtcbiAgICByZXR1cm4gJ2JhY2tlbmQgbm90IGZvdW5kLic7XG4gIH1cblxuICBpZiAoYmFja2VuZEluZm8uaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm4gYmFja2VuZEluZm8uYmFja2VuZDtcbiAgfSBlbHNlIGlmIChiYWNrZW5kSW5mby5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIGJhY2tlbmRJbmZvLmVycm9yITtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpc0luaXRpYWxpemluZyA9ICEhYmFja2VuZEluZm8uaW5pdFByb21pc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgYmFja2VuZEluZm8uaW5pdFByb21pc2UgPSBiYWNrZW5kSW5mby5iYWNrZW5kLmluaXQoYmFja2VuZE5hbWUpO1xuICAgICAgfVxuICAgICAgYXdhaXQgYmFja2VuZEluZm8uaW5pdFByb21pc2U7XG4gICAgICBiYWNrZW5kSW5mby5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICByZXR1cm4gYmFja2VuZEluZm8uYmFja2VuZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWlzSW5pdGlhbGl6aW5nKSB7XG4gICAgICAgIGJhY2tlbmRJbmZvLmVycm9yID0gYCR7ZX1gO1xuICAgICAgICBiYWNrZW5kSW5mby5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYWNrZW5kSW5mby5lcnJvciE7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRlbGV0ZSBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVzb2x2ZSBleGVjdXRpb24gcHJvdmlkZXJzIGZyb20gdGhlIHNwZWNpZmljIHNlc3Npb24gb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBzZXNzaW9uIG9wdGlvbnMgb2JqZWN0LlxuICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0dXBsZSBvZiBhbiBpbml0aWFsaXplZCBiYWNrZW5kIGluc3RhbmNlIGFuZCBhIHNlc3Npb24gb3B0aW9ucyBvYmplY3Qgd2l0aFxuICogZmlsdGVyZWQgRVAgbGlzdC5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyA9IGFzeW5jIChcbiAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbik6IFByb21pc2U8W2JhY2tlbmQ6IEJhY2tlbmQsIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnNdPiA9PiB7XG4gIC8vIGV4dHJhY3QgYmFja2VuZCBoaW50cyBmcm9tIHNlc3Npb24gb3B0aW9uc1xuICBjb25zdCBlcHMgPSBvcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycyB8fCBbXTtcbiAgY29uc3QgYmFja2VuZEhpbnRzID0gZXBzLm1hcCgoaSkgPT4gKHR5cGVvZiBpID09PSAnc3RyaW5nJyA/IGkgOiBpLm5hbWUpKTtcbiAgY29uc3QgYmFja2VuZE5hbWVzID0gYmFja2VuZEhpbnRzLmxlbmd0aCA9PT0gMCA/IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eSA6IGJhY2tlbmRIaW50cztcblxuICAvLyB0cnkgdG8gcmVzb2x2ZSBhbmQgaW5pdGlhbGl6ZSBhbGwgcmVxdWVzdGVkIGJhY2tlbmRzXG4gIGxldCBiYWNrZW5kOiBCYWNrZW5kIHwgdW5kZWZpbmVkO1xuICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgY29uc3QgYXZhaWxhYmxlQmFja2VuZE5hbWVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3QgYmFja2VuZE5hbWUgb2YgYmFja2VuZE5hbWVzKSB7XG4gICAgY29uc3QgcmVzb2x2ZVJlc3VsdCA9IGF3YWl0IHRyeVJlc29sdmVBbmRJbml0aWFsaXplQmFja2VuZChiYWNrZW5kTmFtZSk7XG4gICAgaWYgKHR5cGVvZiByZXNvbHZlUmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3JzLnB1c2goeyBuYW1lOiBiYWNrZW5kTmFtZSwgZXJyOiByZXNvbHZlUmVzdWx0IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWJhY2tlbmQpIHtcbiAgICAgICAgYmFja2VuZCA9IHJlc29sdmVSZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoYmFja2VuZCA9PT0gcmVzb2x2ZVJlc3VsdCkge1xuICAgICAgICBhdmFpbGFibGVCYWNrZW5kTmFtZXMuYWRkKGJhY2tlbmROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBpZiBubyBiYWNrZW5kIGlzIGF2YWlsYWJsZSwgdGhyb3cgZXJyb3IuXG4gIGlmICghYmFja2VuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbm8gYXZhaWxhYmxlIGJhY2tlbmQgZm91bmQuIEVSUjogJHtlcnJvcnMubWFwKChlKSA9PiBgWyR7ZS5uYW1lfV0gJHtlLmVycn1gKS5qb2luKCcsICcpfWApO1xuICB9XG5cbiAgLy8gZm9yIGVhY2ggZXhwbGljaXRseSByZXF1ZXN0ZWQgYmFja2VuZCwgaWYgaXQncyBub3QgYXZhaWxhYmxlLCBvdXRwdXQgd2FybmluZyBtZXNzYWdlLlxuICBmb3IgKGNvbnN0IHsgbmFtZSwgZXJyIH0gb2YgZXJyb3JzKSB7XG4gICAgaWYgKGJhY2tlbmRIaW50cy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYHJlbW92aW5nIHJlcXVlc3RlZCBleGVjdXRpb24gcHJvdmlkZXIgXCIke25hbWV9XCIgZnJvbSBzZXNzaW9uIG9wdGlvbnMgYmVjYXVzZSBpdCBpcyBub3QgYXZhaWxhYmxlOiAke2Vycn1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBmaWx0ZXJlZEVwcyA9IGVwcy5maWx0ZXIoKGkpID0+IGF2YWlsYWJsZUJhY2tlbmROYW1lcy5oYXModHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSkpO1xuXG4gIHJldHVybiBbXG4gICAgYmFja2VuZCxcbiAgICBuZXcgUHJveHkob3B0aW9ucywge1xuICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wID09PSAnZXhlY3V0aW9uUHJvdmlkZXJzJykge1xuICAgICAgICAgIHJldHVybiBmaWx0ZXJlZEVwcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wKTtcbiAgICAgIH0sXG4gICAgfSksXG4gIF07XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5pbXBvcnQgeyBPbm54VmFsdWUgfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgdHlwZSBGZWVkc1R5cGUgPSB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfTtcbiAgdHlwZSBGZXRjaGVzVHlwZSA9IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfTtcbiAgdHlwZSBSZXR1cm5UeXBlID0geyBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIH07XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBzaGFyZWQgU2Vzc2lvbkhhbmRsZXIgZnVuY3Rpb25hbGl0eVxuICpcbiAqIEBpZ25vcmVcbiAqL1xuaW50ZXJmYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIHJlYWRvbmx5IGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICByZWFkb25seSBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgcmVhZG9ubHkgaW5wdXRNZXRhZGF0YTogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhW107XG4gIHJlYWRvbmx5IG91dHB1dE1ldGFkYXRhOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGFbXTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBoYW5kbGVyIGluc3RhbmNlIG9mIGFuIGluZmVyZW5jZSBzZXNzaW9uLlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciBleHRlbmRzIFNlc3Npb25IYW5kbGVyIHtcbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZDtcbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgcnVuKFxuICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsXG4gICAgZmV0Y2hlczogU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUsXG4gICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuICApOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGJhY2tlbmQgdGhhdCBwcm92aWRlcyBpbXBsZW1lbnRhdGlvbiBvZiBtb2RlbCBpbmZlcmVuY2luZy5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2VuZCB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBiYWNrZW5kIGFzeW5jaHJvbm91c2x5LiBTaG91bGQgdGhyb3cgd2hlbiBmYWlsZWQuXG4gICAqL1xuICBpbml0KGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHVyaU9yQnVmZmVyOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPjtcbn1cblxuZXhwb3J0IHsgcmVnaXN0ZXJCYWNrZW5kIH0gZnJvbSAnLi9iYWNrZW5kLWltcGwuanMnO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IC9qcy9zY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLnRzXG4vLyBEbyBub3QgbW9kaWZ5IGZpbGUgY29udGVudCBtYW51YWxseS5cblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMS4yMy4wLWRldi4yMDI1MDcwMy03ZmM2MjM1ODYxJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRW52IH0gZnJvbSAnLi9lbnYuanMnO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcyc7XG5cbnR5cGUgTG9nTGV2ZWxUeXBlID0gRW52Wydsb2dMZXZlbCddO1xuXG5sZXQgbG9nTGV2ZWxWYWx1ZTogUmVxdWlyZWQ8TG9nTGV2ZWxUeXBlPiA9ICd3YXJuaW5nJztcblxuZXhwb3J0IGNvbnN0IGVudjogRW52ID0ge1xuICB3YXNtOiB7fSBhcyBFbnYuV2ViQXNzZW1ibHlGbGFncyxcbiAgd2ViZ2w6IHt9IGFzIEVudi5XZWJHTEZsYWdzLFxuICB3ZWJncHU6IHt9IGFzIEVudi5XZWJHcHVGbGFncyxcbiAgdmVyc2lvbnM6IHsgY29tbW9uOiB2ZXJzaW9uIH0sXG5cbiAgc2V0IGxvZ0xldmVsKHZhbHVlOiBMb2dMZXZlbFR5cGUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCBbJ3ZlcmJvc2UnLCAnaW5mbycsICd3YXJuaW5nJywgJ2Vycm9yJywgJ2ZhdGFsJ10uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7dmFsdWV9YCk7XG4gICAgfVxuICAgIGxvZ0xldmVsVmFsdWUgPSB2YWx1ZTtcbiAgfSxcbiAgZ2V0IGxvZ0xldmVsKCk6IFJlcXVpcmVkPExvZ0xldmVsVHlwZT4ge1xuICAgIHJldHVybiBsb2dMZXZlbFZhbHVlO1xuICB9LFxufTtcblxuLy8gc2V0IHByb3BlcnR5ICdsb2dMZXZlbCcgc28gdGhhdCB0aGV5IGNhbiBiZSBjb3JyZWN0bHkgdHJhbnNmZXJyZWQgdG8gd29ya2VyIGJ5IGBwb3N0TWVzc2FnZSgpYC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbnYsICdsb2dMZXZlbCcsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgZW52IGFzIGVudkltcGwgfSBmcm9tICcuL2Vudi1pbXBsLmpzJztcbmltcG9ydCB7IFRyeUdldEdsb2JhbFR5cGUgfSBmcm9tICcuL3R5cGUtaGVscGVyLmpzJztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEVudiB7XG4gIGV4cG9ydCB0eXBlIFdhc21QYXRoUHJlZml4ID0gc3RyaW5nO1xuICBleHBvcnQgaW50ZXJmYWNlIFdhc21GaWxlUGF0aHMge1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIG92ZXJyaWRlIHBhdGggZm9yIHRoZSBtYWluIC53YXNtIGZpbGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhdGggc2hvdWxkIGJlIGFuIGFic29sdXRlIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiBub3QgbW9kaWZpZWQsIHRoZSBmaWxlbmFtZSBvZiB0aGUgLndhc20gZmlsZSBpczpcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21gIGZvciBkZWZhdWx0IGJ1aWxkXG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLndhc21gIGZvciBKU0VQIGJ1aWxkICh3aXRoIFdlYkdQVSBhbmQgV2ViTk4pXG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC5hc3luY2lmeS53YXNtYCBmb3IgV2ViR1BVIGJ1aWxkIHdpdGggQXN5bmNpZnkgKHdpdGggV2ViTk4pXG4gICAgICovXG4gICAgd2FzbT86IFVSTCB8IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBvdmVycmlkZSBwYXRoIGZvciB0aGUgbWFpbiAubWpzIGZpbGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhdGggc2hvdWxkIGJlIGFuIGFic29sdXRlIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiBub3QgbW9kaWZpZWQsIHRoZSBmaWxlbmFtZSBvZiB0aGUgLm1qcyBmaWxlIGlzOlxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQubWpzYCBmb3IgZGVmYXVsdCBidWlsZFxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanNgIGZvciBKU0VQIGJ1aWxkICh3aXRoIFdlYkdQVSBhbmQgV2ViTk4pXG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC5hc3luY2lmeS5tanNgIGZvciBXZWJHUFUgYnVpbGQgd2l0aCBBc3luY2lmeSAod2l0aCBXZWJOTilcbiAgICAgKi9cbiAgICBtanM/OiBVUkwgfCBzdHJpbmc7XG4gIH1cbiAgZXhwb3J0IHR5cGUgV2FzbVByZWZpeE9yRmlsZVBhdGhzID0gV2FzbVBhdGhQcmVmaXggfCBXYXNtRmlsZVBhdGhzO1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYkFzc2VtYmx5RmxhZ3Mge1xuICAgIC8qKlxuICAgICAqIHNldCBvciBnZXQgbnVtYmVyIG9mIHRocmVhZChzKS4gSWYgb21pdHRlZCBvciBzZXQgdG8gMCwgbnVtYmVyIG9mIHRocmVhZChzKSB3aWxsIGJlIGRldGVybWluZWQgYnkgc3lzdGVtLiBJZiBzZXRcbiAgICAgKiB0byAxLCBubyB3b3JrZXIgdGhyZWFkIHdpbGwgYmUgc3Bhd25lZC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSB3aGVuIFdlYkFzc2VtYmx5IG11bHRpdGhyZWFkIGZlYXR1cmUgaXMgYXZhaWxhYmxlIGluIGN1cnJlbnQgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYDBgXG4gICAgICovXG4gICAgbnVtVGhyZWFkcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIHNldCBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBlbmFibGUgU0lNRC5cbiAgICAgKlxuICAgICAqIE9OTlggUnVudGltZSB3aWxsIHBlcmZvcm0gZmVhdHVyZSBkZXRlY3Rpb24gYmFzZWQgb24gdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkuIFNwZWNpZmljYWxseSwgd2hlbiB0aGUgdmFsdWUgaXNcbiAgICAgKiBzZXQgdG86XG4gICAgICogLSBgdW5kZWZpbmVkYCwgYHRydWVgIG9yIGBcImZpeGVkXCJgOiB3aWxsIGNoZWNrIGF2YWlsYWJpbGl0eSBvZiBGaXhlZC13aWR0aCBTSU1ELlxuICAgICAqIC0gYFwicmVsYXhlZFwiYDogd2lsbCBjaGVjayBhdmFpbGFiaWxpdHkgb2YgUmVsYXhlZCBTSU1ELlxuICAgICAqIC0gYGZhbHNlYDogd2lsbCBub3QgcGVyZm9ybSBTSU1EIGZlYXR1cmUgY2hlY2tpbmcuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgZG9lcyBub3QgbWFrZSBPTk5YIFJ1bnRpbWUgdG8gc3dpdGNoIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJ1bnRpbWUgYXV0b21hdGljYWxseS4gVXNlciBuZWVkXG4gICAgICogdG8gc2V0IGB3YXNtUGF0aHNgIG9yIGB3YXNtQmluYXJ5YCBwcm9wZXJ0eSB0byBsb2FkIHRoZSBjb3JyZXNwb25kaW5nIHJ1bnRpbWUuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgd2hlbiBXZWJBc3NlbWJseSBTSU1EIGZlYXR1cmUgaXMgYXZhaWxhYmxlIGluIGN1cnJlbnQgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYHRydWVgXG4gICAgICovXG4gICAgc2ltZD86IGJvb2xlYW4gfCAnZml4ZWQnIHwgJ3JlbGF4ZWQnO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGBlbnYudHJhY2VgIGluc3RlYWQuIElmIGBlbnYudHJhY2VgIGlzIHNldCwgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICovXG4gICAgdHJhY2U/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCBhIG51bWJlciBzcGVjaWZ5aW5nIHRoZSB0aW1lb3V0IGZvciBpbml0aWFsaXphdGlvbiBvZiBXZWJBc3NlbWJseSBiYWNrZW5kLCBpbiBtaWxsaXNlY29uZHMuIEEgemVyb1xuICAgICAqIHZhbHVlIGluZGljYXRlcyBubyB0aW1lb3V0IGlzIHNldC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYDBgXG4gICAgICovXG4gICAgaW5pdFRpbWVvdXQ/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBjdXN0b20gVVJMIHByZWZpeCB0byB0aGUgLndhc20vLm1qcyBmaWxlcywgb3IgYW4gb2JqZWN0IG9mIG92ZXJyaWRlcyBmb3IgYm90aCAud2FzbS8ubWpzIGZpbGUuIFRoZSBvdmVycmlkZVxuICAgICAqIHBhdGggc2hvdWxkIGJlIGFuIGFic29sdXRlIHBhdGguXG4gICAgICovXG4gICAgd2FzbVBhdGhzPzogV2FzbVByZWZpeE9yRmlsZVBhdGhzO1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY3VzdG9tIGJ1ZmZlciB3aGljaCBjb250YWlucyB0aGUgV2ViQXNzZW1ibHkgYmluYXJ5LiBJZiB0aGlzIHByb3BlcnR5IGlzIHNldCwgdGhlIGB3YXNtUGF0aHNgIHByb3BlcnR5IHdpbGxcbiAgICAgKiBiZSBpZ25vcmVkLlxuICAgICAqL1xuICAgIHdhc21CaW5hcnk/OiBBcnJheUJ1ZmZlckxpa2UgfCBVaW50OEFycmF5O1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIHByb3h5IHRoZSBleGVjdXRpb24gb2YgbWFpbiB0aHJlYWQgdG8gYSB3b3JrZXIgdGhyZWFkLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAgICovXG4gICAgcHJveHk/OiBib29sZWFuO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHTEZsYWdzIHtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBXZWJHTCBDb250ZXh0IElEICh3ZWJnbCBvciB3ZWJnbDIpLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgJ3dlYmdsMidgXG4gICAgICovXG4gICAgY29udGV4dElkPzogJ3dlYmdsJyB8ICd3ZWJnbDInO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQuXG4gICAgICovXG4gICAgcmVhZG9ubHkgY29udGV4dDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIG1heGltdW0gYmF0Y2ggc2l6ZSBmb3IgbWF0bXVsLiAwIG1lYW5zIHRvIGRpc2FibGUgYmF0Y2hpbmcuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIG1hdG11bE1heEJhdGNoU2l6ZT86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSB0ZXh0dXJlIGNhY2hlIG1vZGUuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGAnZnVsbCdgXG4gICAgICovXG4gICAgdGV4dHVyZUNhY2hlTW9kZT86ICdpbml0aWFsaXplck9ubHknIHwgJ2Z1bGwnO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHBhY2tlZCB0ZXh0dXJlIG1vZGVcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHBhY2s/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgd2hldGhlciBlbmFibGUgYXN5bmMgZG93bmxvYWQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBhc3luYz86IGJvb2xlYW47XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhIHtcbiAgICBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgICBkYXRhVHlwZTogc3RyaW5nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1UHJvZmlsaW5nRGF0YVYxIHtcbiAgICB2ZXJzaW9uOiAxO1xuICAgIGlucHV0c01ldGFkYXRhOiByZWFkb25seSBXZWJHcHVQcm9maWxpbmdEYXRhVjFUZW5zb3JNZXRhZGF0YVtdO1xuICAgIG91dHB1dHNNZXRhZGF0YTogcmVhZG9ubHkgV2ViR3B1UHJvZmlsaW5nRGF0YVYxVGVuc29yTWV0YWRhdGFbXTtcbiAgICBrZXJuZWxJZDogbnVtYmVyO1xuICAgIGtlcm5lbFR5cGU6IHN0cmluZztcbiAgICBrZXJuZWxOYW1lOiBzdHJpbmc7XG4gICAgcHJvZ3JhbU5hbWU6IHN0cmluZztcbiAgICBzdGFydFRpbWU6IG51bWJlcjtcbiAgICBlbmRUaW1lOiBudW1iZXI7XG4gIH1cblxuICBleHBvcnQgdHlwZSBXZWJHcHVQcm9maWxpbmdEYXRhID0gV2ViR3B1UHJvZmlsaW5nRGF0YVYxO1xuXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1RmxhZ3Mge1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHByb2ZpbGluZyBtb2RlLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGBlbnYud2ViZ3B1LnByb2ZpbGluZy5tb2RlYCBpbnN0ZWFkLiBJZiBgZW52LndlYmdwdS5wcm9maWxpbmcubW9kZWAgaXMgc2V0LCB0aGlzIHByb3BlcnR5IHdpbGwgYmVcbiAgICAgKiBpZ25vcmVkLlxuICAgICAqL1xuICAgIHByb2ZpbGluZ01vZGU/OiAnb2ZmJyB8ICdkZWZhdWx0JztcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBwcm9maWxpbmc6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IG9yIGdldCB0aGUgcHJvZmlsaW5nIG1vZGUuXG4gICAgICAgKlxuICAgICAgICogQGRlZmF1bHRWYWx1ZSBgJ29mZidgXG4gICAgICAgKi9cbiAgICAgIG1vZGU/OiAnb2ZmJyB8ICdkZWZhdWx0JztcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb3IgZ2V0IGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBhIHByb2ZpbGluZyBkYXRhIGlzIHJlY2VpdmVkLiBJZiBub3Qgc2V0LCB0aGUgcHJvZmlsaW5nIGRhdGEgd2lsbCBiZVxuICAgICAgICogcHJpbnRlZCB0byBjb25zb2xlLlxuICAgICAgICovXG4gICAgICBvbmRhdGE/OiAoZGF0YTogV2ViR3B1UHJvZmlsaW5nRGF0YSkgPT4gdm9pZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHBvd2VyIHByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgb25seSBoYXMgZWZmZWN0IGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICogdXNlZCBhcyBvcHRpb25zIGZvciBgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpYC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9ncHV3ZWIuZ2l0aHViLmlvL2dwdXdlYi8jZGljdGRlZi1ncHVyZXF1ZXN0YWRhcHRlcm9wdGlvbnN9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB1bmRlZmluZWRgXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBDcmVhdGUgeW91ciBvd24gR1BVQWRhcHRlciwgdXNlIGl0IHRvIGNyZWF0ZSBhIEdQVURldmljZSBpbnN0YW5jZSBhbmQgc2V0IHtAbGluayBkZXZpY2V9IHByb3BlcnR5IGlmXG4gICAgICogeW91IHdhbnQgdG8gdXNlIGEgc3BlY2lmaWMgcG93ZXIgcHJlZmVyZW5jZS5cbiAgICAgKi9cbiAgICBwb3dlclByZWZlcmVuY2U/OiAnbG93LXBvd2VyJyB8ICdoaWdoLXBlcmZvcm1hbmNlJztcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBmb3JjZSBmYWxsYmFjayBhZGFwdGVyIGZsYWcuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgb25seSBoYXMgZWZmZWN0IGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICogdXNlZCBhcyBvcHRpb25zIGZvciBgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpYC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9ncHV3ZWIuZ2l0aHViLmlvL2dwdXdlYi8jZGljdGRlZi1ncHVyZXF1ZXN0YWRhcHRlcm9wdGlvbnN9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB1bmRlZmluZWRgXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBDcmVhdGUgeW91ciBvd24gR1BVQWRhcHRlciwgdXNlIGl0IHRvIGNyZWF0ZSBhIEdQVURldmljZSBpbnN0YW5jZSBhbmQgc2V0IHtAbGluayBkZXZpY2V9IHByb3BlcnR5IGlmXG4gICAgICogeW91IHdhbnQgdG8gdXNlIGEgc3BlY2lmaWMgZmFsbGJhY2sgb3B0aW9uLlxuICAgICAqL1xuICAgIGZvcmNlRmFsbGJhY2tBZGFwdGVyPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBhZGFwdGVyIGZvciBXZWJHUFUuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgb25seSBoYXMgZWZmZWN0IGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICogdXNlZCBhcyB0aGUgR1BVIGFkYXB0ZXIgZm9yIHRoZSB1bmRlcmx5aW5nIFdlYkdQVSBiYWNrZW5kIHRvIGNyZWF0ZSBHUFUgZGV2aWNlLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBwcm9wZXJ0eSBpcyBub3Qgc2V0LCBpdCB3aWxsIGJlIGF2YWlsYWJsZSB0byBnZXQgYWZ0ZXIgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLiBUaGVcbiAgICAgKiB2YWx1ZSB3aWxsIGJlIHRoZSBHUFUgYWRhcHRlciB0aGF0IGNyZWF0ZWQgYnkgdGhlIHVuZGVybHlpbmcgV2ViR1BVIGJhY2tlbmQuXG4gICAgICpcbiAgICAgKiBXaGVuIHVzZSB3aXRoIFR5cGVTY3JpcHQsIHRoZSB0eXBlIG9mIHRoaXMgcHJvcGVydHkgaXMgYEdQVUFkYXB0ZXJgIGRlZmluZWQgaW4gXCJAd2ViZ3B1L3R5cGVzXCIuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBJdCBpcyBubyBsb25nZXIgcmVjb21tZW5kZWQgdG8gdXNlIHRoaXMgcHJvcGVydHkuIFRoZSBsYXRlc3QgV2ViR1BVIHNwZWMgYWRkcyBgR1BVRGV2aWNlLmFkYXB0ZXJJbmZvYFxuICAgICAqIChodHRwczovL3d3dy53My5vcmcvVFIvd2ViZ3B1LyNkb20tZ3B1ZGV2aWNlLWFkYXB0ZXJpbmZvKSwgd2hpY2ggYWxsb3dzIHRvIGdldCB0aGUgYWRhcHRlciBpbmZvcm1hdGlvbiBmcm9tIHRoZVxuICAgICAqIGRldmljZS4gV2hlbiBpdCdzIGF2YWlsYWJsZSwgdGhlcmUgaXMgbm8gbmVlZCB0byBzZXQvZ2V0IHRoZSB7QGxpbmsgYWRhcHRlcn0gcHJvcGVydHkuXG4gICAgICovXG4gICAgYWRhcHRlcjogVHJ5R2V0R2xvYmFsVHlwZTwnR1BVQWRhcHRlcic+O1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIEdQVSBkZXZpY2UgZm9yIFdlYkdQVS5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSAzIHZhbGlkIHNjZW5hcmlvcyBvZiBhY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eTpcbiAgICAgKiAtIFNldCBhIHZhbHVlIGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlIHVzZWQgYnkgdGhlIFdlYkdQVSBiYWNrZW5kXG4gICAgICogdG8gcGVyZm9ybSBjYWxjdWxhdGlvbnMuIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBgR1BVRGV2aWNlYCBvYmplY3QsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqIC0gR2V0IHRoZSB2YWx1ZSBiZWZvcmUgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLiBUaGlzIHdpbGwgdHJ5IHRvIGNyZWF0ZSBhIG5ldyBHUFVEZXZpY2VcbiAgICAgKiBpbnN0YW5jZS4gUmV0dXJucyBhIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHRvIGEgYEdQVURldmljZWAgb2JqZWN0LlxuICAgICAqIC0gR2V0IHRoZSB2YWx1ZSBhZnRlciB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFJldHVybnMgYSByZXNvbHZlZCBgUHJvbWlzZWAgdG8gdGhlXG4gICAgICogYEdQVURldmljZWAgb2JqZWN0IHVzZWQgYnkgdGhlIFdlYkdQVSBiYWNrZW5kLlxuICAgICAqL1xuICAgIGdldCBkZXZpY2UoKTogUHJvbWlzZTxUcnlHZXRHbG9iYWxUeXBlPCdHUFVEZXZpY2UnPj47XG4gICAgc2V0IGRldmljZSh2YWx1ZTogVHJ5R2V0R2xvYmFsVHlwZTwnR1BVRGV2aWNlJz4pO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgd2hldGhlciB2YWxpZGF0ZSBpbnB1dCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAgICovXG4gICAgdmFsaWRhdGVJbnB1dENvbnRlbnQ/OiBib29sZWFuO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW52IHtcbiAgLyoqXG4gICAqIHNldCB0aGUgc2V2ZXJpdHkgbGV2ZWwgZm9yIGxvZ2dpbmcuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYCd3YXJuaW5nJ2BcbiAgICovXG4gIGxvZ0xldmVsPzogJ3ZlcmJvc2UnIHwgJ2luZm8nIHwgJ3dhcm5pbmcnIHwgJ2Vycm9yJyB8ICdmYXRhbCc7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlIHdoZXRoZXIgcnVuIGluIGRlYnVnIG1vZGUuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgKi9cbiAgZGVidWc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBzZXQgb3IgZ2V0IGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gZW5hYmxlIHRyYWNlLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICovXG4gIHRyYWNlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogR2V0IHZlcnNpb24gb2YgdGhlIGN1cnJlbnQgcGFja2FnZS5cbiAgICovXG4gIHJlYWRvbmx5IHZlcnNpb25zOiB7XG4gICAgcmVhZG9ubHkgY29tbW9uOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgd2ViPzogc3RyaW5nO1xuICAgIHJlYWRvbmx5IG5vZGU/OiBzdHJpbmc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIHJlYWRvbmx5ICdyZWFjdC1uYXRpdmUnPzogc3RyaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnQgYSBzZXQgb2YgZmxhZ3MgZm9yIFdlYkFzc2VtYmx5XG4gICAqL1xuICByZWFkb25seSB3YXNtOiBFbnYuV2ViQXNzZW1ibHlGbGFncztcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJHTFxuICAgKi9cbiAgcmVhZG9ubHkgd2ViZ2w6IEVudi5XZWJHTEZsYWdzO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnQgYSBzZXQgb2YgZmxhZ3MgZm9yIFdlYkdQVVxuICAgKi9cbiAgcmVhZG9ubHkgd2ViZ3B1OiBFbnYuV2ViR3B1RmxhZ3M7XG5cbiAgW25hbWU6IHN0cmluZ106IHVua25vd247XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGFzIGEgZ2xvYmFsIHNpbmdsZXRvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudjogRW52ID0gZW52SW1wbDtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yVG9EYXRhVXJsT3B0aW9ucywgVGVuc29yVG9JbWFnZURhdGFPcHRpb25zIH0gZnJvbSAnLi90ZW5zb3ItY29udmVyc2lvbi5qcyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLnRvRGF0YVVSTCgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JUb0RhdGFVUkwgPSAodGVuc29yOiBUZW5zb3IsIG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nID0+IHtcbiAgY29uc3QgY2FudmFzID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpIDogbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKTtcbiAgY2FudmFzLndpZHRoID0gdGVuc29yLmRpbXNbM107XG4gIGNhbnZhcy5oZWlnaHQgPSB0ZW5zb3IuZGltc1syXTtcbiAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykgYXNcbiAgICB8IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuICAgIHwgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXG4gICAgfCBudWxsO1xuXG4gIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgIC8vIERlZmF1bHQgdmFsdWVzIGZvciBoZWlnaHQgYW5kIHdpZHRoICYgZm9ybWF0XG4gICAgbGV0IHdpZHRoOiBudW1iZXI7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xuICAgIGlmIChvcHRpb25zPy50ZW5zb3JMYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRlbnNvckxheW91dCA9PT0gJ05IV0MnKSB7XG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbM107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZmF1bHQgbGF5b3V0IGlzIE5DV0hcbiAgICAgIHdpZHRoID0gdGVuc29yLmRpbXNbM107XG4gICAgICBoZWlnaHQgPSB0ZW5zb3IuZGltc1syXTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnM/LmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiAnUkdCJztcblxuICAgIGNvbnN0IG5vcm0gPSBvcHRpb25zPy5ub3JtO1xuICAgIGxldCBub3JtTWVhbjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0ubWVhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtTWVhbiA9IFsyNTUsIDI1NSwgMjU1LCAyNTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG5vcm0ubWVhbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhblswXSwgbm9ybS5tZWFuWzFdLCBub3JtLm1lYW5bMl0sIDBdO1xuICAgICAgICBpZiAobm9ybS5tZWFuWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub3JtTWVhblszXSA9IG5vcm0ubWVhblszXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtQmlhcyA9IFswLCAwLCAwLCAwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBub3JtLmJpYXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0uYmlhc1szXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybUJpYXNbM10gPSBub3JtLmJpYXNbM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdHJpZGUgPSBoZWlnaHQgKiB3aWR0aDtcbiAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLFxuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUsXG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsXG4gICAgICBhVGVuc29yUG9pbnRlciA9IC0xO1xuXG4gICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxuICAgIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICAgIGFUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMztcbiAgICB9IGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgICBjb25zdCBSID0gKCh0ZW5zb3IuZGF0YVtyVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMF0pICogbm9ybU1lYW5bMF07IC8vIFIgdmFsdWVcbiAgICAgICAgY29uc3QgRyA9ICgodGVuc29yLmRhdGFbZ1RlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzFdKSAqIG5vcm1NZWFuWzFdOyAvLyBHIHZhbHVlXG4gICAgICAgIGNvbnN0IEIgPSAoKHRlbnNvci5kYXRhW2JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1syXSkgKiBub3JtTWVhblsyXTsgLy8gQiB2YWx1ZVxuICAgICAgICBjb25zdCBBID0gYVRlbnNvclBvaW50ZXIgPT09IC0xID8gMjU1IDogKCh0ZW5zb3IuZGF0YVthVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbM10pICogbm9ybU1lYW5bM107IC8vIEEgdmFsdWVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzXG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgUiArICcsJyArIEcgKyAnLCcgKyBCICsgJywnICsgQSArICcpJztcbiAgICAgICAgcGl4ZWxzMkRDb250ZXh0LmZpbGxSZWN0KGosIGksIDEsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3RvRGF0YVVSTCcgaW4gY2FudmFzKSB7XG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvRGF0YVVSTCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICB9XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci50b0ltYWdlRGF0YSgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JUb0ltYWdlRGF0YSA9ICh0ZW5zb3I6IFRlbnNvciwgb3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YSA9PiB7XG4gIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9XG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpXG4gICAgICA6IChuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpLmdldENvbnRleHQoJzJkJykgYXMgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTtcbiAgbGV0IGltYWdlOiBJbWFnZURhdGE7XG4gIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgIC8vIERlZmF1bHQgdmFsdWVzIGZvciBoZWlnaHQgYW5kIHdpZHRoICYgZm9ybWF0XG4gICAgbGV0IHdpZHRoOiBudW1iZXI7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xuICAgIGxldCBjaGFubmVsczogbnVtYmVyO1xuICAgIGlmIChvcHRpb25zPy50ZW5zb3JMYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRlbnNvckxheW91dCA9PT0gJ05IV0MnKSB7XG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMV07XG4gICAgICBjaGFubmVscyA9IHRlbnNvci5kaW1zWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IGxheW91dCBpcyBOQ1dIXG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gICAgICBjaGFubmVscyA9IHRlbnNvci5kaW1zWzFdO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IChvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiAnUkdCJykgOiAnUkdCJztcblxuICAgIGNvbnN0IG5vcm0gPSBvcHRpb25zPy5ub3JtO1xuICAgIGxldCBub3JtTWVhbjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0ubWVhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtTWVhbiA9IFsyNTUsIDI1NSwgMjU1LCAyNTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG5vcm0ubWVhbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhblswXSwgbm9ybS5tZWFuWzFdLCBub3JtLm1lYW5bMl0sIDI1NV07XG4gICAgICAgIGlmIChub3JtLm1lYW5bM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vcm1NZWFuWzNdID0gbm9ybS5tZWFuWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5iaWFzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vcm1CaWFzID0gWzAsIDAsIDAsIDBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG5vcm0uYmlhcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhc1swXSwgbm9ybS5iaWFzWzFdLCBub3JtLmJpYXNbMl0sIDBdO1xuICAgICAgICBpZiAobm9ybS5iaWFzWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub3JtQmlhc1szXSA9IG5vcm0uYmlhc1szXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgY2hhbm5lbHMgPT09IDQgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdSR0JBJykgfHxcbiAgICAgICAgKGNoYW5uZWxzID09PSAzICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnUkdCJyAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ0JHUicpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIGZvcm1hdCBkb2Vzbid0IG1hdGNoIGlucHV0IHRlbnNvciBkaW1zXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgcG9pbnRlciBhc3NpZ25tZW50c1xuICAgIGNvbnN0IHN0ZXAgPSA0O1xuICAgIGxldCBySW1hZ2VQb2ludGVyID0gMCxcbiAgICAgIGdJbWFnZVBvaW50ZXIgPSAxLFxuICAgICAgYkltYWdlUG9pbnRlciA9IDIsXG4gICAgICBhSW1hZ2VQb2ludGVyID0gMztcbiAgICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLFxuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUsXG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsXG4gICAgICBhVGVuc29yUG9pbnRlciA9IC0xO1xuXG4gICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxuICAgIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICAgIGFUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMztcbiAgICB9IGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH1cblxuICAgIGltYWdlID0gcGl4ZWxzMkRDb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGZvciAoXG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBpIDwgaGVpZ2h0ICogd2lkdGg7XG4gICAgICBySW1hZ2VQb2ludGVyICs9IHN0ZXAsIGdJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYkltYWdlUG9pbnRlciArPSBzdGVwLCBhSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGkrK1xuICAgICkge1xuICAgICAgaW1hZ2UuZGF0YVtySW1hZ2VQb2ludGVyXSA9ICgodGVuc29yLmRhdGFbclRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzBdKSAqIG5vcm1NZWFuWzBdOyAvLyBSIHZhbHVlXG4gICAgICBpbWFnZS5kYXRhW2dJbWFnZVBvaW50ZXJdID0gKCh0ZW5zb3IuZGF0YVtnVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMV0pICogbm9ybU1lYW5bMV07IC8vIEcgdmFsdWVcbiAgICAgIGltYWdlLmRhdGFbYkltYWdlUG9pbnRlcl0gPSAoKHRlbnNvci5kYXRhW2JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1syXSkgKiBub3JtTWVhblsyXTsgLy8gQiB2YWx1ZVxuICAgICAgaW1hZ2UuZGF0YVthSW1hZ2VQb2ludGVyXSA9XG4gICAgICAgIGFUZW5zb3JQb2ludGVyID09PSAtMSA/IDI1NSA6ICgodGVuc29yLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAvLyBBIHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICB9XG4gIHJldHVybiBpbWFnZTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7XG4gIE9wdGlvbnNEaW1lbnNpb25zLFxuICBPcHRpb25zRm9ybWF0LFxuICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMsXG4gIE9wdGlvbnNUZW5zb3JGb3JtYXQsXG4gIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gIFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zLFxuICBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zLFxuICBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9ucyxcbiAgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnMsXG4gIFRlbnNvckZyb21NTFRlbnNvck9wdGlvbnMsXG4gIFRlbnNvckZyb21UZXh0dXJlT3B0aW9ucyxcbiAgVGVuc29yRnJvbVVybE9wdGlvbnMsXG59IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5pbXBvcnQgeyBUZW5zb3IgYXMgVGVuc29ySW50ZXJmYWNlIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5pbnRlcmZhY2UgQnVmZmVyVG9UZW5zb3JPcHRpb25zXG4gIGV4dGVuZHMgT3B0aW9uc0RpbWVuc2lvbnMsXG4gICAgT3B0aW9uc1RlbnNvckxheW91dCxcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMsXG4gICAgT3B0aW9uc0Zvcm1hdCxcbiAgICBPcHRpb25zVGVuc29yRm9ybWF0IHt9XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSBpbWFnZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0gYnVmZmVyIC0gRXh0cmFjdGVkIGltYWdlIGJ1ZmZlciBkYXRhIC0gYXNzdW1pbmcgUkdCQSBmb3JtYXRcbiAqIEBwYXJhbSBpbWFnZUZvcm1hdCAtIGlucHV0IGltYWdlIGNvbmZpZ3VyYXRpb24gLSByZXF1aXJlZCBjb25maWd1cmF0aW9ucyBoZWlnaHQsIHdpZHRoLCBmb3JtYXRcbiAqIEBwYXJhbSB0ZW5zb3JGb3JtYXQgLSBvdXRwdXQgdGVuc29yIGNvbmZpZ3VyYXRpb24gLSBEZWZhdWx0IGlzIFJHQiBmb3JtYXRcbiAqL1xuZXhwb3J0IGNvbnN0IGJ1ZmZlclRvVGVuc29yID0gKGJ1ZmZlcjogVWludDhDbGFtcGVkQXJyYXkgfCB1bmRlZmluZWQsIG9wdGlvbnM6IEJ1ZmZlclRvVGVuc29yT3B0aW9ucyk6IFRlbnNvciA9PiB7XG4gIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgYnVmZmVyIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG4gIGlmIChvcHRpb25zLmhlaWdodCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaGVpZ2h0IGFuZCB3aWR0aCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxuICBpZiAob3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xuICAgIHRocm93IG5ldyBFcnJvcignTkhXQyBUZW5zb3IgbGF5b3V0IGlzIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gIH1cblxuICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IG9wdGlvbnM7XG5cbiAgY29uc3Qgbm9ybSA9IG9wdGlvbnMubm9ybSA/PyB7IG1lYW46IDI1NSwgYmlhczogMCB9O1xuICBsZXQgbm9ybU1lYW46IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBsZXQgbm9ybUJpYXM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuXG4gIGlmICh0eXBlb2Ygbm9ybS5tZWFuID09PSAnbnVtYmVyJykge1xuICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gIH0gZWxzZSB7XG4gICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuIVswXSwgbm9ybS5tZWFuIVsxXSwgbm9ybS5tZWFuIVsyXSwgbm9ybS5tZWFuIVszXSA/PyAyNTVdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBub3JtLmJpYXMgPT09ICdudW1iZXInKSB7XG4gICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcbiAgfSBlbHNlIHtcbiAgICBub3JtQmlhcyA9IFtub3JtLmJpYXMhWzBdLCBub3JtLmJpYXMhWzFdLCBub3JtLmJpYXMhWzJdLCBub3JtLmJpYXMhWzNdID8/IDBdO1xuICB9XG5cbiAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiAnUkdCQSc7XG4gIC8vIGRlZmF1bHQgdmFsdWUgaXMgUkdCQSBzaW5jZSBpbWFnZWRhdGEgYW5kIEhUTUxJbWFnZUVsZW1lbnQgdXNlcyBpdFxuXG4gIGNvbnN0IG91dHB1dGZvcm1hdCA9XG4gICAgb3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/IChvcHRpb25zLnRlbnNvckZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50ZW5zb3JGb3JtYXQgOiAnUkdCJykgOiAnUkdCJztcbiAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gIGNvbnN0IGZsb2F0MzJEYXRhID0gb3V0cHV0Zm9ybWF0ID09PSAnUkdCQScgPyBuZXcgRmxvYXQzMkFycmF5KHN0cmlkZSAqIDQpIDogbmV3IEZsb2F0MzJBcnJheShzdHJpZGUgKiAzKTtcblxuICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgbGV0IHN0ZXAgPSA0LFxuICAgIHJJbWFnZVBvaW50ZXIgPSAwLFxuICAgIGdJbWFnZVBvaW50ZXIgPSAxLFxuICAgIGJJbWFnZVBvaW50ZXIgPSAyLFxuICAgIGFJbWFnZVBvaW50ZXIgPSAzO1xuICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLFxuICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLFxuICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMixcbiAgICBhVGVuc29yUG9pbnRlciA9IC0xO1xuXG4gIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xuICAgIHN0ZXAgPSAzO1xuICAgIHJJbWFnZVBvaW50ZXIgPSAwO1xuICAgIGdJbWFnZVBvaW50ZXIgPSAxO1xuICAgIGJJbWFnZVBvaW50ZXIgPSAyO1xuICAgIGFJbWFnZVBvaW50ZXIgPSAtMTtcbiAgfVxuXG4gIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBvdXRwdXQgdGVuc29yIGZvcm1hdFxuICBpZiAob3V0cHV0Zm9ybWF0ID09PSAnUkdCQScpIHtcbiAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gIH0gZWxzZSBpZiAob3V0cHV0Zm9ybWF0ID09PSAnUkJHJykge1xuICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gIH0gZWxzZSBpZiAob3V0cHV0Zm9ybWF0ID09PSAnQkdSJykge1xuICAgIGJUZW5zb3JQb2ludGVyID0gMDtcbiAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICByVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gIH1cblxuICBmb3IgKFxuICAgIGxldCBpID0gMDtcbiAgICBpIDwgc3RyaWRlO1xuICAgIGkrKywgckltYWdlUG9pbnRlciArPSBzdGVwLCBiSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGdJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwXG4gICkge1xuICAgIGZsb2F0MzJEYXRhW3JUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltySW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzBdKSAvIG5vcm1NZWFuWzBdO1xuICAgIGZsb2F0MzJEYXRhW2dUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltnSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzFdKSAvIG5vcm1NZWFuWzFdO1xuICAgIGZsb2F0MzJEYXRhW2JUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltiSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzJdKSAvIG5vcm1NZWFuWzJdO1xuICAgIGlmIChhVGVuc29yUG9pbnRlciAhPT0gLTEgJiYgYUltYWdlUG9pbnRlciAhPT0gLTEpIHtcbiAgICAgIGZsb2F0MzJEYXRhW2FUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlclthSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzNdKSAvIG5vcm1NZWFuWzNdO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZsb2F0MzJBcnJheSAtPiBvcnQuVGVuc29yXG4gIGNvbnN0IG91dHB1dFRlbnNvciA9XG4gICAgb3V0cHV0Zm9ybWF0ID09PSAnUkdCQSdcbiAgICAgID8gbmV3IFRlbnNvcignZmxvYXQzMicsIGZsb2F0MzJEYXRhLCBbMSwgNCwgaGVpZ2h0LCB3aWR0aF0pXG4gICAgICA6IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDMsIGhlaWdodCwgd2lkdGhdKTtcbiAgcmV0dXJuIG91dHB1dFRlbnNvcjtcbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21JbWFnZSgpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbUltYWdlID0gYXN5bmMgKFxuICBpbWFnZTogSW1hZ2VEYXRhIHwgSFRNTEltYWdlRWxlbWVudCB8IEltYWdlQml0bWFwIHwgc3RyaW5nLFxuICBvcHRpb25zPzpcbiAgICB8IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zXG4gICAgfCBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9uc1xuICAgIHwgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9uc1xuICAgIHwgVGVuc29yRnJvbVVybE9wdGlvbnMsXG4pOiBQcm9taXNlPFRlbnNvcj4gPT4ge1xuICAvLyBjaGVja2luZyB0aGUgdHlwZSBvZiBpbWFnZSBvYmplY3RcbiAgY29uc3QgaXNIVE1MSW1hZ2VFbGUgPSB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xuICBjb25zdCBpc0ltYWdlRGF0YUVsZSA9IHR5cGVvZiBJbWFnZURhdGEgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VEYXRhO1xuICBjb25zdCBpc0ltYWdlQml0bWFwID0gdHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwO1xuICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZyc7XG5cbiAgbGV0IGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5IHwgdW5kZWZpbmVkO1xuICBsZXQgYnVmZmVyVG9UZW5zb3JPcHRpb25zOiBCdWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zID8/IHt9O1xuXG4gIGNvbnN0IGNyZWF0ZUNhbnZhcyA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbnZhcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjcmVhdGVDYW52YXNDb250ZXh0ID0gKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBPZmZzY3JlZW5DYW52YXMpID0+IHtcbiAgICBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0gZWxzZSBpZiAoY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQoJzJkJykgYXMgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIC8vIGZpbGxpbmcgYW5kIGNoZWNraW5nIGltYWdlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICBpZiAoaXNIVE1MSW1hZ2VFbGUpIHtcbiAgICAvLyBIVE1MSW1hZ2VFbGVtZW50IC0gaW1hZ2Ugb2JqZWN0IC0gZm9ybWF0IGlzIFJHQkEgYnkgZGVmYXVsdFxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXMpO1xuXG4gICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICBsZXQgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgbGV0IHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZEhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZFdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5yZXNpemVkSGVpZ2h0O1xuICAgICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLnRlbnNvckZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgUkdCQSBmb3IgSFRNTEltYWdlRWxlbWVudCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy50ZW5zb3JGb3JtYXQgPSAnUkdCQSc7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgIH1cblxuICAgICAgcGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNJbWFnZURhdGFFbGUpIHtcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXI7XG4gICAgbGV0IHdpZHRoOiBudW1iZXI7XG5cbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZFdpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcbiAgICAgIHdpZHRoID0gb3B0aW9ucy5yZXNpemVkV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgIHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmZvcm1hdCA9ICdSR0JBJztcbiAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuXG4gICAgICB0ZW1wQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dCh0ZW1wQ2FudmFzKTtcblxuICAgICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xuICAgICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBpbWFnZS5kYXRhO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ltYWdlQml0bWFwKSB7XG4gICAgLy8gSW1hZ2VCaXRtYXAgLSBpbWFnZSBvYmplY3QgLSBmb3JtYXQgbXVzdCBiZSBwcm92aWRlZCBieSB1c2VyXG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBpbWFnZSBjb25maWcgd2l0aCBmb3JtYXQgZm9yIEltYWdlYml0bWFwJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XG4gICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KGNhbnZhcyk7XG5cbiAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICBwaXhlbHMyRENvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICByZXR1cm4gYnVmZmVyVG9UZW5zb3IoZGF0YSwgYnVmZmVyVG9UZW5zb3JPcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcbiAgICAgIGlmICghaW1hZ2UgfHwgIWNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3SW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIG5ld0ltYWdlLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgICBuZXdJbWFnZS5zcmMgPSBpbWFnZTtcbiAgICAgIG5ld0ltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gbmV3SW1hZ2Uud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBuZXdJbWFnZS5oZWlnaHQ7XG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKG5ld0ltYWdlLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb25zdCBpbWcgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgIHJlc29sdmUoYnVmZmVyVG9UZW5zb3IoaW1nLmRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uJyk7XG4gIH1cblxuICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGJ1ZmZlclRvVGVuc29yKGRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvbicpO1xuICB9XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tVGV4dHVyZSgpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbVRleHR1cmUgPSA8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5UZXh0dXJlRGF0YVR5cGVzPihcbiAgdGV4dHVyZTogVGVuc29ySW50ZXJmYWNlLlRleHR1cmVUeXBlLFxuICBvcHRpb25zOiBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VD4sXG4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGRvd25sb2FkLCBkaXNwb3NlIH0gPSBvcHRpb25zO1xuICAvLyBBbHdheXMgYXNzdW1lIFJHQkFGMzIuIFRPRE86IHN1cHBvcnQgZGlmZmVyZW50IHRleHR1cmUgZm9ybWF0XG4gIGNvbnN0IGRpbXMgPSBbMSwgaGVpZ2h0LCB3aWR0aCwgNF07XG4gIHJldHVybiBuZXcgVGVuc29yKHsgbG9jYXRpb246ICd0ZXh0dXJlJywgdHlwZTogJ2Zsb2F0MzInLCB0ZXh0dXJlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9KTtcbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21HcHVCdWZmZXIoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21HcHVCdWZmZXIgPSA8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5HcHVCdWZmZXJEYXRhVHlwZXM+KFxuICBncHVCdWZmZXI6IFRlbnNvckludGVyZmFjZS5HcHVCdWZmZXJUeXBlLFxuICBvcHRpb25zOiBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9uczxUPixcbik6IFRlbnNvciA9PiB7XG4gIGNvbnN0IHsgZGF0YVR5cGUsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlIH0gPSBvcHRpb25zO1xuICByZXR1cm4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcicsIHR5cGU6IGRhdGFUeXBlID8/ICdmbG9hdDMyJywgZ3B1QnVmZmVyLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9KTtcbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21NTFRlbnNvcigpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbU1MVGVuc29yID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuTUxUZW5zb3JEYXRhVHlwZXM+KFxuICBtbFRlbnNvcjogVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yVHlwZSxcbiAgb3B0aW9uczogVGVuc29yRnJvbU1MVGVuc29yT3B0aW9uczxUPixcbik6IFRlbnNvciA9PiB7XG4gIGNvbnN0IHsgZGF0YVR5cGUsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlIH0gPSBvcHRpb25zO1xuICByZXR1cm4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAnbWwtdGVuc29yJywgdHlwZTogZGF0YVR5cGUgPz8gJ2Zsb2F0MzInLCBtbFRlbnNvciwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tUGlubmVkQnVmZmVyKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuQ3B1UGlubmVkRGF0YVR5cGVzPihcbiAgdHlwZTogVCxcbiAgYnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGVNYXBbVF0sXG4gIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbik6IFRlbnNvciA9PiBuZXcgVGVuc29yKHsgbG9jYXRpb246ICdjcHUtcGlubmVkJywgdHlwZSwgZGF0YTogYnVmZmVyLCBkaW1zOiBkaW1zID8/IFtidWZmZXIubGVuZ3RoXSB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzID1cbiAgfCBGbG9hdDMyQXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQ4QXJyYXlDb25zdHJ1Y3RvclxuICB8IEludDhBcnJheUNvbnN0cnVjdG9yXG4gIHwgVWludDE2QXJyYXlDb25zdHJ1Y3RvclxuICB8IEludDE2QXJyYXlDb25zdHJ1Y3RvclxuICB8IEludDMyQXJyYXlDb25zdHJ1Y3RvclxuICB8IEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQ4QXJyYXlDb25zdHJ1Y3RvclxuICB8IEZsb2F0NjRBcnJheUNvbnN0cnVjdG9yXG4gIHwgVWludDMyQXJyYXlDb25zdHJ1Y3RvclxuICB8IEJpZ1VpbnQ2NEFycmF5Q29uc3RydWN0b3I7XG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRUeXBlZEFycmF5ID0gSW5zdGFuY2VUeXBlPFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnM+O1xuXG4vLyBhIHJ1bnRpbWUgbWFwIHRoYXQgbWFwcyB0eXBlIHN0cmluZyB0byBUeXBlZEFycmF5IGNvbnN0cnVjdG9yLiBTaG91bGQgbWF0Y2ggVGVuc29yLkRhdGFUeXBlTWFwLlxuZXhwb3J0IGNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAgPSBuZXcgTWFwPHN0cmluZywgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycz4oW1xuICBbJ2Zsb2F0MzInLCBGbG9hdDMyQXJyYXldLFxuICBbJ3VpbnQ4JywgVWludDhBcnJheV0sXG4gIFsnaW50OCcsIEludDhBcnJheV0sXG4gIFsndWludDE2JywgVWludDE2QXJyYXldLFxuICBbJ2ludDE2JywgSW50MTZBcnJheV0sXG4gIFsnaW50MzInLCBJbnQzMkFycmF5XSxcbiAgWydib29sJywgVWludDhBcnJheV0sXG4gIFsnZmxvYXQ2NCcsIEZsb2F0NjRBcnJheV0sXG4gIFsndWludDMyJywgVWludDMyQXJyYXldLFxuICBbJ2ludDQnLCBVaW50OEFycmF5XSxcbiAgWyd1aW50NCcsIFVpbnQ4QXJyYXldLFxuXSk7XG5cbi8vIGEgcnVudGltZSBtYXAgdGhhdCBtYXBzIHR5cGUgc3RyaW5nIHRvIFR5cGVkQXJyYXkgY29uc3RydWN0b3IuIFNob3VsZCBtYXRjaCBUZW5zb3IuRGF0YVR5cGVNYXAuXG5leHBvcnQgY29uc3QgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCA9IG5ldyBNYXA8U3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycywgVGVuc29yLlR5cGU+KFtcbiAgW0Zsb2F0MzJBcnJheSwgJ2Zsb2F0MzInXSxcbiAgW1VpbnQ4QXJyYXksICd1aW50OCddLFxuICBbSW50OEFycmF5LCAnaW50OCddLFxuICBbVWludDE2QXJyYXksICd1aW50MTYnXSxcbiAgW0ludDE2QXJyYXksICdpbnQxNiddLFxuICBbSW50MzJBcnJheSwgJ2ludDMyJ10sXG4gIFtGbG9hdDY0QXJyYXksICdmbG9hdDY0J10sXG4gIFtVaW50MzJBcnJheSwgJ3VpbnQzMiddLFxuXSk7XG5cbi8vIHRoZSBmb2xsb3dpbmcgY29kZSBhbGxvd3MgZGVsYXlpbmcgZXhlY3V0aW9uIG9mIEJpZ0ludC9GbG9hdDE2QXJyYXkgY2hlY2tpbmcuIFRoaXMgYWxsb3dzIGxhenkgaW5pdGlhbGl6YXRpb24gZm9yXG4vLyBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQIGFuZCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLCB3aGljaCBhbGxvd3MgQmlnSW50L0Zsb2F0MTZBcnJheVxuLy8gcG9seWZpbGwgaWYgYXZhaWxhYmxlLlxubGV0IGlzVHlwZWRBcnJheUNoZWNrZWQgPSBmYWxzZTtcbmV4cG9ydCBjb25zdCBjaGVja1R5cGVkQXJyYXkgPSAoKSA9PiB7XG4gIGlmICghaXNUeXBlZEFycmF5Q2hlY2tlZCkge1xuICAgIGlzVHlwZWRBcnJheUNoZWNrZWQgPSB0cnVlO1xuICAgIGNvbnN0IGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdJbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBCaWdJbnQ2NEFycmF5LmZyb207XG4gICAgY29uc3QgaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQmlnVWludDY0QXJyYXkuZnJvbTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCBGbG9hdDE2QXJyYXkgPSAoZ2xvYmFsVGhpcyBhcyBhbnkpLkZsb2F0MTZBcnJheTtcbiAgICBjb25zdCBpc0Zsb2F0MTZBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBGbG9hdDE2QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEZsb2F0MTZBcnJheS5mcm9tO1xuXG4gICAgaWYgKGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSkge1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2ludDY0JywgQmlnSW50NjRBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdJbnQ2NEFycmF5LCAnaW50NjQnKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCd1aW50NjQnLCBCaWdVaW50NjRBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdVaW50NjRBcnJheSwgJ3VpbnQ2NCcpO1xuICAgIH1cbiAgICBpZiAoaXNGbG9hdDE2QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdmbG9hdDE2JywgRmxvYXQxNkFycmF5KTtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEZsb2F0MTZBcnJheSwgJ2Zsb2F0MTYnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgRmxvYXQxNkFycmF5IGlzIG5vdCBhdmFpbGFibGUsIHVzZSAnVWludDE2QXJyYXknIHRvIHN0b3JlIHRoZSBkYXRhLlxuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2Zsb2F0MTYnLCBVaW50MTZBcnJheSk7XG4gICAgfVxuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1xuICBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG4gIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgTUxUZW5zb3JDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG4gIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG59IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5cbi8qKlxuICogY2FsY3VsYXRlIHNpemUgZnJvbSBkaW1zLlxuICpcbiAqIEBwYXJhbSBkaW1zIHRoZSBkaW1zIGFycmF5LiBNYXkgYmUgYW4gaWxsZWdhbCBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVNpemUgPSAoZGltczogcmVhZG9ubHkgdW5rbm93bltdKTogbnVtYmVyID0+IHtcbiAgbGV0IHNpemUgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaW0gPSBkaW1zW2ldO1xuICAgIGlmICh0eXBlb2YgZGltICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIoZGltKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIGlmIChkaW0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIHNpemUgKj0gZGltO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IucmVzaGFwZSgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JSZXNoYXBlID0gKHRlbnNvcjogVGVuc29yLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciA9PiB7XG4gIHN3aXRjaCAodGVuc29yLmxvY2F0aW9uKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvci50eXBlLCB0ZW5zb3IuZGF0YSwgZGltcyk7XG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsXG4gICAgICAgIGRhdGE6IHRlbnNvci5kYXRhIGFzIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVyc1snZGF0YSddLFxuICAgICAgICB0eXBlOiB0ZW5zb3IudHlwZSBhcyBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ3R5cGUnXSxcbiAgICAgICAgZGltcyxcbiAgICAgIH0pO1xuICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ3RleHR1cmUnLFxuICAgICAgICB0ZXh0dXJlOiB0ZW5zb3IudGV4dHVyZSxcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxuICAgICAgICBkaW1zLFxuICAgICAgfSk7XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcicsXG4gICAgICAgIGdwdUJ1ZmZlcjogdGVuc29yLmdwdUJ1ZmZlcixcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBjYXNlICdtbC10ZW5zb3InOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ21sLXRlbnNvcicsXG4gICAgICAgIG1sVGVuc29yOiB0ZW5zb3IubWxUZW5zb3IsXG4gICAgICAgIHR5cGU6IHRlbnNvci50eXBlIGFzIE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHt0ZW5zb3IubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgdGVuc29yVG9EYXRhVVJMLCB0ZW5zb3JUb0ltYWdlRGF0YSB9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24taW1wbC5qcyc7XG5pbXBvcnQgeyBUZW5zb3JUb0RhdGFVcmxPcHRpb25zLCBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMgfSBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcbmltcG9ydCB7XG4gIHRlbnNvckZyb21HcHVCdWZmZXIsXG4gIHRlbnNvckZyb21JbWFnZSxcbiAgdGVuc29yRnJvbU1MVGVuc29yLFxuICB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyLFxuICB0ZW5zb3JGcm9tVGV4dHVyZSxcbn0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS1pbXBsLmpzJztcbmltcG9ydCB7XG4gIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnMsXG4gIFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnMsXG4gIFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLFxuICBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyxcbiAgVGVuc29yRnJvbU1MVGVuc29yT3B0aW9ucyxcbiAgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zLFxuICBUZW5zb3JGcm9tVXJsT3B0aW9ucyxcbiAgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbn0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQge1xuICBjaGVja1R5cGVkQXJyYXksXG4gIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAsXG4gIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAsXG4gIFN1cHBvcnRlZFR5cGVkQXJyYXksXG4gIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsXG59IGZyb20gJy4vdGVuc29yLWltcGwtdHlwZS1tYXBwaW5nLmpzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVNpemUsIHRlbnNvclJlc2hhcGUgfSBmcm9tICcuL3RlbnNvci11dGlscy1pbXBsLmpzJztcbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbnRlcmZhY2UgfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbi8vIHR5cGUgYWxpYXNlcyBmb3IgdGhvc2UgZXhwb3J0ZWQgZnJvbSBUZW5zb3IgaW50ZXJmYWNlXG5cbnR5cGUgVGVuc29yVHlwZSA9IFRlbnNvckludGVyZmFjZS5UeXBlO1xudHlwZSBUZW5zb3JEYXRhVHlwZSA9IFRlbnNvckludGVyZmFjZS5EYXRhVHlwZTtcbnR5cGUgVGVuc29yRGF0YUxvY2F0aW9uID0gVGVuc29ySW50ZXJmYWNlLkRhdGFMb2NhdGlvbjtcbnR5cGUgVGVuc29yVGV4dHVyZVR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZVR5cGU7XG50eXBlIFRlbnNvckdwdUJ1ZmZlclR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyVHlwZTtcbnR5cGUgVGVuc29yTUxUZW5zb3JUeXBlID0gVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yVHlwZTtcblxuLyoqXG4gKiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVGVuc29yIGludGVyZmFjZS5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW5zb3IgaW1wbGVtZW50cyBUZW5zb3JJbnRlcmZhY2Uge1xuICAvLyAjcmVnaW9uIGNvbnN0cnVjdG9yc1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgQ1BVIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGU6IFRlbnNvclR5cGUsXG4gICAgZGF0YTogVGVuc29yRGF0YVR5cGUgfCBVaW50OENsYW1wZWRBcnJheSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBib29sZWFuW10sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IENQVSB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuIFR5cGUgaXMgaW5mZXJyZWQgZnJvbSBkYXRhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgZGF0YTogVGVuc29yRGF0YVR5cGUgfCBVaW50OENsYW1wZWRBcnJheSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgYm9vbGVhbltdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIHBpbm5lZCBDUFUgZGF0YSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAnY3B1LXBpbm5lZCcuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMpO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViR0wgdGV4dHVyZSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAndGV4dHVyZScuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIFdlYkdQVSBidWZmZXIgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ2dwdS1idWZmZXInLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViTk4gTUxUZW5zb3Igd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ21sLXRlbnNvcicuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVycyk7XG5cbiAgLyoqXG4gICAqIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgYXJnMDpcbiAgICAgIHwgVGVuc29yVHlwZVxuICAgICAgfCBUZW5zb3JEYXRhVHlwZVxuICAgICAgfCBVaW50OENsYW1wZWRBcnJheVxuICAgICAgfCByZWFkb25seSBzdHJpbmdbXVxuICAgICAgfCByZWFkb25seSBib29sZWFuW11cbiAgICAgIHwgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzXG4gICAgICB8IFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnNcbiAgICAgIHwgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzXG4gICAgICB8IE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICAgIGFyZzE/OiBUZW5zb3JEYXRhVHlwZSB8IFVpbnQ4Q2xhbXBlZEFycmF5IHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBzdHJpbmdbXSB8IHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICBhcmcyPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICkge1xuICAgIC8vIHBlcmZvcm0gb25lLXRpbWUgY2hlY2sgZm9yIEJpZ0ludC9GbG9hdDE2QXJyYXkgc3VwcG9ydFxuICAgIGNoZWNrVHlwZWRBcnJheSgpO1xuXG4gICAgbGV0IHR5cGU6IFRlbnNvclR5cGU7XG4gICAgbGV0IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSAnb2JqZWN0JyAmJiAnbG9jYXRpb24nIGluIGFyZzApIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gc3BlY2lmaWMgbG9jYXRpb25cbiAgICAgIC8vXG4gICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9IGFyZzAubG9jYXRpb247XG4gICAgICB0eXBlID0gYXJnMC50eXBlO1xuICAgICAgZGltcyA9IGFyZzAuZGltcztcbiAgICAgIHN3aXRjaCAoYXJnMC5sb2NhdGlvbikge1xuICAgICAgICBjYXNlICdjcHUtcGlubmVkJzoge1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5nZXQodHlwZSk7XG4gICAgICAgICAgaWYgKCFleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShhcmcwLmRhdGEgaW5zdGFuY2VvZiBleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGFyZzAuZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0ZXh0dXJlJzoge1xuICAgICAgICAgIGlmICh0eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IGFyZzAudGV4dHVyZTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xuICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSBhcmcwLmRpc3Bvc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdmbG9hdDE2JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDMyJyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDY0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50OCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdib29sJyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQ0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDQnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHt0eXBlfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZ3B1QnVmZmVyRGF0YSA9IGFyZzAuZ3B1QnVmZmVyO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtbC10ZW5zb3InOiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZSAhPT0gJ2Zsb2F0MzInICYmXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQxNicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQ2NCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50MzInICYmXG4gICAgICAgICAgICB0eXBlICE9PSAndWludDY0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDgnICYmXG4gICAgICAgICAgICB0eXBlICE9PSAndWludDgnICYmXG4gICAgICAgICAgICB0eXBlICE9PSAnYm9vbCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50NCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQ0J1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gTUxUZW5zb3JgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5tbFRlbnNvckRhdGEgPSBhcmcwLm1sVGVuc29yO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yIGNvbnN0cnVjdG9yOiB1bnN1cHBvcnRlZCBsb2NhdGlvbiAnJHt0aGlzLmRhdGFMb2NhdGlvbn0nYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIG9mIGxvY2F0aW9uICdjcHUnXG4gICAgICAvL1xuICAgICAgbGV0IGRhdGE6IFRlbnNvckRhdGFUeXBlO1xuICAgICAgbGV0IG1heWJlRGltczogdHlwZW9mIGFyZzEgfCB0eXBlb2YgYXJnMjtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXJnMCBpcyB0eXBlIG9yIGRhdGFcbiAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKHR5cGUsIGRhdGEsIC4uLilcbiAgICAgICAgLy9cbiAgICAgICAgdHlwZSA9IGFyZzA7XG4gICAgICAgIG1heWJlRGltcyA9IGFyZzI7XG4gICAgICAgIGlmIChhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHN0cmluZyB0ZW5zb3JcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHN0cmluZyB0ZW5zb3IncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayB3aGV0aGVyIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIHN0cmluZzsgdGhpcyBpcyB0b28gc2xvdy4gd2UgYXNzdW1lIGl0J3MgY29ycmVjdCBhbmRcbiAgICAgICAgICAvLyBlcnJvciB3aWxsIGJlIHBvcHVsYXRlZCBhdCBpbmZlcmVuY2VcbiAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBudW1lcmljIHRlbnNvclxuICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuZ2V0KGFyZzApO1xuICAgICAgICAgIGlmICh0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdGVuc29yIHR5cGU6ICR7YXJnMH0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICBpZiAoKGFyZzAgPT09ICdmbG9hdDE2JyAmJiB0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IFVpbnQxNkFycmF5KSB8fCBhcmcwID09PSAndWludDQnIHx8IGFyZzAgPT09ICdpbnQ0Jykge1xuICAgICAgICAgICAgICAvLyAtICdmbG9hdDE2JzpcbiAgICAgICAgICAgICAgLy8gICBXaGVuIG5vIEZsb2F0MTZBcnJheSBwb2x5ZmlsbCBpcyB1c2VkLCB3ZSBjYW5ub3QgY3JlYXRlICdmbG9hdDE2JyB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vICAgVGhyb3cgZXJyb3IgaGVyZSBiZWNhdXNlIHdoZW4gdXNlciB0cnkgdG8gdXNlIG51bWJlciBhcnJheSBhcyBkYXRhLFxuICAgICAgICAgICAgICAvLyAgIGUuZy4gbmV3IFRlbnNvcignZmxvYXQxNicsIFsxLCAyLCAzLCA0XSwgZGltcykpLCBpdCB3aWxsIGFjdHVhbGx5IGNhbGxcbiAgICAgICAgICAgICAgLy8gICBVaW50MTZBcnJheS5mcm9tKGFyZzEpIHdoaWNoIGdlbmVyYXRlcyB3cm9uZyBkYXRhLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyAtICd1aW50NCcgYW5kICdpbnQ0JzpcbiAgICAgICAgICAgICAgLy8gICBVaW50OEFycmF5LmZyb20oYXJnMSkgd2lsbCBnZW5lcmF0ZSB3cm9uZyBkYXRhIGZvciAndWludDQnIGFuZCAnaW50NCcgdGVuc29yLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBDcmVhdGluZyBhICR7YXJnMH0gdGVuc29yIGZyb20gbnVtYmVyIGFycmF5IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgJHt0eXBlZEFycmF5Q29uc3RydWN0b3IubmFtZX0gYXMgZGF0YS5gLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcwID09PSAndWludDY0JyB8fCBhcmcwID09PSAnaW50NjQnKSB7XG4gICAgICAgICAgICAgIC8vIHVzZSAnYXMgYW55JyBoZXJlIGJlY2F1c2U6XG4gICAgICAgICAgICAgIC8vIDEuIFR5cGVTY3JpcHQncyBjaGVjayBvbiB0eXBlIG9mICdBcnJheS5pc0FycmF5KCknIGRvZXMgbm90IHdvcmsgd2l0aCByZWFkb25seSBhcnJheXMuXG4gICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3MDAyXG4gICAgICAgICAgICAgIC8vIDIuIFR5cGVTY3JpcHQncyBjaGVjayBvbiB1bmlvbiB0eXBlIG9mICcoQmlnSW50NjRBcnJheUNvbnN0cnVjdG9yfEJpZ1VpbnQ2NEFycmF5Q29uc3RydWN0b3IpLmZyb20oKSdcbiAgICAgICAgICAgICAgLy8gZG9lcyBub3QgYWNjZXB0IHBhcmFtZXRlciBtYXBGbi5cbiAgICAgICAgICAgICAgLy8gMy4gcGFyYW1ldGVycyBvZiAnU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycy5mcm9tKCknIGRvZXMgbm90IG1hdGNoIHRoZSByZXF1aXJlbWVudCBvZiB0aGUgdW5pb25cbiAgICAgICAgICAgICAgLy8gdHlwZS5cblxuICAgICAgICAgICAgICAvLyBhc3N1bWUgJ2FyZzEnIGlzIG9mIHR5cGUgXCJyZWFkb25seSBudW1iZXJbXXxyZWFkb25seSBiaWdpbnRbXVwiIGhlcmUuXG5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgZGF0YSA9ICh0eXBlZEFycmF5Q29uc3RydWN0b3IgYXMgYW55KS5mcm9tKGFyZzEsIEJpZ0ludCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBhc3N1bWUgJ2FyZzEnIGlzIG9mIHR5cGUgXCJyZWFkb25seSBudW1iZXJbXVwiIGhlcmUuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIGRhdGEgPSAodHlwZWRBcnJheUNvbnN0cnVjdG9yIGFzIGFueSkuZnJvbShhcmcxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiB0eXBlZEFycmF5Q29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGRhdGEgPSBhcmcxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXJnMSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgICAgICAgICBpZiAoYXJnMCA9PT0gJ3VpbnQ4Jykge1xuICAgICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSBVaW50OENsYW1wZWRBcnJheSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiB1aW50OGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYXJnMCA9PT0gJ2Zsb2F0MTYnICYmIGFyZzEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSAmJiB0eXBlZEFycmF5Q29uc3RydWN0b3IgIT09IFVpbnQxNkFycmF5KSB7XG4gICAgICAgICAgICAvLyB3aGVuIEZsb2F0MTZBcnJheSBpcyBhdmFpbGFibGUgYW5kIGRhdGEgaXMgb2YgdHlwZSBVaW50MTZBcnJheS5cbiAgICAgICAgICAgIC8vIFdlIGFsbG93IFVpbnQxNkFycmF5IHRvIGJlIHBhc3NlZCBpbiBhcyBkYXRhIGZvciAnZmxvYXQxNicgdGVuc29yIHVudGlsIEZsb2F0MTZBcnJheSBpcyBnZW5lcmFsbHlcbiAgICAgICAgICAgIC8vIHN1cHBvcnRlZCBpbiBKYXZhU2NyaXB0IGVudmlyb25tZW50LlxuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZGF0YSA9IG5ldyAoZ2xvYmFsVGhpcyBhcyBhbnkpLkZsb2F0MTZBcnJheShhcmcxLmJ1ZmZlciwgYXJnMS5ieXRlT2Zmc2V0LCBhcmcxLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgJHt0eXBlfSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiAke3R5cGVkQXJyYXlDb25zdHJ1Y3Rvcn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE92ZXJyaWRlOiBjb25zdHJ1Y3RvcihkYXRhLCAuLi4pXG4gICAgICAgIC8vXG4gICAgICAgIG1heWJlRGltcyA9IGFyZzE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG4gICAgICAgICAgLy8gb25seSBib29sZWFuW10gYW5kIHN0cmluZ1tdIGlzIHN1cHBvcnRlZFxuICAgICAgICAgIGlmIChhcmcwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZpcnN0RWxlbWVudFR5cGUgPSB0eXBlb2YgYXJnMFswXTtcbiAgICAgICAgICBpZiAoZmlyc3RFbGVtZW50VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnc3RyaW5nJztcbiAgICAgICAgICAgIGRhdGEgPSBhcmcwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlyc3RFbGVtZW50VHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0eXBlID0gJ2Jvb2wnO1xuICAgICAgICAgICAgLy8gJ2FyZzAnIGlzIG9mIHR5cGUgJ2Jvb2xlYW5bXScuIFVpbnQ4QXJyYXkuZnJvbShib29sZWFuW10pIGFjdHVhbGx5IHdvcmtzLCBidXQgdHlwZXNjcmlwdCB0aGlua3MgdGhpcyBpc1xuICAgICAgICAgICAgLy8gd3JvbmcgdHlwZS4gV2UgdXNlICdhcyBhbnknIHRvIG1ha2UgaXQgaGFwcHkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShhcmcwIGFzIGFueVtdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBlbGVtZW50IHR5cGUgb2YgZGF0YSBhcnJheTogJHtmaXJzdEVsZW1lbnRUeXBlfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgICAgICAgdHlwZSA9ICd1aW50OCc7XG4gICAgICAgICAgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShhcmcwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBnZXQgdGVuc29yIHR5cGUgZnJvbSBUeXBlZEFycmF5XG4gICAgICAgICAgY29uc3QgbWFwcGVkVHlwZSA9IE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuZ2V0KFxuICAgICAgICAgICAgYXJnMC5jb25zdHJ1Y3RvciBhcyBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG1hcHBlZFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7YXJnMC5jb25zdHJ1Y3Rvcn0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHR5cGUgPSBtYXBwZWRUeXBlO1xuICAgICAgICAgIGRhdGEgPSBhcmcwIGFzIFN1cHBvcnRlZFR5cGVkQXJyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHlwZSBhbmQgZGF0YSBpcyBwcm9jZXNzZWQsIG5vdyBwcm9jZXNzaW5nIGRpbXNcbiAgICAgIGlmIChtYXliZURpbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBhc3N1bWUgMS1EIHRlbnNvciBpZiBkaW1zIG9taXR0ZWRcbiAgICAgICAgbWF5YmVEaW1zID0gW2RhdGEubGVuZ3RoXTtcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWF5YmVEaW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSB0ZW5zb3IncyBkaW1zIG11c3QgYmUgYSBudW1iZXIgYXJyYXlcIik7XG4gICAgICB9XG4gICAgICBkaW1zID0gbWF5YmVEaW1zIGFzIHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgICB0aGlzLmNwdURhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnY3B1JztcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIGNoZWNrIG9uIGRpbXNcbiAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlU2l6ZShkaW1zKTtcbiAgICAvLyBpZiBkYXRhIGlzIG9uIENQVSwgY2hlY2sgd2hldGhlciBkYXRhIGxlbmd0aCBtYXRjaGVzIHRlbnNvciBzaXplXG4gICAgaWYgKHRoaXMuY3B1RGF0YSAmJiBzaXplICE9PSB0aGlzLmNwdURhdGEubGVuZ3RoKSB7XG4gICAgICBpZiAoKHR5cGUgPT09ICd1aW50NCcgfHwgdHlwZSA9PT0gJ2ludDQnKSAmJiBNYXRoLmNlaWwoc2l6ZSAvIDIpID09PSB0aGlzLmNwdURhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIGZvciAodSlpbnQ0LCB0aGUgZGF0YSBsZW5ndGggaXMgaGFsZiBvZiB0aGUgdGVuc29yIHNpemUuIFNvIHdlIGNoZWNrIHRoaXMgc3BlY2lhbCBjYXNlIHdoZW4gc2l6ZSBpcyBvZGQuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHtzaXplfSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHt0aGlzLmNwdURhdGEubGVuZ3RofSkuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRpbXMgPSBkaW1zO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gZmFjdG9yeVxuICBzdGF0aWMgYXN5bmMgZnJvbUltYWdlKFxuICAgIGltYWdlOiBJbWFnZURhdGEgfCBIVE1MSW1hZ2VFbGVtZW50IHwgSW1hZ2VCaXRtYXAgfCBzdHJpbmcsXG4gICAgb3B0aW9ucz86XG4gICAgICB8IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zXG4gICAgICB8IFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zXG4gICAgICB8IFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnNcbiAgICAgIHwgVGVuc29yRnJvbVVybE9wdGlvbnMsXG4gICk6IFByb21pc2U8VGVuc29ySW50ZXJmYWNlPiB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21JbWFnZShpbWFnZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbVRleHR1cmU8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5UZXh0dXJlRGF0YVR5cGVzPihcbiAgICB0ZXh0dXJlOiBUZW5zb3JUZXh0dXJlVHlwZSxcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VD4sXG4gICk6IFRlbnNvckludGVyZmFjZSB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21UZXh0dXJlKHRleHR1cmUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21HcHVCdWZmZXI8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5HcHVCdWZmZXJEYXRhVHlwZXM+KFxuICAgIGdwdUJ1ZmZlcjogVGVuc29yR3B1QnVmZmVyVHlwZSxcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9uczxUPixcbiAgKTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbUdwdUJ1ZmZlcihncHVCdWZmZXIsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21NTFRlbnNvcjxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yRGF0YVR5cGVzPihcbiAgICBtbFRlbnNvcjogVGVuc29yTUxUZW5zb3JUeXBlLFxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21NTFRlbnNvck9wdGlvbnM8VD4sXG4gICk6IFRlbnNvckludGVyZmFjZSB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21NTFRlbnNvcihtbFRlbnNvciwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBpbm5lZEJ1ZmZlcjxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLkNwdVBpbm5lZERhdGFUeXBlcz4oXG4gICAgdHlwZTogVCxcbiAgICBidWZmZXI6IFRlbnNvckludGVyZmFjZS5EYXRhVHlwZU1hcFtUXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21QaW5uZWRCdWZmZXIodHlwZSwgYnVmZmVyLCBkaW1zKTtcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIGNvbnZlcnNpb25zXG4gIHRvRGF0YVVSTChvcHRpb25zPzogVGVuc29yVG9EYXRhVXJsT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRlbnNvclRvRGF0YVVSTCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHRvSW1hZ2VEYXRhKG9wdGlvbnM/OiBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMpOiBJbWFnZURhdGEge1xuICAgIHJldHVybiB0ZW5zb3JUb0ltYWdlRGF0YSh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBwdWJsaWMgZmllbGRzXG4gIHJlYWRvbmx5IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSB0eXBlOiBUZW5zb3JUeXBlO1xuICByZWFkb25seSBzaXplOiBudW1iZXI7XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByaXZhdGUgZmllbGRzXG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEuXG4gICAqL1xuICBwcml2YXRlIGRhdGFMb2NhdGlvbjogVGVuc29yRGF0YUxvY2F0aW9uO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIGRhdGEgb24gQ1BVLCBpZiBsb2NhdGlvbiBpcyAnY3B1JyBvciAnY3B1LXBpbm5lZCcuIG90aGVyd2lzZSBlbXB0eS5cbiAgICovXG4gIHByaXZhdGUgY3B1RGF0YT86IFRlbnNvckRhdGFUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIHVuZGVybHlpbmcgdGV4dHVyZSB3aGVuIGxvY2F0aW9uIGlzICd0ZXh0dXJlJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBncHVUZXh0dXJlRGF0YT86IFRlbnNvclRleHR1cmVUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIHVuZGVybHlpbmcgR1BVIGJ1ZmZlciB3aGVuIGxvY2F0aW9uIGlzICdncHUtYnVmZmVyJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBncHVCdWZmZXJEYXRhPzogVGVuc29yR3B1QnVmZmVyVHlwZTtcblxuICAvKipcbiAgICogc3RvcmVzIHRoZSB1bmRlcmx5aW5nIFdlYk5OIE1MVGVuc29yIHdoZW4gbG9jYXRpb24gaXMgJ21sLXRlbnNvcicuIG90aGVyd2lzZSBlbXB0eS5cbiAgICovXG4gIHByaXZhdGUgbWxUZW5zb3JEYXRhPzogVGVuc29yTUxUZW5zb3JUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgYW4gb3B0aW9uYWwgZG93bmxvYWRlciBmdW5jdGlvbiB0byBkb3dubG9hZCBkYXRhIGZyb20gR1BVIHRvIENQVS5cbiAgICovXG4gIHByaXZhdGUgZG93bmxvYWRlcj8oKTogUHJvbWlzZTxUZW5zb3JEYXRhVHlwZT47XG5cbiAgLyoqXG4gICAqIGEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRhdGEgaXMgYmVpbmcgZG93bmxvYWRlZCBmcm9tIEdQVSB0byBDUFUuXG4gICAqL1xuICBwcml2YXRlIGlzRG93bmxvYWRpbmc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgYW4gb3B0aW9uYWwgZGlzcG9zZXIgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdW5kZXJseWluZyBkYXRhLlxuICAgKi9cbiAgcHJpdmF0ZSBkaXNwb3Nlcj8oKTogdm9pZDtcbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcHJvcGVydGllc1xuICBnZXQgZGF0YSgpOiBUZW5zb3JEYXRhVHlwZSB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIGlmICghdGhpcy5jcHVEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCAnICtcbiAgICAgICAgICAnb3IgdXNlIGB0ZXh0dXJlYCBvciBgZ3B1QnVmZmVyYCBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIEdQVSBkYXRhIGRpcmVjdGx5LicsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jcHVEYXRhO1xuICB9XG5cbiAgZ2V0IGxvY2F0aW9uKCk6IFRlbnNvckRhdGFMb2NhdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YUxvY2F0aW9uO1xuICB9XG5cbiAgZ2V0IHRleHR1cmUoKTogVGVuc29yVGV4dHVyZVR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMuZ3B1VGV4dHVyZURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdMIHRleHR1cmUuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdwdVRleHR1cmVEYXRhO1xuICB9XG5cbiAgZ2V0IGdwdUJ1ZmZlcigpOiBUZW5zb3JHcHVCdWZmZXJUeXBlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKCF0aGlzLmdwdUJ1ZmZlckRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdQVSBidWZmZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGE7XG4gIH1cblxuICBnZXQgbWxUZW5zb3IoKTogVGVuc29yTUxUZW5zb3JUeXBlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKCF0aGlzLm1sVGVuc29yRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViTk4gTUxUZW5zb3IuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1sVGVuc29yRGF0YTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBtZXRob2RzXG5cbiAgYXN5bmMgZ2V0RGF0YShyZWxlYXNlRGF0YT86IGJvb2xlYW4pOiBQcm9taXNlPFRlbnNvckRhdGFUeXBlPiB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIHN3aXRjaCAodGhpcy5kYXRhTG9jYXRpb24pIHtcbiAgICAgIGNhc2UgJ2NwdSc6XG4gICAgICBjYXNlICdjcHUtcGlubmVkJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICBjYXNlICdtbC10ZW5zb3InOiB7XG4gICAgICAgIGlmICghdGhpcy5kb3dubG9hZGVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgbm90IGNyZWF0ZWQgd2l0aCBhIHNwZWNpZmllZCBkYXRhIGRvd25sb2FkZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEb3dubG9hZGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmRvd25sb2FkZXIoKTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnY3B1JztcbiAgICAgICAgICB0aGlzLmNwdURhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgaWYgKHJlbGVhc2VEYXRhICYmIHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5pc0Rvd25sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGdldCBkYXRhIGZyb20gbG9jYXRpb246ICR7dGhpcy5kYXRhTG9jYXRpb259YCk7XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0Rvd25sb2FkaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRpc3Bvc2VyKSB7XG4gICAgICB0aGlzLmRpc3Bvc2VyKCk7XG4gICAgICB0aGlzLmRpc3Bvc2VyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmNwdURhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmdwdUJ1ZmZlckRhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tbFRlbnNvckRhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kb3dubG9hZGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaXNEb3dubG9hZGluZyA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuZGF0YUxvY2F0aW9uID0gJ25vbmUnO1xuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gdGVuc29yIHV0aWxpdGllc1xuICBwcml2YXRlIGVuc3VyZVZhbGlkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRhdGFMb2NhdGlvbiA9PT0gJ25vbmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgcmVzaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvckludGVyZmFjZSB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIGlmICh0aGlzLmRvd25sb2FkZXIgfHwgdGhpcy5kaXNwb3Nlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVzaGFwZSBhIHRlbnNvciB0aGF0IG93bnMgR1BVIHJlc291cmNlLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGVuc29yUmVzaGFwZSh0aGlzLCBkaW1zKTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvckZhY3RvcnkgfSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbXBsIH0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5pbXBvcnQgeyBUeXBlZFRlbnNvclV0aWxzIH0gZnJvbSAnLi90ZW5zb3ItdXRpbHMuanMnO1xuaW1wb3J0IHsgVHJ5R2V0R2xvYmFsVHlwZSB9IGZyb20gJy4vdHlwZS1oZWxwZXIuanMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlICovXG5cbi8qKlxuICogcmVwcmVzZW50IGEgYmFzaWMgdGVuc29yIHdpdGggc3BlY2lmaWVkIGRpbWVuc2lvbnMgYW5kIGRhdGEgdHlwZS5cbiAqL1xuaW50ZXJmYWNlIFR5cGVkVGVuc29yQmFzZTxUIGV4dGVuZHMgVGVuc29yLlR5cGU+IHtcbiAgLyoqXG4gICAqIEdldCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gIC8qKlxuICAgKiBHZXQgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogVDtcbiAgLyoqXG4gICAqIEdldCB0aGUgYnVmZmVyIGRhdGEgb2YgdGhlIHRlbnNvci5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IG9uIENQVSAoZWcuIGl0J3MgaW4gdGhlIGZvcm0gb2YgV2ViR0wgdGV4dHVyZSBvciBXZWJHUFUgYnVmZmVyKSwgdGhyb3cgZXJyb3IuXG4gICAqL1xuICByZWFkb25seSBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF07XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246IFRlbnNvci5EYXRhTG9jYXRpb247XG4gIC8qKlxuICAgKiBHZXQgdGhlIFdlYkdMIHRleHR1cmUgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBHUFUgYXMgV2ViR0wgdGV4dHVyZSwgdGhyb3cgZXJyb3IuXG4gICAqL1xuICByZWFkb25seSB0ZXh0dXJlOiBUZW5zb3IuVGV4dHVyZVR5cGU7XG4gIC8qKlxuICAgKiBHZXQgdGhlIFdlYkdQVSBidWZmZXIgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBHUFUgYXMgV2ViR1BVIGJ1ZmZlciwgdGhyb3cgZXJyb3IuXG4gICAqL1xuICByZWFkb25seSBncHVCdWZmZXI6IFRlbnNvci5HcHVCdWZmZXJUeXBlO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIFdlYk5OIE1MVGVuc29yIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBub3QgaW4gYSBXZWJOTiBNTFRlbnNvciwgdGhyb3cgZXJyb3IuXG4gICAqL1xuICByZWFkb25seSBtbFRlbnNvcjogVGVuc29yLk1MVGVuc29yVHlwZTtcblxuICAvKipcbiAgICogR2V0IHRoZSBidWZmZXIgZGF0YSBvZiB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBvbiBDUFUsIHJldHVybnMgdGhlIGRhdGEgaW1tZWRpYXRlbHkuXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIEdQVSwgZG93bmxvYWRzIHRoZSBkYXRhIGFuZCByZXR1cm5zIHRoZSBwcm9taXNlLlxuICAgKlxuICAgKiBAcGFyYW0gcmVsZWFzZURhdGEgLSB3aGV0aGVyIHJlbGVhc2UgdGhlIGRhdGEgb24gR1BVLiBJZ25vcmUgaWYgZGF0YSBpcyBhbHJlYWR5IG9uIENQVS5cbiAgICovXG4gIGdldERhdGEocmVsZWFzZURhdGE/OiBib29sZWFuKTogUHJvbWlzZTxUZW5zb3IuRGF0YVR5cGVNYXBbVF0+O1xuXG4gIC8qKlxuICAgKiBEaXNwb3NlIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgb24gQ1BVLCByZW1vdmUgaXRzIGludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgdW5kZXJseWluZyBkYXRhLlxuICAgKiBJZiB0aGUgZGF0YSBpcyBvbiBHUFUsIHJlbGVhc2UgdGhlIGRhdGEgb24gR1BVLlxuICAgKlxuICAgKiBBZnRlciBjYWxsaW5nIHRoaXMgZnVuY3Rpb24sIHRoZSB0ZW5zb3IgaXMgY29uc2lkZXJlZCBubyBsb25nZXIgdmFsaWQuIEl0cyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAnbm9uZScuXG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBUZW5zb3Ige1xuICBpbnRlcmZhY2UgRGF0YVR5cGVNYXAge1xuICAgIGZsb2F0MzI6IEZsb2F0MzJBcnJheTtcbiAgICB1aW50ODogVWludDhBcnJheTtcbiAgICBpbnQ4OiBJbnQ4QXJyYXk7XG4gICAgdWludDE2OiBVaW50MTZBcnJheTtcbiAgICBpbnQxNjogSW50MTZBcnJheTtcbiAgICBpbnQzMjogSW50MzJBcnJheTtcbiAgICBpbnQ2NDogQmlnSW50NjRBcnJheTtcbiAgICBzdHJpbmc6IHN0cmluZ1tdO1xuICAgIGJvb2w6IFVpbnQ4QXJyYXk7XG4gICAgZmxvYXQxNjogVWludDE2QXJyYXk7IC8vIEtlZXAgdXNpbmcgVWludDE2QXJyYXkgdW50aWwgd2UgaGF2ZSBhIGNvbmNyZXRlIHNvbHV0aW9uIGZvciBmbG9hdCAxNi5cbiAgICBmbG9hdDY0OiBGbG9hdDY0QXJyYXk7XG4gICAgdWludDMyOiBVaW50MzJBcnJheTtcbiAgICB1aW50NjQ6IEJpZ1VpbnQ2NEFycmF5O1xuICAgIC8vIGNvbXBsZXg2NDogbmV2ZXI7XG4gICAgLy8gY29tcGxleDEyODogbmV2ZXI7XG4gICAgLy8gYmZsb2F0MTY6IG5ldmVyO1xuICAgIHVpbnQ0OiBVaW50OEFycmF5O1xuICAgIGludDQ6IEludDhBcnJheTtcbiAgfVxuXG4gIGludGVyZmFjZSBFbGVtZW50VHlwZU1hcCB7XG4gICAgZmxvYXQzMjogbnVtYmVyO1xuICAgIHVpbnQ4OiBudW1iZXI7XG4gICAgaW50ODogbnVtYmVyO1xuICAgIHVpbnQxNjogbnVtYmVyO1xuICAgIGludDE2OiBudW1iZXI7XG4gICAgaW50MzI6IG51bWJlcjtcbiAgICBpbnQ2NDogYmlnaW50O1xuICAgIHN0cmluZzogc3RyaW5nO1xuICAgIGJvb2w6IGJvb2xlYW47XG4gICAgZmxvYXQxNjogbnVtYmVyOyAvLyBLZWVwIHVzaW5nIFVpbnQxNkFycmF5IHVudGlsIHdlIGhhdmUgYSBjb25jcmV0ZSBzb2x1dGlvbiBmb3IgZmxvYXQgMTYuXG4gICAgZmxvYXQ2NDogbnVtYmVyO1xuICAgIHVpbnQzMjogbnVtYmVyO1xuICAgIHVpbnQ2NDogYmlnaW50O1xuICAgIC8vIGNvbXBsZXg2NDogbmV2ZXI7XG4gICAgLy8gY29tcGxleDEyODogbmV2ZXI7XG4gICAgLy8gYmZsb2F0MTY6IG5ldmVyO1xuICAgIHVpbnQ0OiBudW1iZXI7XG4gICAgaW50NDogbnVtYmVyO1xuICB9XG5cbiAgdHlwZSBEYXRhVHlwZSA9IERhdGFUeXBlTWFwW1R5cGVdO1xuICB0eXBlIEVsZW1lbnRUeXBlID0gRWxlbWVudFR5cGVNYXBbVHlwZV07XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIHBpbm5lZCBDUFUgYnVmZmVyXG4gICAqL1xuICBleHBvcnQgdHlwZSBDcHVQaW5uZWREYXRhVHlwZXMgPSBFeGNsdWRlPFRlbnNvci5UeXBlLCAnc3RyaW5nJz47XG5cbiAgLyoqXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYkdMIHRleHR1cmVcbiAgICovXG4gIGV4cG9ydCB0eXBlIFRleHR1cmVUeXBlID0gV2ViR0xUZXh0dXJlO1xuXG4gIC8qKlxuICAgKiBzdXBwb3J0ZWQgZGF0YSB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHTCB0ZXh0dXJlXG4gICAqL1xuICBleHBvcnQgdHlwZSBUZXh0dXJlRGF0YVR5cGVzID0gJ2Zsb2F0MzInO1xuXG4gIHR5cGUgR3B1QnVmZmVyVHlwZUZhbGxiYWNrID0geyBzaXplOiBudW1iZXI7IG1hcFN0YXRlOiAndW5tYXBwZWQnIHwgJ3BlbmRpbmcnIHwgJ21hcHBlZCcgfTtcbiAgLyoqXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYkdQVSBidWZmZXJcbiAgICovXG4gIGV4cG9ydCB0eXBlIEdwdUJ1ZmZlclR5cGUgPSBUcnlHZXRHbG9iYWxUeXBlPCdHUFVCdWZmZXInLCBHcHVCdWZmZXJUeXBlRmFsbGJhY2s+O1xuXG4gIHR5cGUgTUxUZW5zb3JUeXBlRmFsbGJhY2sgPSB7IGRlc3Ryb3koKTogdm9pZCB9O1xuICAvKipcbiAgICogdHlwZSBhbGlhcyBmb3IgV2ViTk4gTUxUZW5zb3JcbiAgICpcbiAgICogVGhlIHNwZWNpZmljYXRpb24gZm9yIFdlYk5OJ3MgTUxUZW5zb3IgaXMgY3VycmVudGx5IGluIGZsdXguXG4gICAqL1xuICBleHBvcnQgdHlwZSBNTFRlbnNvclR5cGUgPSBUcnlHZXRHbG9iYWxUeXBlPCdNTFRlbnNvcicsIE1MVGVuc29yVHlwZUZhbGxiYWNrPjtcblxuICAvKipcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR1BVIGJ1ZmZlclxuICAgKi9cbiAgZXhwb3J0IHR5cGUgR3B1QnVmZmVyRGF0YVR5cGVzID0gJ2Zsb2F0MzInIHwgJ2Zsb2F0MTYnIHwgJ2ludDMyJyB8ICdpbnQ2NCcgfCAndWludDMyJyB8ICd1aW50OCcgfCAnYm9vbCc7XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYk5OIE1MVGVuc29yXG4gICAqL1xuICBleHBvcnQgdHlwZSBNTFRlbnNvckRhdGFUeXBlcyA9XG4gICAgfCAnZmxvYXQzMidcbiAgICB8ICdmbG9hdDE2J1xuICAgIHwgJ2ludDgnXG4gICAgfCAndWludDgnXG4gICAgfCAnaW50MzInXG4gICAgfCAndWludDMyJ1xuICAgIHwgJ2ludDY0J1xuICAgIHwgJ3VpbnQ2NCdcbiAgICB8ICdib29sJ1xuICAgIHwgJ3VpbnQ0J1xuICAgIHwgJ2ludDQnO1xuXG4gIC8qKlxuICAgKiByZXByZXNlbnQgd2hlcmUgdGhlIHRlbnNvciBkYXRhIGlzIHN0b3JlZFxuICAgKi9cbiAgZXhwb3J0IHR5cGUgRGF0YUxvY2F0aW9uID0gJ25vbmUnIHwgJ2NwdScgfCAnY3B1LXBpbm5lZCcgfCAndGV4dHVyZScgfCAnZ3B1LWJ1ZmZlcicgfCAnbWwtdGVuc29yJztcblxuICAvKipcbiAgICogcmVwcmVzZW50IHRoZSBkYXRhIHR5cGUgb2YgYSB0ZW5zb3JcbiAgICovXG4gIGV4cG9ydCB0eXBlIFR5cGUgPSBrZXlvZiBEYXRhVHlwZU1hcDtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgbXVsdGktZGltZW5zaW9uYWwgYXJyYXlzIHRvIGZlZWQgdG8gb3IgZmV0Y2ggZnJvbSBtb2RlbCBpbmZlcmVuY2luZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUeXBlZFRlbnNvcjxUIGV4dGVuZHMgVGVuc29yLlR5cGU+IGV4dGVuZHMgVHlwZWRUZW5zb3JCYXNlPFQ+LCBUeXBlZFRlbnNvclV0aWxzPFQ+IHt9XG4vKipcbiAqIFJlcHJlc2VudCBtdWx0aS1kaW1lbnNpb25hbCBhcnJheXMgdG8gZmVlZCB0byBvciBmZXRjaCBmcm9tIG1vZGVsIGluZmVyZW5jaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvciBleHRlbmRzIFR5cGVkVGVuc29yQmFzZTxUZW5zb3IuVHlwZT4sIFR5cGVkVGVuc29yVXRpbHM8VGVuc29yLlR5cGU+IHt9XG5cbi8qKlxuICogdHlwZSBUZW5zb3JDb25zdHJ1Y3RvciBkZWZpbmVzIHRoZSBjb25zdHJ1Y3RvcnMgb2YgJ1RlbnNvcicgdG8gY3JlYXRlIENQVSB0ZW5zb3IgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckNvbnN0cnVjdG9yIGV4dGVuZHMgVGVuc29yRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gQ1BVIHRlbnNvciAtIHNwZWNpZnkgZWxlbWVudCB0eXBlXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgc3RyaW5nIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwWydzdHJpbmcnXSB8IHJlYWRvbmx5IHN0cmluZ1tdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVHlwZWRUZW5zb3I8J3N0cmluZyc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9vbCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKFxuICAgIHR5cGU6ICdib29sJyxcbiAgICBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbJ2Jvb2wnXSB8IHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFR5cGVkVGVuc29yPCdib29sJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gYSBVaW50OENsYW1wZWRBcnJheSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAodHlwZTogJ3VpbnQ4JywgZGF0YTogVWludDhDbGFtcGVkQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50OCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgNjQtYml0IGludGVnZXIgdHlwZWQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IDxUIGV4dGVuZHMgJ3VpbnQ2NCcgfCAnaW50NjQnPihcbiAgICB0eXBlOiBULFxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXSB8IHJlYWRvbmx5IGJpZ2ludFtdIHwgcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApOiBUeXBlZFRlbnNvcjxUPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IG51bWVyaWMgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IDxUIGV4dGVuZHMgRXhjbHVkZTxUZW5zb3IuVHlwZSwgJ3N0cmluZycgfCAnYm9vbCcgfCAndWludDY0JyB8ICdpbnQ2NCc+PihcbiAgICB0eXBlOiBULFxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXSB8IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVHlwZWRUZW5zb3I8VD47XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIENQVSB0ZW5zb3IgLSBpbmZlciBlbGVtZW50IHR5cGVzXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBmbG9hdDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBGbG9hdDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdmbG9hdDMyJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQ4IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBJbnQ4QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQ4Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogVWludDhBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQ4Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogVWludDhDbGFtcGVkQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50OCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDE2IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBVaW50MTZBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQxNic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50MTYgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IEludDE2QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQxNic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50MzIgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IEludDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQzMic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50NjQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IEJpZ0ludDY0QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQ2NCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgc3RyaW5nIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiByZWFkb25seSBzdHJpbmdbXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3N0cmluZyc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9vbCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogcmVhZG9ubHkgYm9vbGVhbltdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnYm9vbCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgZmxvYXQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogRmxvYXQ2NEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnZmxvYXQ2NCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBVaW50MzJBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQzMic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDY0IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBCaWdVaW50NjRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQ2NCc+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIENQVSB0ZW5zb3IgLSBmYWxsIGJhY2sgdG8gbm9uLWdlbmVyaWMgdGVuc29yIHR5cGUgZGVjbGFyYXRpb25cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoXG4gICAgdHlwZTogVGVuc29yLlR5cGUsXG4gICAgZGF0YTogVGVuc29yLkRhdGFUeXBlIHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBzdHJpbmdbXSB8IHJlYWRvbmx5IGJpZ2ludFtdIHwgcmVhZG9ubHkgYm9vbGVhbltdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVGVuc29yO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IFRlbnNvci5EYXRhVHlwZSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yO1xuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBUZW5zb3IgPSBUZW5zb3JJbXBsIGFzIFRlbnNvckNvbnN0cnVjdG9yO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBlbnYgfSBmcm9tICcuL2Vudi1pbXBsLmpzJztcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCBUUkFDRSA9IChkZXZpY2VUeXBlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLnRpbWVTdGFtcChgJHtkZXZpY2VUeXBlfTo6T1JUOjoke2xhYmVsfWApO1xufTtcblxuY29uc3QgVFJBQ0VfRlVOQyA9IChtc2c6IHN0cmluZywgZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaz8uc3BsaXQoL1xcclxcbnxcXHJ8XFxuL2cpIHx8IFtdO1xuICBsZXQgaGFzVHJhY2VGdW5jID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGFzVHJhY2VGdW5jICYmICFzdGFja1tpXS5pbmNsdWRlcygnVFJBQ0VfRlVOQycpKSB7XG4gICAgICBsZXQgbGFiZWwgPSBgRlVOQ18ke21zZ306OiR7c3RhY2tbaV0udHJpbSgpLnNwbGl0KCcgJylbMV19YDtcbiAgICAgIGlmIChleHRyYU1zZykge1xuICAgICAgICBsYWJlbCArPSBgOjoke2V4dHJhTXNnfWA7XG4gICAgICB9XG4gICAgICBUUkFDRSgnQ1BVJywgbGFiZWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RhY2tbaV0uaW5jbHVkZXMoJ1RSQUNFX0ZVTkMnKSkge1xuICAgICAgaGFzVHJhY2VGdW5jID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0VfRlVOQ19CRUdJTiA9IChleHRyYU1zZz86IHN0cmluZykgPT4ge1xuICBpZiAodHlwZW9mIGVudi50cmFjZSA9PT0gJ3VuZGVmaW5lZCcgPyAhZW52Lndhc20udHJhY2UgOiAhZW52LnRyYWNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFRSQUNFX0ZVTkMoJ0JFR0lOJywgZXh0cmFNc2cpO1xufTtcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCBUUkFDRV9GVU5DX0VORCA9IChleHRyYU1zZz86IHN0cmluZykgPT4ge1xuICBpZiAodHlwZW9mIGVudi50cmFjZSA9PT0gJ3VuZGVmaW5lZCcgPyAhZW52Lndhc20udHJhY2UgOiAhZW52LnRyYWNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFRSQUNFX0ZVTkMoJ0VORCcsIGV4dHJhTXNnKTtcbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0VfRVZFTlRfQkVHSU4gPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLnRpbWUoYE9SVDo6JHtleHRyYU1zZ31gKTtcbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0VfRVZFTlRfRU5EID0gKGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS50aW1lRW5kKGBPUlQ6OiR7ZXh0cmFNc2d9YCk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIH0gZnJvbSAnLi9iYWNrZW5kLmpzJztcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZSB9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHsgT25ueFZhbHVlIH0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcbmltcG9ydCB7IFRSQUNFX0ZVTkNfQkVHSU4sIFRSQUNFX0ZVTkNfRU5ELCBUUkFDRV9FVkVOVF9CRUdJTiwgVFJBQ0VfRVZFTlRfRU5EIH0gZnJvbSAnLi90cmFjZS5qcyc7XG5cbnR5cGUgU2Vzc2lvbk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlNlc3Npb25PcHRpb25zO1xudHlwZSBSdW5PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SdW5PcHRpb25zO1xudHlwZSBGZWVkc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZlZWRzVHlwZTtcbnR5cGUgRmV0Y2hlc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZldGNoZXNUeXBlO1xudHlwZSBSZXR1cm5UeXBlID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SZXR1cm5UeXBlO1xuXG5leHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiBpbXBsZW1lbnRzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2Uge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKGhhbmRsZXI6IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZSB8IFJ1bk9wdGlvbnMsIGFyZzI/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIFRSQUNFX0VWRU5UX0JFR0lOKCdJbmZlcmVuY2VTZXNzaW9uLnJ1bicpO1xuICAgIGNvbnN0IGZldGNoZXM6IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfSA9IHt9O1xuICAgIGxldCBvcHRpb25zOiBSdW5PcHRpb25zID0ge307XG4gICAgLy8gY2hlY2sgaW5wdXRzXG4gICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiJ2ZlZWRzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXCIsXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBpc0ZldGNoZXNFbXB0eSA9IHRydWU7XG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG92ZXJyaWRlIGlzIGJlaW5nIHVzZWRcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgLy8gb3V0cHV0IG5hbWVzXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBhcmcxKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7bmFtZX0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyAmJiBhcmcyICE9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGFyZzEgaXMgZmV0Y2hlcyBvciBvcHRpb25zXG4gICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXG4gICAgICAgIGxldCBpc0ZldGNoZXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgYXJnMUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmcxKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoYXJnMSBhcyBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLk51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZldGNoZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzEgYXMgUnVuT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbGwgaW5wdXRzIGFyZSBpbiBmZWVkXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMuaW5wdXROYW1lcykge1xuICAgICAgaWYgKHR5cGVvZiBmZWVkc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtuYW1lfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIG5vIGZldGNoZXMgaXMgc3BlY2lmaWVkLCB3ZSB1c2UgdGhlIGZ1bGwgb3V0cHV0IG5hbWVzIGxpc3RcbiAgICBpZiAoaXNGZXRjaGVzRW1wdHkpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLm91dHB1dE5hbWVzKSB7XG4gICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zIGFyZSBwcmVwYXJlZFxuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuaGFuZGxlci5ydW4oZmVlZHMsIGZldGNoZXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJldHVyblZhbHVlOiB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNba2V5XTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IG5ldyBUZW5zb3IocmVzdWx0LnR5cGUsIHJlc3VsdC5kYXRhLCByZXN1bHQuZGltcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgVFJBQ0VfRVZFTlRfRU5EKCdJbmZlcmVuY2VTZXNzaW9uLnJ1bicpO1xuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG5cbiAgYXN5bmMgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGUocGF0aDogc3RyaW5nLCBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgY3JlYXRlKFxuICAgIGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLFxuICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcbiAgICBieXRlTGVuZ3RoPzogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcbiAgc3RhdGljIGNyZWF0ZShidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBhc3luYyBjcmVhdGUoXG4gICAgYXJnMDogc3RyaW5nIHwgQXJyYXlCdWZmZXJMaWtlIHwgVWludDhBcnJheSxcbiAgICBhcmcxPzogU2Vzc2lvbk9wdGlvbnMgfCBudW1iZXIsXG4gICAgYXJnMj86IG51bWJlcixcbiAgICBhcmczPzogU2Vzc2lvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICBUUkFDRV9FVkVOVF9CRUdJTignSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUnKTtcbiAgICAvLyBlaXRoZXIgbG9hZCBmcm9tIGEgZmlsZSBvciBidWZmZXJcbiAgICBsZXQgZmlsZVBhdGhPclVpbnQ4QXJyYXk6IHN0cmluZyB8IFVpbnQ4QXJyYXk7XG4gICAgbGV0IG9wdGlvbnM6IFNlc3Npb25PcHRpb25zID0ge307XG5cbiAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYXJnMCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBhcmcwIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpXG4gICAgKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBhcmcwO1xuICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgbGV0IGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJykge1xuICAgICAgICBieXRlT2Zmc2V0ID0gYXJnMTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlT2Zmc2V0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVPZmZzZXQnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVPZmZzZXQnIGlzIG91dCBvZiByYW5nZSBbMCwgJHtidWZmZXIuYnl0ZUxlbmd0aH0pLmApO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0O1xuICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGFyZzI7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlTGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHtidWZmZXIuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXR9XS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnb2JqZWN0JyAmJiBhcmczICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnMztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmczICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgfVxuICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFswXTogbXVzdCBiZSAncGF0aCcgb3IgJ2J1ZmZlcicuXCIpO1xuICAgIH1cblxuICAgIC8vIHJlc29sdmUgYmFja2VuZCwgdXBkYXRlIHNlc3Npb24gb3B0aW9ucyB3aXRoIHZhbGlkYXRlZCBFUHMsIGFuZCBjcmVhdGUgc2Vzc2lvbiBoYW5kbGVyXG4gICAgY29uc3QgW2JhY2tlbmQsIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzXSA9IGF3YWl0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzKG9wdGlvbnMpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBhd2FpdCBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKGZpbGVQYXRoT3JVaW50OEFycmF5LCBvcHRpb25zV2l0aFZhbGlkYXRlZEVQcyk7XG4gICAgVFJBQ0VfRVZFTlRfRU5EKCdJbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZScpO1xuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gICAgcmV0dXJuIG5ldyBJbmZlcmVuY2VTZXNzaW9uKGhhbmRsZXIpO1xuICB9XG5cbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgdGhpcy5oYW5kbGVyLnN0YXJ0UHJvZmlsaW5nKCk7XG4gIH1cbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuaGFuZGxlci5lbmRQcm9maWxpbmcoKTtcbiAgfVxuXG4gIGdldCBpbnB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXM7XG4gIH1cbiAgZ2V0IG91dHB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzO1xuICB9XG5cbiAgZ2V0IGlucHV0TWV0YWRhdGEoKTogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5WYWx1ZU1ldGFkYXRhW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuaW5wdXRNZXRhZGF0YTtcbiAgfVxuXG4gIGdldCBvdXRwdXRNZXRhZGF0YSgpOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlZhbHVlTWV0YWRhdGFbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXRNZXRhZGF0YTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlcjogSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkltcGwgfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanMnO1xuaW1wb3J0IHsgT25ueE1vZGVsT3B0aW9ucyB9IGZyb20gJy4vb25ueC1tb2RlbC5qcyc7XG5pbXBvcnQgeyBPbm54VmFsdWUsIE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQgdHlwZSB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcbmltcG9ydCB7IFRyeUdldEdsb2JhbFR5cGUgfSBmcm9tICcuL3R5cGUtaGVscGVyLmpzJztcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSAqL1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gIC8vICNyZWdpb24gaW5wdXQvb3V0cHV0IHR5cGVzXG5cbiAgdHlwZSBPbm54VmFsdWVNYXBUeXBlID0geyByZWFkb25seSBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIH07XG4gIHR5cGUgTnVsbGFibGVPbm54VmFsdWVNYXBUeXBlID0geyByZWFkb25seSBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIHwgbnVsbCB9O1xuXG4gIC8qKlxuICAgKiBBIGZlZWRzIChtb2RlbCBpbnB1dHMpIGlzIGFuIG9iamVjdCB0aGF0IHVzZXMgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgdHlwZSBGZWVkc1R5cGUgPSBPbm54VmFsdWVNYXBUeXBlO1xuXG4gIC8qKlxuICAgKiBBIGZldGNoZXMgKG1vZGVsIG91dHB1dHMpIGNvdWxkIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiAtIE9taXR0ZWQuIFVzZSBtb2RlbCdzIG91dHB1dCBuYW1lcyBkZWZpbml0aW9uLlxuICAgKiAtIEFuIGFycmF5IG9mIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBvdXRwdXQgbmFtZXMuXG4gICAqIC0gQW4gb2JqZWN0IHRoYXQgdXNlIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgb3IgbnVsbCBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICpcbiAgICogQHJlbWFya1xuICAgKiBkaWZmZXJlbnQgZnJvbSBpbnB1dCBhcmd1bWVudCwgaW4gb3V0cHV0LCBPbm54VmFsdWUgaXMgb3B0aW9uYWwuIElmIGFuIE9ubnhWYWx1ZSBpcyBwcmVzZW50IGl0IHdpbGwgYmVcbiAgICogdXNlZCBhcyBhIHByZS1hbGxvY2F0ZWQgdmFsdWUgYnkgdGhlIGluZmVyZW5jZSBlbmdpbmU7IGlmIG9taXR0ZWQsIGluZmVyZW5jZSBlbmdpbmUgd2lsbCBhbGxvY2F0ZSBidWZmZXJcbiAgICogaW50ZXJuYWxseS5cbiAgICovXG4gIHR5cGUgRmV0Y2hlc1R5cGUgPSByZWFkb25seSBzdHJpbmdbXSB8IE51bGxhYmxlT25ueFZhbHVlTWFwVHlwZTtcblxuICAvKipcbiAgICogQSBpbmZlcmVuY2luZyByZXR1cm4gdHlwZSBpcyBhbiBvYmplY3QgdGhhdCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICB0eXBlIFJldHVyblR5cGUgPSBPbm54VmFsdWVNYXBUeXBlO1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHNlc3Npb24gb3B0aW9uc1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiBjb25maWd1cmF0aW9ucyBmb3Igc2Vzc2lvbiBiZWhhdmlvci5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbk9wdGlvbnMgZXh0ZW5kcyBPbm54TW9kZWxPcHRpb25zIHtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBleGVjdXRpb24gcHJvdmlkZXIgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEFuIGV4ZWN1dGlvbiBwcm92aWRlciBvcHRpb24gY2FuIGJlIGEgc3RyaW5nIGluZGljYXRpbmcgdGhlIG5hbWUgb2YgdGhlIGV4ZWN1dGlvbiBwcm92aWRlcixcbiAgICAgKiBvciBhbiBvYmplY3Qgb2YgY29ycmVzcG9uZGluZyB0eXBlLlxuICAgICAqL1xuICAgIGV4ZWN1dGlvblByb3ZpZGVycz86IHJlYWRvbmx5IEV4ZWN1dGlvblByb3ZpZGVyQ29uZmlnW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50cmEgT1AgdGhyZWFkcyBudW1iZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKS5cbiAgICAgKi9cbiAgICBpbnRyYU9wTnVtVGhyZWFkcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlciBPUCB0aHJlYWRzIG51bWJlci5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIGludGVyT3BOdW1UaHJlYWRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGZyZWVEaW1lbnNpb25PdmVycmlkZXM/OiB7IHJlYWRvbmx5IFtkaW1lbnNpb25OYW1lOiBzdHJpbmddOiBudW1iZXIgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpbWl6YXRpb24gbGV2ZWwuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD86ICdkaXNhYmxlZCcgfCAnYmFzaWMnIHwgJ2V4dGVuZGVkJyB8ICdsYXlvdXQnIHwgJ2FsbCc7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBDUFUgbWVtb3J5IGFyZW5hLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGVuYWJsZUNwdU1lbUFyZW5hPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIG1lbW9yeSBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGVuYWJsZU1lbVBhdHRlcm4/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0aW9uIG1vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZXhlY3V0aW9uTW9kZT86ICdzZXF1ZW50aWFsJyB8ICdwYXJhbGxlbCc7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpbWl6ZWQgbW9kZWwgZmlsZSBwYXRoLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBzZXR0aW5nIGlzIHNwZWNpZmllZCwgdGhlIG9wdGltaXplZCBtb2RlbCB3aWxsIGJlIGR1bXBlZC4gSW4gYnJvd3NlciwgYSBibG9iIHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIHdpdGggYSBwb3AtdXAgd2luZG93LlxuICAgICAqL1xuICAgIG9wdGltaXplZE1vZGVsRmlsZVBhdGg/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBwcm9maWxpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBmdXR1cmUgdXNlLlxuICAgICAqL1xuICAgIGVuYWJsZVByb2ZpbGluZz86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBGaWxlIHByZWZpeCBmb3IgcHJvZmlsaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGEgcGxhY2Vob2xkZXIgZm9yIGEgZnV0dXJlIHVzZS5cbiAgICAgKi9cbiAgICBwcm9maWxlRmlsZVByZWZpeD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIExvZyBJRC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBsb2dJZD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIExvZyBzZXZlcml0eSBsZXZlbC4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL2NvbW1vbi9sb2dnaW5nL3NldmVyaXR5LmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBsb2dTZXZlcml0eUxldmVsPzogMCB8IDEgfCAyIHwgMyB8IDQ7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgdmVyYm9zaXR5IGxldmVsLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqL1xuICAgIGxvZ1ZlcmJvc2l0eUxldmVsPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBzdHJpbmcgYXMgYSBwcmVmZXJyZWQgZGF0YSBsb2NhdGlvbiBmb3IgYWxsIG91dHB1dHMsIG9yIGFuIG9iamVjdCB0aGF0IHVzZSBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgYVxuICAgICAqIHByZWZlcnJlZCBkYXRhIGxvY2F0aW9uIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIFdlYiBmb3IgV2ViR0wgYW5kIFdlYkdQVSBFUC5cbiAgICAgKi9cbiAgICBwcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj86IE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB8IHsgcmVhZG9ubHkgW291dHB1dE5hbWU6IHN0cmluZ106IE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB9O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBlbmFibGUgZ3JhcGggY2FwdHVyZS5cbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgV2ViIGZvciBXZWJHUFUgRVAuXG4gICAgICovXG4gICAgZW5hYmxlR3JhcGhDYXB0dXJlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlIGNvbmZpZ3VyYXRpb25zIGZvciBhIHNlc3Npb24uIFNlZVxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvYmxvYi9tYWluL2luY2x1ZGUvb25ueHJ1bnRpbWUvY29yZS9zZXNzaW9uL1xuICAgICAqIG9ubnhydW50aW1lX3Nlc3Npb25fb3B0aW9uc19jb25maWdfa2V5cy5oXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZXh0cmE6IHtcbiAgICAgKiAgIHNlc3Npb246IHtcbiAgICAgKiAgICAgc2V0X2Rlbm9ybWFsX2FzX3plcm86IFwiMVwiLFxuICAgICAqICAgICBkaXNhYmxlX3ByZXBhY2tpbmc6IFwiMVwiXG4gICAgICogICB9LFxuICAgICAqICAgb3B0aW1pemF0aW9uOiB7XG4gICAgICogICAgIGVuYWJsZV9nZWx1X2FwcHJveGltYXRpb246IFwiMVwiXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGV4dHJhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIH1cblxuICAvLyAjcmVnaW9uIGV4ZWN1dGlvbiBwcm92aWRlcnNcblxuICAvLyBDdXJyZW50bHksIHdlIGhhdmUgdGhlIGZvbGxvd2luZyBiYWNrZW5kcyB0byBzdXBwb3J0IGV4ZWN1dGlvbiBwcm92aWRlcnM6XG4gIC8vIEJhY2tlbmQgTm9kZS5qcyBiaW5kaW5nOiBzdXBwb3J0cyAnY3B1JywgJ2RtbCcgKHdpbjMyKSwgJ2NvcmVtbCcgKG1hY09TKSBhbmQgJ2N1ZGEnIChsaW51eCkuXG4gIC8vIEJhY2tlbmQgV2ViQXNzZW1ibHk6IHN1cHBvcnRzICdjcHUnLCAnd2FzbScsICd3ZWJncHUnIGFuZCAnd2Vibm4nLlxuICAvLyBCYWNrZW5kIE9OTlguanM6IHN1cHBvcnRzICd3ZWJnbCcuXG4gIC8vIEJhY2tlbmQgUmVhY3QgTmF0aXZlOiBzdXBwb3J0cyAnY3B1JywgJ3hubnBhY2snLCAnY29yZW1sJyAoaU9TKSwgJ25uYXBpJyAoQW5kcm9pZCkuXG4gIGludGVyZmFjZSBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcCB7XG4gICAgY29yZW1sOiBDb3JlTUxFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBjcHU6IENwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGN1ZGE6IEN1ZGFFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBkbWw6IERtbEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIG5uYXBpOiBObmFwaUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHRlbnNvcnJ0OiBUZW5zb3JSdEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHdhc206IFdlYkFzc2VtYmx5RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2ViZ2w6IFdlYkdMRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2ViZ3B1OiBXZWJHcHVFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3ZWJubjogV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBxbm46IFFubkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHhubnBhY2s6IFhubnBhY2tFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgfVxuXG4gIHR5cGUgRXhlY3V0aW9uUHJvdmlkZXJOYW1lID0ga2V5b2YgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb25NYXA7XG4gIHR5cGUgRXhlY3V0aW9uUHJvdmlkZXJDb25maWcgPVxuICAgIHwgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb25NYXBbRXhlY3V0aW9uUHJvdmlkZXJOYW1lXVxuICAgIHwgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb25cbiAgICB8IEV4ZWN1dGlvblByb3ZpZGVyTmFtZVxuICAgIHwgc3RyaW5nO1xuXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIENwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdjcHUnO1xuICAgIHVzZUFyZW5hPzogYm9vbGVhbjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIEN1ZGFFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnY3VkYSc7XG4gICAgZGV2aWNlSWQ/OiBudW1iZXI7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBEbWxFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnZG1sJztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFRlbnNvclJ0RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3RlbnNvcnJ0JztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkFzc2VtYmx5RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3dhc20nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR0xFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2ViZ2wnO1xuICAgIC8vIFRPRE86IGFkZCBmbGFnc1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgWG5ucGFja0V4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd4bm5wYWNrJztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJncHUnO1xuICAgIHByZWZlcnJlZExheW91dD86ICdOQ0hXJyB8ICdOSFdDJztcbiAgfVxuXG4gIC8vICNyZWdpb24gV2ViTk4gb3B0aW9uc1xuXG4gIGludGVyZmFjZSBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2Vibm4nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzZXQgb2Ygb3B0aW9ucyBmb3IgY3JlYXRpbmcgYSBXZWJOTiBNTENvbnRleHQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkaWN0ZGVmLW1sY29udGV4dG9wdGlvbnNcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5Db250ZXh0T3B0aW9ucyB7XG4gICAgZGV2aWNlVHlwZT86ICdjcHUnIHwgJ2dwdScgfCAnbnB1JztcbiAgICBudW1UaHJlYWRzPzogbnVtYmVyO1xuICAgIHBvd2VyUHJlZmVyZW5jZT86ICdkZWZhdWx0JyB8ICdsb3ctcG93ZXInIHwgJ2hpZ2gtcGVyZm9ybWFuY2UnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzZXQgb2Ygb3B0aW9ucyBmb3IgV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyIHdpdGhvdXQgTUxDb250ZXh0LlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJOTk9wdGlvbnNXaXRob3V0TUxDb250ZXh0IGV4dGVuZHMgV2ViTk5FeGVjdXRpb25Qcm92aWRlck5hbWUsIFdlYk5OQ29udGV4dE9wdGlvbnMge1xuICAgIGNvbnRleHQ/OiBuZXZlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2V0IG9mIG9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlciB3aXRoIE1MQ29udGV4dC5cbiAgICpcbiAgICogV2hlbiBNTENvbnRleHQgaXMgcHJvdmlkZWQsIHRoZSBkZXZpY2VUeXBlIGlzIGFsc28gcmVxdWlyZWQgc28gdGhhdCB0aGUgV2ViTk4gRVAgY2FuIGRldGVybWluZSB0aGUgcHJlZmVycmVkXG4gICAqIGNoYW5uZWwgbGF5b3V0LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJubi8jZG9tLW1sLWNyZWF0ZWNvbnRleHRcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5PcHRpb25zV2l0aE1MQ29udGV4dFxuICAgIGV4dGVuZHMgV2ViTk5FeGVjdXRpb25Qcm92aWRlck5hbWUsXG4gICAgICBPbWl0PFdlYk5OQ29udGV4dE9wdGlvbnMsICdkZXZpY2VUeXBlJz4sXG4gICAgICBSZXF1aXJlZDxQaWNrPFdlYk5OQ29udGV4dE9wdGlvbnMsICdkZXZpY2VUeXBlJz4+IHtcbiAgICBjb250ZXh0OiBUcnlHZXRHbG9iYWxUeXBlPCdNTENvbnRleHQnPjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2V0IG9mIG9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlciB3aXRoIE1MQ29udGV4dCB3aGljaCBpcyBjcmVhdGVkIGZyb20gR1BVRGV2aWNlLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJubi8jZG9tLW1sLWNyZWF0ZWNvbnRleHQtZ3B1ZGV2aWNlXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OT3B0aW9uc1dlYkdwdSBleHRlbmRzIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJOYW1lIHtcbiAgICBjb250ZXh0OiBUcnlHZXRHbG9iYWxUeXBlPCdNTENvbnRleHQnPjtcbiAgICBncHVEZXZpY2U6IFRyeUdldEdsb2JhbFR5cGU8J0dQVURldmljZSc+O1xuICB9XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlci5cbiAgICovXG4gIGV4cG9ydCB0eXBlIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gPVxuICAgIHwgV2ViTk5PcHRpb25zV2l0aG91dE1MQ29udGV4dFxuICAgIHwgV2ViTk5PcHRpb25zV2l0aE1MQ29udGV4dFxuICAgIHwgV2ViTk5PcHRpb25zV2ViR3B1O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICBleHBvcnQgaW50ZXJmYWNlIFFubkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdxbm4nO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIFFOTiBiYWNrZW5kIHR5cGUuIEUuZy4sICdjcHUnIG9yICdodHAnLlxuICAgICAqIE11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIGBiYWNrZW5kUGF0aGAuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCAnaHRwJ1xuICAgICAqL1xuICAgIGJhY2tlbmRUeXBlPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSBwYXRoIHRvIHRoZSBRTk4gYmFja2VuZCBsaWJyYXJ5LlxuICAgICAqIE11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIGBiYWNrZW5kVHlwZWAuXG4gICAgICovXG4gICAgYmFja2VuZFBhdGg/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIGVuYWJsZSBIVFAgRlAxNiBwcmVjaXNpb24uXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgZW5hYmxlRnAxNlByZWNpc2lvbj86IGJvb2xlYW47XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBDb3JlTUxFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnY29yZW1sJztcbiAgICAvKipcbiAgICAgKiBUaGUgYml0IGZsYWdzIGZvciBDb3JlTUwgZXhlY3V0aW9uIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQ09SRU1MX0ZMQUdfVVNFX0NQVV9PTkxZID0gMHgwMDFcbiAgICAgKiBDT1JFTUxfRkxBR19FTkFCTEVfT05fU1VCR1JBUEggPSAweDAwMlxuICAgICAqIENPUkVNTF9GTEFHX09OTFlfRU5BQkxFX0RFVklDRV9XSVRIX0FORSA9IDB4MDA0XG4gICAgICogQ09SRU1MX0ZMQUdfT05MWV9BTExPV19TVEFUSUNfSU5QVVRfU0hBUEVTID0gMHgwMDhcbiAgICAgKiBDT1JFTUxfRkxBR19DUkVBVEVfTUxQUk9HUkFNID0gMHgwMTBcbiAgICAgKiBDT1JFTUxfRkxBR19VU0VfQ1BVX0FORF9HUFUgPSAweDAyMFxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogU2VlIGluY2x1ZGUvb25ueHJ1bnRpbWUvY29yZS9wcm92aWRlcnMvY29yZW1sL2NvcmVtbF9wcm92aWRlcl9mYWN0b3J5LmggZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoaXMgZmxhZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nKS5cbiAgICAgKi9cbiAgICBjb3JlTWxGbGFncz86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHdoZXRoZXIgdG8gdXNlIENQVSBvbmx5IGluIENvcmVNTCBFUC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAocmVhY3QtbmF0aXZlKS5cbiAgICAgKi9cbiAgICB1c2VDUFVPbmx5PzogYm9vbGVhbjtcbiAgICB1c2VDUFVBbmRHUFU/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byBlbmFibGUgQ29yZU1MIEVQIG9uIHN1YmdyYXBoLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChyZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIGVuYWJsZU9uU3ViZ3JhcGg/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byBvbmx5IGVuYWJsZSBDb3JlTUwgRVAgZm9yIEFwcGxlIGRldmljZXMgd2l0aCBBTkUgKEFwcGxlIE5ldXJhbCBFbmdpbmUpLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChyZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIG9ubHlFbmFibGVEZXZpY2VXaXRoQU5FPzogYm9vbGVhbjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIE5uYXBpRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ25uYXBpJztcbiAgICB1c2VGUDE2PzogYm9vbGVhbjtcbiAgICB1c2VOQ0hXPzogYm9vbGVhbjtcbiAgICBjcHVEaXNhYmxlZD86IGJvb2xlYW47XG4gICAgY3B1T25seT86IGJvb2xlYW47XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJ1biBvcHRpb25zXG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIGNvbmZpZ3VyYXRpb25zIGZvciBpbmZlcmVuY2UgcnVuIGJlaGF2aW9yXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFJ1bk9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIExvZyBzZXZlcml0eSBsZXZlbC4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL2NvbW1vbi9sb2dnaW5nL3NldmVyaXR5LmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBsb2dTZXZlcml0eUxldmVsPzogMCB8IDEgfCAyIHwgMyB8IDQ7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgdmVyYm9zaXR5IGxldmVsLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqL1xuICAgIGxvZ1ZlcmJvc2l0eUxldmVsPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGVybWluYXRlIGFsbCBpbmNvbXBsZXRlIE9ydFJ1biBjYWxscyBhcyBzb29uIGFzIHBvc3NpYmxlIGlmIHRydWVcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKi9cbiAgICB0ZXJtaW5hdGU/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQSB0YWcgZm9yIHRoZSBSdW4oKSBjYWxscyB1c2luZyB0aGlzXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgdGFnPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgc2luZ2xlIHJ1biBjb25maWd1cmF0aW9uIGVudHJ5LiBTZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvc2Vzc2lvbi9cbiAgICAgKiBvbm54cnVudGltZV9ydW5fb3B0aW9uc19jb25maWdfa2V5cy5oXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBleHRyYToge1xuICAgICAqICAgbWVtb3J5OiB7XG4gICAgICogICAgIGVuYWJsZV9tZW1vcnlfYXJlbmFfc2hyaW5rYWdlOiBcIjFcIixcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHZhbHVlIG1ldGFkYXRhXG5cbiAgLyoqXG4gICAqIFRoZSBjb21tb24gcGFydCBvZiB0aGUgdmFsdWUgbWV0YWRhdGEgdHlwZSBmb3IgYm90aCB0ZW5zb3IgYW5kIG5vbi10ZW5zb3IgdmFsdWVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBWYWx1ZU1ldGFkYXRhQmFzZSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNwZWNpZmllZCBpbnB1dCBvciBvdXRwdXQuXG4gICAgICovXG4gICAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgdGhlIG1ldGFkYXRhIG9mIGEgbm9uLXRlbnNvciB2YWx1ZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgTm9uVGVuc29yVmFsdWVNZXRhZGF0YSBleHRlbmRzIFZhbHVlTWV0YWRhdGFCYXNlIHtcbiAgICAvKipcbiAgICAgKiBHZXQgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdGVuc29yLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGlzVGVuc29yOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIHRoZSBtZXRhZGF0YSBvZiBhIHRlbnNvciB2YWx1ZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGVuc29yVmFsdWVNZXRhZGF0YSBleHRlbmRzIFZhbHVlTWV0YWRhdGFCYXNlIHtcbiAgICAvKipcbiAgICAgKiBHZXQgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdGVuc29yLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGlzVGVuc29yOiB0cnVlO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAgICovXG4gICAgcmVhZG9ubHkgdHlwZTogVGVuc29yLlR5cGU7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzaGFwZSBvZiB0aGUgdGVuc29yLlxuICAgICAqXG4gICAgICogSWYgdGhlIHNoYXBlIGlzIG5vdCBkZWZpbmVkLCB0aGUgdmFsdWUgd2lsbCBhbiBlbXB0eSBhcnJheS4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgc2hhcGVcbiAgICAgKiBvZiB0aGUgdGVuc29yLiBFYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZy4gSWYgdGhlIGVsZW1lbnQgaXMgYSBudW1iZXIsIGl0IHJlcHJlc2VudHNcbiAgICAgKiB0aGUgY29ycmVzcG9uZGluZyBkaW1lbnNpb24gc2l6ZS4gSWYgdGhlIGVsZW1lbnQgaXMgYSBzdHJpbmcsIGl0IHJlcHJlc2VudHMgYSBzeW1ib2xpYyBkaW1lbnNpb24uXG4gICAgICovXG4gICAgcmVhZG9ubHkgc2hhcGU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIHRoZSBtZXRhZGF0YSBvZiBhIHZhbHVlLlxuICAgKi9cbiAgZXhwb3J0IHR5cGUgVmFsdWVNZXRhZGF0YSA9IE5vblRlbnNvclZhbHVlTWV0YWRhdGEgfCBUZW5zb3JWYWx1ZU1ldGFkYXRhO1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBydW50aW1lIGluc3RhbmNlIG9mIGFuIE9OTlggbW9kZWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gIC8vICNyZWdpb24gcnVuKClcblxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgbW9kZWwgYXN5bmNocm9ub3VzbHkgd2l0aCB0aGUgZ2l2ZW4gZmVlZHMgYW5kIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uSW5wdXRUeXBlYCBmb3IgZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGluZmVyZW5jZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHJ1bihmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIG1vZGVsIGFzeW5jaHJvbm91c2x5IHdpdGggdGhlIGdpdmVuIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yIGRldGFpbC5cbiAgICogQHBhcmFtIGZldGNoZXMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgb3V0cHV0LiBTZWUgdHlwZSBkZXNjcmlwdGlvbiBvZiBgSW5mZXJlbmNlU2Vzc2lvbi5PdXRwdXRUeXBlYCBmb3JcbiAgICogZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGluZmVyZW5jZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHJ1bihcbiAgICBmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsXG4gICAgZmV0Y2hlczogSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcmVsZWFzZSgpXG5cbiAgLyoqXG4gICAqIFJlbGVhc2UgdGhlIGluZmVyZW5jZSBzZXNzaW9uIGFuZCB0aGUgdW5kZXJseWluZyByZXNvdXJjZXMuXG4gICAqL1xuICByZWxlYXNlKCk6IFByb21pc2U8dm9pZD47XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcHJvZmlsaW5nXG5cbiAgLyoqXG4gICAqIFN0YXJ0IHByb2ZpbGluZy5cbiAgICovXG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEVuZCBwcm9maWxpbmcuXG4gICAqL1xuICBlbmRQcm9maWxpbmcoKTogdm9pZDtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBtZXRhZGF0YVxuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXQgb3V0cHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEdldCBpbnB1dCBtZXRhZGF0YSBvZiB0aGUgbG9hZGVkIG1vZGVsLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5wdXRNZXRhZGF0YTogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhW107XG5cbiAgLyoqXG4gICAqIEdldCBvdXRwdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dE1ldGFkYXRhOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGFbXTtcblxuICAvLyAjZW5kcmVnaW9uXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlU2Vzc2lvbkZhY3Rvcnkge1xuICAvLyAjcmVnaW9uIGNyZWF0ZSgpXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIGFuIE9OTlggbW9kZWwgZmlsZS5cbiAgICpcbiAgICogQHBhcmFtIHVyaSAtIFRoZSBVUkkgb3IgZmlsZSBwYXRoIG9mIHRoZSBtb2RlbCB0byBsb2FkLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKHVyaTogc3RyaW5nLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIGFuIGFycmF5IGJ1ZmVyLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gQW4gQXJyYXlCdWZmZXIgcmVwcmVzZW50YXRpb24gb2YgYW4gT05OWCBtb2RlbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBzcGVjaWZ5IGNvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBJbmZlcmVuY2VTZXNzaW9uIG9iamVjdC5cbiAgICovXG4gIGNyZWF0ZShidWZmZXI6IEFycmF5QnVmZmVyTGlrZSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBzZWdtZW50IG9mIGFuIGFycmF5IGJ1ZmVyLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gQW4gQXJyYXlCdWZmZXIgcmVwcmVzZW50YXRpb24gb2YgYW4gT05OWCBtb2RlbC5cbiAgICogQHBhcmFtIGJ5dGVPZmZzZXQgLSBUaGUgYmVnaW5uaW5nIG9mIHRoZSBzcGVjaWZpZWQgcG9ydGlvbiBvZiB0aGUgYXJyYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0gYnl0ZUxlbmd0aCAtIFRoZSBsZW5ndGggaW4gYnl0ZXMgb2YgdGhlIGFycmF5IGJ1ZmZlci5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBzcGVjaWZ5IGNvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBJbmZlcmVuY2VTZXNzaW9uIG9iamVjdC5cbiAgICovXG4gIGNyZWF0ZShcbiAgICBidWZmZXI6IEFycmF5QnVmZmVyTGlrZSxcbiAgICBieXRlT2Zmc2V0OiBudW1iZXIsXG4gICAgYnl0ZUxlbmd0aD86IG51bWJlcixcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYSBVaW50OEFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gQSBVaW50OEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUoYnVmZmVyOiBVaW50OEFycmF5LCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgSW5mZXJlbmNlU2Vzc2lvbjogSW5mZXJlbmNlU2Vzc2lvbkZhY3RvcnkgPSBJbmZlcmVuY2VTZXNzaW9uSW1wbDtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzLCBPcHRpb25zVGVuc29yTGF5b3V0IH0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yVG9EYXRhVXJsT3B0aW9ucyBleHRlbmRzIE9wdGlvbnNUZW5zb3JMYXlvdXQsIE9wdGlvbnNGb3JtYXQsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyBleHRlbmRzIE9wdGlvbnNUZW5zb3JMYXlvdXQsIE9wdGlvbnNGb3JtYXQsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNpb25VdGlscyB7XG4gIC8qKlxuICAgKiBjcmVhdGVzIGEgRGF0YVVSTCBpbnN0YW5jZSBmcm9tIHRlbnNvclxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgYSBEYXRhVVJMIGluc3RhbmNlIGZyb20gdGhlIHRlbnNvci5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgZm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiBAcmV0dXJucyBhIERhdGFVUkwgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgaW1hZ2UgY29udmVydGVkIGZyb20gdGVuc29yIGRhdGFcbiAgICovXG4gIHRvRGF0YVVSTChvcHRpb25zPzogVGVuc29yVG9EYXRhVXJsT3B0aW9ucyk6IHN0cmluZztcblxuICAvKipcbiAgICogY3JlYXRlcyBhbiBJbWFnZURhdGEgaW5zdGFuY2UgZnJvbSB0ZW5zb3JcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGFuIEltYWdlRGF0YSBpbnN0YW5jZSBmcm9tIHRoZSB0ZW5zb3IuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYGZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogQHJldHVybnMgYW4gSW1hZ2VEYXRhIGluc3RhbmNlIHJlcHJlc2VudGluZyB0aGUgaW1hZ2UgY29udmVydGVkIGZyb20gdGVuc29yIGRhdGFcbiAgICovXG4gIHRvSW1hZ2VEYXRhKG9wdGlvbnM/OiBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMpOiBJbWFnZURhdGE7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciwgVHlwZWRUZW5zb3IgfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbmV4cG9ydCB0eXBlIEltYWdlRm9ybWF0ID0gJ1JHQicgfCAnUkdCQScgfCAnQkdSJyB8ICdSQkcnO1xuZXhwb3J0IHR5cGUgSW1hZ2VUZW5zb3JMYXlvdXQgPSAnTkhXQycgfCAnTkNIVyc7XG5cbi8vIHRoZSBmb2xsb3dpbmcgcmVnaW9uIGNvbnRhaW5zIHR5cGUgZGVmaW5pdGlvbnMgZm9yIGNvbnN0cnVjdGluZyB0ZW5zb3IgZnJvbSBhIHNwZWNpZmljIGxvY2F0aW9uLlxuXG4vLyAjcmVnaW9uIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIHNwZWNpZmljIGxvY2F0aW9uXG5cbi8qKlxuICogcmVwcmVzZW50IGNvbW1vbiBwcm9wZXJ0aWVzIG9mIHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gKi9cbmludGVyZmFjZSBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4gZXh0ZW5kcyBQaWNrPFRlbnNvciwgJ2RpbXMnPiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIHJlYWRvbmx5IHR5cGU6IFQ7XG59XG5cbi8qKlxuICogcmVwcmVzZW50IHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgR1BVIHJlc291cmNlLlxuICovXG5pbnRlcmZhY2UgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5UeXBlPiB7XG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBkb3dubG9hZCBkYXRhIGZyb20gR1BVIHRvIENQVS5cbiAgICpcbiAgICogSWYgbm90IHByb3ZpZGVkLCB0aGUgdGVuc29yIHRyZWF0IHRoZSBHUFUgZGF0YSBhcyBleHRlcm5hbCByZXNvdXJjZS5cbiAgICovXG4gIGRvd25sb2FkPygpOiBQcm9taXNlPFRlbnNvci5EYXRhVHlwZU1hcFtUXT47XG5cbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgdGVuc29yIGlzIGRpc3Bvc2VkLlxuICAgKlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIHRoZSB0ZW5zb3IgdHJlYXQgdGhlIEdQVSBkYXRhIGFzIGV4dGVybmFsIHJlc291cmNlLlxuICAgKi9cbiAgZGlzcG9zZT8oKTogdm9pZDtcbn1cblxuLyoqXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBwaW5uZWQgQ1BVIGJ1ZmZlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLkNwdVBpbm5lZERhdGFUeXBlcyA9IFRlbnNvci5DcHVQaW5uZWREYXRhVHlwZXM+XG4gIGV4dGVuZHMgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIHRvIGJlICdjcHUtcGlubmVkJy5cbiAgICovXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiAnY3B1LXBpbm5lZCc7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBDUFUgcGlubmVkIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXTtcbn1cblxuLyoqXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHTCB0ZXh0dXJlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLlRleHR1cmVEYXRhVHlwZXMgPSBUZW5zb3IuVGV4dHVyZURhdGFUeXBlcz5cbiAgZXh0ZW5kcyBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4sXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ3RleHR1cmUnLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICd0ZXh0dXJlJztcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIFdlYkdMIHRleHR1cmUgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqL1xuICByZWFkb25seSB0ZXh0dXJlOiBUZW5zb3IuVGV4dHVyZVR5cGU7XG59XG5cbi8qKlxuICogcmVwcmVzZW50IHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR1BVIGJ1ZmZlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcyA9IFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+XG4gIGV4dGVuZHMgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+LFxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIHRvIGJlICdncHUtYnVmZmVyJy5cbiAgICovXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcic7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBXZWJHUFUgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgZ3B1QnVmZmVyOiBUZW5zb3IuR3B1QnVmZmVyVHlwZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLk1MVGVuc29yRGF0YVR5cGVzID0gVGVuc29yLk1MVGVuc29yRGF0YVR5cGVzPlxuICBleHRlbmRzIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPixcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSB0byBiZSAnbWwtdGVuc29yJy5cbiAgICovXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiAnbWwtdGVuc29yJztcblxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgV2ViTk4gTUxUZW5zb3IgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqL1xuICByZWFkb25seSBtbFRlbnNvcjogVGVuc29yLk1MVGVuc29yVHlwZTtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG4vLyB0aGUgZm9sbG93aW5nIHJlZ2lvbiBjb250YWlucyB0eXBlIGRlZmluaXRpb25zIG9mIGVhY2ggaW5kaXZpZHVhbCBvcHRpb25zLlxuLy8gdGhlIHRlbnNvciBmYWN0b3J5IGZ1bmN0aW9ucyB1c2UgYSBjb21wb3NpdGlvbiBvZiB0aG9zZSBvcHRpb25zIGFzIHRoZSBwYXJhbWV0ZXIgdHlwZS5cblxuLy8gI3JlZ2lvbiBPcHRpb25zIGZpZWxkc1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNGb3JtYXQge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBpbWFnZSBmb3JtYXQgcmVwcmVzZW50ZWQgaW4gUkdCQSBjb2xvciBzcGFjZS5cbiAgICovXG4gIGZvcm1hdD86IEltYWdlRm9ybWF0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNUZW5zb3JGb3JtYXQge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBpbWFnZSBmb3JtYXQgb2YgdGhlIHRlbnNvci5cbiAgICpcbiAgICogTk9URTogdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBvcHRpb24gJ2Zvcm1hdCcuIFdoaWxlIG9wdGlvbiAnZm9ybWF0JyByZXByZXNlbnRzIHRoZSBvcmlnaW5hbCBpbWFnZSwgJ3RlbnNvckZvcm1hdCdcbiAgICogcmVwcmVzZW50cyB0aGUgdGFyZ2V0IGZvcm1hdCBvZiB0aGUgdGVuc29yLiBBIHRyYW5zcG9zZSB3aWxsIGJlIHBlcmZvcm1lZCBpZiB0aGV5IGFyZSBkaWZmZXJlbnQuXG4gICAqL1xuICB0ZW5zb3JGb3JtYXQ/OiBJbWFnZUZvcm1hdDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zVGVuc29yRGF0YVR5cGUge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIGRhdGFUeXBlPzogJ2Zsb2F0MzInIHwgJ3VpbnQ4Jztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zVGVuc29yTGF5b3V0IHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgdGVuc29yIGxheW91dCB3aGVuIHJlcHJlc2VudGluZyBkYXRhIG9mIG9uZSBvciBtb3JlIGltYWdlKHMpLlxuICAgKi9cbiAgdGVuc29yTGF5b3V0PzogSW1hZ2VUZW5zb3JMYXlvdXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc0RpbWVuc2lvbnMge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBpbWFnZSBoZWlnaHQgaW4gcGl4ZWxcbiAgICovXG4gIGhlaWdodD86IG51bWJlcjtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgaW1hZ2Ugd2lkdGggaW4gcGl4ZWxcbiAgICovXG4gIHdpZHRoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zIHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgcmVzaXplZCBoZWlnaHQuIElmIG9taXR0ZWQsIG9yaWdpbmFsIGhlaWdodCB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICByZXNpemVkSGVpZ2h0PzogbnVtYmVyO1xuICAvKipcbiAgICogRGVzY3JpYmVzIHJlc2l6ZWQgd2lkdGggLSBjYW4gYmUgYWNjZXNzZWQgdmlhIHRlbnNvciBkaW1lbnNpb25zIGFzIHdlbGxcbiAgICovXG4gIHJlc2l6ZWRXaWR0aD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge1xuICAvKipcbiAgICogRGVzY3JpYmVzIG5vcm1hbGl6YXRpb24gcGFyYW1ldGVycyB3aGVuIHByZXByb2Nlc3NpbmcgdGhlIGltYWdlIGFzIG1vZGVsIGlucHV0LlxuICAgKlxuICAgKiBEYXRhIGVsZW1lbnQgYXJlIHJhbmdlZCBmcm9tIDAgdG8gMjU1LlxuICAgKi9cbiAgbm9ybT86IHtcbiAgICAvKipcbiAgICAgKiBUaGUgJ2JpYXMnIHZhbHVlIGZvciBpbWFnZSBub3JtYWxpemF0aW9uLlxuICAgICAqIC0gSWYgb21pdHRlZCwgdXNlIGRlZmF1bHQgdmFsdWUgMC5cbiAgICAgKiAtIElmIGl0J3MgYSBzaW5nbGUgbnVtYmVyLCBhcHBseSB0byBlYWNoIGNoYW5uZWxcbiAgICAgKiAtIElmIGl0J3MgYW4gYXJyYXkgb2YgMyBvciA0IG51bWJlcnMsIGFwcGx5IGVsZW1lbnQtd2lzZS4gTnVtYmVyIG9mIGVsZW1lbnRzIG5lZWQgdG8gbWF0Y2ggdGhlIG51bWJlciBvZiBjaGFubmVsc1xuICAgICAqIGZvciB0aGUgY29ycmVzcG9uZGluZyBpbWFnZSBmb3JtYXRcbiAgICAgKi9cbiAgICBiaWFzPzogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgLyoqXG4gICAgICogVGhlICdtZWFuJyB2YWx1ZSBmb3IgaW1hZ2Ugbm9ybWFsaXphdGlvbi5cbiAgICAgKiAtIElmIG9taXR0ZWQsIHVzZSBkZWZhdWx0IHZhbHVlIDI1NS5cbiAgICAgKiAtIElmIGl0J3MgYSBzaW5nbGUgbnVtYmVyLCBhcHBseSB0byBlYWNoIGNoYW5uZWxcbiAgICAgKiAtIElmIGl0J3MgYW4gYXJyYXkgb2YgMyBvciA0IG51bWJlcnMsIGFwcGx5IGVsZW1lbnQtd2lzZS4gTnVtYmVyIG9mIGVsZW1lbnRzIG5lZWQgdG8gbWF0Y2ggdGhlIG51bWJlciBvZiBjaGFubmVsc1xuICAgICAqIGZvciB0aGUgY29ycmVzcG9uZGluZyBpbWFnZSBmb3JtYXRcbiAgICAgKi9cbiAgICBtZWFuPzogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIH07XG59XG5cbi8vICNlbmRyZWdpb25cblxuLy8gI3JlZ2lvbiBPcHRpb25zIGNvbXBvc2l0aW9uXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnNcbiAgZXh0ZW5kcyBPcHRpb25SZXNpemVkRGltZW5zaW9ucyxcbiAgICBPcHRpb25zVGVuc29yRm9ybWF0LFxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gICAgT3B0aW9uc1RlbnNvckRhdGFUeXBlLFxuICAgIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zXG4gIGV4dGVuZHMgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCxcbiAgICBPcHRpb25zVGVuc29yTGF5b3V0LFxuICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSxcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tVXJsT3B0aW9uc1xuICBleHRlbmRzIE9wdGlvbnNEaW1lbnNpb25zLFxuICAgIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLFxuICAgIE9wdGlvbnNUZW5zb3JGb3JtYXQsXG4gICAgT3B0aW9uc1RlbnNvckxheW91dCxcbiAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsXG4gICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9uc1xuICBleHRlbmRzIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLFxuICAgIE9wdGlvbnNUZW5zb3JGb3JtYXQsXG4gICAgT3B0aW9uc1RlbnNvckxheW91dCxcbiAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsXG4gICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQgZXh0ZW5kcyBUZW5zb3IuVGV4dHVyZURhdGFUeXBlcz5cbiAgZXh0ZW5kcyBSZXF1aXJlZDxPcHRpb25zRGltZW5zaW9ucz4sXG4gICAgT3B0aW9uc0Zvcm1hdCxcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiAvKiBUT0RPOiBhZGQgbW9yZSAqLyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQgZXh0ZW5kcyBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzPlxuICBleHRlbmRzIFBpY2s8VGVuc29yLCAnZGltcyc+LFxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICBkYXRhVHlwZT86IFQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbU1MVGVuc29yT3B0aW9uczxUIGV4dGVuZHMgVGVuc29yLk1MVGVuc29yRGF0YVR5cGVzPlxuICBleHRlbmRzIFBpY2s8VGVuc29yLCAnZGltcyc+LFxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICBkYXRhVHlwZT86IFQ7XG59XG5cbi8vICNlbmRyZWdpb25cblxuLyoqXG4gKiB0eXBlIFRlbnNvckZhY3RvcnkgZGVmaW5lcyB0aGUgZmFjdG9yeSBmdW5jdGlvbnMgb2YgJ1RlbnNvcicgdG8gY3JlYXRlIHRlbnNvciBpbnN0YW5jZXMgZnJvbSBleGlzdGluZyBkYXRhIG9yXG4gKiByZXNvdXJjZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRmFjdG9yeSB7XG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhbiBJbWFnZURhdGEgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBpbWFnZURhdGEgLSB0aGUgSW1hZ2VEYXRhIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIEltYWdlRGF0YS5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKFxuICAgIGltYWdlRGF0YTogSW1hZ2VEYXRhLFxuICAgIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+IHwgVHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIEhUTUxJbWFnZUVsZW1lbnQgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBpbWFnZUVsZW1lbnQgLSB0aGUgSFRNTEltYWdlRWxlbWVudCBvYmplY3QgdG8gY3JlYXRlIHRlbnNvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBIVE1MSW1hZ2VFbGVtZW50LlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGB0ZW5zb3JGb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIC0gYGRhdGFUeXBlYDogYCdmbG9hdDMyJ2BcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tSW1hZ2UoXG4gICAgaW1hZ2VFbGVtZW50OiBIVE1MSW1hZ2VFbGVtZW50LFxuICAgIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+IHwgVHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBVUkxcbiAgICpcbiAgICogQHBhcmFtIHVybFNvdXJjZSAtIGEgc3RyaW5nIGFzIGEgVVJMIHRvIHRoZSBpbWFnZSBvciBhIGRhdGEgVVJMIGNvbnRhaW5pbmcgdGhlIGltYWdlIGRhdGEuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBVUkwuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZSh1cmxTb3VyY2U6IHN0cmluZywgb3B0aW9ucz86IFRlbnNvckZyb21VcmxPcHRpb25zKTogUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+IHwgVHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhbiBJbWFnZUJpdG1hcCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGJpdG1hcCAtIHRoZSBJbWFnZUJpdG1hcCBvYmplY3QgdG8gY3JlYXRlIHRlbnNvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBVUkwuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZShcbiAgICBiaXRtYXA6IEltYWdlQml0bWFwLFxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnMsXG4gICk6IFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPiB8IFR5cGVkVGVuc29yPCd1aW50OCc+PjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYSBXZWJHTCB0ZXh0dXJlXG4gICAqXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gdGhlIFdlYkdMVGV4dHVyZSBvYmplY3QgdG8gY3JlYXRlIHRlbnNvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBXZWJHTCB0ZXh0dXJlLlxuICAgKlxuICAgKiBUaGUgb3B0aW9ucyBpbmNsdWRlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAtIGB3aWR0aGA6IHRoZSB3aWR0aCBvZiB0aGUgdGV4dHVyZS4gUmVxdWlyZWQuXG4gICAqIC0gYGhlaWdodGA6IHRoZSBoZWlnaHQgb2YgdGhlIHRleHR1cmUuIFJlcXVpcmVkLlxuICAgKiAtIGBmb3JtYXRgOiB0aGUgZm9ybWF0IG9mIHRoZSB0ZXh0dXJlLiBJZiBvbWl0dGVkLCBhc3N1bWUgJ1JHQkEnLlxuICAgKiAtIGBkb3dubG9hZGA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRvd25sb2FkIHRoZSB0ZW5zb3IgZGF0YSBmcm9tIEdQVSB0byBDUFUuIElmIG9taXR0ZWQsIHRoZSBHUFUgZGF0YVxuICAgKiB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkLiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3RcbiAgICogbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqIC0gYGRpc3Bvc2VgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkaXNwb3NlIHRoZSB0ZW5zb3IgZGF0YSBvbiBHUFUuIElmIG9taXR0ZWQsIHRoZSBHUFUgZGF0YSB3aWxsIG5vdCBiZSBkaXNwb3NlZC5cbiAgICogVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21UZXh0dXJlPFQgZXh0ZW5kcyBUZW5zb3IuVGV4dHVyZURhdGFUeXBlcyA9ICdmbG9hdDMyJz4oXG4gICAgdGV4dHVyZTogVGVuc29yLlRleHR1cmVUeXBlLFxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUPixcbiAgKTogVHlwZWRUZW5zb3I8J2Zsb2F0MzInPjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYSBXZWJHUFUgYnVmZmVyXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSB0aGUgR1BVQnVmZmVyIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFdlYkdQVSBidWZmZXIuXG4gICAqXG4gICAqIFRoZSBvcHRpb25zIGluY2x1ZGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIC0gYGRhdGFUeXBlYDogdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhc3N1bWUgJ2Zsb2F0MzInLlxuICAgKiAtIGBkaW1zYDogdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBSZXF1aXJlZC5cbiAgICogLSBgZG93bmxvYWRgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkb3dubG9hZCB0aGUgdGVuc29yIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGFcbiAgICogd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZC4gVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0XG4gICAqIG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKiAtIGBkaXNwb3NlYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdGVuc29yIGRhdGEgb24gR1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGEgd2lsbCBub3QgYmUgZGlzcG9zZWQuXG4gICAqIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgYSBHUFUgYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndCBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tR3B1QnVmZmVyPFQgZXh0ZW5kcyBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzPihcbiAgICBidWZmZXI6IFRlbnNvci5HcHVCdWZmZXJUeXBlLFxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQ+LFxuICApOiBUeXBlZFRlbnNvcjxUPjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYSBXZWJOTiBNTFRlbnNvclxuICAgKlxuICAgKiBAcGFyYW0gdGVuc29yIC0gdGhlIE1MVGVuc29yIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIGEgV2ViTk4gTUxUZW5zb3IuXG4gICAqXG4gICAqIFRoZSBvcHRpb25zIGluY2x1ZGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIC0gYGRhdGFUeXBlYDogdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhc3N1bWUgJ2Zsb2F0MzInLlxuICAgKiAtIGBkaW1zYDogdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBSZXF1aXJlZC5cbiAgICogLSBgZG93bmxvYWRgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkb3dubG9hZCB0aGUgdGVuc29yIGRhdGEgZnJvbSB0aGUgTUxUZW5zb3IgdG8gQ1BVLiBJZiBvbWl0dGVkLCB0aGUgTUxUZW5zb3JcbiAgICogZGF0YSB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkLiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IHRoZSBXZWJOTiBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuXG4gICAqIFVzZXJzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKiAtIGBkaXNwb3NlYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdGVuc29yIGRhdGEgb24gdGhlIFdlYk5OIE1MVGVuc29yLiBJZiBvbWl0dGVkLCB0aGUgTUxUZW5zb3Igd2lsbFxuICAgKiBub3QgYmUgZGlzcG9zZWQuIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgdGhlIFdlYk5OIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3QgbmVlZCB0b1xuICAgKiBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbU1MVGVuc29yPFQgZXh0ZW5kcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXM+KFxuICAgIHRlbnNvcjogVGVuc29yLk1MVGVuc29yVHlwZSxcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zPFQ+LFxuICApOiBUeXBlZFRlbnNvcjxUPjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYSBwcmUtYWxsb2NhdGVkIGJ1ZmZlci4gVGhlIGJ1ZmZlciB3aWxsIGJlIHVzZWQgYXMgYSBwaW5uZWQgYnVmZmVyLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSB0ZW5zb3IgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gYSBUeXBlZEFycmF5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHR5cGUuXG4gICAqIEBwYXJhbSBkaW1zIC0gc3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21QaW5uZWRCdWZmZXI8VCBleHRlbmRzIEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnPj4oXG4gICAgdHlwZTogVCxcbiAgICBidWZmZXI6IFRlbnNvci5EYXRhVHlwZU1hcFtUXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vKipcbiAqIEEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZpbGUncyBVUkwgb3IgcGF0aC5cbiAqXG4gKiBQYXRoIGlzIHZhaWxhYmxlIG9ubHkgaW4gb25ueHJ1bnRpbWUtbm9kZSBvciBvbm54cnVudGltZS13ZWIgcnVubmluZyBpbiBOb2RlLmpzLlxuICovXG5leHBvcnQgdHlwZSBGaWxlVXJsT3JQYXRoID0gc3RyaW5nO1xuXG4vKipcbiAqIEEgQmxvYiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgZmlsZS5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZUJsb2IgPSBCbG9iO1xuXG4vKipcbiAqIEEgVWludDhBcnJheSwgQXJyYXlCdWZmZXIgb3IgU2hhcmVkQXJyYXlCdWZmZXIgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGZpbGUgY29udGVudC5cbiAqXG4gKiBXaGVuIGl0IGlzIGFuIEFycmF5QnVmZmVyIG9yIFNoYXJlZEFycmF5QnVmZmVyLCB0aGUgd2hvbGUgYnVmZmVyIGlzIGFzc3VtZWQgdG8gYmUgdGhlIGZpbGUgY29udGVudC5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZURhdGEgPSBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXJMaWtlO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBmaWxlIHRoYXQgY2FuIGJlIGxvYWRlZCBieSB0aGUgT05OWCBSdW50aW1lIEphdmFTY3JpcHQgQVBJLlxuICovXG5leHBvcnQgdHlwZSBGaWxlVHlwZSA9IEZpbGVVcmxPclBhdGggfCBGaWxlQmxvYiB8IEZpbGVEYXRhO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXh0ZXJuYWwgZGF0YSBmaWxlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4dGVybmFsRGF0YUZpbGVEZXNjcmlwdGlvbiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBleHRlcm5hbCBkYXRhIGZpbGUuXG4gICAqL1xuICBkYXRhOiBGaWxlVHlwZTtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGZpbGUgcGF0aC5cbiAgICovXG4gIHBhdGg6IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGV4dGVybmFsIGRhdGEgZmlsZS5cbiAqXG4gKiBXaGVuIHVzaW5nIGEgc3RyaW5nLCBpdCBzaG91bGQgYmUgYSBmaWxlIFVSTCBvciBwYXRoIHRoYXQgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIHRoZSBtb2RlbCBmaWxlLlxuICovXG5leHBvcnQgdHlwZSBFeHRlcm5hbERhdGFGaWxlVHlwZSA9IEV4dGVybmFsRGF0YUZpbGVEZXNjcmlwdGlvbiB8IEZpbGVVcmxPclBhdGg7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgbW9kZWwgbG9hZGluZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPbm54TW9kZWxPcHRpb25zIHtcbiAgLyoqXG4gICAqIFNwZWNpZnlpbmcgYSBsaXN0IG9mIGZpbGVzIHRoYXQgcmVwcmVzZW50cyB0aGUgZXh0ZXJuYWwgZGF0YS5cbiAgICovXG4gIGV4dGVybmFsRGF0YT86IHJlYWRvbmx5IEV4dGVybmFsRGF0YUZpbGVUeXBlW107XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcblxuZXhwb3J0IHR5cGUgTm9uVGVuc29yVHlwZSA9IG5ldmVyO1xuXG4vKipcbiAqIFR5cGUgT25ueFZhbHVlIFJlcHJlc2VudHMgYm90aCB0ZW5zb3JzIGFuZCBub24tdGVuc29ycyB2YWx1ZSBmb3IgbW9kZWwncyBpbnB1dHMvb3V0cHV0cy5cbiAqXG4gKiBOT1RFOiBjdXJyZW50bHkgbm90IHN1cHBvcnQgbm9uLXRlbnNvclxuICovXG5leHBvcnQgdHlwZSBPbm54VmFsdWUgPSBUZW5zb3IgfCBOb25UZW5zb3JUeXBlO1xuXG4vKipcbiAqIFR5cGUgT25ueFZhbHVlRGF0YUxvY2F0aW9uIHJlcHJlc2VudHMgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIG9mIGFuIE9ubnhWYWx1ZS5cbiAqL1xuZXhwb3J0IHR5cGUgT25ueFZhbHVlRGF0YUxvY2F0aW9uID0gVGVuc29yLkRhdGFMb2NhdGlvbjtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyoqXG4gKiAjIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSVxuICpcbiAqIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSSBpcyBhIHVuaWZpZWQgQVBJIGZvciBhbGwgSmF2YVNjcmlwdCB1c2FnZXMsIGluY2x1ZGluZyB0aGUgZm9sbG93aW5nIE5QTSBwYWNrYWdlczpcbiAqXG4gKiAtIFtvbm54cnVudGltZS1ub2RlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1ub2RlKVxuICogLSBbb25ueHJ1bnRpbWUtd2ViXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS13ZWIpXG4gKiAtIFtvbm54cnVudGltZS1yZWFjdC1uYXRpdmVdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL29ubnhydW50aW1lLXJlYWN0LW5hdGl2ZSlcbiAqXG4gKiBTZWUgYWxzbzpcbiAqIC0gW0dldCBTdGFydGVkXShodHRwczovL29ubnhydW50aW1lLmFpL2RvY3MvZ2V0LXN0YXJ0ZWQvd2l0aC1qYXZhc2NyaXB0LylcbiAqIC0gW0luZmVyZW5jZSBleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS1pbmZlcmVuY2UtZXhhbXBsZXMvdHJlZS9tYWluL2pzKVxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5cbmV4cG9ydCAqIGZyb20gJy4vYmFja2VuZC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Vudi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RyYWNlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vb25ueC1tb2RlbC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5leHBvcnQgY29uc3QgaXNOb2RlID0gISEodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8vIDxyZWZlcmVuY2UgbGliPVwid2Vid29ya2VyXCIgLz5cblxuLy9cbi8vICogdHlwZSBoYWNrIGZvciBcIkhUTUxJbWFnZUVsZW1lbnRcIlxuLy9cbi8vIGluIHR5cGVzY3JpcHQsIHRoZSB0eXBlIG9mIFwiSFRNTEltYWdlRWxlbWVudFwiIGlzIGRlZmluZWQgaW4gbGliLmRvbS5kLnRzLCB3aGljaCBpcyBjb25mbGljdCB3aXRoIGxpYi53ZWJ3b3JrZXIuZC50cy5cbi8vIHdoZW4gd2UgdXNlIHdlYndvcmtlciwgdGhlIGxpYi53ZWJ3b3JrZXIuZC50cyB3aWxsIGJlIHVzZWQsIHdoaWNoIGRvZXMgbm90IGhhdmUgSFRNTEltYWdlRWxlbWVudCBkZWZpbmVkLlxuLy9cbi8vIHdlIHdpbGwgZ2V0IHRoZSBmb2xsb3dpbmcgZXJyb3JzIGNvbXBsYWluaW5nIHRoYXQgSFRNTEltYWdlRWxlbWVudCBpcyBub3QgZGVmaW5lZDpcbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIC4uL2NvbW1vbi9kaXN0L2Nqcy90ZW5zb3ItZmFjdG9yeS5kLnRzOjE4NzoyOSAtIGVycm9yIFRTMjU1MjogQ2Fubm90IGZpbmQgbmFtZSAnSFRNTEltYWdlRWxlbWVudCcuIERpZCB5b3UgbWVhblxuLy8gJ0hUTUxMSUVsZW1lbnQnP1xuLy9cbi8vIDE4NyAgICAgZnJvbUltYWdlKGltYWdlRWxlbWVudDogSFRNTEltYWdlRWxlbWVudCwgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zKTpcbi8vIFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPiB8IFR5cGVkVGVuc29yPCd1aW50OCc+Pjtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5+fn5+fn5+flxuLy9cbi8vIG5vZGVfbW9kdWxlcy9Ad2ViZ3B1L3R5cGVzL2Rpc3QvaW5kZXguZC50czo4Mzo3IC0gZXJyb3IgVFMyNTUyOiBDYW5ub3QgZmluZCBuYW1lICdIVE1MSW1hZ2VFbGVtZW50Jy4gRGlkIHlvdSBtZWFuXG4vLyAnSFRNTExJRWxlbWVudCc/XG4vL1xuLy8gODMgICAgIHwgSFRNTEltYWdlRWxlbWVudFxuLy8gICAgICAgICAgfn5+fn5+fn5+fn5+fn5+flxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gYEhUTUxJbWFnZUVsZW1lbnRgIGlzIG9ubHkgdXNlZCBpbiB0eXBlIGRlY2xhcmF0aW9uIGFuZCBub3QgaW4gcmVhbCBjb2RlLiBTbyB3ZSBkZWZpbmUgaXQgYXMgYHVua25vd25gIGhlcmUgdG9cbi8vIGJ5cGFzcyB0aGUgdHlwZSBjaGVjay5cblxuLy9cbi8vICogdHlwZSBoYWNrIGZvciBcImRvY3VtZW50XCJcbi8vXG4vLyBpbiB0eXBlc2NyaXB0LCB0aGUgdHlwZSBvZiBcImRvY3VtZW50XCIgaXMgZGVmaW5lZCBpbiBsaWIuZG9tLmQudHMsIHNvIGl0J3Mgbm90IGF2YWlsYWJsZSBpbiB3ZWJ3b3JrZXIuXG4vL1xuLy8gd2Ugd2lsbCBnZXQgdGhlIGZvbGxvd2luZyBlcnJvcnMgY29tcGxhaW5pbmcgdGhhdCBkb2N1bWVudCBpcyBub3QgZGVmaW5lZDpcbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIGxpYi93YXNtL3dhc20tdXRpbHMtaW1wb3J0LnRzOjc6MzMgLSBlcnJvciBUUzI1ODQ6IENhbm5vdCBmaW5kIG5hbWUgJ2RvY3VtZW50Jy4gRG8geW91IG5lZWQgdG8gY2hhbmdlIHlvdXIgdGFyZ2V0XG4vLyBsaWJyYXJ5PyBUcnkgY2hhbmdpbmcgdGhlICdsaWInIGNvbXBpbGVyIG9wdGlvbiB0byBpbmNsdWRlICdkb20nLlxuLy9cbi8vIDcgZXhwb3J0IGNvbnN0IHNjcmlwdFNyYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyAoZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmMgOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+XG4vL1xuLy8gbGliL3dhc20vd2FzbS11dGlscy1pbXBvcnQudHM6Nzo2MSAtIGVycm9yIFRTMjU4NDogQ2Fubm90IGZpbmQgbmFtZSAnZG9jdW1lbnQnLiBEbyB5b3UgbmVlZCB0byBjaGFuZ2UgeW91ciB0YXJnZXRcbi8vIGxpYnJhcnk/IFRyeSBjaGFuZ2luZyB0aGUgJ2xpYicgY29tcGlsZXIgb3B0aW9uIHRvIGluY2x1ZGUgJ2RvbScuXG4vL1xuLy8gNyBleHBvcnQgY29uc3Qgc2NyaXB0U3JjID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IChkb2N1bWVudD8uY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyYyA6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+XG4vL1xuLy8gbGliL3dhc20vd2FzbS11dGlscy1pbXBvcnQudHM6Nzo4OCAtIGVycm9yIFRTMjU1MjogQ2Fubm90IGZpbmQgbmFtZSAnSFRNTFNjcmlwdEVsZW1lbnQnLiBEaWQgeW91IG1lYW5cbi8vICdIVE1MTElFbGVtZW50Jz9cbi8vXG4vLyA3IGV4cG9ydCBjb25zdCBzY3JpcHRTcmMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gKGRvY3VtZW50Py5jdXJyZW50U2NyaXB0IGFzIEhUTUxTY3JpcHRFbGVtZW50KT8uc3JjIDpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5+fn5+fn5+fn5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gYGRvY3VtZW50YCBpcyB1c2VkIHRvIGdldCB0aGUgY3VycmVudCBzY3JpcHQgVVJMLCB3aGljaCBpcyBub3QgYXZhaWxhYmxlIGluIHdlYndvcmtlci4gVGhpcyBmaWxlIGlzIHNlcnZlZCBhcyBhXG4vLyBcImR1YWxcIiBmaWxlIGZvciBlbnRyaWVzIG9mIGJvdGggd2Vid29ya2VyIGFuZCB0aGUgZXNtIG1vZHVsZS5cbi8vXG5kZWNsYXJlIGdsb2JhbCB7XG4gIHR5cGUgSFRNTEltYWdlRWxlbWVudCA9IHVua25vd247XG4gIHR5cGUgSFRNTFNjcmlwdEVsZW1lbnQgPSB7IHNyYz86IHN0cmluZyB9O1xuICBjb25zdCBkb2N1bWVudDogdW5kZWZpbmVkIHwgeyBjdXJyZW50U2NyaXB0PzogSFRNTFNjcmlwdEVsZW1lbnQgfTtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeVxuICpcbiAqIFRoaXMgZmlsZSBpcyBzZXJ2ZWQgYXMgYSBcImR1YWxcIiBmaWxlIGZvciBib3RoIGVudHJpZXMgb2YgdGhlIGZvbGxvd2luZzpcbiAqIC0gVGhlIHByb3h5IHdvcmtlciBpdHNlbGYuXG4gKiAgIC0gV2hlbiB1c2VkIGFzIGEgd29ya2VyLCBpdCBsaXN0ZW5zIHRvIHRoZSBtZXNzYWdlcyBmcm9tIHRoZSBtYWluIHRocmVhZCBhbmQgcGVyZm9ybXMgdGhlIGNvcnJlc3BvbmRpbmcgb3BlcmF0aW9ucy5cbiAqICAgLSBTaG91bGQgYmUgaW1wb3J0ZWQgZGlyZWN0bHkgdXNpbmcgYG5ldyBXb3JrZXIoKWAgaW4gdGhlIG1haW4gdGhyZWFkLlxuICpcbiAqIC0gVGhlIEVTTSBtb2R1bGUgdGhhdCBjcmVhdGVzIHRoZSBwcm94eSB3b3JrZXIgKGFzIGEgd29ya2VyIGxhdW5jaGVyKS5cbiAqICAgLSBXaGVuIHVzZWQgYXMgYSB3b3JrZXIgbGF1bmNoZXIsIGl0IGNyZWF0ZXMgdGhlIHByb3h5IHdvcmtlciBhbmQgcmV0dXJucyBpdC5cbiAqICAgLSBTaG91bGQgYmUgaW1wb3J0ZWQgdXNpbmcgYGltcG9ydCgpYCBpbiB0aGUgbWFpbiB0aHJlYWQsIHdpdGggdGhlIHF1ZXJ5IHBhcmFtZXRlciBgaW1wb3J0PTFgLlxuICpcbiAqIFRoaXMgZmlsZSB3aWxsIGJlIGFsd2F5cyBjb21waWxpbmcgaW50byBFU00gZm9ybWF0LlxuICovXG5cbmltcG9ydCB0eXBlIHsgT3J0V2FzbU1lc3NhZ2UsIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhIH0gZnJvbSAnLi4vcHJveHktbWVzc2FnZXMuanMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlU2Vzc2lvbixcbiAgY29weUZyb21FeHRlcm5hbEJ1ZmZlcixcbiAgZW5kUHJvZmlsaW5nLFxuICBleHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycyxcbiAgaW5pdEVwLFxuICBpbml0UnVudGltZSxcbiAgcmVsZWFzZVNlc3Npb24sXG4gIHJ1bixcbn0gZnJvbSAnLi4vd2FzbS1jb3JlLWltcGwuanMnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5IH0gZnJvbSAnLi4vd2FzbS1mYWN0b3J5LmpzJztcbmltcG9ydCB7IHNjcmlwdFNyYyB9IGZyb20gJy4uL3dhc20tdXRpbHMtaW1wb3J0LmpzJztcblxuY29uc3QgV09SS0VSX05BTUUgPSAnb3J0LXdhc20tcHJveHktd29ya2VyJztcbmNvbnN0IGlzUHJveHlXb3JrZXIgPSBnbG9iYWxUaGlzLnNlbGY/Lm5hbWUgPT09IFdPUktFUl9OQU1FO1xuXG5pZiAoaXNQcm94eVdvcmtlcikge1xuICAvLyBXb3JrZXIgdGhyZWFkXG4gIHNlbGYub25tZXNzYWdlID0gKGV2OiBNZXNzYWdlRXZlbnQ8T3J0V2FzbU1lc3NhZ2U+KTogdm9pZCA9PiB7XG4gICAgY29uc3QgeyB0eXBlLCBpbjogbWVzc2FnZSB9ID0gZXYuZGF0YTtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2luaXQtd2FzbSc6XG4gICAgICAgICAgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KG1lc3NhZ2UhLndhc20pLnRoZW4oXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIGluaXRSdW50aW1lKG1lc3NhZ2UhKS50aGVuKFxuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5pdC1lcCc6IHtcbiAgICAgICAgICBjb25zdCB7IGVwTmFtZSwgZW52IH0gPSBtZXNzYWdlITtcbiAgICAgICAgICBpbml0RXAoZW52LCBlcE5hbWUpLnRoZW4oXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NvcHktZnJvbSc6IHtcbiAgICAgICAgICBjb25zdCB7IGJ1ZmZlciB9ID0gbWVzc2FnZSE7XG4gICAgICAgICAgY29uc3QgYnVmZmVyRGF0YSA9IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIG91dDogYnVmZmVyRGF0YSB9IGFzIE9ydFdhc21NZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjcmVhdGUnOiB7XG4gICAgICAgICAgY29uc3QgeyBtb2RlbCwgb3B0aW9ucyB9ID0gbWVzc2FnZSE7XG4gICAgICAgICAgY3JlYXRlU2Vzc2lvbihtb2RlbCwgb3B0aW9ucykudGhlbihcbiAgICAgICAgICAgIChzZXNzaW9uTWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBvdXQ6IHNlc3Npb25NZXRhZGF0YSB9IGFzIE9ydFdhc21NZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3JlbGVhc2UnOlxuICAgICAgICAgIHJlbGVhc2VTZXNzaW9uKG1lc3NhZ2UhKTtcbiAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3J1bic6IHtcbiAgICAgICAgICBjb25zdCB7IHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG9wdGlvbnMgfSA9IG1lc3NhZ2UhO1xuICAgICAgICAgIHJ1bihzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBuZXcgQXJyYXkob3V0cHV0SW5kaWNlcy5sZW5ndGgpLmZpbGwobnVsbCksIG9wdGlvbnMpLnRoZW4oXG4gICAgICAgICAgICAob3V0cHV0cykgPT4ge1xuICAgICAgICAgICAgICBpZiAob3V0cHV0cy5zb21lKChvKSA9PiBvWzNdICE9PSAnY3B1JykpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVycjogJ1Byb3h5IGRvZXMgbm90IHN1cHBvcnQgbm9uLWNwdSB0ZW5zb3IgbG9jYXRpb24uJyB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZShcbiAgICAgICAgICAgICAgICAgIHsgdHlwZSwgb3V0OiBvdXRwdXRzIH0gYXMgT3J0V2FzbU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICBleHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycyhbLi4uaW5wdXRzLCAuLi5vdXRwdXRzXSBhcyBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdlbmQtcHJvZmlsaW5nJzpcbiAgICAgICAgICBlbmRQcm9maWxpbmcobWVzc2FnZSEpO1xuICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyIH0gYXMgT3J0V2FzbU1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm94eVdvcmtlclxuICA/IG51bGxcbiAgOiAodXJsT3ZlcnJpZGU/OiBzdHJpbmcpID0+XG4gICAgICBuZXcgV29ya2VyKHVybE92ZXJyaWRlID8/IHNjcmlwdFNyYyEsIHsgdHlwZTogQlVJTERfREVGUy5JU19FU00gPyAnbW9kdWxlJyA6ICdjbGFzc2ljJywgbmFtZTogV09SS0VSX05BTUUgfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB0eXBlIHsgT3J0V2FzbU1vZHVsZSB9IGZyb20gJy4vd2FzbS10eXBlcyc7XG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuL3dhc20tdXRpbHMtZW52JztcblxuLyoqXG4gKiBUaGUgb3JpZ2luIG9mIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEluIE5vZGUuanMsIHRoaXMgaXMgdW5kZWZpbmVkLlxuICovXG5jb25zdCBvcmlnaW4gPSBpc05vZGUgfHwgdHlwZW9mIGxvY2F0aW9uID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGxvY2F0aW9uLm9yaWdpbjtcblxuLyoqXG4gKiBTb21lIGJ1bmRsZXJzIChlZy4gV2VicGFjaykgd2lsbCByZXdyaXRlIGBpbXBvcnQubWV0YS51cmxgIHRvIGEgZmlsZSBVUkwgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIGBpbXBvcnQubWV0YS51cmxgIHN0YXJ0cyB3aXRoIGBmaWxlOmAsIGJ1dCB1c2luZyB0aGUgYD5gIGFuZCBgPGAgb3BlcmF0b3JzIGluc3RlYWQgb2ZcbiAqIGBzdGFydHNXaXRoYCBmdW5jdGlvbiBzbyB0aGF0IGNvZGUgbWluaW1pemVycyBjYW4gcmVtb3ZlIHRoZSBkZWFkIGNvZGUgY29ycmVjdGx5LlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB3ZSB1c2UgdGVyc2VyIHRvIG1pbmlmeSB0aGUgZm9sbG93aW5nIGNvZGU6XG4gKiBgYGBqc1xuICogaWYgKFwiZmlsZTovL2hhcmQtY29kZWQtZmlsZW5hbWVcIi5zdGFydHNXaXRoKFwiZmlsZTpcIikpIHtcbiAqICAgY29uc29sZS5sb2coMSlcbiAqIH0gZWxzZSB7XG4gKiAgIGNvbnNvbGUubG9nKDIpXG4gKiB9XG4gKlxuICogaWYgKFwiZmlsZTovL2hhcmQtY29kZWQtZmlsZW5hbWVcIiA+IFwiZmlsZTpcIiAmJiBcImZpbGU6Ly9oYXJkLWNvZGVkLWZpbGVuYW1lXCIgPCBcImZpbGU7XCIpIHtcbiAqICAgY29uc29sZS5sb2coMylcbiAqIH0gZWxzZSB7XG4gKiAgIGNvbnNvbGUubG9nKDQpXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGUgbWluaWZpZWQgY29kZSB3aWxsIGJlOlxuICogYGBganNcbiAqIFwiZmlsZTovL2hhcmQtY29kZWQtZmlsZW5hbWVcIi5zdGFydHNXaXRoKFwiZmlsZTpcIik/Y29uc29sZS5sb2coMSk6Y29uc29sZS5sb2coMiksY29uc29sZS5sb2coMyk7XG4gKiBgYGBcbiAqXG4gKiAodXNlIFRlcnNlciA1LjM5LjAgd2l0aCBkZWZhdWx0IG9wdGlvbnMsIGh0dHBzOi8vdHJ5LnRlcnNlci5vcmcvKVxuICpcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGltcG9ydC5tZXRhLnVybCBpcyBoYXJkY29kZWQgYXMgYSBmaWxlIFVSSS5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzRXNtSW1wb3J0TWV0YVVybEhhcmRjb2RlZEFzRmlsZVVyaSA9XG4gIEJVSUxEX0RFRlMuSVNfRVNNICYmIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCEgPiAnZmlsZTonICYmIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCEgPCAnZmlsZTsnO1xuXG5jb25zdCBnZXRTY3JpcHRTcmMgPSAoKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgLy8gaWYgTm9kZWpzLCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmIChpc05vZGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIC8vIGlmIEl0J3MgRVNNLCB1c2UgaW1wb3J0Lm1ldGEudXJsXG4gIGlmIChCVUlMRF9ERUZTLklTX0VTTSkge1xuICAgIC8vIEZvciBFU00sIGlmIHRoZSBpbXBvcnQubWV0YS51cmwgaXMgYSBmaWxlIFVSTCwgdGhpcyB1c3VhbGx5IG1lYW5zIHRoZSBidW5kbGVyIHJld3JpdGVzIGBpbXBvcnQubWV0YS51cmxgIHRvXG4gICAgLy8gdGhlIGZpbGUgcGF0aCBhdCBjb21waWxlIHRpbWUuIEluIHRoaXMgY2FzZSwgdGhpcyBmaWxlIHBhdGggY2Fubm90IGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBydW50aW1lIFVSTC5cbiAgICAvL1xuICAgIC8vIFdlIG5lZWQgdG8gdXNlIHRoZSBVUkwgY29uc3RydWN0b3IgbGlrZSB0aGlzOlxuICAgIC8vIGBgYGpzXG4gICAgLy8gbmV3IFVSTCgnYWN0dWFsLWJ1bmRsZS1uYW1lLmpzJywgaW1wb3J0Lm1ldGEudXJsKS5ocmVmXG4gICAgLy8gYGBgXG4gICAgLy8gU28gdGhhdCBidW5kbGVyIGNhbiBwcmVwcm9jZXNzIHRoZSBVUkwgY29ycmVjdGx5LlxuICAgIGlmIChpc0VzbUltcG9ydE1ldGFVcmxIYXJkY29kZWRBc0ZpbGVVcmkpIHtcbiAgICAgIC8vIGlmIHRoZSByZXdyaXR0ZW4gVVJMIGlzIGEgcmVsYXRpdmUgcGF0aCwgd2UgbmVlZCB0byB1c2UgdGhlIG9yaWdpbiB0byByZXNvbHZlIHRoZSBVUkwuXG5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgYSB3b3JrYXJvdW5kIGZvciBWaXRlLlxuICAgICAgLy9cbiAgICAgIC8vIFZpdGUgdXNlcyBhIGJ1bmRsZXIocm9sbHVwL3JvbGxkb3duKSB0aGF0IGRvZXMgbm90IHJld3JpdGUgYGltcG9ydC5tZXRhLnVybGAgdG8gYSBmaWxlIFVSTC4gU28gaW4gdGhlb3J5LCB0aGlzXG4gICAgICAvLyBjb2RlIHBhdGggc2hvdWxkIG5vdCBiZSBleGVjdXRlZCBpbiBWaXRlLiBIb3dldmVyLCB0aGUgYnVuZGxlciBkb2VzIG5vdCBrbm93IGl0IGFuZCBpdCBzdGlsbCB0cnkgdG8gbG9hZCB0aGVcbiAgICAgIC8vIGZvbGxvd2luZyBwYXR0ZXJuOlxuICAgICAgLy8gLSBgcmV0dXJuIG5ldyBVUkwoJ2ZpbGVuYW1lJywgaW1wb3J0Lm1ldGEudXJsKS5ocmVmYFxuICAgICAgLy9cbiAgICAgIC8vIEJ5IHJlcGxhY2luZyB0aGUgcGF0dGVybiBhYm92ZSB3aXRoIHRoZSBmb2xsb3dpbmcgY29kZSwgd2UgY2FuIHNraXAgdGhlIHJlc291cmNlIGxvYWRpbmcgYmVoYXZpb3I6XG4gICAgICAvLyAtIGBjb25zdCBVUkwyID0gVVJMOyByZXR1cm4gbmV3IFVSTDIoJ2ZpbGVuYW1lJywgaW1wb3J0Lm1ldGEudXJsKS5ocmVmO2BcbiAgICAgIC8vXG4gICAgICAvLyBBbmQgaXQgc3RpbGwgd29ya3MgaW4gV2VicGFjay5cbiAgICAgIGNvbnN0IFVSTDIgPSBVUkw7XG4gICAgICByZXR1cm4gbmV3IFVSTChuZXcgVVJMMihCVUlMRF9ERUZTLkJVTkRMRV9GSUxFTkFNRSwgQlVJTERfREVGUy5FU01fSU1QT1JUX01FVEFfVVJMKS5ocmVmLCBvcmlnaW4pLmhyZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTDtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICAgPyAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyY1xuICAgIDogLy8gdXNlIGBzZWxmLmxvY2F0aW9uLmhyZWZgIGlmIGF2YWlsYWJsZVxuICAgICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IHNlbGYubG9jYXRpb24/LmhyZWZcbiAgICAgIDogdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBUaGUgY2xhc3NpYyBzY3JpcHQgc291cmNlIFVSTC4gVGhpcyBpcyBub3QgYWx3YXlzIGF2YWlsYWJsZSBpbiBub24gRVNNb2R1bGUgZW52aXJvbm1lbnRzLlxuICpcbiAqIEluIE5vZGUuanMsIHRoaXMgaXMgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3Qgc2NyaXB0U3JjID0gZ2V0U2NyaXB0U3JjKCk7XG5cbi8qKlxuICogSW5mZXIgdGhlIHdhc20gcGF0aCBwcmVmaXggZnJvbSB0aGUgc2NyaXB0IHNvdXJjZSBVUkwuXG4gKlxuICogQHJldHVybnMgVGhlIGluZmVycmVkIHdhc20gcGF0aCBwcmVmaXgsIG9yIHVuZGVmaW5lZCBpZiB0aGUgc2NyaXB0IHNvdXJjZSBVUkwgaXMgbm90IGF2YWlsYWJsZSBvciBpcyBhIGJsb2IgVVJMLlxuICovXG5leHBvcnQgY29uc3QgaW5mZXJXYXNtUGF0aFByZWZpeEZyb21TY3JpcHRTcmMgPSAoKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHNjcmlwdFNyYyAmJiAhc2NyaXB0U3JjLnN0YXJ0c1dpdGgoJ2Jsb2I6JykpIHtcbiAgICByZXR1cm4gc2NyaXB0U3JjLnN1YnN0cmluZygwLCBzY3JpcHRTcmMubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBmaWxlbmFtZSB3aXRoIHByZWZpeCBpcyBmcm9tIHRoZSBzYW1lIG9yaWdpbi5cbiAqL1xuY29uc3QgaXNTYW1lT3JpZ2luID0gKGZpbGVuYW1lOiBzdHJpbmcsIHByZWZpeE92ZXJyaWRlPzogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgYmFzZVVybCA9IHByZWZpeE92ZXJyaWRlID8/IHNjcmlwdFNyYztcbiAgICBjb25zdCB1cmwgPSBiYXNlVXJsID8gbmV3IFVSTChmaWxlbmFtZSwgYmFzZVVybCkgOiBuZXcgVVJMKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gdXJsLm9yaWdpbiA9PT0gb3JpZ2luO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBpbnB1dHMgdG8gYW4gYWJzb2x1dGUgVVJMIHdpdGggdGhlIGdpdmVuIHByZWZpeCBvdmVycmlkZS4gSWYgZmFpbGVkLCByZXR1cm4gdW5kZWZpbmVkLlxuICovXG5jb25zdCBub3JtYWxpemVVcmwgPSAoZmlsZW5hbWU6IHN0cmluZywgcHJlZml4T3ZlcnJpZGU/OiBzdHJpbmcpID0+IHtcbiAgY29uc3QgYmFzZVVybCA9IHByZWZpeE92ZXJyaWRlID8/IHNjcmlwdFNyYztcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBiYXNlVXJsID8gbmV3IFVSTChmaWxlbmFtZSwgYmFzZVVybCkgOiBuZXcgVVJMKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gdXJsLmhyZWY7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgZmFsbGJhY2sgVVJMIGlmIGFuIGFic29sdXRlIFVSTCBjYW5ub3QgYmUgY3JlYXRlZCBieSB0aGUgbm9ybWFsaXplVXJsIGZ1bmN0aW9uLlxuICovXG5jb25zdCBmYWxsYmFja1VybCA9IChmaWxlbmFtZTogc3RyaW5nLCBwcmVmaXhPdmVycmlkZT86IHN0cmluZykgPT4gYCR7cHJlZml4T3ZlcnJpZGUgPz8gJy4vJ30ke2ZpbGVuYW1lfWA7XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdXNlZCB0byBwcmVsb2FkIGEgbW9kdWxlIGZyb20gYSBVUkwuXG4gKlxuICogSWYgdGhlIG9yaWdpbiBvZiB0aGUgd29ya2VyIFVSTCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBvcmlnaW4sIHRoZSB3b3JrZXIgY2Fubm90IGJlIGxvYWRlZCBkaXJlY3RseS5cbiAqIFNlZSBkaXNjdXNzaW9ucyBpbiBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3dvcmtlci1sb2FkZXIvaXNzdWVzLzE1NFxuICpcbiAqIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBmZXRjaCB0aGUgd29ya2VyIFVSTCBhbmQgY3JlYXRlIGEgbmV3IEJsb2IgVVJMIHdpdGggdGhlIHNhbWUgb3JpZ2luIGFzIGEgd29ya2Fyb3VuZC5cbiAqXG4gKiBAcGFyYW0gYWJzb2x1dGVVcmwgLSBUaGUgYWJzb2x1dGUgVVJMIHRvIHByZWxvYWQuXG4gKlxuICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG5ldyBCbG9iIFVSTFxuICovXG5jb25zdCBwcmVsb2FkID0gYXN5bmMgKGFic29sdXRlVXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFic29sdXRlVXJsLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pO1xuICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn07XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdXNlZCB0byBkeW5hbWljYWxseSBpbXBvcnQgYSBtb2R1bGUgZnJvbSBhIFVSTC5cbiAqXG4gKiBUaGUgYnVpbGQgc2NyaXB0IGhhcyBzcGVjaWFsIGhhbmRsaW5nIGZvciB0aGlzIGZ1bmN0aW9uIHRvIGVuc3VyZSB0aGF0IHRoZSBVUkwgaXMgbm90IGJ1bmRsZWQgaW50byB0aGUgZmluYWwgb3V0cHV0LlxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIGltcG9ydC5cbiAqXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZWZhdWx0IGV4cG9ydCBvZiB0aGUgbW9kdWxlLlxuICovXG5jb25zdCBkeW5hbWljSW1wb3J0RGVmYXVsdCA9IGFzeW5jIDxUPih1cmw6IHN0cmluZyk6IFByb21pc2U8VD4gPT5cbiAgKGF3YWl0IGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovIHVybCkpLmRlZmF1bHQ7XG5cbi8qKlxuICogVGhlIHByb3h5IHdvcmtlciBmYWN0b3J5IGltcG9ydGVkIGZyb20gdGhlIHByb3h5IHdvcmtlciBtb2R1bGUuXG4gKlxuICogVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHRoZSBXZWJBc3NlbWJseSBwcm94eSBpcyBub3QgZGlzYWJsZWQuXG4gKi9cbmNvbnN0IGNyZWF0ZVByb3h5V29ya2VyOiAoKHVybE92ZXJyaWRlPzogc3RyaW5nKSA9PiBXb3JrZXIpIHwgdW5kZWZpbmVkID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgPyB1bmRlZmluZWQgOiByZXF1aXJlKCcuL3Byb3h5LXdvcmtlci9tYWluJykuZGVmYXVsdDtcblxuLyoqXG4gKiBJbXBvcnQgdGhlIHByb3h5IHdvcmtlci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICogMS4gSWYgYSBwcmVsb2FkIGlzIG5lZWRlZCwgaXQgd2lsbCBwcmVsb2FkIHRoZSBtb2R1bGUgYW5kIHJldHVybiB0aGUgb2JqZWN0IFVSTC5cbiAqIDIuIFVzZSB0aGUgcHJveHkgd29ya2VyIGZhY3RvcnkgdG8gY3JlYXRlIHRoZSBwcm94eSB3b3JrZXIuXG4gKlxuICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHR1cGxlIG9mIDIgZWxlbWVudHM6XG4gKiAgICAgICAgICAgIC0gVGhlIG9iamVjdCBVUkwgb2YgdGhlIHByZWxvYWRlZCBtb2R1bGUsIG9yIHVuZGVmaW5lZCBpZiBubyBwcmVsb2FkIGlzIG5lZWRlZC5cbiAqICAgICAgICAgICAgLSBUaGUgcHJveHkgd29ya2VyLlxuICovXG5leHBvcnQgY29uc3QgaW1wb3J0UHJveHlXb3JrZXIgPSBhc3luYyAoKTogUHJvbWlzZTxbdW5kZWZpbmVkIHwgc3RyaW5nLCBXb3JrZXJdPiA9PiB7XG4gIGlmICghc2NyaXB0U3JjKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBwcm94eSB3b3JrZXI6IGNhbm5vdCBkZXRlcm1pbmUgdGhlIHNjcmlwdCBzb3VyY2UgVVJMLicpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHNjcmlwdCBzb3VyY2UgaXMgZnJvbSB0aGUgc2FtZSBvcmlnaW4sIHdlIGNhbiB1c2UgdGhlIGVtYmVkZGVkIHByb3h5IG1vZHVsZSBkaXJlY3RseS5cbiAgaWYgKGlzU2FtZU9yaWdpbihzY3JpcHRTcmMpKSB7XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIGNyZWF0ZVByb3h5V29ya2VyISgpXTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgbmVlZCB0byBwcmVsb2FkXG4gIGNvbnN0IHVybCA9IGF3YWl0IHByZWxvYWQoc2NyaXB0U3JjKTtcbiAgcmV0dXJuIFt1cmwsIGNyZWF0ZVByb3h5V29ya2VyISh1cmwpXTtcbn07XG5cbi8qKlxuICogVGhlIGVtYmVkZGVkIFdlYkFzc2VtYmx5IG1vZHVsZS5cbiAqXG4gKiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGluIEVTTSBhbmQgd2hlbiBlbWJlZGRpbmcgaXMgbm90IGRpc2FibGVkLlxuICovXG5jb25zdCBlbWJlZGRlZFdhc21Nb2R1bGU6IEVtc2NyaXB0ZW5Nb2R1bGVGYWN0b3J5PE9ydFdhc21Nb2R1bGU+IHwgdW5kZWZpbmVkID1cbiAgQlVJTERfREVGUy5JU19FU00gJiYgQlVJTERfREVGUy5FTkFCTEVfQlVORExFX1dBU01fSlNcbiAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgICByZXF1aXJlKFxuICAgICAgICAhQlVJTERfREVGUy5ESVNBQkxFX0pTRVBcbiAgICAgICAgICA/ICcuLi8uLi9kaXN0L29ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanMnXG4gICAgICAgICAgOiAhQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVVxuICAgICAgICAgICAgPyAnLi4vLi4vZGlzdC9vcnQtd2FzbS1zaW1kLXRocmVhZGVkLmFzeW5jaWZ5Lm1qcydcbiAgICAgICAgICAgIDogJy4uLy4uL2Rpc3Qvb3J0LXdhc20tc2ltZC10aHJlYWRlZC5tanMnLFxuICAgICAgKS5kZWZhdWx0XG4gICAgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogSW1wb3J0IHRoZSBXZWJBc3NlbWJseSBtb2R1bGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHBlcmZvcm0gdGhlIGZvbGxvd2luZyBzdGVwczpcbiAqIDEuIElmIHRoZSBlbWJlZGRlZCBtb2R1bGUgZXhpc3RzIGFuZCBubyBjdXN0b20gVVJMIGlzIHNwZWNpZmllZCwgdXNlIHRoZSBlbWJlZGRlZCBtb2R1bGUuXG4gKiAyLiBJZiBhIHByZWxvYWQgaXMgbmVlZGVkLCBpdCB3aWxsIHByZWxvYWQgdGhlIG1vZHVsZSBhbmQgcmV0dXJuIHRoZSBvYmplY3QgVVJMLlxuICogMy4gT3RoZXJ3aXNlLCBpdCB3aWxsIHBlcmZvcm0gYSBkeW5hbWljIGltcG9ydCBvZiB0aGUgbW9kdWxlLlxuICpcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0dXBsZSBvZiAyIGVsZW1lbnRzOlxuICogICAgICAgICAgICAtIFRoZSBvYmplY3QgVVJMIG9mIHRoZSBwcmVsb2FkZWQgbW9kdWxlLCBvciB1bmRlZmluZWQgaWYgbm8gcHJlbG9hZCBpcyBuZWVkZWQuXG4gKiAgICAgICAgICAgIC0gVGhlIGRlZmF1bHQgZXhwb3J0IG9mIHRoZSBtb2R1bGUsIHdoaWNoIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGltcG9ydFdhc21Nb2R1bGUgPSBhc3luYyAoXG4gIHVybE92ZXJyaWRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIHByZWZpeE92ZXJyaWRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGlzTXVsdGlUaHJlYWRlZDogYm9vbGVhbixcbiAgaXNXYXNtT3ZlcnJpZGRlbjogYm9vbGVhbixcbik6IFByb21pc2U8W3VuZGVmaW5lZCB8IHN0cmluZywgRW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT5dPiA9PiB7XG4gIC8vXG4gIC8vIENoZWNrIGlmIHdlIHNob3VsZCB1c2UgdGhlIGVtYmVkZGVkIG1vZHVsZS5cbiAgLy9cblxuICAvLyBUbyB1c2UgdGhlIGVtYmVkZGVkIG1vZHVsZSwgaXQgc2hvdWxkIGJlIGF2YWlsYWJsZSwgYW5kIG5vIFVSTCBvdmVycmlkZSBvciBwcmVmaXggb3ZlcnJpZGUgc2hvdWxkIGJlIHNwZWNpZmllZC5cbiAgbGV0IHVzZUVtYmVkZGVkTW9kdWxlID0gZW1iZWRkZWRXYXNtTW9kdWxlICYmICEodXJsT3ZlcnJpZGUgfHwgcHJlZml4T3ZlcnJpZGUpO1xuICBpZiAodXNlRW1iZWRkZWRNb2R1bGUpIHtcbiAgICBpZiAoIXNjcmlwdFNyYykge1xuICAgICAgLy8gbm8gVVJMIGluZm8gYXZhaWxhYmxlLlxuICAgICAgLy9cbiAgICAgIC8vIE5vdGU6IHdoZW4gdGhlIGVtYmVkZGVkIG1vZHVsZSBpcyBhdmFpbGFibGUsIGl0IG1lYW5zIHRoZSBjdXJyZW50IHNjcmlwdCBpcyBFU00uIFVzdWFsbHksIGluIEVTTSwgdGhlXG4gICAgICAvLyBgaW1wb3J0Lm1ldGEudXJsYCBpcyBhdmFpbGFibGUuIEJ1dCBpbiBzb21lIGNhc2VzIChlZy4gQ2xvdWRmbGFyZSBXb3JrZXJzKSwgdGhlIHZhbHVlIG9mIGBpbXBvcnQubWV0YS51cmxgXG4gICAgICAvLyBjYW4gYmUgYG51bGxgIG9yIGB1bmRlZmluZWRgLiBJbiB0aGlzIGNhc2UsIHdlIGNhbiBvbmx5IGxvYWQgdGhlIGVtYmVkZGVkIG1vZHVsZSB3aGVuOlxuICAgICAgLy9cbiAgICAgIC8vIDEuIFRoZSBXZWJBc3NlbWJseSBtb2R1bGUgYmluYXJ5IGlzIG92ZXJyaWRkZW46XG4gICAgICAvLyAgICBgYGBqc1xuICAgICAgLy8gICAgZW52Lndhc20ud2FzbVBhdGhzID0gdW5kZWZpbmVkOyAgLy8gb3Igbm90IHNwZWNpZmllZFxuICAgICAgLy8gICAgZW52Lndhc20ud2FzbUJpbmFyeSA9IC8qIGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBXZWJBc3NlbWJseSBiaW5hcnkgKi87XG4gICAgICAvLyAgICBgYGBcbiAgICAgIC8vXG4gICAgICAvLyAyLiBUaGUgXCIud2FzbVwiIG9ubHkgaXMgb3ZlcnJpZGRlbi5cbiAgICAgIC8vICAgIGBgYGpzXG4gICAgICAvLyAgICBlbnYud2FzbS53YXNtUGF0aHMgPSB7IHdhc206IC8qIFVSTCBvZiB0aGUgLndhc20gZmlsZSAqLyB9O1xuICAgICAgLy8gICAgYGBgXG4gICAgICAvL1xuICAgICAgaWYgKGlzV2FzbU92ZXJyaWRkZW4gJiYgIWlzTXVsdGlUaHJlYWRlZCkge1xuICAgICAgICB1c2VFbWJlZGRlZE1vZHVsZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBkZXRlcm1pbmUgdGhlIHNjcmlwdCBzb3VyY2UgVVJMLicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiB0aGUgc2NyaXB0IHNvdXJjZSBpcyBhdmFpbGFibGUsIHdlIGNhbiBjaGVjayBpZiBpdCBpcyBmcm9tIHRoZSBzYW1lIG9yaWdpbi5cbiAgICAgIHVzZUVtYmVkZGVkTW9kdWxlID0gaXNTYW1lT3JpZ2luKHNjcmlwdFNyYyk7XG4gICAgfVxuICB9XG4gIGlmICh1c2VFbWJlZGRlZE1vZHVsZSkge1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCBlbWJlZGRlZFdhc21Nb2R1bGUhXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB3YXNtTW9kdWxlRmlsZW5hbWUgPSAhQlVJTERfREVGUy5ESVNBQkxFX0pTRVBcbiAgICAgID8gJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanMnXG4gICAgICA6ICFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVXG4gICAgICAgID8gJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQuYXN5bmNpZnkubWpzJ1xuICAgICAgICA6ICdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLm1qcyc7XG4gICAgY29uc3Qgd2FzbU1vZHVsZVVybCA9IHVybE92ZXJyaWRlID8/IG5vcm1hbGl6ZVVybCh3YXNtTW9kdWxlRmlsZW5hbWUsIHByZWZpeE92ZXJyaWRlKTtcbiAgICAvLyBuZWVkIHRvIHByZWxvYWQgaWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICAgIC8vIDEuIG5vdCBpbiBOb2RlLmpzLlxuICAgIC8vICAgIC0gTm9kZS5qcyBkb2VzIG5vdCBoYXZlIHRoZSBzYW1lIG9yaWdpbiBwb2xpY3kgZm9yIGNyZWF0aW5nIHdvcmtlcnMuXG4gICAgLy8gMi4gbXVsdGktdGhyZWFkZWQgaXMgZW5hYmxlZC5cbiAgICAvLyAgICAtIElmIG11bHRpLXRocmVhZGVkIGlzIGRpc2FibGVkLCBubyB3b3JrZXIgd2lsbCBiZSBjcmVhdGVkLiBTbyB3ZSBkb24ndCBuZWVkIHRvIHByZWxvYWQgdGhlIG1vZHVsZS5cbiAgICAvLyAzLiB0aGUgYWJzb2x1dGUgVVJMIGlzIGF2YWlsYWJsZS5cbiAgICAvLyAgICAtIElmIHRoZSBhYnNvbHV0ZSBVUkwgaXMgZmFpbGVkIHRvIGJlIGNyZWF0ZWQsIHRoZSBvcmlnaW4gY2Fubm90IGJlIGRldGVybWluZWQuIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBub3RcbiAgICAvLyAgICBwcmVsb2FkIHRoZSBtb2R1bGUuXG4gICAgLy8gNC4gdGhlIHdvcmtlciBVUkwgaXMgbm90IGZyb20gdGhlIHNhbWUgb3JpZ2luLlxuICAgIC8vICAgIC0gSWYgdGhlIHdvcmtlciBVUkwgaXMgZnJvbSB0aGUgc2FtZSBvcmlnaW4sIHdlIGNhbiBjcmVhdGUgdGhlIHdvcmtlciBkaXJlY3RseS5cbiAgICBjb25zdCBuZWVkUHJlbG9hZCA9ICFpc05vZGUgJiYgaXNNdWx0aVRocmVhZGVkICYmIHdhc21Nb2R1bGVVcmwgJiYgIWlzU2FtZU9yaWdpbih3YXNtTW9kdWxlVXJsLCBwcmVmaXhPdmVycmlkZSk7XG4gICAgY29uc3QgdXJsID0gbmVlZFByZWxvYWRcbiAgICAgID8gYXdhaXQgcHJlbG9hZCh3YXNtTW9kdWxlVXJsKVxuICAgICAgOiAod2FzbU1vZHVsZVVybCA/PyBmYWxsYmFja1VybCh3YXNtTW9kdWxlRmlsZW5hbWUsIHByZWZpeE92ZXJyaWRlKSk7XG4gICAgcmV0dXJuIFtuZWVkUHJlbG9hZCA/IHVybCA6IHVuZGVmaW5lZCwgYXdhaXQgZHluYW1pY0ltcG9ydERlZmF1bHQ8RW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT4+KHVybCldO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBFbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgdHlwZSB7IE9ydFdhc21Nb2R1bGUgfSBmcm9tICcuL3dhc20tdHlwZXMnO1xuaW1wb3J0IHsgaW1wb3J0V2FzbU1vZHVsZSwgaW5mZXJXYXNtUGF0aFByZWZpeEZyb21TY3JpcHRTcmMgfSBmcm9tICcuL3dhc20tdXRpbHMtaW1wb3J0JztcblxubGV0IHdhc206IE9ydFdhc21Nb2R1bGUgfCB1bmRlZmluZWQ7XG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmxldCBpbml0aWFsaXppbmcgPSBmYWxzZTtcbmxldCBhYm9ydGVkID0gZmFsc2U7XG5cbmNvbnN0IGlzTXVsdGlUaHJlYWRTdXBwb3J0ZWQgPSAoKTogYm9vbGVhbiA9PiB7XG4gIC8vIElmICdTaGFyZWRBcnJheUJ1ZmZlcicgaXMgbm90IGF2YWlsYWJsZSwgV2ViQXNzZW1ibHkgdGhyZWFkcyB3aWxsIG5vdCB3b3JrLlxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGVzdCBmb3IgdHJhbnNmZXJhYmlsaXR5IG9mIFNBQnMgKGZvciBicm93c2Vycy4gbmVlZGVkIGZvciBGaXJlZm94KVxuICAgIC8vIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyFtc2cvbW96aWxsYS5kZXYucGxhdGZvcm0vSUhrQlpsSEVUcEEvZHdzTU5jaFdFUUFKXG4gICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSk7XG4gICAgfVxuXG4gICAgLy8gVGVzdCBmb3IgV2ViQXNzZW1ibHkgdGhyZWFkcyBjYXBhYmlsaXR5IChmb3IgYm90aCBicm93c2VycyBhbmQgTm9kZS5qcylcbiAgICAvLyBUaGlzIHR5cGVkIGFycmF5IGlzIGEgV2ViQXNzZW1ibHkgcHJvZ3JhbSBjb250YWluaW5nIHRocmVhZGVkIGluc3RydWN0aW9ucy5cbiAgICByZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUoXG4gICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgMCwgMCwgMSwgNCwgMSwgOTYsIDAsIDAsIDMsIDIsIDEsIDAsIDUsIDQsIDEsIDMsIDEsIDEsIDEwLCAxMSwgMSwgOSwgMCwgNjUsIDAsIDI1NCwgMTYsXG4gICAgICAgIDIsIDAsIDI2LCAxMSxcbiAgICAgIF0pLFxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IGlzU2ltZFN1cHBvcnRlZCA9ICgpOiBib29sZWFuID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSBTSU1EIGNhcGFiaWxpdHkgKGZvciBib3RoIGJyb3dzZXJzIGFuZCBOb2RlLmpzKVxuICAgIC8vIFRoaXMgdHlwZWQgYXJyYXkgaXMgYSBXZWJBc3NlbWJseSBwcm9ncmFtIGNvbnRhaW5pbmcgU0lNRCBpbnN0cnVjdGlvbnMuXG5cbiAgICAvLyBUaGUgYmluYXJ5IGRhdGEgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIGZvbGxvd2luZyBjb2RlIGJ5IHdhdDJ3YXNtOlxuICAgIC8vXG4gICAgLy8gKG1vZHVsZVxuICAgIC8vICAgKHR5cGUgJHQwIChmdW5jKSlcbiAgICAvLyAgIChmdW5jICRmMCAodHlwZSAkdDApXG4gICAgLy8gICAgIChkcm9wXG4gICAgLy8gICAgICAgKGkzMng0LmRvdF9pMTZ4OF9zXG4gICAgLy8gICAgICAgICAoaTh4MTYuc3BsYXRcbiAgICAvLyAgICAgICAgICAgKGkzMi5jb25zdCAwKSlcbiAgICAvLyAgICAgICAgICh2MTI4LmNvbnN0IGkzMng0IDB4MDAwMDAwMDAgMHgwMDAwMDAwMCAweDAwMDAwMDAwIDB4MDAwMDAwMDApKSkpKVxuXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDQsIDEsIDk2LCAwLCAwLCAzLCAyLCAxLCAwLCAxMCwgMzAsIDEsIDI4LCAwLCA2NSwgMCwgMjUzLCAxNSwgMjUzLCAxMiwgMCwgMCwgMCxcbiAgICAgICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjUzLCAxODYsIDEsIDI2LCAxMSxcbiAgICAgIF0pLFxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IGlzUmVsYXhlZFNpbWRTdXBwb3J0ZWQgPSAoKTogYm9vbGVhbiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gVGVzdCBmb3IgV2ViQXNzZW1ibHkgUmVsYXhlZCBTSU1EIGNhcGFiaWxpdHkgKGZvciBib3RoIGJyb3dzZXJzIGFuZCBOb2RlLmpzKVxuICAgIC8vIFRoaXMgdHlwZWQgYXJyYXkgaXMgYSBXZWJBc3NlbWJseSBwcm9ncmFtIGNvbnRhaW5pbmcgUmVsYXhlZCBTSU1EIGluc3RydWN0aW9ucy5cblxuICAgIC8vIFRoZSBiaW5hcnkgZGF0YSBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgZm9sbG93aW5nIGNvZGUgYnkgd2F0Mndhc206XG4gICAgLy8gKG1vZHVsZVxuICAgIC8vICAgKGZ1bmMgKHJlc3VsdCB2MTI4KVxuICAgIC8vICAgICAgaTMyLmNvbnN0IDFcbiAgICAvLyAgICAgIGk4eDE2LnNwbGF0XG4gICAgLy8gICAgICBpMzIuY29uc3QgMlxuICAgIC8vICAgICAgaTh4MTYuc3BsYXRcbiAgICAvLyAgICAgIGkzMi5jb25zdCAzXG4gICAgLy8gICAgICBpOHgxNi5zcGxhdFxuICAgIC8vICAgICAgaTMyeDQucmVsYXhlZF9kb3RfaTh4MTZfaTd4MTZfYWRkX3NcbiAgICAvLyAgIClcbiAgICAvLyAgKVxuICAgIHJldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShcbiAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCA1LCAxLCA5NiwgMCwgMSwgMTIzLCAzLCAyLCAxLCAwLCAxMCwgMTksIDEsIDE3LCAwLCA2NSwgMSwgMjUzLCAxNSwgNjUsIDIsIDI1MyxcbiAgICAgICAgMTUsIDY1LCAzLCAyNTMsIDE1LCAyNTMsIDE0NywgMiwgMTEsXG4gICAgICBdKSxcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5ID0gYXN5bmMgKGZsYWdzOiBFbnYuV2ViQXNzZW1ibHlGbGFncyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgaWYgKGluaXRpYWxpemluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZGV0ZWN0ZWQuXCIpO1xuICB9XG4gIGlmIChhYm9ydGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGZhaWxlZC5cIik7XG4gIH1cblxuICBpbml0aWFsaXppbmcgPSB0cnVlO1xuXG4gIC8vIHdhc20gZmxhZ3MgYXJlIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgY29uc3QgdGltZW91dCA9IGZsYWdzLmluaXRUaW1lb3V0ITtcbiAgbGV0IG51bVRocmVhZHMgPSBmbGFncy5udW1UaHJlYWRzITtcblxuICAvLyBlbnN1cmUgU0lNRCBpcyBzdXBwb3J0ZWRcbiAgaWYgKGZsYWdzLnNpbWQgPT09IGZhbHNlKSB7XG4gICAgLy8gc2tpcCBTSU1EIGZlYXR1cmUgY2hlY2tpbmcgYXMgaXQgaXMgZGlzYWJsZWQgZXhwbGljaXRseSBieSB1c2VyXG4gIH0gZWxzZSBpZiAoZmxhZ3Muc2ltZCA9PT0gJ3JlbGF4ZWQnKSB7XG4gICAgLy8gY2hlY2sgaWYgcmVsYXhlZCBTSU1EIGlzIHN1cHBvcnRlZFxuICAgIGlmICghaXNSZWxheGVkU2ltZFN1cHBvcnRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbGF4ZWQgV2ViQXNzZW1ibHkgU0lNRCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LicpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghaXNTaW1kU3VwcG9ydGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkFzc2VtYmx5IFNJTUQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4nKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIG11bHRpLXRocmVhZGluZyBpcyBzdXBwb3J0ZWRcbiAgY29uc3QgbXVsdGlUaHJlYWRTdXBwb3J0ZWQgPSBpc011bHRpVGhyZWFkU3VwcG9ydGVkKCk7XG4gIGlmIChudW1UaHJlYWRzID4gMSAmJiAhbXVsdGlUaHJlYWRTdXBwb3J0ZWQpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdlbnYud2FzbS5udW1UaHJlYWRzIGlzIHNldCB0byAnICtcbiAgICAgICAgICBudW1UaHJlYWRzICtcbiAgICAgICAgICAnLCBidXQgdGhpcyB3aWxsIG5vdCB3b3JrIHVubGVzcyB5b3UgZW5hYmxlIGNyb3NzT3JpZ2luSXNvbGF0ZWQgbW9kZS4gJyArXG4gICAgICAgICAgJ1NlZSBodHRwczovL3dlYi5kZXYvY3Jvc3Mtb3JpZ2luLWlzb2xhdGlvbi1ndWlkZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdXZWJBc3NlbWJseSBtdWx0aS10aHJlYWRpbmcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gJyArICdGYWxsaW5nIGJhY2sgdG8gc2luZ2xlLXRocmVhZGluZy4nLFxuICAgICk7XG5cbiAgICAvLyBzZXQgZmxhZ3MubnVtVGhyZWFkcyB0byAxIHNvIHRoYXQgT3J0SW5pdCgpIHdpbGwgbm90IGNyZWF0ZSBhIGdsb2JhbCB0aHJlYWQgcG9vbC5cbiAgICBmbGFncy5udW1UaHJlYWRzID0gbnVtVGhyZWFkcyA9IDE7XG4gIH1cblxuICBjb25zdCB3YXNtUGF0aHMgPSBmbGFncy53YXNtUGF0aHM7XG4gIGNvbnN0IHdhc21QcmVmaXhPdmVycmlkZSA9IHR5cGVvZiB3YXNtUGF0aHMgPT09ICdzdHJpbmcnID8gd2FzbVBhdGhzIDogdW5kZWZpbmVkO1xuICBjb25zdCBtanNQYXRoT3ZlcnJpZGVGbGFnID0gKHdhc21QYXRocyBhcyBFbnYuV2FzbUZpbGVQYXRocyk/Lm1qcztcbiAgY29uc3QgbWpzUGF0aE92ZXJyaWRlID0gKG1qc1BhdGhPdmVycmlkZUZsYWcgYXMgVVJMKT8uaHJlZiA/PyBtanNQYXRoT3ZlcnJpZGVGbGFnO1xuICBjb25zdCB3YXNtUGF0aE92ZXJyaWRlRmxhZyA9ICh3YXNtUGF0aHMgYXMgRW52Lldhc21GaWxlUGF0aHMpPy53YXNtO1xuICBjb25zdCB3YXNtUGF0aE92ZXJyaWRlID0gKHdhc21QYXRoT3ZlcnJpZGVGbGFnIGFzIFVSTCk/LmhyZWYgPz8gd2FzbVBhdGhPdmVycmlkZUZsYWc7XG4gIGNvbnN0IHdhc21CaW5hcnlPdmVycmlkZSA9IGZsYWdzLndhc21CaW5hcnk7XG5cbiAgY29uc3QgW29iamVjdFVybCwgb3J0V2FzbUZhY3RvcnldID0gYXdhaXQgaW1wb3J0V2FzbU1vZHVsZShcbiAgICBtanNQYXRoT3ZlcnJpZGUsXG4gICAgd2FzbVByZWZpeE92ZXJyaWRlLFxuICAgIG51bVRocmVhZHMgPiAxLFxuICAgICEhd2FzbUJpbmFyeU92ZXJyaWRlIHx8ICEhd2FzbVBhdGhPdmVycmlkZSxcbiAgKTtcblxuICBsZXQgaXNUaW1lb3V0ID0gZmFsc2U7XG5cbiAgY29uc3QgdGFza3M6IEFycmF5PFByb21pc2U8dm9pZD4+ID0gW107XG5cbiAgLy8gcHJvbWlzZSBmb3IgdGltZW91dFxuICBpZiAodGltZW91dCA+IDApIHtcbiAgICB0YXNrcy5wdXNoKFxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIC8vIHByb21pc2UgZm9yIG1vZHVsZSBpbml0aWFsaXphdGlvblxuICB0YXNrcy5wdXNoKFxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZzogUGFydGlhbDxPcnRXYXNtTW9kdWxlPiA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgdGhyZWFkcy4gV2ViQXNzZW1ibHkgd2lsbCBjcmVhdGUgKE1vZHVsZS5udW1UaHJlYWRzIC0gMSkgd29ya2Vycy4gSWYgaXQgaXMgMSwgbm8gd29ya2VyIHdpbGwgYmVcbiAgICAgICAgICogY3JlYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIG51bVRocmVhZHMsXG4gICAgICB9O1xuXG4gICAgICBpZiAod2FzbUJpbmFyeU92ZXJyaWRlKSB7XG4gICAgICAgIC8vIFNldCBhIGN1c3RvbSBidWZmZXIgd2hpY2ggY29udGFpbnMgdGhlIFdlYkFzc2VtYmx5IGJpbmFyeS4gVGhpcyB3aWxsIHNraXAgdGhlIHdhc20gZmlsZSBmZXRjaGluZy5cbiAgICAgICAgY29uZmlnLndhc21CaW5hcnkgPSB3YXNtQmluYXJ5T3ZlcnJpZGU7XG4gICAgICB9IGVsc2UgaWYgKHdhc21QYXRoT3ZlcnJpZGUgfHwgd2FzbVByZWZpeE92ZXJyaWRlKSB7XG4gICAgICAgIC8vIEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gbG9jYXRlIHRoZSBXZWJBc3NlbWJseSBmaWxlLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiB0aGUgZnVsbCBwYXRoIG9mIHRoZSBmaWxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBTaW5jZSBFbXNjcmlwdGVuIDMuMS41OCwgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBmb3IgdGhlIC53YXNtIGZpbGUuXG4gICAgICAgIGNvbmZpZy5sb2NhdGVGaWxlID0gKGZpbGVOYW1lKSA9PiB3YXNtUGF0aE92ZXJyaWRlID8/IHdhc21QcmVmaXhPdmVycmlkZSArIGZpbGVOYW1lO1xuICAgICAgfSBlbHNlIGlmIChtanNQYXRoT3ZlcnJpZGUgJiYgbWpzUGF0aE92ZXJyaWRlLmluZGV4T2YoJ2Jsb2I6JykgIT09IDApIHtcbiAgICAgICAgLy8gaWYgbWpzIHBhdGggaXMgc3BlY2lmaWVkLCB1c2UgaXQgYXMgdGhlIGJhc2UgcGF0aCBmb3IgdGhlIC53YXNtIGZpbGUuXG4gICAgICAgIGNvbmZpZy5sb2NhdGVGaWxlID0gKGZpbGVOYW1lKSA9PiBuZXcgVVJMKGZpbGVOYW1lLCBtanNQYXRoT3ZlcnJpZGUpLmhyZWY7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdFVybCkge1xuICAgICAgICBjb25zdCBpbmZlcnJlZFdhc21QYXRoUHJlZml4ID0gaW5mZXJXYXNtUGF0aFByZWZpeEZyb21TY3JpcHRTcmMoKTtcbiAgICAgICAgaWYgKGluZmVycmVkV2FzbVBhdGhQcmVmaXgpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgd2FzbSBtb2R1bGUgaXMgcHJlbG9hZGVkLCB1c2UgdGhlIGluZmVycmVkIHdhc20gcGF0aCBhcyB0aGUgYmFzZSBwYXRoIGZvciB0aGUgLndhc20gZmlsZS5cbiAgICAgICAgICBjb25maWcubG9jYXRlRmlsZSA9IChmaWxlTmFtZSkgPT4gaW5mZXJyZWRXYXNtUGF0aFByZWZpeCArIGZpbGVOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9ydFdhc21GYWN0b3J5KGNvbmZpZykudGhlbihcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICAgIChtb2R1bGUpID0+IHtcbiAgICAgICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgd2FzbSA9IG1vZHVsZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgaWYgKG9iamVjdFVybCkge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVcmwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgZmFpbGVkIHRvIGluaXRpYWxpemVcbiAgICAgICAgKHdoYXQpID0+IHtcbiAgICAgICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICByZWplY3Qod2hhdCk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pLFxuICApO1xuXG4gIGF3YWl0IFByb21pc2UucmFjZSh0YXNrcyk7XG5cbiAgaWYgKGlzVGltZW91dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke3RpbWVvdXR9bXNgKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldEluc3RhbmNlID0gKCk6IE9ydFdhc21Nb2R1bGUgPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQgJiYgd2FzbSkge1xuICAgIHJldHVybiB3YXNtO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LicpO1xufTtcblxuZXhwb3J0IGNvbnN0IGRpc3Bvc2UgPSAoKTogdm9pZCA9PiB7XG4gIGlmIChpbml0aWFsaXplZCAmJiAhaW5pdGlhbGl6aW5nICYmICFhYm9ydGVkKSB7XG4gICAgLy8gVE9ETzogY3VycmVudGx5IFwiUFRocmVhZC50ZXJtaW5hdGVBbGxUaHJlYWRzKClcIiBpcyBub3QgZXhwb3NlZCBpbiB0aGUgd2FzbSBtb2R1bGUuXG4gICAgLy8gICAgICAgQW5kIHRoaXMgZnVuY3Rpb24gaXMgbm90IHlldCBjYWxsZWQgYnkgYW55IGNvZGUuXG4gICAgLy8gICAgICAgSWYgaXQgaXMgbmVlZGVkIGluIHRoZSBmdXR1cmUsIHdlIHNob3VsZCBleHBvc2UgaXQgaW4gdGhlIHdhc20gbW9kdWxlIGFuZCB1bmNvbW1lbnQgdGhlIGZvbGxvd2luZyBsaW5lLlxuXG4gICAgLy8gd2FzbT8uUFRocmVhZD8udGVybWluYXRlQWxsVGhyZWFkcygpO1xuICAgIHdhc20gPSB1bmRlZmluZWQ7XG5cbiAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGFib3J0ZWQgPSB0cnVlO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBnZXRJbnN0YW5jZSB9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcblxuZXhwb3J0IGNvbnN0IGFsbG9jV2FzbVN0cmluZyA9IChkYXRhOiBzdHJpbmcsIGFsbG9jczogbnVtYmVyW10pOiBudW1iZXIgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBjb25zdCBkYXRhTGVuZ3RoID0gd2FzbS5sZW5ndGhCeXRlc1VURjgoZGF0YSkgKyAxO1xuICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5fbWFsbG9jKGRhdGFMZW5ndGgpO1xuICB3YXNtLnN0cmluZ1RvVVRGOChkYXRhLCBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoKTtcbiAgYWxsb2NzLnB1c2goZGF0YU9mZnNldCk7XG5cbiAgcmV0dXJuIGRhdGFPZmZzZXQ7XG59O1xuXG5pbnRlcmZhY2UgRXh0cmFPcHRpb25zSGFuZGxlciB7XG4gIChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgaXRlcmF0ZUV4dHJhT3B0aW9ucyA9IChcbiAgb3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIHByZWZpeDogc3RyaW5nLFxuICBzZWVuOiBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PixcbiAgaGFuZGxlcjogRXh0cmFPcHRpb25zSGFuZGxlcixcbik6IHZvaWQgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgIGlmIChzZWVuLmhhcyhvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9ucycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWVuLmFkZChvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBPYmplY3QuZW50cmllcyhvcHRpb25zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBuYW1lID0gcHJlZml4ID8gcHJlZml4ICsga2V5IDoga2V5O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKHZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBuYW1lICsgJy4nLCBzZWVuLCBoYW5kbGVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaGFuZGxlcihuYW1lLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBoYW5kbGVyKG5hbWUsIHZhbHVlID8gJzEnIDogJzAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIGNoZWNrIHdlYiBhc3NlbWJseSBBUEkncyBsYXN0IGVycm9yIGFuZCB0aHJvdyBlcnJvciBpZiBhbnkgZXJyb3Igb2NjdXJyZWQuXG4gKiBAcGFyYW0gbWVzc2FnZSBhIG1lc3NhZ2UgdXNlZCB3aGVuIGFuIGVycm9yIG9jY3VycmVkLlxuICovXG5leHBvcnQgY29uc3QgY2hlY2tMYXN0RXJyb3IgPSAobWVzc2FnZTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuXG4gIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBwdHJTaXplID0gd2FzbS5QVFJfU0laRTtcbiAgICBjb25zdCBwYXJhbXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoMiAqIHB0clNpemUpO1xuICAgIHdhc20uX09ydEdldExhc3RFcnJvcihwYXJhbXNPZmZzZXQsIHBhcmFtc09mZnNldCArIHB0clNpemUpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IE51bWJlcih3YXNtLmdldFZhbHVlKHBhcmFtc09mZnNldCwgcHRyU2l6ZSA9PT0gNCA/ICdpMzInIDogJ2k2NCcpKTtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2VQb2ludGVyID0gd2FzbS5nZXRWYWx1ZShwYXJhbXNPZmZzZXQgKyBwdHJTaXplLCAnKicpO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZVBvaW50ZXIgPyB3YXNtLlVURjhUb1N0cmluZyhlcnJvck1lc3NhZ2VQb2ludGVyKSA6ICcnO1xuICAgIHRocm93IG5ldyBFcnJvcihgJHttZXNzYWdlfSBFUlJPUl9DT0RFOiAke2Vycm9yQ29kZX0sIEVSUk9SX01FU1NBR0U6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IGdldEluc3RhbmNlIH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHsgYWxsb2NXYXNtU3RyaW5nLCBjaGVja0xhc3RFcnJvciwgaXRlcmF0ZUV4dHJhT3B0aW9ucyB9IGZyb20gJy4vd2FzbS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBzZXRSdW5PcHRpb25zID0gKG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFtudW1iZXIsIG51bWJlcltdXSA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBsZXQgcnVuT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGNvbnN0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBydW5PcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnM/LmxvZ1NldmVyaXR5TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVuT3B0aW9ucy5sb2dTZXZlcml0eUxldmVsID0gMjsgLy8gRGVmYXVsdCB0byB3YXJuaW5nXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgIT09ICdudW1iZXInIHx8XG4gICAgICAhTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwpIHx8XG4gICAgICBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPCAwIHx8XG4gICAgICBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPiA0XG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7b3B0aW9ucy5sb2dTZXZlcml0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5sb2dWZXJib3NpdHlMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBydW5PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsID0gMDsgLy8gRGVmYXVsdCB0byAwXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7b3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8udGVybWluYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bk9wdGlvbnMudGVybWluYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHRhZ0RhdGFPZmZzZXQgPSAwO1xuICAgIGlmIChvcHRpb25zPy50YWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFnRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhvcHRpb25zLnRhZywgYWxsb2NzKTtcbiAgICB9XG5cbiAgICBydW5PcHRpb25zSGFuZGxlID0gd2FzbS5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhcbiAgICAgIHJ1bk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCEsXG4gICAgICBydW5PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsISxcbiAgICAgICEhcnVuT3B0aW9ucy50ZXJtaW5hdGUhLFxuICAgICAgdGFnRGF0YU9mZnNldCxcbiAgICApO1xuICAgIGlmIChydW5PcHRpb25zSGFuZGxlID09PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9ucy5cIik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmV4dHJhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnMob3B0aW9ucy5leHRyYSwgJycsIG5ldyBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PigpLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGtleSwgYWxsb2NzKTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xuXG4gICAgICAgIGlmICh3YXNtLl9PcnRBZGRSdW5Db25maWdFbnRyeShydW5PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9LmApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3J1bk9wdGlvbnNIYW5kbGUsIGFsbG9jc107XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMocnVuT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIGFsbG9jcy5mb3JFYWNoKChhbGxvYykgPT4gd2FzbS5fZnJlZShhbGxvYykpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB0eXBlIHsgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IGdldEluc3RhbmNlIH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHsgYWxsb2NXYXNtU3RyaW5nLCBjaGVja0xhc3RFcnJvciwgaXRlcmF0ZUV4dHJhT3B0aW9ucyB9IGZyb20gJy4vd2FzbS11dGlscyc7XG5cbmNvbnN0IGdldEdyYXBoT3B0aW16YXRpb25MZXZlbCA9IChncmFwaE9wdGltaXphdGlvbkxldmVsOiBzdHJpbmcgfCB1bmtub3duKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChncmFwaE9wdGltaXphdGlvbkxldmVsKSB7XG4gICAgY2FzZSAnZGlzYWJsZWQnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnZXh0ZW5kZWQnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAnbGF5b3V0JzpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgJ2FsbCc6XG4gICAgICByZXR1cm4gOTk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2dyYXBoT3B0aW1pemF0aW9uTGV2ZWx9YCk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEV4ZWN1dGlvbk1vZGUgPSAoZXhlY3V0aW9uTW9kZTogJ3NlcXVlbnRpYWwnIHwgJ3BhcmFsbGVsJyk6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAoZXhlY3V0aW9uTW9kZSkge1xuICAgIGNhc2UgJ3NlcXVlbnRpYWwnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAncGFyYWxsZWwnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZXhlY3V0aW9uTW9kZX1gKTtcbiAgfVxufTtcblxuY29uc3QgYXBwZW5kRGVmYXVsdE9wdGlvbnMgPSAob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IHZvaWQgPT4ge1xuICBpZiAoIW9wdGlvbnMuZXh0cmEpIHtcbiAgICBvcHRpb25zLmV4dHJhID0ge307XG4gIH1cbiAgaWYgKCFvcHRpb25zLmV4dHJhLnNlc3Npb24pIHtcbiAgICBvcHRpb25zLmV4dHJhLnNlc3Npb24gPSB7fTtcbiAgfVxuICBjb25zdCBzZXNzaW9uID0gb3B0aW9ucy5leHRyYS5zZXNzaW9uIGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIGlmICghc2Vzc2lvbi51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICAgIHNlc3Npb24udXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSA9ICcxJztcbiAgfVxuXG4gIC8vIGlmIHVzaW5nIEpTRVAgd2l0aCBXZWJHUFUsIGFsd2F5cyBkaXNhYmxlIG1lbW9yeSBwYXR0ZXJuXG4gIGlmIChcbiAgICBvcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycyAmJlxuICAgIG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzLnNvbWUoKGVwKSA9PiAodHlwZW9mIGVwID09PSAnc3RyaW5nJyA/IGVwIDogZXAubmFtZSkgPT09ICd3ZWJncHUnKVxuICApIHtcbiAgICBvcHRpb25zLmVuYWJsZU1lbVBhdHRlcm4gPSBmYWxzZTtcbiAgfVxufTtcblxuY29uc3QgYXBwZW5kU2Vzc2lvbkNvbmZpZyA9IChzZXNzaW9uT3B0aW9uc0hhbmRsZTogbnVtYmVyLCBrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgYWxsb2NzOiBudW1iZXJbXSk6IHZvaWQgPT4ge1xuICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGtleSwgYWxsb2NzKTtcbiAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xuICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke2tleX0gLSAke3ZhbHVlfS5gKTtcbiAgfVxufTtcblxuY29uc3QgYXBwZW5kRXBPcHRpb24gPSAoZXBPcHRpb25zOiBBcnJheTxbbnVtYmVyLCBudW1iZXJdPiwga2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIGFsbG9jczogbnVtYmVyW10pOiB2b2lkID0+IHtcbiAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhrZXksIGFsbG9jcyk7XG4gIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyh2YWx1ZSwgYWxsb2NzKTtcbiAgZXBPcHRpb25zLnB1c2goW2tleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldF0pO1xufTtcblxuY29uc3Qgc2V0RXhlY3V0aW9uUHJvdmlkZXJzID0gYXN5bmMgKFxuICBzZXNzaW9uT3B0aW9uc0hhbmRsZTogbnVtYmVyLFxuICBleGVjdXRpb25Qcm92aWRlcnM6IHJlYWRvbmx5IEluZmVyZW5jZVNlc3Npb24uRXhlY3V0aW9uUHJvdmlkZXJDb25maWdbXSxcbiAgYWxsb2NzOiBudW1iZXJbXSxcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBmb3IgKGNvbnN0IGVwIG9mIGV4ZWN1dGlvblByb3ZpZGVycykge1xuICAgIGxldCBlcE5hbWUgPSB0eXBlb2YgZXAgPT09ICdzdHJpbmcnID8gZXAgOiBlcC5uYW1lO1xuICAgIGNvbnN0IGVwT3B0aW9uczogQXJyYXk8W251bWJlciwgbnVtYmVyXT4gPSBbXTtcblxuICAgIC8vIGNoZWNrIEVQIG5hbWVcbiAgICBzd2l0Y2ggKGVwTmFtZSkge1xuICAgICAgY2FzZSAnd2Vibm4nOlxuICAgICAgICBlcE5hbWUgPSAnV0VCTk4nO1xuICAgICAgICBpZiAodHlwZW9mIGVwICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IHdlYm5uT3B0aW9ucyA9IGVwIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICAgICAgICAvLyBjb25zdCBjb250ZXh0ID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OT3B0aW9uc1dpdGhNTENvbnRleHQpPy5jb250ZXh0O1xuICAgICAgICAgIGNvbnN0IGRldmljZVR5cGUgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/LmRldmljZVR5cGU7XG4gICAgICAgICAgaWYgKGRldmljZVR5cGUpIHtcbiAgICAgICAgICAgIGFwcGVuZFNlc3Npb25Db25maWcoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsICdkZXZpY2VUeXBlJywgZGV2aWNlVHlwZSwgYWxsb2NzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3ZWJncHUnOlxuICAgICAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpIHtcbiAgICAgICAgICBlcE5hbWUgPSAnV2ViR1BVJztcbiAgICAgICAgICBsZXQgY3VzdG9tRGV2aWNlOiBHUFVEZXZpY2UgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGVwICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tT3B0aW9ucyA9IGVwIGFzIHVua25vd24gYXMgeyBkZXZpY2U6IEdQVURldmljZSB9O1xuICAgICAgICAgICAgaWYgKGN1c3RvbU9wdGlvbnMuZGV2aWNlKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgR1BVRGV2aWNlICE9PSAndW5kZWZpbmVkJyAmJiBjdXN0b21PcHRpb25zLmRldmljZSBpbnN0YW5jZW9mIEdQVURldmljZSkge1xuICAgICAgICAgICAgICAgIGN1c3RvbURldmljZSA9IGN1c3RvbU9wdGlvbnMuZGV2aWNlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHUFUgZGV2aWNlIHNldCBpbiBXZWJHUFUgRVAgb3B0aW9ucy4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiBoYW5kbGUgbW9yZSBvcHRpb25zXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaW5mbyA9IGdldEluc3RhbmNlKCkud2ViZ3B1UmVnaXN0ZXJEZXZpY2UhKGN1c3RvbURldmljZSk7XG4gICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IFtkZXZpY2VJZCwgaW5zdGFuY2VIYW5kbGUsIGRldmljZUhhbmRsZV0gPSBpbmZvO1xuICAgICAgICAgICAgYXBwZW5kRXBPcHRpb24oZXBPcHRpb25zLCAnZGV2aWNlSWQnLCBkZXZpY2VJZC50b1N0cmluZygpLCBhbGxvY3MpO1xuICAgICAgICAgICAgYXBwZW5kRXBPcHRpb24oZXBPcHRpb25zLCAnd2ViZ3B1SW5zdGFuY2UnLCBpbnN0YW5jZUhhbmRsZS50b1N0cmluZygpLCBhbGxvY3MpO1xuICAgICAgICAgICAgYXBwZW5kRXBPcHRpb24oZXBPcHRpb25zLCAnd2ViZ3B1RGV2aWNlJywgZGV2aWNlSGFuZGxlLnRvU3RyaW5nKCksIGFsbG9jcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVwTmFtZSA9ICdKUyc7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHdlYmdwdU9wdGlvbnMgPSBlcCBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgICAgICAgICAgaWYgKHdlYmdwdU9wdGlvbnM/LnByZWZlcnJlZExheW91dCkge1xuICAgICAgICAgICAgICBpZiAod2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQgIT09ICdOQ0hXJyAmJiB3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dCAhPT0gJ05IV0MnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcmVmZXJyZWRMYXlvdXQgbXVzdCBiZSBlaXRoZXIgJ05DSFcnIG9yICdOSFdDJzogJHt3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dH1gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcHBlbmRTZXNzaW9uQ29uZmlnKHNlc3Npb25PcHRpb25zSGFuZGxlLCAncHJlZmVycmVkTGF5b3V0Jywgd2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQsIGFsbG9jcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2FzbSc6XG4gICAgICBjYXNlICdjcHUnOlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7ZXBOYW1lfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGVwTmFtZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoZXBOYW1lLCBhbGxvY3MpO1xuICAgIGNvbnN0IGVwT3B0aW9uc0NvdW50ID0gZXBPcHRpb25zLmxlbmd0aDtcbiAgICBsZXQga2V5c09mZnNldCA9IDA7XG4gICAgbGV0IHZhbHVlc09mZnNldCA9IDA7XG4gICAgaWYgKGVwT3B0aW9uc0NvdW50ID4gMCkge1xuICAgICAga2V5c09mZnNldCA9IGdldEluc3RhbmNlKCkuX21hbGxvYyhlcE9wdGlvbnNDb3VudCAqIGdldEluc3RhbmNlKCkuUFRSX1NJWkUpO1xuICAgICAgYWxsb2NzLnB1c2goa2V5c09mZnNldCk7XG4gICAgICB2YWx1ZXNPZmZzZXQgPSBnZXRJbnN0YW5jZSgpLl9tYWxsb2MoZXBPcHRpb25zQ291bnQgKiBnZXRJbnN0YW5jZSgpLlBUUl9TSVpFKTtcbiAgICAgIGFsbG9jcy5wdXNoKHZhbHVlc09mZnNldCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVwT3B0aW9uc0NvdW50OyBpKyspIHtcbiAgICAgICAgZ2V0SW5zdGFuY2UoKS5zZXRWYWx1ZShrZXlzT2Zmc2V0ICsgaSAqIGdldEluc3RhbmNlKCkuUFRSX1NJWkUsIGVwT3B0aW9uc1tpXVswXSwgJyonKTtcbiAgICAgICAgZ2V0SW5zdGFuY2UoKS5zZXRWYWx1ZSh2YWx1ZXNPZmZzZXQgKyBpICogZ2V0SW5zdGFuY2UoKS5QVFJfU0laRSwgZXBPcHRpb25zW2ldWzFdLCAnKicpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoXG4gICAgICAoYXdhaXQgZ2V0SW5zdGFuY2UoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoXG4gICAgICAgIHNlc3Npb25PcHRpb25zSGFuZGxlLFxuICAgICAgICBlcE5hbWVEYXRhT2Zmc2V0LFxuICAgICAgICBrZXlzT2Zmc2V0LFxuICAgICAgICB2YWx1ZXNPZmZzZXQsXG4gICAgICAgIGVwT3B0aW9uc0NvdW50LFxuICAgICAgKSkgIT09IDBcbiAgICApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBhcHBlbmQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke2VwTmFtZX0uYCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0U2Vzc2lvbk9wdGlvbnMgPSBhc3luYyAob3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPFtudW1iZXIsIG51bWJlcltdXT4gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgbGV0IHNlc3Npb25PcHRpb25zSGFuZGxlID0gMDtcbiAgY29uc3QgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IHNlc3Npb25PcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgYXBwZW5kRGVmYXVsdE9wdGlvbnMoc2Vzc2lvbk9wdGlvbnMpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCA9IGdldEdyYXBoT3B0aW16YXRpb25MZXZlbChzZXNzaW9uT3B0aW9ucy5ncmFwaE9wdGltaXphdGlvbkxldmVsID8/ICdhbGwnKTtcbiAgICBjb25zdCBleGVjdXRpb25Nb2RlID0gZ2V0RXhlY3V0aW9uTW9kZShzZXNzaW9uT3B0aW9ucy5leGVjdXRpb25Nb2RlID8/ICdzZXF1ZW50aWFsJyk7XG4gICAgY29uc3QgbG9nSWREYXRhT2Zmc2V0ID1cbiAgICAgIHR5cGVvZiBzZXNzaW9uT3B0aW9ucy5sb2dJZCA9PT0gJ3N0cmluZycgPyBhbGxvY1dhc21TdHJpbmcoc2Vzc2lvbk9wdGlvbnMubG9nSWQsIGFsbG9jcykgOiAwO1xuXG4gICAgY29uc3QgbG9nU2V2ZXJpdHlMZXZlbCA9IHNlc3Npb25PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPz8gMjsgLy8gRGVmYXVsdCB0byAyIC0gd2FybmluZ1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihsb2dTZXZlcml0eUxldmVsKSB8fCBsb2dTZXZlcml0eUxldmVsIDwgMCB8fCBsb2dTZXZlcml0eUxldmVsID4gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgc2V2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2xvZ1NldmVyaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9nVmVyYm9zaXR5TGV2ZWwgPSBzZXNzaW9uT3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCA/PyAwOyAvLyBEZWZhdWx0IHRvIDAgLSB2ZXJib3NlXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxvZ1ZlcmJvc2l0eUxldmVsKSB8fCBsb2dWZXJib3NpdHlMZXZlbCA8IDAgfHwgbG9nVmVyYm9zaXR5TGV2ZWwgPiA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2xvZ1ZlcmJvc2l0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGltaXplZE1vZGVsRmlsZVBhdGhPZmZzZXQgPVxuICAgICAgdHlwZW9mIHNlc3Npb25PcHRpb25zLm9wdGltaXplZE1vZGVsRmlsZVBhdGggPT09ICdzdHJpbmcnXG4gICAgICAgID8gYWxsb2NXYXNtU3RyaW5nKHNlc3Npb25PcHRpb25zLm9wdGltaXplZE1vZGVsRmlsZVBhdGgsIGFsbG9jcylcbiAgICAgICAgOiAwO1xuXG4gICAgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSB3YXNtLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhcbiAgICAgIGdyYXBoT3B0aW1pemF0aW9uTGV2ZWwsXG4gICAgICAhIXNlc3Npb25PcHRpb25zLmVuYWJsZUNwdU1lbUFyZW5hLFxuICAgICAgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVNZW1QYXR0ZXJuLFxuICAgICAgZXhlY3V0aW9uTW9kZSxcbiAgICAgICEhc2Vzc2lvbk9wdGlvbnMuZW5hYmxlUHJvZmlsaW5nLFxuICAgICAgMCxcbiAgICAgIGxvZ0lkRGF0YU9mZnNldCxcbiAgICAgIGxvZ1NldmVyaXR5TGV2ZWwsXG4gICAgICBsb2dWZXJib3NpdHlMZXZlbCxcbiAgICAgIG9wdGltaXplZE1vZGVsRmlsZVBhdGhPZmZzZXQsXG4gICAgKTtcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgY3JlYXRlIHNlc3Npb24gb3B0aW9ucy5cIik7XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25PcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycykge1xuICAgICAgYXdhaXQgc2V0RXhlY3V0aW9uUHJvdmlkZXJzKHNlc3Npb25PcHRpb25zSGFuZGxlLCBzZXNzaW9uT3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMsIGFsbG9jcyk7XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZW5hYmxlR3JhcGhDYXB0dXJlIG11c3QgYmUgYSBib29sZWFuIHZhbHVlOiAke3Nlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZX1gKTtcbiAgICAgIH1cbiAgICAgIGFwcGVuZFNlc3Npb25Db25maWcoXG4gICAgICAgIHNlc3Npb25PcHRpb25zSGFuZGxlLFxuICAgICAgICAnZW5hYmxlR3JhcGhDYXB0dXJlJyxcbiAgICAgICAgc2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlLnRvU3RyaW5nKCksXG4gICAgICAgIGFsbG9jcyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25PcHRpb25zLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpIHtcbiAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzZXNzaW9uT3B0aW9ucy5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSBuYW1lIG11c3QgYmUgYSBzdHJpbmc6ICR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSB2YWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXI6ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhuYW1lLCBhbGxvY3MpO1xuICAgICAgICBpZiAod2FzbS5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlKHNlc3Npb25PcHRpb25zSGFuZGxlLCBuYW1lT2Zmc2V0LCB2YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGU6ICR7bmFtZX0gLSAke3ZhbHVlfS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5leHRyYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKHNlc3Npb25PcHRpb25zLmV4dHJhLCAnJywgbmV3IFdlYWtTZXQ8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KCksIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGFwcGVuZFNlc3Npb25Db25maWcoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleSwgdmFsdWUsIGFsbG9jcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3Nlc3Npb25PcHRpb25zSGFuZGxlLCBhbGxvY3NdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHNlc3Npb25PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICBpZiAod2FzbS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHNlc3Npb25PcHRpb25zSGFuZGxlKSAhPT0gMCkge1xuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbiBvcHRpb25zLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYWxsb2NzLmZvckVhY2goKGFsbG9jKSA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuLy8gYSBkdW1teSB0eXBlIGRlY2xhcmF0aW9uIGZvciBGbG9hdDE2QXJyYXkgaW4gY2FzZSBhbnkgcG9seWZpbGwgaXMgYXZhaWxhYmxlLlxuZGVjbGFyZSBnbG9iYWwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IEZsb2F0MTZBcnJheTogYW55O1xufVxuXG4vLyBUaGlzIGZpbGUgaW5jbHVkZXMgY29tbW9uIGRlZmluaXRpb25zLiBUaGV5IGRvIE5PVCBoYXZlIGRlcGVuZGVuY3kgb24gdGhlIFdlYkFzc2VtYmx5IGluc3RhbmNlLlxuXG4vKipcbiAqIENvcGllZCBmcm9tIE9OTlggZGVmaW5pdGlvbi4gVXNlIHRoaXMgdG8gZHJvcCBkZXBlbmRlbmN5ICdvbm54X3Byb3RvJyB0byBkZWNyZWFzZSBjb21waWxlZCAuanMgZmlsZSBzaXplLlxuICovXG5leHBvcnQgY29uc3QgZW51bSBEYXRhVHlwZSB7XG4gIHVuZGVmaW5lZCA9IDAsXG4gIGZsb2F0ID0gMSxcbiAgdWludDggPSAyLFxuICBpbnQ4ID0gMyxcbiAgdWludDE2ID0gNCxcbiAgaW50MTYgPSA1LFxuICBpbnQzMiA9IDYsXG4gIGludDY0ID0gNyxcbiAgc3RyaW5nID0gOCxcbiAgYm9vbCA9IDksXG4gIGZsb2F0MTYgPSAxMCxcbiAgZG91YmxlID0gMTEsXG4gIHVpbnQzMiA9IDEyLFxuICB1aW50NjQgPSAxMyxcbiAgY29tcGxleDY0ID0gMTQsXG4gIGNvbXBsZXgxMjggPSAxNSxcbiAgYmZsb2F0MTYgPSAxNixcblxuICAvLyA0LWJpdCBkYXRhLXR5cGVzXG4gIHVpbnQ0ID0gMjEsXG4gIGludDQgPSAyMixcbn1cblxuLyoqXG4gKiBNYXAgc3RyaW5nIHRlbnNvciBkYXRhIHRvIGVudW0gdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtID0gKHR5cGU6IHN0cmluZyk6IERhdGFUeXBlID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnaW50OCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50ODtcbiAgICBjYXNlICd1aW50OCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDg7XG4gICAgY2FzZSAnYm9vbCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuYm9vbDtcbiAgICBjYXNlICdpbnQxNic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50MTY7XG4gICAgY2FzZSAndWludDE2JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50MTY7XG4gICAgY2FzZSAnaW50MzInOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDMyO1xuICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDMyO1xuICAgIGNhc2UgJ2Zsb2F0MTYnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmZsb2F0MTY7XG4gICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuZmxvYXQ7XG4gICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuZG91YmxlO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuc3RyaW5nO1xuICAgIGNhc2UgJ2ludDY0JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQ2NDtcbiAgICBjYXNlICd1aW50NjQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQ2NDtcbiAgICBjYXNlICdpbnQ0JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQ0O1xuICAgIGNhc2UgJ3VpbnQ0JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50NDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIE1hcCBlbnVtIHZhbHVlIHRvIHN0cmluZyB0ZW5zb3IgZGF0YVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcgPSAodHlwZVByb3RvOiBEYXRhVHlwZSk6IFRlbnNvci5UeXBlID0+IHtcbiAgc3dpdGNoICh0eXBlUHJvdG8pIHtcbiAgICBjYXNlIERhdGFUeXBlLmludDg6XG4gICAgICByZXR1cm4gJ2ludDgnO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDg6XG4gICAgICByZXR1cm4gJ3VpbnQ4JztcbiAgICBjYXNlIERhdGFUeXBlLmJvb2w6XG4gICAgICByZXR1cm4gJ2Jvb2wnO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50MTY6XG4gICAgICByZXR1cm4gJ2ludDE2JztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQxNjpcbiAgICAgIHJldHVybiAndWludDE2JztcbiAgICBjYXNlIERhdGFUeXBlLmludDMyOlxuICAgICAgcmV0dXJuICdpbnQzMic7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50MzI6XG4gICAgICByZXR1cm4gJ3VpbnQzMic7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDE2OlxuICAgICAgcmV0dXJuICdmbG9hdDE2JztcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0OlxuICAgICAgcmV0dXJuICdmbG9hdDMyJztcbiAgICBjYXNlIERhdGFUeXBlLmRvdWJsZTpcbiAgICAgIHJldHVybiAnZmxvYXQ2NCc7XG4gICAgY2FzZSBEYXRhVHlwZS5zdHJpbmc6XG4gICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQ2NDpcbiAgICAgIHJldHVybiAnaW50NjQnO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDY0OlxuICAgICAgcmV0dXJuICd1aW50NjQnO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50NDpcbiAgICAgIHJldHVybiAnaW50NCc7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50NDpcbiAgICAgIHJldHVybiAndWludDQnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGVQcm90b31gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBnZXQgdGVuc29yIHNpemUgaW4gYnl0ZXMgYnkgdGhlIGdpdmVuIGRhdGEgdHlwZSBhbmQgZGltZW5zaW9uc1xuICogQHJldHVybnMgc2l6ZSBpbiBpbnRlZ2VyIG9yIHVuZGVmaW5lZCBpZiB0aGUgZGF0YSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzID0gKFxuICBkYXRlVHlwZTogbnVtYmVyLFxuICBkaW1zT3JTaXplOiByZWFkb25seSBudW1iZXJbXSB8IG51bWJlcixcbik6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IGVsZW1lbnRTaXplID0gW1xuICAgIC0xLCAvLyB1bmRlZmluZWQgPSAwXG4gICAgNCwgLy8gZmxvYXQgPSAxXG4gICAgMSwgLy8gdWludDggPSAyXG4gICAgMSwgLy8gaW50OCA9IDNcbiAgICAyLCAvLyB1aW50MTYgPSA0XG4gICAgMiwgLy8gaW50MTYgPSA1XG4gICAgNCwgLy8gaW50MzIgPSA2XG4gICAgOCwgLy8gaW50NjQgPSA3XG4gICAgLTEsIC8vIHN0cmluZyA9IDhcbiAgICAxLCAvLyBib29sID0gOVxuICAgIDIsIC8vIGZsb2F0MTYgPSAxMFxuICAgIDgsIC8vIGRvdWJsZSA9IDExXG4gICAgNCwgLy8gdWludDMyID0gMTJcbiAgICA4LCAvLyB1aW50NjQgPSAxM1xuICAgIC0xLCAvLyBjb21wbGV4NjQgPSAxNFxuICAgIC0xLCAvLyBjb21wbGV4MTI4ID0gMTVcbiAgICAtMSwgLy8gYmZsb2F0MTYgPSAxNlxuICAgIC0xLCAvLyBGTE9BVDhFNE0zRk4gPSAxN1xuICAgIC0xLCAvLyBGTE9BVDhFNE0zRk5VWiA9IDE4XG4gICAgLTEsIC8vIEZMT0FUOEU1TTIgPSAxOVxuICAgIC0xLCAvLyBGTE9BVDhFNU0yRk5VWiA9IDIwXG4gICAgMC41LCAvLyB1aW50NCA9IDIxXG4gICAgMC41LCAvLyBpbnQ0ID0gMjJcbiAgXVtkYXRlVHlwZV07XG5cbiAgY29uc3Qgc2l6ZSA9IHR5cGVvZiBkaW1zT3JTaXplID09PSAnbnVtYmVyJyA/IGRpbXNPclNpemUgOiBkaW1zT3JTaXplLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpO1xuICByZXR1cm4gZWxlbWVudFNpemUgPiAwID8gTWF0aC5jZWlsKHNpemUgKiBlbGVtZW50U2l6ZSkgOiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIGdldCB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciBieSB0aGUgZ2l2ZW4gdGVuc29yIHR5cGVcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IChcbiAgdHlwZTogVGVuc29yLlR5cGUsXG4pOlxuICB8IEZsb2F0MzJBcnJheUNvbnN0cnVjdG9yXG4gIHwgVWludDhBcnJheUNvbnN0cnVjdG9yXG4gIHwgSW50OEFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50MTZBcnJheUNvbnN0cnVjdG9yXG4gIHwgSW50MTZBcnJheUNvbnN0cnVjdG9yXG4gIHwgSW50MzJBcnJheUNvbnN0cnVjdG9yXG4gIHwgQmlnSW50NjRBcnJheUNvbnN0cnVjdG9yXG4gIHwgVWludDhBcnJheUNvbnN0cnVjdG9yXG4gIHwgRmxvYXQ2NEFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50MzJBcnJheUNvbnN0cnVjdG9yXG4gIHwgQmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvciA9PiB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Zsb2F0MTYnOlxuICAgICAgLy8gYWxsb3cgRmxvYXQxNkFycmF5IHBvbHlmaWxsLlxuICAgICAgcmV0dXJuIHR5cGVvZiBGbG9hdDE2QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEZsb2F0MTZBcnJheS5mcm9tID8gRmxvYXQxNkFycmF5IDogVWludDE2QXJyYXk7XG4gICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIHJldHVybiBVaW50OEFycmF5O1xuICAgIGNhc2UgJ2ludDgnOlxuICAgICAgcmV0dXJuIEludDhBcnJheTtcbiAgICBjYXNlICd1aW50MTYnOlxuICAgICAgcmV0dXJuIFVpbnQxNkFycmF5O1xuICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgIHJldHVybiBJbnQxNkFycmF5O1xuICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgIHJldHVybiBJbnQzMkFycmF5O1xuICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XG4gICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICByZXR1cm4gRmxvYXQ2NEFycmF5O1xuICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICByZXR1cm4gVWludDMyQXJyYXk7XG4gICAgY2FzZSAnaW50NjQnOlxuICAgICAgcmV0dXJuIEJpZ0ludDY0QXJyYXk7XG4gICAgY2FzZSAndWludDY0JzpcbiAgICAgIHJldHVybiBCaWdVaW50NjRBcnJheTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFwIHN0cmluZyBsb2cgbGV2ZWwgdG8gaW50ZWdlciB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgbG9nTGV2ZWxTdHJpbmdUb0VudW0gPSAobG9nTGV2ZWw/OiAndmVyYm9zZScgfCAnaW5mbycgfCAnd2FybmluZycgfCAnZXJyb3InIHwgJ2ZhdGFsJyk6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAobG9nTGV2ZWwpIHtcbiAgICBjYXNlICd2ZXJib3NlJzpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgJ2luZm8nOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnd2FybmluZyc6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICByZXR1cm4gMztcbiAgICBjYXNlICdmYXRhbCc6XG4gICAgICByZXR1cm4gNDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2xvZ0xldmVsfWApO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRlbnNvciB0eXBlIGlzIHN1cHBvcnRlZCBieSBHUFUgYnVmZmVyXG4gKi9cbmV4cG9ydCBjb25zdCBpc0dwdUJ1ZmZlclN1cHBvcnRlZFR5cGUgPSAodHlwZTogVGVuc29yLlR5cGUpOiB0eXBlIGlzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXMgPT5cbiAgdHlwZSA9PT0gJ2Zsb2F0MzInIHx8XG4gIHR5cGUgPT09ICdmbG9hdDE2JyB8fFxuICB0eXBlID09PSAnaW50MzInIHx8XG4gIHR5cGUgPT09ICdpbnQ2NCcgfHxcbiAgdHlwZSA9PT0gJ3VpbnQzMicgfHxcbiAgdHlwZSA9PT0gJ3VpbnQ4JyB8fFxuICB0eXBlID09PSAnYm9vbCcgfHxcbiAgdHlwZSA9PT0gJ3VpbnQ0JyB8fFxuICB0eXBlID09PSAnaW50NCc7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdGVuc29yIHR5cGUgaXMgc3VwcG9ydGVkIGJ5IFdlYk5OIE1MVGVuc29yXG4gKi9cbmV4cG9ydCBjb25zdCBpc01MVGVuc29yU3VwcG9ydGVkVHlwZSA9ICh0eXBlOiBUZW5zb3IuVHlwZSk6IHR5cGUgaXMgVGVuc29yLk1MVGVuc29yRGF0YVR5cGVzID0+XG4gIHR5cGUgPT09ICdmbG9hdDMyJyB8fFxuICB0eXBlID09PSAnZmxvYXQxNicgfHxcbiAgdHlwZSA9PT0gJ2ludDMyJyB8fFxuICB0eXBlID09PSAnaW50NjQnIHx8XG4gIHR5cGUgPT09ICd1aW50MzInIHx8XG4gIHR5cGUgPT09ICd1aW50NjQnIHx8XG4gIHR5cGUgPT09ICdpbnQ4JyB8fFxuICB0eXBlID09PSAndWludDgnIHx8XG4gIHR5cGUgPT09ICdib29sJyB8fFxuICB0eXBlID09PSAndWludDQnIHx8XG4gIHR5cGUgPT09ICdpbnQ0JztcblxuLyoqXG4gKiBNYXAgc3RyaW5nIGRhdGEgbG9jYXRpb24gdG8gaW50ZWdlciB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtID0gKGxvY2F0aW9uOiBUZW5zb3IuRGF0YUxvY2F0aW9uKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChsb2NhdGlvbikge1xuICAgIGNhc2UgJ25vbmUnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgJ2NwdS1waW5uZWQnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAndGV4dHVyZSc6XG4gICAgICByZXR1cm4gMztcbiAgICBjYXNlICdncHUtYnVmZmVyJzpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgJ21sLXRlbnNvcic6XG4gICAgICByZXR1cm4gNTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxvY2F0aW9uOiAke2xvY2F0aW9ufWApO1xuICB9XG59O1xuXG4vKipcbiAqIE1hcCBpbnRlZ2VyIGRhdGEgbG9jYXRpb24gdG8gc3RyaW5nIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBkYXRhTG9jYXRpb25FbnVtVG9TdHJpbmcgPSAobG9jYXRpb246IG51bWJlcik6IFRlbnNvci5EYXRhTG9jYXRpb24gfCB1bmRlZmluZWQgPT5cbiAgKFsnbm9uZScsICdjcHUnLCAnY3B1LXBpbm5lZCcsICd0ZXh0dXJlJywgJ2dwdS1idWZmZXInLCAnbWwtdGVuc29yJ10gYXMgY29uc3QpW2xvY2F0aW9uXTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi93YXNtLXV0aWxzLWVudic7XG5cbi8qKlxuICogTG9hZCBhIGZpbGUgaW50byBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGZpbGUgLSB0aGUgZmlsZSB0byBsb2FkLiBDYW4gYmUgYSBVUkwvcGF0aCwgYSBCbG9iLCBhbiBBcnJheUJ1ZmZlciwgb3IgYSBVaW50OEFycmF5LlxuICogQHJldHVybnMgYSBVaW50OEFycmF5IGNvbnRhaW5pbmcgdGhlIGZpbGUgZGF0YS5cbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRGaWxlID0gYXN5bmMgKGZpbGU6IHN0cmluZyB8IEJsb2IgfCBBcnJheUJ1ZmZlckxpa2UgfCBVaW50OEFycmF5KTogUHJvbWlzZTxVaW50OEFycmF5PiA9PiB7XG4gIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAvLyBsb2FkIGZpbGUgaW50byBBcnJheUJ1ZmZlciBpbiBOb2RlLmpzXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHJlYWRGaWxlIH0gPSByZXF1aXJlKCdub2RlOmZzL3Byb21pc2VzJyk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCByZWFkRmlsZShmaWxlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLmNvZGUgPT09ICdFUlJfRlNfRklMRV9UT09fTEFSR0UnKSB7XG4gICAgICAgICAgLy8gZmlsZSBpcyB0b28gbGFyZ2UsIHVzZSBmcy5jcmVhdGVSZWFkU3RyZWFtIGluc3RlYWRcbiAgICAgICAgICBjb25zdCB7IGNyZWF0ZVJlYWRTdHJlYW0gfSA9IHJlcXVpcmUoJ25vZGU6ZnMnKTtcbiAgICAgICAgICBjb25zdCBzdHJlYW0gPSBjcmVhdGVSZWFkU3RyZWFtKGZpbGUpO1xuICAgICAgICAgIGNvbnN0IGNodW5rczogVWludDhBcnJheVtdID0gW107XG4gICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQoY2h1bmtzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbG9hZCBmaWxlIGludG8gQXJyYXlCdWZmZXIgaW4gYnJvd3NlcnNcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZmlsZSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2ZpbGV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb250ZW50TGVuZ3RoSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gICAgICBjb25zdCBmaWxlU2l6ZSA9IGNvbnRlbnRMZW5ndGhIZWFkZXIgPyBwYXJzZUludChjb250ZW50TGVuZ3RoSGVhZGVyLCAxMCkgOiAwO1xuICAgICAgaWYgKGZpbGVTaXplIDwgMTA3Mzc0MTgyNCAvKiAxR0IgKi8pIHtcbiAgICAgICAgLy8gd2hlbiBDb250ZW50LUxlbmd0aCBoZWFkZXIgaXMgbm90IHNldCwgd2UgY2Fubm90IGRldGVybWluZSB0aGUgZmlsZSBzaXplLiBXZSBhc3N1bWUgaXQgaXMgc21hbGwgZW5vdWdoIHRvXG4gICAgICAgIC8vIGxvYWQgaW50byBtZW1vcnkuXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZpbGUgaXMgdG9vIGxhcmdlLCB1c2Ugc3RyZWFtIGluc3RlYWRcbiAgICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZmlsZX0sIG5vIHJlc3BvbnNlIGJvZHkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcblxuICAgICAgICBsZXQgYnVmZmVyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIHRyeSB0byBjcmVhdGUgQXJyYXlCdWZmZXIgZGlyZWN0bHlcbiAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZmlsZVNpemUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSYW5nZUVycm9yKSB7XG4gICAgICAgICAgICAvLyB1c2UgV2ViQXNzZW1ibHkgTWVtb3J5IHRvIGFsbG9jYXRlIGxhcmdlciBBcnJheUJ1ZmZlclxuICAgICAgICAgICAgY29uc3QgcGFnZXMgPSBNYXRoLmNlaWwoZmlsZVNpemUgLyA2NTUzNik7XG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHsgaW5pdGlhbDogcGFnZXMsIG1heGltdW06IHBhZ2VzIH0pLmJ1ZmZlcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjaHVua1NpemUgPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQsIGNodW5rU2l6ZSk7XG4gICAgICAgICAgY2h1bmsuc2V0KHZhbHVlKTtcbiAgICAgICAgICBvZmZzZXQgKz0gY2h1bmtTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIsIDAsIGZpbGVTaXplKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpKTtcbiAgfSBlbHNlIGlmIChmaWxlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBmaWxlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShmaWxlKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgbG9nTGV2ZWxTdHJpbmdUb0VudW0gfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XG5cbnR5cGUgTG9nTGV2ZWwgPSBOb25OdWxsYWJsZTxFbnZbJ2xvZ0xldmVsJ10+O1xudHlwZSBNZXNzYWdlU3RyaW5nID0gc3RyaW5nO1xudHlwZSBNZXNzYWdlRnVuY3Rpb24gPSAoKSA9PiBzdHJpbmc7XG50eXBlIE1lc3NhZ2UgPSBNZXNzYWdlU3RyaW5nIHwgTWVzc2FnZUZ1bmN0aW9uO1xuXG5jb25zdCBsb2dMZXZlbFByZWZpeCA9IFsnVicsICdJJywgJ1cnLCAnRScsICdGJ107XG5cbmNvbnN0IGRvTG9nID0gKGxldmVsOiBudW1iZXIsIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLmxvZyhgWyR7bG9nTGV2ZWxQcmVmaXhbbGV2ZWxdfSwke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1dJHttZXNzYWdlfWApO1xufTtcblxubGV0IGNvbmZpZ0xvZ0xldmVsOiBMb2dMZXZlbCB8IHVuZGVmaW5lZDtcbmxldCBkZWJ1ZzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcblxuZXhwb3J0IGNvbnN0IGNvbmZpZ3VyZUxvZ2dlciA9ICgkY29uZmlnTG9nTGV2ZWw6IExvZ0xldmVsLCAkZGVidWc6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgY29uZmlnTG9nTGV2ZWwgPSAkY29uZmlnTG9nTGV2ZWw7XG4gIGRlYnVnID0gJGRlYnVnO1xufTtcblxuLyoqXG4gKiBBIHNpbXBsZSBsb2dnaW5nIHV0aWxpdHkgdG8gbG9nIG1lc3NhZ2VzIHRvIHRoZSBjb25zb2xlLlxuICovXG5leHBvcnQgY29uc3QgTE9HID0gKGxvZ0xldmVsOiBMb2dMZXZlbCwgbXNnOiBNZXNzYWdlKTogdm9pZCA9PiB7XG4gIGNvbnN0IG1lc3NhZ2VMZXZlbCA9IGxvZ0xldmVsU3RyaW5nVG9FbnVtKGxvZ0xldmVsKTtcbiAgY29uc3QgY29uZmlnTGV2ZWwgPSBsb2dMZXZlbFN0cmluZ1RvRW51bShjb25maWdMb2dMZXZlbCk7XG4gIGlmIChtZXNzYWdlTGV2ZWwgPj0gY29uZmlnTGV2ZWwpIHtcbiAgICBkb0xvZyhtZXNzYWdlTGV2ZWwsIHR5cGVvZiBtc2cgPT09ICdmdW5jdGlvbicgPyBtc2coKSA6IG1zZyk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBzaW1wbGUgbG9nZ2luZyB1dGlsaXR5IHRvIGxvZyBtZXNzYWdlcyB0byB0aGUgY29uc29sZS4gT25seSBsb2dzIHdoZW4gZGVidWcgaXMgZW5hYmxlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IExPR19ERUJVRzogdHlwZW9mIExPRyA9ICguLi5hcmdzOiBQYXJhbWV0ZXJzPHR5cGVvZiBMT0c+KSA9PiB7XG4gIGlmIChkZWJ1Zykge1xuICAgIExPRyguLi5hcmdzKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuZXhwb3J0IGNsYXNzIE1hdE11bFV0aWwge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZSB3aGVuIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgKiBAcGFyYW0gYSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhIHR1cGxlIG9mIDIgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHBhcmFtIGIgVGhlIHNoYXBlIG9mIHRlbnNvciBCLiBTaG91bGQgYmUgYSB0dXBsZSBvZiAyIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXG4gICAqL1xuICBzdGF0aWMgY2FsY01hdE11bFNoYXBlKGE6IFtudW1iZXIsIG51bWJlcl0sIGI6IFtudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXJdIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gYVsxXSAhPT0gYlswXSA/IHVuZGVmaW5lZCA6IFthWzBdLCBiWzFdXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQnJvYWRjYXN0VXRpbCB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlIHdoZW4gYnJvYWRjYXN0aW5nIDIgdGVuc29yc1xuICAgKiBAcGFyYW0gYSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gYiBUaGUgc2hhcGUgb2YgdGVuc29yIEIuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gaXNNYXRNdWwgV2hldGhlciB0aGUgb3BlcmF0aW9uIGlzIE1hdE11bFxuICAgKiBAcmV0dXJucyBUaGUgZXhwZWN0ZWQgc2hhcGUgb2YgdGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIGlmIE4vQVxuICAgKi9cbiAgc3RhdGljIGNhbGNTaGFwZShcbiAgICBhZGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgYmRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGlzTWF0TXVsID0gZmFsc2UsXG4gICk6IHJlYWRvbmx5IG51bWJlcltdIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBhcmFuayA9IGFkaW1zLmxlbmd0aDtcbiAgICBjb25zdCBicmFuayA9IGJkaW1zLmxlbmd0aDtcbiAgICBpZiAoYXJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBiZGltcztcbiAgICB9XG4gICAgaWYgKGJyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gYWRpbXM7XG4gICAgfVxuICAgIGNvbnN0IGNyYW5rID0gTWF0aC5tYXgoYWRpbXMubGVuZ3RoLCBiZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IGNkaW1zID0gbmV3IEFycmF5PG51bWJlcj4oY3JhbmspO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBsYXN0IDIgZGltZW5zaW9uIGlmIGl0IGlzIE1hdE11bFxuICAgIGlmIChpc01hdE11bCkge1xuICAgICAgaWYgKGFyYW5rIDwgMiB8fCBicmFuayA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNTaGFwZU1hdE11bCA9IE1hdE11bFV0aWwuY2FsY01hdE11bFNoYXBlKFxuICAgICAgICBbYWRpbXNbYXJhbmsgLSAyXSwgYWRpbXNbYXJhbmsgLSAxXV0sXG4gICAgICAgIFtiZGltc1ticmFuayAtIDJdLCBiZGltc1ticmFuayAtIDFdXSxcbiAgICAgICk7XG4gICAgICBpZiAoY1NoYXBlTWF0TXVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIFtjZGltc1tjcmFuayAtIDJdLCBjZGltc1tjcmFuayAtIDFdXSA9IGNTaGFwZU1hdE11bDtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gaXNNYXRNdWwgPyAzIDogMTsgaSA8PSBjcmFuazsgaSsrKSB7XG4gICAgICBjb25zdCBhTGVuID0gYXJhbmsgLSBpIDwgMCA/IDEgOiBhZGltc1thcmFuayAtIGldO1xuICAgICAgY29uc3QgYkxlbiA9IGJyYW5rIC0gaSA8IDAgPyAxIDogYmRpbXNbYnJhbmsgLSBpXTtcblxuICAgICAgaWYgKGFMZW4gIT09IGJMZW4gJiYgYUxlbiA+IDEgJiYgYkxlbiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGFMZW4sIGJMZW4pO1xuICAgICAgaWYgKGFMZW4gJiYgYkxlbikge1xuICAgICAgICBjZGltc1tjcmFuayAtIGldID0gTWF0aC5tYXgoYUxlbiwgYkxlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3aGVuIGVpdGhlciBhTGVuIG9yIGJMZW4gaXMgMCwgdGhlIG90aGVyIHNob3VsZCBiZSBlaXRoZXIgMCBvciAxLCBvdGhlcndpc2UgaXQgaXMgbm90IGJyb2FkY2FzdGFibGUuXG4gICAgICAgIGlmIChtYXggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjZGltc1tjcmFuayAtIGldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2RpbXM7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgc2hhcGUgaXMgdW5pZGlyZWN0aW9uYWwgYnJvYWRjYXN0YWJsZSB0byBhbm90aGVyIHNoYXBlXG4gICAqIEBwYXJhbSBzaGFwZSBUaGUgaW5wdXQgc2hhcGVcbiAgICogQHBhcmFtIGZpbmFsU2hhcGUgVGhlIGRlc2lyZWQgc2hhcGUgYWZ0ZXIgYnJvYWRjYXN0aW5nXG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZEJyb2FkY2FzdChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGZpbmFsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgLy8gYWxpZ24gc2hhcGUgdG8gdGhlIHJpZ2h0XG4gICAgY29uc3QgaW5wdXRSYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGZpbmFsUmFuayA9IGZpbmFsU2hhcGUubGVuZ3RoO1xuICAgIGlmIChpbnB1dFJhbmsgPiBmaW5hbFJhbmspIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gaW5wdXRSYW5rOyBpKyspIHtcbiAgICAgIGlmIChzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gMSAmJiBzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gZmluYWxTaGFwZVtmaW5hbFJhbmsgLSBpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaGFwZVV0aWwge1xuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzaXplIChudW1iZXIgb2YgZWxlbWVudHMpXG4gICAqL1xuICBzdGF0aWMgc2l6ZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGRpbXMubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IGRpbXMgY29ycmVzcG9uZGluZyB0byB0eXBlIGNoYW5nZSB0byBwYWNrLiBleC4gdWludDggZGF0YSB0byB1aW50MzJcbiAgICovXG4gIHN0YXRpYyBjb252ZXJ0U2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHNpemUgPSA0KTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBuZXdEaW1zID0gbmV3IEFycmF5KHJhbmspO1xuICAgIGxldCBpID0gcmFuayAtIDE7XG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgaWYgKGRpbXNbaV0gJSBzaXplID09PSAwKSB7XG4gICAgICAgIG5ld0RpbXNbaV0gPSBkaW1zW2ldIC8gc2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2l6ZSAlIGRpbXNbaV0gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29udmVydCBzaGFwZScpO1xuICAgICAgfVxuICAgICAgbmV3RGltc1tpXSA9IDE7XG4gICAgICBzaXplIC89IGRpbXNbaV07XG4gICAgICBpLS07XG4gICAgfVxuICAgIGZvciAoaS0tOyBpID49IDA7IGktLSkge1xuICAgICAgbmV3RGltc1tpXSA9IGRpbXNbaV07XG4gICAgfVxuICAgIHJldHVybiBuZXdEaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKSBmcm9tIHRoZSBnaXZlbiBheGlzIChpbmNsdXNpdmUpXG4gICAqL1xuICBzdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24oZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPiBkaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke2F4aXN9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZGltcy5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7XG4gICAgfVxuICAgIHJldHVybiBTaGFwZVV0aWwuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zLCBheGlzLCBkaW1zLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzaXplIChudW1iZXIgb2YgZWxlbWVudHMpIHRvIHRoZSBnaXZlbiBheGlzIChleGNsdXNpdmUpXG4gICAqL1xuICBzdGF0aWMgc2l6ZVRvRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgMCB8fCBheGlzID4gZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtheGlzfSBmb3Igc2l6ZVRvRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtkaW1zLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGF4aXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKSBmcm9tIGFuZCB0byB0aGUgZ2l2ZW4gYXhpcyBbc3RhcnQsIGVuZClcbiAgICovXG4gIHN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgbGV0IHNpemUgPSAxO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAvLyBzYWZldHkgY2hlY2sgYXMgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IG11bHRpcGxlIG90aGVyIG1ldGhvZHMgcmVxdWlyaW5nIHNpemUuXG4gICAgICAvLyBzaXplIGNhbm5vdCBiZSBuZWdhdGl2ZS5cbiAgICAgIGlmIChkaW1zW2ldIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgICAgICAnY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGVtLicsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzaXplICo9IE51bWJlcihkaW1zW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cblxuICBzdGF0aWMgY29tcHV0ZVN0cmlkZXMoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xuICAgIGlmIChyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChyYW5rID09PSAxKSB7XG4gICAgICByZXR1cm4gWzFdO1xuICAgIH1cbiAgICBjb25zdCBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmspO1xuICAgIHN0cmlkZXNbcmFuayAtIDFdID0gMTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IGRpbXNbcmFuayAtIDFdO1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHN0cmlkZXNbaV0gPSBzdHJpZGVzW2kgKyAxXSAqIGRpbXNbaSArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaWRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBub3JtYWxpemUgYXhpcyBvZiByYW5nZSBbLXIsIHIpIGludG8gWzAsIHIpLlxuICAgKi9cbiAgc3RhdGljIG5vcm1hbGl6ZUF4aXMoYXhpczogbnVtYmVyLCB0ZW5zb3JSYW5rOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgLXRlbnNvclJhbmsgJiYgYXhpcyA+PSB0ZW5zb3JSYW5rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLicpO1xuICAgIH1cbiAgICByZXR1cm4gYXhpcyA8IDAgPyBheGlzICsgdGVuc29yUmFuayA6IGF4aXM7XG4gIH1cblxuICBzdGF0aWMgbm9ybWFsaXplQXhlcyhheGVzOiByZWFkb25seSBudW1iZXJbXSwgdGVuc29yUmFuaz86IG51bWJlcik6IG51bWJlcltdIHtcbiAgICByZXR1cm4gYXhlcy5tYXAoKHgpID0+IHRoaXMubm9ybWFsaXplQXhpcyh4LCB0ZW5zb3JSYW5rID8/IGF4ZXMubGVuZ3RoKSk7XG4gIH1cblxuICAvKipcbiAgICogU29ydHMgYSBnaXZlbiBhcnJheSBiYXNlZCBvbiB0aGUgaW5kaWNlcyBpbiB0aGUgUGVybSBhcnJheVxuICAgKiBVc2VkIGluIFRyYW5zcG9zZVxuICAgKiBAcGFyYW0gYSBBcnJheSB0byBiZSBzb3J0ZWQgc3VjaCBhcyBkaW1zIG9yIHN0cmlkZXNcbiAgICogQHBhcmFtIHBlcm0gUGVybSBnaXZlbjsgaWYgbnVsbCBhIHdpbGwgYmUgcmV2ZXJzZWRcbiAgICovXG4gIHN0YXRpYyBzb3J0QmFzZWRPblBlcm0oYTogcmVhZG9ubHkgbnVtYmVyW10sIHBlcm0/OiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBpZiAocGVybSkge1xuICAgICAgcmV0dXJuIHBlcm0ubWFwKCh2KSA9PiBhW3ZdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGEuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhZHMgYSBnaXZlbiBzaGFwZSBhY2NvcmRpbmcgdG8gdGhlIHBhZGRpbmcgdmFsdWVzXG4gICAqIEBwYXJhbSBkaW1zIHNoYXBlIG9mIHRoZSBUZW5zb3IgdG8gYmUgcGFkZGVkXG4gICAqIEBwYXJhbSBwYWQgcGFkIHZhbHVlc1xuICAgKi9cbiAgc3RhdGljIHBhZFNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBwYWQ6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICByZXR1cm4gZGltcy5tYXAoKHYsIGkpID0+IHYgKyBwYWRbaV0gKyBwYWRbaSArIHJhbmtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSB0d28gc2hhcGVzIGFyZSBpZGVudGljYWxcbiAgICogQHBhcmFtIHNoYXBlMVxuICAgKiBAcGFyYW0gc2hhcGUyXG4gICAqL1xuICBzdGF0aWMgYXJlRXF1YWwoc2hhcGUxOiByZWFkb25seSBudW1iZXJbXSwgc2hhcGUyOiByZWFkb25seSBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChzaGFwZTEubGVuZ3RoICE9PSBzaGFwZTIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzaGFwZTEuZXZlcnkoKHYsIGkpID0+IHYgPT09IHNoYXBlMltpXSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFBvb2xDb252VXRpbCB7XG4gIC8qKlxuICAgKiBBZGp1c3QgdGhlIGtlcm5lbCwgc3RyaWRlcywgcGFkcyB0byBjb3JyZWN0IHJhbmsuIFNldCB0byBkZWZhdWx0IHZhbHVlIGlmIG5vdCBwcmVzZW50XG4gICAqIEBwYXJhbSBpc0dsb2JhbE9wZXJhdG9yIElmIHRydWUsIHBlcmZvcm0gZ2xvYmFsIHBvb2xpbmcuXG4gICAqIEBwYXJhbSBpbnB1dERpbXMgVGhlIGlucHV0IHRlbnNvciBkaW1lbnNpb24uXG4gICAqIEBwYXJhbSBrZXJuZWxTaGFwZSBUaGUgc2l6ZSBvZiB0aGUga2VybmVsIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIHN0cmlkZXMgU3RyaWRlIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGRpbGF0aW9ucyBEaWxhdGlvbiBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXG4gICAqL1xuICBzdGF0aWMgYWRqdXN0UG9vbEF0dHJpYnV0ZXMoXG4gICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGtlcm5lbFNoYXBlOiBudW1iZXJbXSxcbiAgICBzdHJpZGVzOiBudW1iZXJbXSxcbiAgICBkaWxhdGlvbnM6IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICApOiB2b2lkIHtcbiAgICBpZiAoIWlzR2xvYmFsT3BlcmF0b3IgJiYga2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dERpbXMubGVuZ3RoIC0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2Ygc3BlY2lmaWVkIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIDIgbGVzcyB0aGFuIGxlbmd0aCBvZiBpbnB1dCBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzR2xvYmFsT3BlcmF0b3IpIHtcbiAgICAgIC8vIGFkanVzdCBrZXJuZWwgc2hhcGUgdG8gY292ZXIgdGhlIGlucHV0IGRpbXNcbiAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgICBpZiAoZGltID49IGtlcm5lbFNoYXBlLmxlbmd0aCkge1xuICAgICAgICAgIGtlcm5lbFNoYXBlLnB1c2goaW5wdXREaW1zW2RpbSArIDJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXJuZWxTaGFwZVtkaW1dID0gaW5wdXREaW1zW2RpbSArIDJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IHN0cmlkZXMgbGVuZ3RoIHRvIG1hdGNoIGtlcm5lbCBzaGFwZSBsZW5ndGhcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGg7IGRpbSsrKSB7XG4gICAgICBpZiAoZGltIDwgc3RyaWRlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHN0cmlkZXNbZGltXSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmlkZXMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmlkZXMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGp1c3QgZGlsYXRpb24gdmFsdWVcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGg7IGRpbSsrKSB7XG4gICAgICBpZiAoZGltIDwgZGlsYXRpb25zLmxlbmd0aCkge1xuICAgICAgICBpZiAoZGlsYXRpb25zW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpbGF0aW9ucy5wdXNoKDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkanVzdCBwYWRzIGxlbmd0aCB0byBtYXRjaCAyICoga2VybmVsIHNoYXBlIGxlbmd0aFxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aCAqIDI7IGRpbSsrKSB7XG4gICAgICBpZiAoZGltIDwgcGFkcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHBhZHNbZGltXSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFkcy5wdXNoKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhbml0eSBjaGVja3MgZm9yIHZhbHVlcyBpbiBrZXJuZWwgc2hhcGVzIGFuZCBwYWRzXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGtlcm5lbFNoYXBlW2RpbV0gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFkc1tkaW1dID49IGtlcm5lbFNoYXBlW2RpbV0gfHwgcGFkc1tkaW0gKyBrZXJuZWxTaGFwZS5sZW5ndGhdID49IGtlcm5lbFNoYXBlW2RpbV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRzIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4ga2VybmVsJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRqdXN0IHBhZCB2YWx1ZXMgYmFzZWQgb24gJ2F1dG9QYWQnIGF0dHJpYnV0ZVxuICBzdGF0aWMgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKFxuICAgIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgcGFkczogbnVtYmVyW10sXG4gICAgaXNDaGFubmVsTGFzdDogYm9vbGVhbixcbiAgICBhdXRvUGFkPzogc3RyaW5nLFxuICApOiB2b2lkIHtcbiAgICBpZiAoIWF1dG9QYWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGFkcy5sZW5ndGggIT09IDIgKiAoaW5wdXREaW1zLmxlbmd0aCAtIDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChzdHJpZGVzLmxlbmd0aCAhPT0gaW5wdXREaW1zLmxlbmd0aCAtIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHN0cmlkZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKGtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXREaW1zLmxlbmd0aCAtIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICBQb29sQ29udlV0aWwuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXG4gICAgICAgIGlucHV0RGltc1tkaW0gKyAoaXNDaGFubmVsTGFzdCA/IDEgOiAyKV0sXG4gICAgICAgIHN0cmlkZXNbZGltXSxcbiAgICAgICAgZGlsYXRpb25zW2RpbV0sXG4gICAgICAgIGtlcm5lbFNoYXBlW2RpbV0sXG4gICAgICAgIHBhZHMsXG4gICAgICAgIGRpbSxcbiAgICAgICAgZGltICsgaW5wdXREaW1zLmxlbmd0aCAtIDIsXG4gICAgICAgIGF1dG9QYWQsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG91dHB1dCBzaGFwZSBmb3IgUG9vbCBvcHMgYmFzZWQgb24gaW5wdXQgYXR0cmlidXRlcy4gKFNob3VsZCBiZSB1c2VkIG9ubHkgZm9yIFBvb2wgb3BzKVxuICAgKiBAcGFyYW0gaXNHbG9iYWxPcGVyYXRvciBJZiB0cnVlLCBwZXJmb3JtIGdsb2JhbCBwb29saW5nLlxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLiAoaW5wdXRzWzBdLmRpbXMpXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBkaWxhdGlvbnMgRGlsYXRpb24gYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBhdXRvUGFkIERFUFJFQ0FURUQgYXR0cmlidXRlIHN1cHBvcnRlZCBmb3IgbGVnYWN5IG1vZGVscy4gU3BlY2lmaWVzIGhvdyB0byBpbXBsaWNpdGx5IGNhbGN1bGF0ZSBwYWRzIGluIGVhY2hcbiAgICogICAgIGRpbWVuc2lvbi4gQ2FuIHRha2UgdmFsdWVzIE5PVFNFVCwgU0FNRV9VUFBFUiwgU0FNRV9MT1dFUiwgb3IgVkFMSUQuXG4gICAqL1xuICBzdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShcbiAgICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLFxuICAgIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgc3RyaWRlczogbnVtYmVyW10sXG4gICAgZGlsYXRpb25zOiBudW1iZXJbXSxcbiAgICBrZXJuZWxTaGFwZTogbnVtYmVyW10sXG4gICAgcGFkczogbnVtYmVyW10sXG4gICAgYXV0b1BhZD86IHN0cmluZyxcbiAgKTogbnVtYmVyW10ge1xuICAgIGlmIChpbnB1dERpbXMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hhcGUgbXVzdCBiZSBvZiBzaXplIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJhdGNoIHNpemUgYW5kIG51bWJlciBvZiBjaGFubmVscyBvZiBvdXRwdXRcbiAgICBjb25zdCBvdXRwdXREaW1zID0gW2lucHV0RGltc1swXSwgaW5wdXREaW1zWzFdXTtcblxuICAgIFBvb2xDb252VXRpbC5jb21wdXRlU2hhcGVIZWxwZXIoXG4gICAgICBpc0dsb2JhbE9wZXJhdG9yLFxuICAgICAgaW5wdXREaW1zLFxuICAgICAgb3V0cHV0RGltcyxcbiAgICAgIHN0cmlkZXMsXG4gICAgICBkaWxhdGlvbnMsXG4gICAgICBrZXJuZWxTaGFwZSxcbiAgICAgIHBhZHMsXG4gICAgICBhdXRvUGFkLFxuICAgICk7XG4gICAgcmV0dXJuIG91dHB1dERpbXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIENvbnYgb3AgYmFzZWQgb24gaW5wdXQgYXR0cmlidXRlcy4gKFNob3VsZCBiZSB1c2VkIG9ubHkgZm9yIENvbnYgb3ApXG4gICAqIEBwYXJhbSBpbnB1dERpbXMgVGhlIGlucHV0IHRlbnNvciBkaW1lbnNpb24uIChpbnB1dHNbMF0uZGltcylcbiAgICogQHBhcmFtIGZpbHRlckRpbXMgVGhlIGZpbHRlciB0ZW5zb3IgZGltZW5zaW9uLiAoaW5wdXRzWzFdLmRpbXMpXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBrZXJuZWxTaGFwZSBUaGUgc2l6ZSBvZiB0aGUga2VybmVsIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIHBhZHMgUGFkZGluZyBmb3IgdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGF1dG9QYWQgREVQUkVDQVRFRCBhdHRyaWJ1dGUgc3VwcG9ydGVkIGZvciBsZWdhY3kgbW9kZWxzLiBTcGVjaWZpZXMgaG93IHRvIGltcGxpY2l0bHkgY2FsY3VsYXRlIHBhZHMgaW4gZWFjaFxuICAgKiAgICAgZGltZW5zaW9uLiBDYW4gdGFrZSB2YWx1ZXMgTk9UU0VULCBTQU1FX1VQUEVSLCBTQU1FX0xPV0VSLCBvciBWQUxJRC5cbiAgICovXG4gIHN0YXRpYyBjb21wdXRlQ29udk91dHB1dFNoYXBlKFxuICAgIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgZmlsdGVyRGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgc3RyaWRlczogbnVtYmVyW10sXG4gICAgZGlsYXRpb25zOiBudW1iZXJbXSxcbiAgICBrZXJuZWxTaGFwZTogbnVtYmVyW10sXG4gICAgcGFkczogbnVtYmVyW10sXG4gICAgYXV0b1BhZD86IHN0cmluZyxcbiAgKTogbnVtYmVyW10ge1xuICAgIGlmIChpbnB1dERpbXMubGVuZ3RoIDw9IDAgfHwgZmlsdGVyRGltcy5sZW5ndGggPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlucHV0IHRlbnNvciBkaW1zIG9yIGludmFsaWQgZmlsdGVyIHRlbnNvciBkaW1zJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJhdGNoIHNpemUgYW5kIG51bWJlciBvZiBjaGFubmVscyBvZiBvdXRwdXRcbiAgICBjb25zdCBvdXRwdXREaW1zID0gW2lucHV0RGltc1swXSwgZmlsdGVyRGltc1swXV07XG5cbiAgICBQb29sQ29udlV0aWwuY29tcHV0ZVNoYXBlSGVscGVyKGZhbHNlLCBpbnB1dERpbXMsIG91dHB1dERpbXMsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGUsIHBhZHMsIGF1dG9QYWQpO1xuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLy8gd2lsbCBjb21wdXRlIG91dHB1dCBzaGFwZXMgZm9yIGRhdGEgZGltZW5zaW9ucyBPTkxZIChpLmUuKSBubyBiYXRjaCBzaXplIGFuZCBjaGFubmVsc1xuICAvLyBjYWxsZWQgYnkgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSgpIGFuZCBjb21wdXRlQ29udk91dHB1dFNoYXBlKClcbiAgLy8gYWRqdXN0IHBhZHMgYmFzZWQgb24gJ2F1dG9QYWQnIGF0dHJpYnV0ZSBwcmlvciB0byBzaGFwZSBjb21wdXRhdGlvblxuICBwcml2YXRlIHN0YXRpYyBjb21wdXRlU2hhcGVIZWxwZXIoXG4gICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIG91dHB1dERpbXM6IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGF1dG9QYWQ/OiBzdHJpbmcsXG4gICkge1xuICAgIGlmIChpc0dsb2JhbE9wZXJhdG9yKSB7XG4gICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgICAgb3V0cHV0RGltcy5wdXNoKDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgICAgb3V0cHV0RGltcy5wdXNoKFxuICAgICAgICAgIFBvb2xDb252VXRpbC5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShcbiAgICAgICAgICAgIGlucHV0RGltc1tkaW0gKyAyXSxcbiAgICAgICAgICAgIHN0cmlkZXNbZGltXSxcbiAgICAgICAgICAgIGRpbGF0aW9uc1tkaW1dLFxuICAgICAgICAgICAga2VybmVsU2hhcGVbZGltXSxcbiAgICAgICAgICAgIHBhZHMsXG4gICAgICAgICAgICBkaW0sXG4gICAgICAgICAgICBkaW0gKyBpbnB1dERpbXMubGVuZ3RoIC0gMixcbiAgICAgICAgICAgIGF1dG9QYWQsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBoZWxwZXIgZm9yIGNvbXB1dGVTaGFwZUhlbHBlcigpIGFuZCBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoKVxuICAvLyBhZGp1c3RzIHBhZCB2YWx1ZSBmb3IgZ2l2ZW4gJ2F1dG9QYWQnIHN0cmluZyBhbmQgY29tcHV0ZXMgb3V0cHV0IHNoYXBlIGFsb25nIGEgcGFydGljdWxhciBkaW1lbnNpb25cbiAgcHJpdmF0ZSBzdGF0aWMgYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXG4gICAgaW5TaXplOiBudW1iZXIsXG4gICAgc3RyaWRlOiBudW1iZXIsXG4gICAgZGlsYXRpb246IG51bWJlcixcbiAgICBrZXJuZWw6IG51bWJlcixcbiAgICBwYWRzOiBudW1iZXJbXSxcbiAgICBwYWRIZWFkSW5kZXg6IG51bWJlcixcbiAgICBwYWRUYWlsSW5kZXg6IG51bWJlcixcbiAgICBhdXRvUGFkPzogc3RyaW5nLFxuICApOiBudW1iZXIge1xuICAgIGNvbnN0IGRrZXJuZWwgPSBkaWxhdGlvbiAqIChrZXJuZWwgLSAxKSArIDE7XG4gICAgaWYgKGF1dG9QYWQgJiYgYXV0b1BhZCAhPT0gJ05PVFNFVCcpIHtcbiAgICAgIHN3aXRjaCAoYXV0b1BhZCkge1xuICAgICAgICBjYXNlICdWQUxJRCc6XG4gICAgICAgICAgcGFkc1twYWRIZWFkSW5kZXhdID0gMDtcbiAgICAgICAgICBwYWRzW3BhZFRhaWxJbmRleF0gPSAwO1xuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgLSBka2VybmVsKSAvIHN0cmlkZSArIDEpO1xuICAgICAgICBjYXNlICdTQU1FX0xPV0VSJzpcbiAgICAgICAgY2FzZSAnU0FNRV9VUFBFUic6XG4gICAgICAgICAgaWYgKGRpbGF0aW9uICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbGF0aW9uIG5vdCBzdXBwb3J0ZWQgZm9yIFNBTUVfVVBQRVIgb3IgU0FNRV9MT1dFUicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsZWdhY3lUYXJnZXRTaXplID0gKGluU2l6ZSArIHN0cmlkZSAtIDEpIC8gc3RyaWRlO1xuICAgICAgICAgICAgY29uc3QgcGFkTmVlZGVkID0gKGxlZ2FjeVRhcmdldFNpemUgLSAxKSAqIHN0cmlkZSArIGtlcm5lbCAtIGluU2l6ZTtcbiAgICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9IGF1dG9QYWQgPT09ICdTQU1FX0xPV0VSJyA/IE1hdGguZmxvb3IoKHBhZE5lZWRlZCArIDEpIC8gMikgOiBNYXRoLmZsb29yKHBhZE5lZWRlZCAvIDIpO1xuICAgICAgICAgICAgcGFkc1twYWRUYWlsSW5kZXhdID0gcGFkTmVlZGVkIC0gcGFkc1twYWRIZWFkSW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGluU2l6ZSArIHBhZE5lZWRlZCAtIGtlcm5lbCkgLyBzdHJpZGUgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGluU2l6ZSArIHBhZHNbcGFkSGVhZEluZGV4XSArIHBhZHNbcGFkVGFpbEluZGV4XSAtIGRrZXJuZWwpIC8gc3RyaWRlICsgMSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHZW1tVXRpbCB7XG4gIC8vIHdpbGwgbWFrZSBzdXJlIGlucHV0IHNoYXBlcyBhcmUgY29tcGF0aWJsZSBmb3IgdGhpcyBvcFxuICAvLyBhbmQgcmV0dXJuIGJhY2sgdGhlIHNoYXBlIG9mIHRoZSBvdXRwdXQgaW4gdGhlIGZvcm0gb2YgYSB0dXBsZVxuICAvLyB3aWxsIHRocm93IGV4Y2VwdGlvbiBpZiB0aGUgaW5wdXQgc2hhcGVzIGFyZSBub3QgY29tcGF0aWJsZVxuICBzdGF0aWMgZ2V0U2hhcGVPZkdlbW1SZXN1bHQoXG4gICAgbGVmdFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICB0cmFuc0xlZnQ6IGJvb2xlYW4sXG4gICAgcmlnaHRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgdHJhbnNSaWdodDogYm9vbGVhbixcbiAgICBiaWFzU2hhcGU/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGlmIChsZWZ0U2hhcGUubGVuZ3RoICE9PSAyIHx8IHJpZ2h0U2hhcGUubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXBlIG5lZWQgdG8gYmUgb2Ygc2l6ZSAyJyk7XG4gICAgfVxuXG4gICAgbGV0IE06IG51bWJlcjtcbiAgICBsZXQgSzogbnVtYmVyO1xuICAgIGxldCBOOiBudW1iZXI7XG5cbiAgICBpZiAodHJhbnNMZWZ0KSB7XG4gICAgICBNID0gbGVmdFNoYXBlWzFdO1xuICAgICAgSyA9IGxlZnRTaGFwZVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgTSA9IGxlZnRTaGFwZVswXTtcbiAgICAgIEsgPSBsZWZ0U2hhcGVbMV07XG4gICAgfVxuXG4gICAgbGV0IGtEaW0gPSAtMTtcblxuICAgIGlmICh0cmFuc1JpZ2h0KSB7XG4gICAgICBOID0gcmlnaHRTaGFwZVswXTtcbiAgICAgIGtEaW0gPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBOID0gcmlnaHRTaGFwZVsxXTtcbiAgICAgIGtEaW0gPSAwO1xuICAgIH1cblxuICAgIGlmIChyaWdodFNoYXBlW2tEaW1dICE9PSBLKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpbWVuc2lvbiBtaXNtYXRjaCcpO1xuICAgIH1cblxuICAgIGlmIChNIDw9IDAgfHwgTiA8PSAwIHx8IEsgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNoYXBlIHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIGlmIChiaWFzU2hhcGUgJiYgIUJyb2FkY2FzdFV0aWwuaXNWYWxpZEJyb2FkY2FzdChiaWFzU2hhcGUsIFtNLCBOXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2VtbTogaW52YWxpZCBiaWFzIHNoYXBlIGZvciBicm9hZGNhc3QnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW00sIE4sIEtdO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBNSU5fQ0xJUCA9IC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzg7XG5leHBvcnQgY29uc3QgTUFYX0NMSVAgPSAzLjQwMjgyMzQ2NjM4NTI4ODZlMzg7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3RvciB9IGZyb20gJy4uL3dhc20tY29tbW9uJztcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoXG4gIGRhdGFCdWZmZXI6IEFycmF5QnVmZmVyLFxuICB0eXBlOiBUZW5zb3IuVHlwZSxcbik6XG4gIHwgSW50MzJBcnJheVxuICB8IFVpbnQzMkFycmF5XG4gIHwgQmlnSW50NjRBcnJheVxuICB8IEJpZ1VpbnQ2NEFycmF5XG4gIHwgVWludDhBcnJheVxuICB8IEZsb2F0MzJBcnJheVxuICB8IEZsb2F0NjRBcnJheVxuICB8IEludDhBcnJheVxuICB8IEludDE2QXJyYXlcbiAgfCBVaW50MTZBcnJheSA9PiBuZXcgKHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0eXBlKSkoZGF0YUJ1ZmZlcik7XG5cbi8qKlxuICogYSBUZW5zb3JWaWV3IGRvZXMgbm90IG93biB0aGUgZGF0YS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JWaWV3IHtcbiAgcmVhZG9ubHkgZGF0YTogbnVtYmVyO1xuICByZWFkb25seSBkYXRhVHlwZTogbnVtYmVyO1xuICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcblxuICAvKipcbiAgICogZ2V0IGEgRmxvYXQxNkFycmF5IGRhdGEgdmlldyBvZiB0aGUgdGVuc29yIGRhdGEuIHRlbnNvciBkYXRhIG11c3QgYmUgb24gQ1BVLlxuICAgKi9cbiAgZ2V0VWludDE2QXJyYXkoKTogVWludDE2QXJyYXk7XG5cbiAgLyoqXG4gICAqIGdldCBhIEZsb2F0MzJBcnJheSBkYXRhIHZpZXcgb2YgdGhlIHRlbnNvciBkYXRhLiB0ZW5zb3IgZGF0YSBtdXN0IGJlIG9uIENQVS5cbiAgICovXG4gIGdldEZsb2F0MzJBcnJheSgpOiBGbG9hdDMyQXJyYXk7XG5cbiAgLyoqXG4gICAqIGdldCBhIEJpZ0ludDY0QXJyYXkgZGF0YSB2aWV3IG9mIHRoZSB0ZW5zb3IgZGF0YS4gdGVuc29yIGRhdGEgbXVzdCBiZSBvbiBDUFUuXG4gICAqL1xuICBnZXRCaWdJbnQ2NEFycmF5KCk6IEJpZ0ludDY0QXJyYXk7XG5cbiAgLyoqXG4gICAqIGdldCBhIEludDMyQXJyYXkgZGF0YSB2aWV3IG9mIHRoZSB0ZW5zb3IgZGF0YS4gdGVuc29yIGRhdGEgbXVzdCBiZSBvbiBDUFUuXG4gICAqL1xuICBnZXRJbnQzMkFycmF5KCk6IEludDMyQXJyYXk7XG5cbiAgLyoqXG4gICAqIGdldCBhIFVpbnQxNkFycmF5IGRhdGEgdmlldyBvZiB0aGUgdGVuc29yIGRhdGEuIHRlbnNvciBkYXRhIG11c3QgYmUgb24gQ1BVLlxuICAgKi9cbiAgZ2V0VWludDE2QXJyYXkoKTogVWludDE2QXJyYXk7XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIG5ldyB0ZW5zb3IgdmlldyB3aXRoIHRoZSBzYW1lIGRhdGEgYnV0IGRpZmZlcmVudCBkaW1lbnNpb25zLlxuICAgKi9cbiAgcmVzaGFwZShuZXdEaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvclZpZXc7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFdlYk5OQmFja2VuZCB9IGZyb20gJy4uL2JhY2tlbmQtd2Vibm4nO1xuaW1wb3J0IHsgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yIH0gZnJvbSAnLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgTE9HX0RFQlVHIH0gZnJvbSAnLi4vbG9nJztcblxuLy8gV2ViTk4gQVBJIGN1cnJlbnRseSBkb2VzIG5vdCBoYXZlIGEgVHlwZVNjcmlwdCBkZWZpbml0aW9uIGZpbGUuIFRoaXMgZmlsZSBpcyBhIHdvcmthcm91bmQgd2l0aCB0eXBlcyBnZW5lcmF0ZWQgZnJvbVxuLy8gV2ViTk4gQVBJIHNwZWNpZmljYXRpb24uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VibWFjaGluZWxlYXJuaW5nL3dlYm5uL2lzc3Vlcy82Nzdcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJ3ZWJubi5kLnRzXCIgLz5cblxuLyoqXG4gKiBNYXAgZnJvbSBNTE9wZXJhbmREYXRhVHlwZSB0byBzaXplIGluIGJpdHMuIFVzaW5nIGJpdHMgaW5zdGVhZCBvZiBieXRlcyB0byBhdm9pZCBwb3NzaWJsZSBwcmVjaXNpb24gbG9zcyBvbiBpbnQ0IGFuZCB1aW50NC5cbiAqL1xuY29uc3Qgd2Vibm5EYXRhVHlwZVRvU2l6ZSA9IG5ldyBNYXA8TUxPcGVyYW5kRGF0YVR5cGUsIG51bWJlcj4oW1xuICBbJ2Zsb2F0MzInLCAzMl0sXG4gIFsnZmxvYXQxNicsIDE2XSxcbiAgWydpbnQzMicsIDMyXSxcbiAgWyd1aW50MzInLCAzMl0sXG4gIFsnaW50NjQnLCA2NF0sXG4gIFsndWludDY0JywgNjRdLFxuICBbJ2ludDgnLCA4XSxcbiAgWyd1aW50OCcsIDhdLFxuICBbJ2ludDQnLCA0XSxcbiAgWyd1aW50NCcsIDRdLFxuXSk7XG5cbi8vIENvbnZlcnQgaW50ZWdlciBkYXRhIHRvIGFuIEludDMyQXJyYXkgYnVmZmVyLlxuLy8gU3VwcG9ydHMgY29udmVyc2lvbiBmcm9tIGludDY0LCB1aW50NjQsIHVpbnQzMiwgaW50OCBhbmQgdWludDggdG8gaW50MzIuXG5leHBvcnQgY29uc3QgY29udmVydERhdGFUb0ludDMyID0gKGRhdGE6IFVpbnQ4QXJyYXksIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSk6IFVpbnQ4QXJyYXkgPT4ge1xuICBpZiAoZGF0YVR5cGUgPT09ICdpbnQzMicpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGNvbnN0IGRhdGFUeXBlU2l6ZSA9IHdlYm5uRGF0YVR5cGVUb1NpemUuZ2V0KGRhdGFUeXBlKTtcbiAgaWYgKCFkYXRhVHlwZVNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFdlYk5OIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBkYXRhIHR5cGU6ICR7ZGF0YVR5cGV9YCk7XG4gIH1cbiAgY29uc3QgYnl0ZXNQZXJFbGVtZW50ID0gZGF0YVR5cGVTaXplIC8gODtcbiAgLy8gTWFrZSBzdXJlIHRoZSBkYXRhIGxlbmd0aCBpcyBhIG11bHRpcGxlIG9mIHRoZSBkYXRhIHR5cGUgc2l6ZS5cbiAgaWYgKGRhdGEuYnl0ZUxlbmd0aCAlIGJ5dGVzUGVyRWxlbWVudCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVaW50OEFycmF5IGxlbmd0aCAtIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke2J5dGVzUGVyRWxlbWVudH0uYCk7XG4gIH1cblxuICAvLyBDb252ZXJ0IFVpbnQ4QXJyYXkgdG8gb3JpZ2luYWwgdHlwZWQgYXJyYXkuXG4gIGNvbnN0IG51bUVsZW1lbnRzID0gZGF0YS5ieXRlTGVuZ3RoIC8gYnl0ZXNQZXJFbGVtZW50O1xuICBjb25zdCBvcmlnaW5hbEFycmF5ID0gbmV3ICh0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YVR5cGUpKShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBudW1FbGVtZW50cyk7XG5cbiAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgIGNhc2UgJ2ludDY0JzpcbiAgICBjYXNlICd1aW50NjQnOiB7XG4gICAgICAvLyBDb252ZXJ0IG9yaWdpbmFsIHR5cGVkIGFycmF5IHRvIEludDMyQXJyYXkuXG4gICAgICBjb25zdCBpbnQzMkFycmF5ID0gbmV3IEludDMyQXJyYXkobnVtRWxlbWVudHMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1FbGVtZW50czsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb3JpZ2luYWxBcnJheVtpXTtcblxuICAgICAgICAvLyBDaGVjayBmb3Igb3ZlcmZsb3cuXG4gICAgICAgIGlmICh2YWx1ZSA+IDIxNDc0ODM2NDduIHx8IHZhbHVlIDwgLTIxNDc0ODM2NDhuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IGNvbnZlcnQgaW50NjQgZGF0YSB0byBpbnQzMiAtIHZhbHVlIG91dCBvZiByYW5nZS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGludDMyQXJyYXlbaV0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaW50MzJBcnJheS5idWZmZXIpO1xuICAgIH1cbiAgICBjYXNlICdpbnQ4JzpcbiAgICBjYXNlICd1aW50OCc6XG4gICAgY2FzZSAndWludDMyJzoge1xuICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJmbG93LlxuICAgICAgaWYgKGRhdGFUeXBlID09PSAndWludDMyJykge1xuICAgICAgICBpZiAob3JpZ2luYWxBcnJheS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUgPiAyMTQ3NDgzNjQ3KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCBjb252ZXJ0IHVpbnQzMiBkYXRhIHRvIGludDMyIC0gdmFsdWUgb3V0IG9mIHJhbmdlLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDb252ZXJ0IG9yaWdpbmFsIHR5cGVkIGFycmF5IHRvIEludDMyQXJyYXkuXG4gICAgICBjb25zdCBpbnQzMkFycmF5ID0gSW50MzJBcnJheS5mcm9tKG9yaWdpbmFsQXJyYXksIE51bWJlcik7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaW50MzJBcnJheS5idWZmZXIpO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIGNvbnZlcnNpb24gZnJvbSAke2RhdGFUeXBlfSB0byAnaW50MzInYCk7XG4gIH1cbn07XG5cbi8vIENvbnZlcnQgSW50MzJBcnJheSBkYXRhIHRvIG9yaWdpbmFsIGludGVnZXIgZGF0YSBidWZmZXIuXG4vLyBTdXBwb3J0cyBjb252ZXJzaW9uIGZyb20gaW50MzIgdG8gaW50NjQsIHVpbnQ2NCwgdWludDMyLCBpbnQ4IGFuZCB1aW50OC5cbmV4cG9ydCBjb25zdCBjb252ZXJ0SW50MzJUb0RhdGEgPSAoZGF0YTogVWludDhBcnJheSwgZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlKTogVWludDhBcnJheSA9PiB7XG4gIGlmIChkYXRhVHlwZSA9PT0gJ2ludDMyJykge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSBkYXRhIGxlbmd0aCBpcyBhIG11bHRpcGxlIG9mIDQgYnl0ZXMgKEludDMyQXJyYXkpLlxuICBpZiAoZGF0YS5ieXRlTGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBVaW50OEFycmF5IGxlbmd0aCAtIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0IChpbnQzMikuJyk7XG4gIH1cblxuICAvLyBDb252ZXJ0IFVpbnQ4QXJyYXkgdG8gSW50MzJBcnJheS5cbiAgY29uc3QgbnVtRWxlbWVudHMgPSBkYXRhLmJ5dGVMZW5ndGggLyA0O1xuICBjb25zdCBpbnQzMkFycmF5ID0gbmV3IEludDMyQXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgbnVtRWxlbWVudHMpO1xuXG4gIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICBjYXNlICdpbnQ2NCc6IHtcbiAgICAgIGNvbnN0IGJpZ0ludDY0QXJyYXkgPSBCaWdJbnQ2NEFycmF5LmZyb20oaW50MzJBcnJheSwgQmlnSW50KTtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShiaWdJbnQ2NEFycmF5LmJ1ZmZlcik7XG4gICAgfVxuICAgIGNhc2UgJ3VpbnQ2NCc6IHtcbiAgICAgIGlmIChpbnQzMkFycmF5LnNvbWUoKHZhbHVlKSA9PiB2YWx1ZSA8IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBjb252ZXJ0IGludDMyIGRhdGEgdG8gdWluNjQgLSBuZWdhdGl2ZSB2YWx1ZSBmb3VuZC4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJpZ1VpbnQ2NEFycmF5ID0gQmlnVWludDY0QXJyYXkuZnJvbShpbnQzMkFycmF5LCBCaWdJbnQpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJpZ1VpbnQ2NEFycmF5LmJ1ZmZlcik7XG4gICAgfVxuICAgIGNhc2UgJ2ludDgnOiB7XG4gICAgICBpZiAoaW50MzJBcnJheS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUgPCAtMTI4IHx8IHZhbHVlID4gMTI3KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgY29udmVydCBpbnQzMiBkYXRhIHRvIGludDggLSB2YWx1ZSBvdXQgb2YgcmFuZ2UuJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbnQ4QXJyYXkgPSBJbnQ4QXJyYXkuZnJvbShpbnQzMkFycmF5LCBOdW1iZXIpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGludDhBcnJheS5idWZmZXIpO1xuICAgIH1cbiAgICBjYXNlICd1aW50OCc6IHtcbiAgICAgIGlmIChpbnQzMkFycmF5LnNvbWUoKHZhbHVlKSA9PiB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAyNTUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBjb252ZXJ0IGludDMyIGRhdGEgdG8gdWludDggLSB2YWx1ZSBvdXQgb2YgcmFuZ2UuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGludDMyQXJyYXksIE51bWJlcik7XG4gICAgfVxuICAgIGNhc2UgJ3VpbnQzMic6IHtcbiAgICAgIGlmIChpbnQzMkFycmF5LnNvbWUoKHZhbHVlKSA9PiB2YWx1ZSA8IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBjb252ZXJ0IGludDMyIGRhdGEgdG8gdWludDMyIC0gbmVnYXRpdmUgdmFsdWUgZm91bmQuJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB1aW50MzJBcnJheSA9IFVpbnQzMkFycmF5LmZyb20oaW50MzJBcnJheSwgTnVtYmVyKTtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh1aW50MzJBcnJheS5idWZmZXIpO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIGNvbnZlcnNpb24gZnJvbSAnaW50MzInIHRvICR7ZGF0YVR5cGV9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCB0eXBlIFRlbnNvcklkID0gbnVtYmVyO1xuXG4vKipcbiAqIE1hbmFnZXMgVGVuc29ySWQgdG8gTUxUZW5zb3IgbWFwcGluZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JNYW5hZ2VyIHtcbiAgLyoqXG4gICAqIFJlc2VydmUgYSBuZXcgVGVuc29ySWQuXG4gICAqL1xuICByZXNlcnZlVGVuc29ySWQoKTogVGVuc29ySWQ7XG4gIC8qKlxuICAgKiBSZWxlYXNlIGEgVGVuc29ySWQuXG4gICAqL1xuICByZWxlYXNlVGVuc29ySWQodGVuc29ySWQ6IFRlbnNvcklkKTogdm9pZDtcbiAgLyoqXG4gICAqIEVuc3VyZSBhIE1MVGVuc29yIGlzIGNyZWF0ZWQgZm9yIHRoZSBUZW5zb3JJZC5cbiAgICovXG4gIGVuc3VyZVRlbnNvcihcbiAgICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgICB0ZW5zb3JJZDogVGVuc29ySWQsXG4gICAgZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlLFxuICAgIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBjb3B5T2xkOiBib29sZWFuLFxuICApOiBQcm9taXNlPE1MVGVuc29yPjtcbiAgLyoqXG4gICAqIFVwbG9hZCBkYXRhIHRvIGEgTUxUZW5zb3IuXG4gICAqL1xuICB1cGxvYWQodGVuc29ySWQ6IFRlbnNvcklkLCBkYXRhOiBVaW50OEFycmF5KTogdm9pZDtcbiAgLyoqXG4gICAqIERvd25sb2FkIGRhdGEgZnJvbSBhIE1MVGVuc29yLlxuICAgKi9cbiAgZG93bmxvYWQodGVuc29ySWQ6IFRlbnNvcklkKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj47XG4gIGRvd25sb2FkKHRlbnNvcklkOiBUZW5zb3JJZCwgZHN0VGVuc29yOiBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcik6IFByb21pc2U8dW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIFJlbGVhc2UgYWxsIHRlbnNvcnMgZm9yIGEgZ2l2ZW4gc2Vzc2lvbi5cbiAgICovXG4gIHJlbGVhc2VUZW5zb3JzRm9yU2Vzc2lvbihzZXNzaW9uOiBudW1iZXIpOiB2b2lkO1xuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXh0ZXJuYWxseSBjcmVhdGVkIE1MVGVuc29yIHdpdGggYSBnaXZlbiBzZXNzaW9uIGlkIGFuZCByZXR1cm4gYSBUZW5zb3JJZC5cbiAgICovXG4gIHJlZ2lzdGVyVGVuc29yKHNlc3Npb25JZDogbnVtYmVyLCBtbFRlbnNvcjogTUxUZW5zb3IsIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSwgc2hhcGU6IG51bWJlcltdKTogVGVuc29ySWQ7XG59XG5cbmxldCB0ZW5zb3JHdWlkID0gMTtcbmNvbnN0IGNyZWF0ZU5ld1RlbnNvcklkID0gKCk6IFRlbnNvcklkID0+IHRlbnNvckd1aWQrKztcblxuLyoqXG4gKiBNYXAgZnJvbSBkYXRhIHR5cGUgdG8gZmFsbGJhY2sgZGF0YSB0eXBlLlxuICogV2hlbiB0aGUgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBvcmlnaW5hbCBkYXRhIHR5cGUsIHVzZSBmYWxsYmFjayBkYXRhIHR5cGUgYXMgd29ya2Fyb3VuZC5cbiAqIE5vdGU6IEN1cnJlbnRseSwgd2Ugb25seSBzdXBwb3J0IGZhbGxiYWNrIHRvIGludDMyIGZvciBjZXJ0YWluIGludGVnZXIgZGF0YSB0eXBlcy5cbiAqL1xuY29uc3Qgd2Vibm5EYXRhVHlwZVRvRmFsbGJhY2sgPSBuZXcgTWFwPE1MT3BlcmFuZERhdGFUeXBlLCBNTE9wZXJhbmREYXRhVHlwZT4oW1xuICBbJ2ludDgnLCAnaW50MzInXSxcbiAgWyd1aW50OCcsICdpbnQzMiddLFxuICBbJ3VpbnQzMicsICdpbnQzMiddLFxuICBbJ2ludDY0JywgJ2ludDMyJ10sXG5dKTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGJ5dGUgbGVuZ3RoIG9mIGEgdGVuc29yIHdpdGggdGhlIGdpdmVuIGRhdGEgdHlwZSBhbmQgc2hhcGUuXG4gKi9cbmNvbnN0IGNhbGN1bGF0ZUJ5dGVMZW5ndGggPSAoZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlLCBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXIgPT4ge1xuICBjb25zdCBkYXRhVHlwZVNpemUgPSB3ZWJubkRhdGFUeXBlVG9TaXplLmdldChkYXRhVHlwZSk7XG4gIGlmICghZGF0YVR5cGVTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBXZWJOTiBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfWApO1xuICB9XG4gIHJldHVybiBzaGFwZS5sZW5ndGggPiAwID8gTWF0aC5jZWlsKChzaGFwZS5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKSAqIGRhdGFUeXBlU2l6ZSkgLyA4KSA6IDA7XG59O1xuXG4vKipcbiAqIFRlbnNvcldyYXBwZXIgd3JhcHMgYW4gTUxUZW5zb3IgYW5kIHByb3ZpZGVzIGEgd2F5IHRvIHRyYWNrIHRoZSBsYXN0IHNlc3Npb24gdGhhdCB1c2VkIGl0LlxuICovXG5jbGFzcyBUZW5zb3JXcmFwcGVyIHtcbiAgLy8gVGhlIGlkIG9mIHRoZSBsYXN0IHNlc3Npb24gdGhhdCB1c2VkIHRoaXMgdGVuc29yLlxuICBwdWJsaWMgc2Vzc2lvbklkOiBudW1iZXI7XG4gIC8vIFRoaXMgZmxhZyBpcyB1c2VkIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIGRhdGEgaGFzIGJlZW4gY29udmVydGVkIHRvIGZhbGxiYWNrIGRhdGEgdHlwZS5cbiAgcHVibGljIGlzRGF0YUNvbnZlcnRlZCA9IGZhbHNlO1xuXG4gIHByaXZhdGUgbWxDb250ZXh0OiBNTENvbnRleHQ7XG4gIHByaXZhdGUgbWxUZW5zb3I6IE1MVGVuc29yO1xuICBwcml2YXRlIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZTtcbiAgLy8gRmFsbGJhY2sgZGF0YSB0eXBlIHRvIHVzZSB3aGVuIHRoZSBjb250ZXh0IGRvZXMgbm90IHN1cHBvcnQgdGhlIG9yaWdpbmFsIGRhdGEgdHlwZS5cbiAgcHJpdmF0ZSBmYWxsYmFja0RhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSB0ZW5zb3JTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG5cbiAgY29uc3RydWN0b3IoZGVzY3JpcHRvcjoge1xuICAgIHNlc3Npb25JZDogbnVtYmVyO1xuICAgIGNvbnRleHQ6IE1MQ29udGV4dDtcbiAgICB0ZW5zb3I6IE1MVGVuc29yO1xuICAgIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZTtcbiAgICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG4gICAgZmFsbGJhY2tEYXRhVHlwZT86IE1MT3BlcmFuZERhdGFUeXBlO1xuICB9KSB7XG4gICAgY29uc3QgeyBzZXNzaW9uSWQsIGNvbnRleHQsIHRlbnNvciwgZGF0YVR5cGUsIHNoYXBlLCBmYWxsYmFja0RhdGFUeXBlIH0gPSBkZXNjcmlwdG9yO1xuICAgIHRoaXMuc2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICAgIHRoaXMubWxDb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm1sVGVuc29yID0gdGVuc29yO1xuICAgIHRoaXMuZGF0YVR5cGUgPSBkYXRhVHlwZTtcbiAgICB0aGlzLnRlbnNvclNoYXBlID0gc2hhcGU7XG4gICAgdGhpcy5mYWxsYmFja0RhdGFUeXBlID0gZmFsbGJhY2tEYXRhVHlwZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdGVuc29yKCk6IE1MVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5tbFRlbnNvcjtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdHlwZSgpOiBNTE9wZXJhbmREYXRhVHlwZSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVR5cGU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGZhbGxiYWNrVHlwZSgpOiBNTE9wZXJhbmREYXRhVHlwZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuZmFsbGJhY2tEYXRhVHlwZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2hhcGUoKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIHJldHVybiB0aGlzLnRlbnNvclNoYXBlO1xuICB9XG5cbiAgcHVibGljIGdldCBieXRlTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZUJ5dGVMZW5ndGgodGhpcy5kYXRhVHlwZSwgdGhpcy50ZW5zb3JTaGFwZSk7XG4gIH1cblxuICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHtcbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiAnW1dlYk5OXSBUZW5zb3JXcmFwcGVyLmRlc3Ryb3knKTtcbiAgICB0aGlzLm1sVGVuc29yLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHB1YmxpYyB3cml0ZShkYXRhOiBVaW50OEFycmF5KTogdm9pZCB7XG4gICAgdGhpcy5tbENvbnRleHQud3JpdGVUZW5zb3IodGhpcy5tbFRlbnNvciwgZGF0YSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcmVhZCgpOiBQcm9taXNlPEFycmF5QnVmZmVyPjtcbiAgcHVibGljIGFzeW5jIHJlYWQoZHN0QnVmZmVyPzogQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpOiBQcm9taXNlPEFycmF5QnVmZmVyIHwgdW5kZWZpbmVkPjtcbiAgcHVibGljIGFzeW5jIHJlYWQoZHN0QnVmZmVyPzogQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpOiBQcm9taXNlPEFycmF5QnVmZmVyIHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKHRoaXMuZmFsbGJhY2tEYXRhVHlwZSkge1xuICAgICAgLy8gVGhpcyB0ZW5zb3IgaGFzIGJlZW4gZmFsbGJhY2sgdG8gaW50MzIgYXMgd29ya2Fyb3VuZCwgd2UgbmVlZCB0byByZWFkIGl0IGFzIGl0cyBvcmlnaW5hbCBpbnRlZ2VyIGRhdGEgdHlwZS5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IpO1xuICAgICAgY29uc3Qgb3JpZ2luYWxEYXRhID0gY29udmVydEludDMyVG9EYXRhKG5ldyBVaW50OEFycmF5KGRhdGEpLCB0aGlzLmRhdGFUeXBlKTtcblxuICAgICAgaWYgKGRzdEJ1ZmZlcikge1xuICAgICAgICBjb25zdCB0YXJnZXRCdWZmZXIgPVxuICAgICAgICAgIGRzdEJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXG4gICAgICAgICAgICA/IG5ldyBVaW50OEFycmF5KGRzdEJ1ZmZlcilcbiAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoZHN0QnVmZmVyLmJ1ZmZlciwgZHN0QnVmZmVyLmJ5dGVPZmZzZXQsIGRzdEJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGFyZ2V0QnVmZmVyLnNldChvcmlnaW5hbERhdGEpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsRGF0YS5idWZmZXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkc3RCdWZmZXIgPyB0aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IsIGRzdEJ1ZmZlcikgOiB0aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjYW5SZXVzZVRlbnNvcihjb250ZXh0OiBNTENvbnRleHQsIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubWxDb250ZXh0ID09PSBjb250ZXh0ICYmXG4gICAgICB0aGlzLmRhdGFUeXBlID09PSBkYXRhVHlwZSAmJlxuICAgICAgdGhpcy50ZW5zb3JTaGFwZS5sZW5ndGggPT09IHNoYXBlLmxlbmd0aCAmJlxuICAgICAgdGhpcy50ZW5zb3JTaGFwZS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gc2hhcGVbaV0pXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRJc0RhdGFDb252ZXJ0ZWQoaXNDb252ZXJ0ZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLmlzRGF0YUNvbnZlcnRlZCA9IGlzQ29udmVydGVkO1xuICB9XG59XG5cbi8qKlxuICogVGVuc29yVHJhY2tlciB0cmFja3MgdGhlIE1MVGVuc29yIGFuZCBwZW5kaW5nIHVwbG9hZCBkYXRhLlxuICpcbiAqIFdlIG5lZWQgdG8gdHJhY2sgdGhlIE1MVGVuc29yIGFuZCBwZW5kaW5nIHVwbG9hZCBkYXRhIGJlY2F1c2Ugd2UgZGVsYXkgdGhlIGNyZWF0aW9uIG9mIE1MVGVuc29yIHVudGlsXG4gKiB3ZSBrbm93IHRoZSBkYXRhIHR5cGUgYW5kIHNoYXBlLiBUaGlzIGlzIGJlY2F1c2UgV2ViTk4gb25seSBzdXBwb3J0IGNyZWF0aW5nIE1MVGVuc29ycyB3aXRoIGRhdGFUeXBlcyBhbmQgc2hhcGUuXG4gKi9cbmNsYXNzIFRlbnNvcklkVHJhY2tlciB7XG4gIHByaXZhdGUgYWN0aXZlVXBsb2FkPzogVWludDhBcnJheTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHRlbnNvck1hbmFnZXI6IFRlbnNvck1hbmFnZXJJbXBsLFxuICAgIHByaXZhdGUgd3JhcHBlcj86IFRlbnNvcldyYXBwZXIsXG4gICkge31cblxuICBwdWJsaWMgZ2V0IHRlbnNvcldyYXBwZXIoKTogVGVuc29yV3JhcHBlciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMud3JhcHBlcjtcbiAgfVxuXG4gIHB1YmxpYyByZWxlYXNlVGVuc29yKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnRlbnNvcldyYXBwZXIpIHtcbiAgICAgIHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yKHRoaXMudGVuc29yV3JhcHBlcik7XG4gICAgICB0aGlzLndyYXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGVuc3VyZVRlbnNvcihcbiAgICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgICBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUsXG4gICAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGNvcHlPbGQ6IGJvb2xlYW4sXG4gICk6IFByb21pc2U8TUxUZW5zb3I+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy50ZW5zb3JNYW5hZ2VyLmdldE1MQ29udGV4dChzZXNzaW9uSWQpO1xuICAgIGNvbnN0IG9wTGltaXRzID0gdGhpcy50ZW5zb3JNYW5hZ2VyLmdldE1MT3BTdXBwb3J0TGltaXRzKHNlc3Npb25JZCk7XG4gICAgbGV0IGZhbGxiYWNrRGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlIHwgdW5kZWZpbmVkO1xuICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZXh0IHN1cHBvcnRzIHRoZSBkYXRhIHR5cGUuIElmIG5vdCwgdHJ5IHRvIHVzZSB0aGUgZmFsbGJhY2sgZGF0YSB0eXBlLlxuICAgIGlmICghb3BMaW1pdHM/LmlucHV0LmRhdGFUeXBlcy5pbmNsdWRlcyhkYXRhVHlwZSkpIHtcbiAgICAgIGZhbGxiYWNrRGF0YVR5cGUgPSB3ZWJubkRhdGFUeXBlVG9GYWxsYmFjay5nZXQoZGF0YVR5cGUpO1xuICAgICAgaWYgKCFmYWxsYmFja0RhdGFUeXBlIHx8IG9wTGltaXRzPy5pbnB1dC5kYXRhVHlwZXMuaW5jbHVkZXMoZmFsbGJhY2tEYXRhVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXZWJOTiBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfWApO1xuICAgICAgfVxuICAgICAgTE9HX0RFQlVHKFxuICAgICAgICAndmVyYm9zZScsXG4gICAgICAgICgpID0+IGBbV2ViTk5dIFRlbnNvcklkVHJhY2tlci5lbnN1cmVUZW5zb3I6IGZhbGxiYWNrIGRhdGFUeXBlIGZyb20gJHtkYXRhVHlwZX0gdG8gJHtmYWxsYmFja0RhdGFUeXBlfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndyYXBwZXIpIHtcbiAgICAgIGlmICh0aGlzLndyYXBwZXIuY2FuUmV1c2VUZW5zb3IoY29udGV4dCwgZGF0YVR5cGUsIHNoYXBlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLnRlbnNvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb3B5T2xkKSB7XG4gICAgICAgICAgaWYgKHRoaXMud3JhcHBlci5ieXRlTGVuZ3RoICE9PSBjYWxjdWxhdGVCeXRlTGVuZ3RoKGRhdGFUeXBlLCBzaGFwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNvcHkgZGF0YSB0byB0ZW5zb3Igd2l0aCBkaWZmZXJlbnQgc2l6ZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hY3RpdmVVcGxvYWQgPSBuZXcgVWludDhBcnJheShhd2FpdCB0aGlzLndyYXBwZXIucmVhZCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcih0aGlzLndyYXBwZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgY29uc3QgdXNhZ2UgPSB0eXBlb2YgTUxUZW5zb3JVc2FnZSA9PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1MVGVuc29yVXNhZ2UuUkVBRCB8IE1MVGVuc29yVXNhZ2UuV1JJVEU7XG4gICAgdGhpcy53cmFwcGVyID0gYXdhaXQgdGhpcy50ZW5zb3JNYW5hZ2VyLmdldENhY2hlZFRlbnNvcihcbiAgICAgIHNlc3Npb25JZCxcbiAgICAgIGRhdGFUeXBlLFxuICAgICAgc2hhcGUsXG4gICAgICB1c2FnZSxcbiAgICAgIHRydWUsXG4gICAgICB0cnVlLFxuICAgICAgZmFsbGJhY2tEYXRhVHlwZSxcbiAgICApO1xuXG4gICAgaWYgKGNvcHlPbGQgJiYgdGhpcy5hY3RpdmVVcGxvYWQpIHtcbiAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gY29udmVydCB0aGUgb3JpZ2luYWwgaW50ZWdlciBkYXRhIHRvIGludDMyLFxuICAgICAgLy8gYmVjYXVzZSBpdCBoYXMgYmVlbiBjb252ZXJ0ZWQgd2hlbiBpdCB3YXMgdXBsb2FkZWQuXG4gICAgICB0aGlzLndyYXBwZXIud3JpdGUodGhpcy5hY3RpdmVVcGxvYWQpO1xuICAgICAgdGhpcy5hY3RpdmVVcGxvYWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMud3JhcHBlci50ZW5zb3I7XG4gIH1cblxuICBwdWJsaWMgdXBsb2FkKGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICBsZXQgbmV3RGF0YSA9IGRhdGE7XG4gICAgaWYgKHRoaXMud3JhcHBlcikge1xuICAgICAgaWYgKHRoaXMud3JhcHBlci5mYWxsYmFja1R5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlci5mYWxsYmFja1R5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgICAvLyBDb252ZXJ0IG9yaWdpbmFsIGludGVnZXIgZGF0YSB0byBpbnQzMi5cbiAgICAgICAgICBuZXdEYXRhID0gY29udmVydERhdGFUb0ludDMyKGRhdGEsIHRoaXMud3JhcHBlci50eXBlKTtcbiAgICAgICAgICB0aGlzLndyYXBwZXIuc2V0SXNEYXRhQ29udmVydGVkKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZmFsbGJhY2sgZGF0YSB0eXBlOiAke3RoaXMud3JhcHBlci5mYWxsYmFja1R5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGRhdGEgc2l6ZSBtYXRjaGVzIHRoZSB0ZW5zb3Igc2l6ZS5cbiAgICAgIGlmIChkYXRhLmJ5dGVMZW5ndGggPT09IHRoaXMud3JhcHBlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIC8vIFdyaXRlIHRoZSBuZXdEYXRhIHRvIHRoZSB0ZW5zb3IuXG4gICAgICAgIHRoaXMud3JhcHBlci53cml0ZShuZXdEYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gJ0RhdGEgc2l6ZSBkb2VzIG5vdCBtYXRjaCB0ZW5zb3Igc2l6ZS4gUmVsZWFzaW5nIHRlbnNvci4nKTtcbiAgICAgICAgdGhpcy5yZWxlYXNlVGVuc29yKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWN0aXZlVXBsb2FkKSB7XG4gICAgICB0aGlzLmFjdGl2ZVVwbG9hZC5zZXQobmV3RGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWN0aXZlVXBsb2FkID0gbmV3IFVpbnQ4QXJyYXkobmV3RGF0YSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGRvd25sb2FkKGRzdEJ1ZmZlcj86IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTxBcnJheUJ1ZmZlciB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICh0aGlzLmFjdGl2ZVVwbG9hZCkge1xuICAgICAgLy8gSWYgdGhpcy5hY3RpdmVVcGxvYWQgaGFzIGJlZW4gY29udmVydGVkIHRvIGludDMyLCB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgYmFjayB0byBvcmlnaW5hbCBpbnRlZ2VyIGRhdGEgdHlwZS5cbiAgICAgIGNvbnN0IGRzdERhdGEgPSB0aGlzLndyYXBwZXI/LmlzRGF0YUNvbnZlcnRlZFxuICAgICAgICA/IGNvbnZlcnRJbnQzMlRvRGF0YSh0aGlzLmFjdGl2ZVVwbG9hZCwgdGhpcy53cmFwcGVyPy50eXBlKVxuICAgICAgICA6IHRoaXMuYWN0aXZlVXBsb2FkO1xuXG4gICAgICBpZiAoZHN0QnVmZmVyKSB7XG4gICAgICAgIGlmIChkc3RCdWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIG5ldyBVaW50OEFycmF5KGRzdEJ1ZmZlcikuc2V0KGRzdERhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ldyBVaW50OEFycmF5KGRzdEJ1ZmZlci5idWZmZXIsIGRzdEJ1ZmZlci5ieXRlT2Zmc2V0LCBkc3RCdWZmZXIuYnl0ZUxlbmd0aCkuc2V0KGRzdERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkc3REYXRhLmJ1ZmZlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLndyYXBwZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yIGhhcyBub3QgYmVlbiBjcmVhdGVkLicpO1xuICAgIH1cblxuICAgIGlmICghZHN0QnVmZmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVyLnJlYWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud3JhcHBlci5yZWFkKGRzdEJ1ZmZlcik7XG4gIH1cbn1cblxuY2xhc3MgVGVuc29yTWFuYWdlckltcGwgaW1wbGVtZW50cyBUZW5zb3JNYW5hZ2VyIHtcbiAgcHJpdmF0ZSB0ZW5zb3JUcmFja2Vyc0J5SWQ6IE1hcDxUZW5zb3JJZCwgVGVuc29ySWRUcmFja2VyPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBmcmVlVGVuc29yczogVGVuc29yV3JhcHBlcltdID0gW107XG4gIHByaXZhdGUgZXh0ZXJuYWxUZW5zb3JzOiBTZXQ8VGVuc29yV3JhcHBlcj4gPSBuZXcgU2V0KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBiYWNrZW5kOiBXZWJOTkJhY2tlbmQpIHt9XG5cbiAgcHVibGljIGdldE1MQ29udGV4dChzZXNzaW9uSWQ6IG51bWJlcik6IE1MQ29udGV4dCB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuYmFja2VuZC5nZXRNTENvbnRleHQoc2Vzc2lvbklkKTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTUxDb250ZXh0IG5vdCBmb3VuZCBmb3Igc2Vzc2lvbi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0TUxPcFN1cHBvcnRMaW1pdHMoc2Vzc2lvbklkOiBudW1iZXIpOiBNTE9wU3VwcG9ydExpbWl0cyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuYmFja2VuZC5nZXRNTE9wU3VwcG9ydExpbWl0cyhzZXNzaW9uSWQpO1xuICB9XG5cbiAgcHVibGljIHJlc2VydmVUZW5zb3JJZCgpOiBUZW5zb3JJZCB7XG4gICAgY29uc3QgdGVuc29ySWQgPSBjcmVhdGVOZXdUZW5zb3JJZCgpO1xuICAgIHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLnNldCh0ZW5zb3JJZCwgbmV3IFRlbnNvcklkVHJhY2tlcih0aGlzKSk7XG4gICAgcmV0dXJuIHRlbnNvcklkO1xuICB9XG5cbiAgcHVibGljIHJlbGVhc2VUZW5zb3JJZCh0ZW5zb3JJZDogVGVuc29ySWQpOiB2b2lkIHtcbiAgICBjb25zdCB0ZW5zb3JUcmFja2VyID0gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHRlbnNvcklkKTtcbiAgICBpZiAoIXRlbnNvclRyYWNrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZGVsZXRlKHRlbnNvcklkKTtcbiAgICBpZiAodGVuc29yVHJhY2tlci50ZW5zb3JXcmFwcGVyKSB7XG4gICAgICB0aGlzLnJlbGVhc2VUZW5zb3IodGVuc29yVHJhY2tlci50ZW5zb3JXcmFwcGVyKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZW5zdXJlVGVuc29yKFxuICAgIHNlc3Npb25JZDogbnVtYmVyLFxuICAgIHRlbnNvcklkOiBUZW5zb3JJZCxcbiAgICBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUsXG4gICAgc2hhcGU6IG51bWJlcltdLFxuICAgIGNvcHlPbGQ6IGJvb2xlYW4sXG4gICk6IFByb21pc2U8TUxUZW5zb3I+IHtcbiAgICBMT0dfREVCVUcoXG4gICAgICAndmVyYm9zZScsXG4gICAgICAoKSA9PlxuICAgICAgICBgW1dlYk5OXSBUZW5zb3JNYW5hZ2VyLmVuc3VyZVRlbnNvciB7dGVuc29ySWQ6ICR7dGVuc29ySWR9LCBkYXRhVHlwZTogJHtcbiAgICAgICAgICBkYXRhVHlwZVxuICAgICAgICB9LCBzaGFwZTogJHtzaGFwZX0sIGNvcHlPbGQ6ICR7Y29weU9sZH19YCxcbiAgICApO1xuICAgIGNvbnN0IHRlbnNvciA9IHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0ZW5zb3JJZCk7XG4gICAgaWYgKCF0ZW5zb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yIG5vdCBmb3VuZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbnNvci5lbnN1cmVUZW5zb3Ioc2Vzc2lvbklkLCBkYXRhVHlwZSwgc2hhcGUsIGNvcHlPbGQpO1xuICB9XG5cbiAgcHVibGljIHVwbG9hZCh0ZW5zb3JJZDogVGVuc29ySWQsIGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICBjb25zdCB0ZW5zb3IgPSB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQodGVuc29ySWQpO1xuICAgIGlmICghdGVuc29yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBub3QgZm91bmQuJyk7XG4gICAgfVxuICAgIHRlbnNvci51cGxvYWQoZGF0YSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZG93bmxvYWQodGVuc29ySWQ6IFRlbnNvcklkKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj47XG4gIHB1YmxpYyBhc3luYyBkb3dubG9hZCh0ZW5zb3JJZDogVGVuc29ySWQsIGRzdEJ1ZmZlcjogQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpOiBQcm9taXNlPHVuZGVmaW5lZD47XG4gIGFzeW5jIGRvd25sb2FkKHRlbnNvcklkOiBUZW5zb3JJZCwgZHN0QnVmZmVyPzogQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpOiBQcm9taXNlPEFycmF5QnVmZmVyIHwgdW5kZWZpbmVkPiB7XG4gICAgTE9HX0RFQlVHKFxuICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgKCkgPT4gYFtXZWJOTl0gVGVuc29yTWFuYWdlci5kb3dubG9hZCB7dGVuc29ySWQ6ICR7dGVuc29ySWR9LCBkc3RCdWZmZXI6ICR7ZHN0QnVmZmVyPy5ieXRlTGVuZ3RofX1gLFxuICAgICk7XG4gICAgY29uc3QgdGVuc29yVHJhY2tlciA9IHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0ZW5zb3JJZCk7XG4gICAgaWYgKCF0ZW5zb3JUcmFja2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBub3QgZm91bmQuJyk7XG4gICAgfVxuICAgIHJldHVybiB0ZW5zb3JUcmFja2VyLmRvd25sb2FkKGRzdEJ1ZmZlcik7XG4gIH1cblxuICBwdWJsaWMgcmVsZWFzZVRlbnNvcnNGb3JTZXNzaW9uKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCB0ZW5zb3Igb2YgdGhpcy5mcmVlVGVuc29ycykge1xuICAgICAgaWYgKHRlbnNvci5zZXNzaW9uSWQgPT09IHNlc3Npb25JZCkge1xuICAgICAgICB0ZW5zb3IuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZyZWVUZW5zb3JzID0gdGhpcy5mcmVlVGVuc29ycy5maWx0ZXIoKHRlbnNvcikgPT4gdGVuc29yLnNlc3Npb25JZCAhPT0gc2Vzc2lvbklkKTtcbiAgfVxuXG4gIHB1YmxpYyByZWdpc3RlclRlbnNvcihcbiAgICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgICBtbFRlbnNvcjogTUxUZW5zb3IsXG4gICAgZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlLFxuICAgIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVGVuc29ySWQge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldE1MQ29udGV4dChzZXNzaW9uSWQpO1xuICAgIGNvbnN0IHRlbnNvcklkID0gY3JlYXRlTmV3VGVuc29ySWQoKTtcbiAgICAvLyBEZWZhdWx0aW5nIHRvIFJFQUQgfCBXUklURSBpZiB1c2FnZSBpcyBub3QgcHJvdmlkZWQuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBjb25zdCB3cmFwcGVyID0gbmV3IFRlbnNvcldyYXBwZXIoe1xuICAgICAgc2Vzc2lvbklkLFxuICAgICAgY29udGV4dCxcbiAgICAgIHRlbnNvcjogbWxUZW5zb3IsXG4gICAgICBkYXRhVHlwZSxcbiAgICAgIHNoYXBlLFxuICAgIH0pO1xuICAgIHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLnNldCh0ZW5zb3JJZCwgbmV3IFRlbnNvcklkVHJhY2tlcih0aGlzLCB3cmFwcGVyKSk7XG4gICAgdGhpcy5leHRlcm5hbFRlbnNvcnMuYWRkKHdyYXBwZXIpO1xuICAgIHJldHVybiB0ZW5zb3JJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb3IgY3JlYXRlIGFuIE1MVGVuc29yIHdpdGggdGhlIGdpdmVuIGRhdGEgdHlwZSBhbmQgc2hhcGUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0Q2FjaGVkVGVuc29yKFxuICAgIHNlc3Npb25JZDogbnVtYmVyLFxuICAgIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSxcbiAgICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgdXNhZ2U6IE1MVGVuc29yVXNhZ2VGbGFncyB8IHVuZGVmaW5lZCxcbiAgICB3cml0YWJsZTogYm9vbGVhbixcbiAgICByZWFkYWJsZTogYm9vbGVhbixcbiAgICBmYWxsYmFja0RhdGFUeXBlPzogTUxPcGVyYW5kRGF0YVR5cGUsXG4gICk6IFByb21pc2U8VGVuc29yV3JhcHBlcj4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldE1MQ29udGV4dChzZXNzaW9uSWQpO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCB0ZW5zb3JdIG9mIHRoaXMuZnJlZVRlbnNvcnMuZW50cmllcygpKSB7XG4gICAgICBpZiAodGVuc29yLmNhblJldXNlVGVuc29yKGNvbnRleHQsIGRhdGFUeXBlLCBzaGFwZSkpIHtcbiAgICAgICAgTE9HX0RFQlVHKFxuICAgICAgICAgICd2ZXJib3NlJyxcbiAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgYFtXZWJOTl0gUmV1c2luZyB0ZW5zb3Ige2RhdGFUeXBlOiAke2RhdGFUeXBlfSwgJHtcbiAgICAgICAgICAgICAgZmFsbGJhY2tEYXRhVHlwZSA/IGBmYWxsYmFja0RhdGFUeXBlOiAke2ZhbGxiYWNrRGF0YVR5cGV9LGAgOiAnJ1xuICAgICAgICAgICAgfSBzaGFwZTogJHtzaGFwZX1gLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGhpcy5mcmVlVGVuc29ycy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgICAgICB3cmFwcGVyLnNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICB9XG4gICAgfVxuICAgIExPR19ERUJVRyhcbiAgICAgICd2ZXJib3NlJyxcbiAgICAgICgpID0+XG4gICAgICAgIGBbV2ViTk5dIE1MQ29udGV4dC5jcmVhdGVUZW5zb3Ige2RhdGFUeXBlOiAke2RhdGFUeXBlfSwgJHtcbiAgICAgICAgICBmYWxsYmFja0RhdGFUeXBlID8gYGZhbGxiYWNrRGF0YVR5cGU6ICR7ZmFsbGJhY2tEYXRhVHlwZX0sYCA6ICcnXG4gICAgICAgIH0gc2hhcGU6ICR7c2hhcGV9fWAsXG4gICAgKTtcbiAgICBjb25zdCB0ZW5zb3IgPSBhd2FpdCBjb250ZXh0LmNyZWF0ZVRlbnNvcih7XG4gICAgICBkYXRhVHlwZTogZmFsbGJhY2tEYXRhVHlwZSA/PyBkYXRhVHlwZSwgLy8gSWYgZmFsbGJhY2sgZGF0YSB0eXBlIGlzIHByb3ZpZGVkLCB1c2UgaXQuXG4gICAgICBzaGFwZSxcbiAgICAgIGRpbWVuc2lvbnM6IHNoYXBlLFxuICAgICAgdXNhZ2UsXG4gICAgICB3cml0YWJsZSxcbiAgICAgIHJlYWRhYmxlLFxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVGVuc29yV3JhcHBlcih7IHNlc3Npb25JZCwgY29udGV4dCwgdGVuc29yLCBkYXRhVHlwZSwgc2hhcGUsIGZhbGxiYWNrRGF0YVR5cGUgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZSB0ZW5zb3IgZm9yIHJldXNlIHVubGVzcyBleHRlcm5hbC5cbiAgICovXG4gIHB1YmxpYyByZWxlYXNlVGVuc29yKHRlbnNvcldyYXBwZXI6IFRlbnNvcldyYXBwZXIpIHtcbiAgICBpZiAodGhpcy5leHRlcm5hbFRlbnNvcnMuaGFzKHRlbnNvcldyYXBwZXIpKSB7XG4gICAgICB0aGlzLmV4dGVybmFsVGVuc29ycy5kZWxldGUodGVuc29yV3JhcHBlcik7XG4gICAgfVxuICAgIHRoaXMuZnJlZVRlbnNvcnMucHVzaCh0ZW5zb3JXcmFwcGVyKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlVGVuc29yTWFuYWdlciA9ICguLi5hcmdzOiBDb25zdHJ1Y3RvclBhcmFtZXRlcnM8dHlwZW9mIFRlbnNvck1hbmFnZXJJbXBsPik6IFRlbnNvck1hbmFnZXIgPT5cbiAgbmV3IFRlbnNvck1hbmFnZXJJbXBsKC4uLmFyZ3MpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLyBXZWJOTiBBUEkgY3VycmVudGx5IGRvZXMgbm90IGhhdmUgYSBUeXBlU2NyaXB0IGRlZmluaXRpb24gZmlsZS4gVGhpcyBmaWxlIGlzIGEgd29ya2Fyb3VuZCB3aXRoIHR5cGVzIGdlbmVyYXRlZCBmcm9tXG4vLyBXZWJOTiBBUEkgc3BlY2lmaWNhdGlvbi5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJtYWNoaW5lbGVhcm5pbmcvd2Vibm4vaXNzdWVzLzY3N1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIndlYm5uL3dlYm5uLmQudHNcIiAvPlxuXG5pbXBvcnQgeyBFbnYsIFRlbnNvciB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IERhdGFUeXBlLCB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSB9IGZyb20gJy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IGdldEluc3RhbmNlIH0gZnJvbSAnLi4vd2FzbS1mYWN0b3J5JztcblxuaW1wb3J0IHsgY3JlYXRlVmlldyB9IGZyb20gJy4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgVGVuc29ySWQsIGNyZWF0ZVRlbnNvck1hbmFnZXIsIGNvbnZlcnREYXRhVG9JbnQzMiB9IGZyb20gJy4vd2Vibm4vdGVuc29yLW1hbmFnZXInO1xuaW1wb3J0IHsgY29uZmlndXJlTG9nZ2VyLCBMT0dfREVCVUcgfSBmcm9tICcuL2xvZyc7XG5cbi8qXG4gKiBUZW5zb3JQcm90bzo6ZGF0YV90eXBlIHRvIFdlYk5OIE9wZXJhbmRUeXBlIG1hcHBpbmcuXG4gKi9cbmNvbnN0IG9ubnhEYXRhVHlwZVRvV2Vibm5EYXRhVHlwZSA9IG5ldyBNYXA8RGF0YVR5cGUsIE1MT3BlcmFuZERhdGFUeXBlPihbXG4gIFtEYXRhVHlwZS5mbG9hdCwgJ2Zsb2F0MzInXSxcbiAgW0RhdGFUeXBlLmZsb2F0MTYsICdmbG9hdDE2J10sXG4gIFtEYXRhVHlwZS5pbnQzMiwgJ2ludDMyJ10sXG4gIFtEYXRhVHlwZS51aW50MzIsICd1aW50MzInXSxcbiAgW0RhdGFUeXBlLmludDY0LCAnaW50NjQnXSxcbiAgW0RhdGFUeXBlLnVpbnQ2NCwgJ3VpbnQ2NCddLFxuICBbRGF0YVR5cGUuaW50NCwgJ2ludDQnXSxcbiAgW0RhdGFUeXBlLnVpbnQ0LCAndWludDQnXSxcbiAgW0RhdGFUeXBlLmludDgsICdpbnQ4J10sXG4gIFtEYXRhVHlwZS51aW50OCwgJ3VpbnQ4J10sXG4gIFtEYXRhVHlwZS5ib29sLCAndWludDgnXSxcbl0pO1xuXG50eXBlIE1MQ29udGV4dEVudHJ5ID0ge1xuICBncHVEZXZpY2U/OiBHUFVEZXZpY2U7XG4gIG9wdGlvbnM/OiBNTENvbnRleHRPcHRpb25zO1xuICBtbENvbnRleHQ6IE1MQ29udGV4dDtcbn07XG5cbmNvbnN0IGNvbXBhcmVNTENvbnRleHRPcHRpb25zID0gKGE/OiBNTENvbnRleHRPcHRpb25zLCBiPzogTUxDb250ZXh0T3B0aW9ucyk6IGJvb2xlYW4gPT4ge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFLZXlzID0gT2JqZWN0LmtleXMoYSkuc29ydCgpIGFzIEFycmF5PGtleW9mIHR5cGVvZiBhPjtcbiAgY29uc3QgYktleXMgPSBPYmplY3Qua2V5cyhiKS5zb3J0KCkgYXMgQXJyYXk8a2V5b2YgdHlwZW9mIGI+O1xuICByZXR1cm4gYUtleXMubGVuZ3RoID09PSBiS2V5cy5sZW5ndGggJiYgYUtleXMuZXZlcnkoKGtleSwgaW5kZXgpID0+IGtleSA9PT0gYktleXNbaW5kZXhdICYmIGFba2V5XSA9PT0gYltrZXldKTtcbn07XG5cbi8qKlxuICogV2ViTk4gYmFja2VuZCBpbXBsZW1lbnRhdGlvbi4gVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIE1MVGVuc29ycyBjcmVhdGVkIGJ5IHRoZSBiYWNrZW5kIGFuZCBrZWVwIHRyYWNrXG4gKiBvZiB0aGUgY3VycmVudCBNTENvbnRleHQgYmVpbmcgdXNlZCBieSB0aGUgc2Vzc2lvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJOTkJhY2tlbmQge1xuICAvKipcbiAgICogVGVuc29yIG1hbmFnZXJzIGZvciBlYWNoIHNlc3Npb24uXG4gICAqL1xuICBwcml2YXRlIHRlbnNvck1hbmFnZXIgPSBjcmVhdGVUZW5zb3JNYW5hZ2VyKHRoaXMpO1xuICAvKipcbiAgICogTWFwcyBmcm9tIHNlc3Npb24gaWQgdG8gTUxDb250ZXh0cy5cbiAgICovXG4gIHByaXZhdGUgbWxDb250ZXh0QnlTZXNzaW9uSWQgPSBuZXcgTWFwPG51bWJlciwgTUxDb250ZXh0PigpO1xuICAvKipcbiAgICogTWFwcyBmcm9tIE1MQ29udGV4dCB0byBzZXNzaW9uIGlkcy5cbiAgICovXG4gIHByaXZhdGUgc2Vzc2lvbklkc0J5TUxDb250ZXh0ID0gbmV3IE1hcDxNTENvbnRleHQsIFNldDxudW1iZXI+PigpO1xuICAvKipcbiAgICogQ2FjaGUgb2YgTUxDb250ZXh0cy5cbiAgICovXG4gIHByaXZhdGUgbWxDb250ZXh0Q2FjaGU6IE1MQ29udGV4dEVudHJ5W10gPSBbXTtcbiAgLyoqXG4gICAqIEN1cnJlbnQgc2Vzc2lvbiBpZC5cbiAgICovXG4gIHByaXZhdGUgYWN0aXZlU2Vzc2lvbklkPzogbnVtYmVyO1xuICAvKipcbiAgICogTWFwcyBmcm9tIHNlc3Npb24gaWQgdG8gbGlzdCBvZiBncmFwaCBpbnB1dHMuXG4gICAqL1xuICBwcml2YXRlIHNlc3Npb25HcmFwaElucHV0czogTWFwPG51bWJlciwgc3RyaW5nW10+ID0gbmV3IE1hcCgpO1xuICAvKipcbiAgICogTWFwcyBmcm9tIHNlc3Npb24gaWQgdG8gbGlzdCBvZiBncmFwaCBvdXRwdXRzLlxuICAgKi9cbiAgcHJpdmF0ZSBzZXNzaW9uR3JhcGhPdXRwdXRzOiBNYXA8bnVtYmVyLCBzdHJpbmdbXT4gPSBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBUZW1wb3JhcnkgZ3JhcGggaW5wdXRzIGZvciB0aGUgY3VycmVudCBzZXNzaW9uLlxuICAgKiBUaGVzZSBpbnB1dHMgd2lsbCBiZSByZWdpc3RlcmVkIHdoZW4gdGhlIHNlc3Npb24gaXMgY3JlYXRlZC5cbiAgICovXG4gIHByaXZhdGUgdGVtcG9yYXJ5R3JhcGhJbnB1dHM6IHN0cmluZ1tdID0gW107XG4gIC8qKlxuICAgKiBUZW1wb3JhcnkgZ3JhcGggb3V0cHV0cyBmb3IgdGhlIGN1cnJlbnQgc2Vzc2lvbi5cbiAgICogVGhlc2Ugb3V0cHV0cyB3aWxsIGJlIHJlZ2lzdGVyZWQgd2hlbiB0aGUgc2Vzc2lvbiBpcyBjcmVhdGVkLlxuICAgKi9cbiAgcHJpdmF0ZSB0ZW1wb3JhcnlHcmFwaE91dHB1dHM6IHN0cmluZ1tdID0gW107XG4gIC8qKlxuICAgKiBUZW1wb3JhcnkgdGVuc29ycyBmb3IgdGhlIGN1cnJlbnQgc2Vzc2lvbi5cbiAgICovXG4gIHByaXZhdGUgdGVtcG9yYXJ5U2Vzc2lvblRlbnNvcklkczogTWFwPG51bWJlciwgVGVuc29ySWRbXT4gPSBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBNYXBzIGZyb20gc2Vzc2lvbiBpZCB0byBNTE9wU3VwcG9ydExpbWl0cy5cbiAgICovXG4gIHByaXZhdGUgbWxPcFN1cHBvcnRMaW1pdHNCeVNlc3Npb25JZCA9IG5ldyBNYXA8bnVtYmVyLCBNTE9wU3VwcG9ydExpbWl0cz4oKTtcblxuICBjb25zdHJ1Y3RvcihlbnY6IEVudikge1xuICAgIGNvbmZpZ3VyZUxvZ2dlcihlbnYubG9nTGV2ZWwhLCAhIWVudi5kZWJ1Zyk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGN1cnJlbnRTZXNzaW9uSWQoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5hY3RpdmVTZXNzaW9uSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgc2Vzc2lvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hY3RpdmVTZXNzaW9uSWQ7XG4gIH1cblxuICBwdWJsaWMgb25SdW5TdGFydChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViTk5dIG9uUnVuU3RhcnQge3Nlc3Npb25JZDogJHtzZXNzaW9uSWR9fWApO1xuICAgIHRoaXMuYWN0aXZlU2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICB9XG5cbiAgcHVibGljIG9uUnVuRW5kKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJOTl0gb25SdW5FbmQge3Nlc3Npb25JZDogJHtzZXNzaW9uSWR9fWApO1xuICAgIGNvbnN0IHRlbnNvcklkcyA9IHRoaXMudGVtcG9yYXJ5U2Vzc2lvblRlbnNvcklkcy5nZXQoc2Vzc2lvbklkKTtcbiAgICBpZiAoIXRlbnNvcklkcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHRlbnNvcklkIG9mIHRlbnNvcklkcykge1xuICAgICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJOTl0gcmVsZWFzaW5nIHRlbXBvcmFyeSB0ZW5zb3Ige3RlbnNvcklkOiAke3RlbnNvcklkfX1gKTtcbiAgICAgIHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29ySWQodGVuc29ySWQpO1xuICAgIH1cbiAgICB0aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgdGhpcy5hY3RpdmVTZXNzaW9uSWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY3JlYXRlTUxDb250ZXh0KG9wdGlvbnNPckRldmljZT86IE1MQ29udGV4dE9wdGlvbnMgfCBHUFVEZXZpY2UpOiBQcm9taXNlPE1MQ29udGV4dD4ge1xuICAgIGlmIChvcHRpb25zT3JEZXZpY2UgaW5zdGFuY2VvZiBHUFVEZXZpY2UpIHtcbiAgICAgIGNvbnN0IG1sQ29udGV4dEluZGV4ID0gdGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5ncHVEZXZpY2UgPT09IG9wdGlvbnNPckRldmljZSk7XG4gICAgICBpZiAobWxDb250ZXh0SW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW21sQ29udGV4dEluZGV4XS5tbENvbnRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtbENvbnRleHQgPSBhd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dChvcHRpb25zT3JEZXZpY2UpO1xuICAgICAgICB0aGlzLm1sQ29udGV4dENhY2hlLnB1c2goeyBncHVEZXZpY2U6IG9wdGlvbnNPckRldmljZSwgbWxDb250ZXh0IH0pO1xuICAgICAgICByZXR1cm4gbWxDb250ZXh0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9uc09yRGV2aWNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG1sQ29udGV4dEluZGV4ID0gdGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgoXG4gICAgICAgIChlbnRyeSkgPT4gZW50cnkub3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIGVudHJ5LmdwdURldmljZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgKTtcbiAgICAgIGlmIChtbENvbnRleHRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbbWxDb250ZXh0SW5kZXhdLm1sQ29udGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1sQ29udGV4dCA9IGF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KCk7XG4gICAgICAgIHRoaXMubWxDb250ZXh0Q2FjaGUucHVzaCh7IG1sQ29udGV4dCB9KTtcbiAgICAgICAgcmV0dXJuIG1sQ29udGV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtbENvbnRleHRJbmRleCA9IHRoaXMubWxDb250ZXh0Q2FjaGUuZmluZEluZGV4KChlbnRyeSkgPT5cbiAgICAgIGNvbXBhcmVNTENvbnRleHRPcHRpb25zKGVudHJ5Lm9wdGlvbnMsIG9wdGlvbnNPckRldmljZSksXG4gICAgKTtcbiAgICBpZiAobWxDb250ZXh0SW5kZXggIT09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZVttbENvbnRleHRJbmRleF0ubWxDb250ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtbENvbnRleHQgPSBhd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dChvcHRpb25zT3JEZXZpY2UpO1xuICAgICAgdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHsgb3B0aW9uczogb3B0aW9uc09yRGV2aWNlLCBtbENvbnRleHQgfSk7XG4gICAgICByZXR1cm4gbWxDb250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZWdpc3Rlck1MQ29udGV4dChzZXNzaW9uSWQ6IG51bWJlciwgbWxDb250ZXh0OiBNTENvbnRleHQpOiB2b2lkIHtcbiAgICB0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLnNldChzZXNzaW9uSWQsIG1sQ29udGV4dCk7XG4gICAgbGV0IHNlc3Npb25JZHMgPSB0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5nZXQobWxDb250ZXh0KTtcbiAgICBpZiAoIXNlc3Npb25JZHMpIHtcbiAgICAgIHNlc3Npb25JZHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5zZXQobWxDb250ZXh0LCBzZXNzaW9uSWRzKTtcbiAgICB9XG4gICAgc2Vzc2lvbklkcy5hZGQoc2Vzc2lvbklkKTtcblxuICAgIGlmICghdGhpcy5tbE9wU3VwcG9ydExpbWl0c0J5U2Vzc2lvbklkLmhhcyhzZXNzaW9uSWQpKSB7XG4gICAgICB0aGlzLm1sT3BTdXBwb3J0TGltaXRzQnlTZXNzaW9uSWQuc2V0KHNlc3Npb25JZCwgbWxDb250ZXh0Lm9wU3VwcG9ydExpbWl0cygpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZW1wb3JhcnlHcmFwaElucHV0cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNlc3Npb25HcmFwaElucHV0cy5zZXQoc2Vzc2lvbklkLCB0aGlzLnRlbXBvcmFyeUdyYXBoSW5wdXRzKTtcbiAgICAgIHRoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHMgPSBbXTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVtcG9yYXJ5R3JhcGhPdXRwdXRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2Vzc2lvbkdyYXBoT3V0cHV0cy5zZXQoc2Vzc2lvbklkLCB0aGlzLnRlbXBvcmFyeUdyYXBoT3V0cHV0cyk7XG4gICAgICB0aGlzLnRlbXBvcmFyeUdyYXBoT3V0cHV0cyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBvblJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zZXNzaW9uR3JhcGhJbnB1dHMuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgdGhpcy5zZXNzaW9uR3JhcGhPdXRwdXRzLmRlbGV0ZShzZXNzaW9uSWQpO1xuICAgIGNvbnN0IG1sQ29udGV4dCA9IHRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuZ2V0KHNlc3Npb25JZCkhO1xuICAgIGlmICghbWxDb250ZXh0KSB7XG4gICAgICAvLyBDdXJyZW50IHNlc3Npb24gaXMgbm90IGEgV2ViTk4gc2Vzc2lvbi5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3JzRm9yU2Vzc2lvbihzZXNzaW9uSWQpO1xuICAgIHRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgdGhpcy5tbE9wU3VwcG9ydExpbWl0c0J5U2Vzc2lvbklkLmRlbGV0ZShzZXNzaW9uSWQpO1xuICAgIGNvbnN0IHNlc3Npb25JZHMgPSB0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5nZXQobWxDb250ZXh0KSE7XG4gICAgc2Vzc2lvbklkcy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICBpZiAoc2Vzc2lvbklkcy5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5kZWxldGUobWxDb250ZXh0KTtcbiAgICAgIGNvbnN0IG1sQ29udGV4dEluZGV4ID0gdGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5tbENvbnRleHQgPT09IG1sQ29udGV4dCk7XG4gICAgICBpZiAobWxDb250ZXh0SW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMubWxDb250ZXh0Q2FjaGUuc3BsaWNlKG1sQ29udGV4dEluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0TUxDb250ZXh0KHNlc3Npb25JZDogbnVtYmVyKTogTUxDb250ZXh0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5nZXQoc2Vzc2lvbklkKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRNTE9wU3VwcG9ydExpbWl0cyhzZXNzaW9uSWQ6IG51bWJlcik6IE1MT3BTdXBwb3J0TGltaXRzIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5tbE9wU3VwcG9ydExpbWl0c0J5U2Vzc2lvbklkLmdldChzZXNzaW9uSWQpO1xuICB9XG5cbiAgcHVibGljIHJlc2VydmVUZW5zb3JJZCgpOiBUZW5zb3JJZCB7XG4gICAgcmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5yZXNlcnZlVGVuc29ySWQoKTtcbiAgfVxuXG4gIHB1YmxpYyByZWxlYXNlVGVuc29ySWQodGVuc29ySWQ6IFRlbnNvcklkKTogdm9pZCB7XG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJOTl0gcmVsZWFzZVRlbnNvcklkIHt0ZW5zb3JJZDogJHt0ZW5zb3JJZH19YCk7XG4gICAgdGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3JJZCh0ZW5zb3JJZCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZW5zdXJlVGVuc29yKFxuICAgIHNlc3Npb25JZDogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICAgIHRlbnNvcklkOiBUZW5zb3JJZCxcbiAgICBvbm54RGF0YVR5cGU6IERhdGFUeXBlLFxuICAgIGRpbWVuc2lvbnM6IG51bWJlcltdLFxuICAgIGNvcHlPbGQ6IGJvb2xlYW4sXG4gICk6IFByb21pc2U8TUxUZW5zb3I+IHtcbiAgICBjb25zdCB3ZWJubkRhdGFUeXBlID0gb25ueERhdGFUeXBlVG9XZWJubkRhdGFUeXBlLmdldChvbm54RGF0YVR5cGUpO1xuICAgIGlmICghd2Vibm5EYXRhVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtvbm54RGF0YVR5cGV9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlbnNvck1hbmFnZXIuZW5zdXJlVGVuc29yKFxuICAgICAgc2Vzc2lvbklkID8/IHRoaXMuY3VycmVudFNlc3Npb25JZCxcbiAgICAgIHRlbnNvcklkLFxuICAgICAgd2Vibm5EYXRhVHlwZSxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICBjb3B5T2xkLFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY3JlYXRlVGVtcG9yYXJ5VGVuc29yKFxuICAgIHNlc3Npb25JZDogbnVtYmVyLFxuICAgIG9ubnhEYXRhVHlwZTogRGF0YVR5cGUsXG4gICAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICApOiBQcm9taXNlPFRlbnNvcklkPiB7XG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJOTl0gY3JlYXRlVGVtcG9yYXJ5VGVuc29yIHtvbm54RGF0YVR5cGU6ICR7b25ueERhdGFUeXBlfSwgc2hhcGU6ICR7c2hhcGV9fWApO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gb25ueERhdGFUeXBlVG9XZWJubkRhdGFUeXBlLmdldChvbm54RGF0YVR5cGUpO1xuICAgIGlmICghZGF0YVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgT05OWCBkYXRhIHR5cGU6ICR7b25ueERhdGFUeXBlfWApO1xuICAgIH1cbiAgICBjb25zdCB0ZW5zb3JJZCA9IHRoaXMudGVuc29yTWFuYWdlci5yZXNlcnZlVGVuc29ySWQoKTtcbiAgICBhd2FpdCB0aGlzLnRlbnNvck1hbmFnZXIuZW5zdXJlVGVuc29yKHNlc3Npb25JZCwgdGVuc29ySWQsIGRhdGFUeXBlLCBzaGFwZSwgZmFsc2UpO1xuICAgIGNvbnN0IHRlbnNvcklkcyA9IHRoaXMudGVtcG9yYXJ5U2Vzc2lvblRlbnNvcklkcy5nZXQoc2Vzc2lvbklkKTtcbiAgICBpZiAoIXRlbnNvcklkcykge1xuICAgICAgdGhpcy50ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzLnNldChzZXNzaW9uSWQsIFt0ZW5zb3JJZF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZW5zb3JJZHMucHVzaCh0ZW5zb3JJZCk7XG4gICAgfVxuICAgIHJldHVybiB0ZW5zb3JJZDtcbiAgfVxuXG4gIHB1YmxpYyB1cGxvYWRUZW5zb3IodGVuc29ySWQ6IFRlbnNvcklkLCBkYXRhOiBVaW50OEFycmF5KTogdm9pZCB7XG4gICAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gICAgaWYgKCF3YXNtLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gdXBsb2FkIHRvIGEgTUxUZW5zb3Igd2hpbGUgc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yIGlzIGZhbHNlJyk7XG4gICAgfVxuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViTk5dIHVwbG9hZFRlbnNvciB7dGVuc29ySWQ6ICR7dGVuc29ySWR9LCBkYXRhOiAke2RhdGEuYnl0ZUxlbmd0aH19YCk7XG4gICAgdGhpcy50ZW5zb3JNYW5hZ2VyLnVwbG9hZCh0ZW5zb3JJZCwgZGF0YSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZG93bmxvYWRUZW5zb3IodGVuc29ySWQ6IFRlbnNvcklkLCBkc3RCdWZmZXI6IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHRlbnNvcklkLCBkc3RCdWZmZXIpO1xuICB9XG5cbiAgcHVibGljIGNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcih0ZW5zb3JJZDogVGVuc29ySWQsIHR5cGU6IFRlbnNvci5NTFRlbnNvckRhdGFUeXBlcyk6ICgpID0+IFByb21pc2U8VGVuc29yLkRhdGFUeXBlPiB7XG4gICAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnRlbnNvck1hbmFnZXIuZG93bmxvYWQodGVuc29ySWQpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVZpZXcoZGF0YSwgdHlwZSk7XG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyByZWdpc3Rlck1MVGVuc29yKHNlc3Npb25JZDogbnVtYmVyLCB0ZW5zb3I6IE1MVGVuc29yLCBvbm54RGF0YVR5cGU6IERhdGFUeXBlLCBkaW1lbnNpb25zOiBudW1iZXJbXSk6IFRlbnNvcklkIHtcbiAgICBjb25zdCB3ZWJubkRhdGFUeXBlID0gb25ueERhdGFUeXBlVG9XZWJubkRhdGFUeXBlLmdldChvbm54RGF0YVR5cGUpO1xuICAgIGlmICghd2Vibm5EYXRhVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtvbm54RGF0YVR5cGV9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSB0aGlzLnRlbnNvck1hbmFnZXIucmVnaXN0ZXJUZW5zb3Ioc2Vzc2lvbklkLCB0ZW5zb3IsIHdlYm5uRGF0YVR5cGUsIGRpbWVuc2lvbnMpO1xuICAgIExPR19ERUJVRyhcbiAgICAgICd2ZXJib3NlJyxcbiAgICAgICgpID0+XG4gICAgICAgIGBbV2ViTk5dIHJlZ2lzdGVyTUxUZW5zb3Ige3RlbnNvcjogJHt0ZW5zb3J9LCBkYXRhVHlwZTogJHt3ZWJubkRhdGFUeXBlfSwgZGltZW5zaW9uczogJHtcbiAgICAgICAgICBkaW1lbnNpb25zXG4gICAgICAgIH19IC0+IHt0ZW5zb3JJZDogJHtpZH19YCxcbiAgICApO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8vIFJlZ2lzdGVyIGEgV2ViTk4gQ29uc3RhbnQgb3BlcmFuZCBmcm9tIGV4dGVybmFsIGRhdGEuXG4gIHB1YmxpYyByZWdpc3Rlck1MQ29uc3RhbnQoXG4gICAgZXh0ZXJuYWxGaWxlUGF0aDogc3RyaW5nLFxuICAgIGRhdGFPZmZzZXQ6IG51bWJlcixcbiAgICBkYXRhTGVuZ3RoOiBudW1iZXIsXG4gICAgYnVpbGRlcjogTUxHcmFwaEJ1aWxkZXIsXG4gICAgZGVzYzogTUxPcGVyYW5kRGVzY3JpcHRvcixcbiAgICBtb3VudGVkRmlsZXM6IE1hcDxzdHJpbmcsIFVpbnQ4QXJyYXk+IHwgdW5kZWZpbmVkLFxuICAgIHNob3VsZENvbnZlcnRJbnQ2NFRvSW50MzIgPSBmYWxzZSxcbiAgKTogTUxPcGVyYW5kIHtcbiAgICAvLyBJZiBhdmFpbGFibGUsIFwiTW9kdWxlLk1vdW50ZWRGaWxlc1wiIGlzIGEgTWFwIGZvciBhbGwgcHJlbG9hZGVkIGZpbGVzLlxuICAgIGlmICghbW91bnRlZEZpbGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVybmFsIG1vdW50ZWQgZmlsZXMgYXJlIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgfVxuXG4gICAgbGV0IGZpbGVQYXRoID0gZXh0ZXJuYWxGaWxlUGF0aDtcbiAgICBpZiAoZXh0ZXJuYWxGaWxlUGF0aC5zdGFydHNXaXRoKCcuLycpKSB7XG4gICAgICBmaWxlUGF0aCA9IGV4dGVybmFsRmlsZVBhdGguc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICBjb25zdCBmaWxlRGF0YSA9IG1vdW50ZWRGaWxlcy5nZXQoZmlsZVBhdGgpO1xuICAgIGlmICghZmlsZURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSB3aXRoIG5hbWUgJHtmaWxlUGF0aH0gbm90IGZvdW5kIGluIHByZWxvYWRlZCBmaWxlcy5gKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YU9mZnNldCArIGRhdGFMZW5ndGggPiBmaWxlRGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dCBvZiBib3VuZHM6IGRhdGEgb2Zmc2V0IGFuZCBsZW5ndGggZXhjZWVkIHRoZSBleHRlcm5hbCBmaWxlIGRhdGEgc2l6ZS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBmaWxlRGF0YS5zbGljZShkYXRhT2Zmc2V0LCBkYXRhT2Zmc2V0ICsgZGF0YUxlbmd0aCkuYnVmZmVyO1xuICAgIGxldCBidWZmZXJWaWV3OiBBcnJheUJ1ZmZlclZpZXc7XG4gICAgc3dpdGNoIChkZXNjLmRhdGFUeXBlKSB7XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgICAgYnVmZmVyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmbG9hdDE2JzpcbiAgICAgICAgYnVmZmVyVmlldyA9XG4gICAgICAgICAgdHlwZW9mIEZsb2F0MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgRmxvYXQxNkFycmF5LmZyb20gPyBuZXcgRmxvYXQxNkFycmF5KGJ1ZmZlcikgOiBuZXcgVWludDE2QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnQzMic6XG4gICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgSW50MzJBcnJheShidWZmZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnQ2NCc6XG4gICAgICAgIGlmIChzaG91bGRDb252ZXJ0SW50NjRUb0ludDMyKSB7XG4gICAgICAgICAgLy8gSW50NjQgaXMgbm90IHN1cHBvcnRlZCBieSBjdXJyZW50IGNvbnRleHQsIHVzZSBpbnQzMiBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnN0IGludDMyQnVmZmVyID0gY29udmVydERhdGFUb0ludDMyKG5ldyBVaW50OEFycmF5KGJ1ZmZlciksICdpbnQ2NCcpO1xuICAgICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgSW50MzJBcnJheShpbnQzMkJ1ZmZlci5idWZmZXIpO1xuICAgICAgICAgIGRlc2MuZGF0YVR5cGUgPSAnaW50MzInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgQmlnSW50NjRBcnJheShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndWludDY0JzpcbiAgICAgICAgYnVmZmVyVmlldyA9IG5ldyBCaWdVaW50NjRBcnJheShidWZmZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgICBidWZmZXJWaWV3ID0gbmV3IEludDhBcnJheShidWZmZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ludDQnOlxuICAgICAgY2FzZSAndWludDQnOlxuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgICBidWZmZXJWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkZXNjLmRhdGFUeXBlfSBpbiBjcmVhdGluZyBXZWJOTiBDb25zdGFudCBmcm9tIGV4dGVybmFsIGRhdGEuYCk7XG4gICAgfVxuXG4gICAgTE9HX0RFQlVHKFxuICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgKCkgPT5cbiAgICAgICAgYFtXZWJOTl0gcmVnaXN0ZXJNTENvbnN0YW50IHtkYXRhVHlwZTogJHtkZXNjLmRhdGFUeXBlfSwgc2hhcGU6ICR7ZGVzYy5zaGFwZX19fSAke1xuICAgICAgICAgIHNob3VsZENvbnZlcnRJbnQ2NFRvSW50MzIgPyAnKE5vdGU6IGl0IHdhcyBpbnQ2NCBkYXRhIHR5cGUgYW5kIHJlZ2lzdGVyZWQgdG8gaW50MzIgYXMgd29ya2Fyb3VuZCknIDogJydcbiAgICAgICAgfWAsXG4gICAgKTtcblxuICAgIHJldHVybiBidWlsZGVyLmNvbnN0YW50KGRlc2MsIGJ1ZmZlclZpZXcpO1xuICB9XG5cbiAgcHVibGljIHJlZ2lzdGVyR3JhcGhJbnB1dChpbnB1dE5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHMucHVzaChpbnB1dE5hbWUpO1xuICB9XG5cbiAgcHVibGljIHJlZ2lzdGVyR3JhcGhPdXRwdXQob3V0cHV0TmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy50ZW1wb3JhcnlHcmFwaE91dHB1dHMucHVzaChvdXRwdXROYW1lKTtcbiAgfVxuXG4gIHB1YmxpYyBpc0dyYXBoSW5wdXQoc2Vzc2lvbklkOiBudW1iZXIsIGlucHV0TmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaW5wdXROYW1lcyA9IHRoaXMuc2Vzc2lvbkdyYXBoSW5wdXRzLmdldChzZXNzaW9uSWQpO1xuICAgIGlmICghaW5wdXROYW1lcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXROYW1lcy5pbmNsdWRlcyhpbnB1dE5hbWUpO1xuICB9XG5cbiAgcHVibGljIGlzR3JhcGhPdXRwdXQoc2Vzc2lvbklkOiBudW1iZXIsIG91dHB1dE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG91dHB1dE5hbWVzID0gdGhpcy5zZXNzaW9uR3JhcGhPdXRwdXRzLmdldChzZXNzaW9uSWQpO1xuICAgIGlmICghb3V0cHV0TmFtZXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dE5hbWVzLmluY2x1ZGVzKG91dHB1dE5hbWUpO1xuICB9XG5cbiAgcHVibGljIGlzR3JhcGhJbnB1dE91dHB1dFR5cGVTdXBwb3J0ZWQoc2Vzc2lvbklkOiBudW1iZXIsIHR5cGU6IFRlbnNvci5UeXBlLCBpc0lucHV0ID0gdHJ1ZSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGRhdGFUeXBlID0gb25ueERhdGFUeXBlVG9XZWJubkRhdGFUeXBlLmdldCh0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSh0eXBlKSk7XG4gICAgY29uc3Qgb3BMaW1pdHMgPSB0aGlzLm1sT3BTdXBwb3J0TGltaXRzQnlTZXNzaW9uSWQuZ2V0KHNlc3Npb25JZCk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGFUeXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc0lucHV0KSB7XG4gICAgICByZXR1cm4gISFvcExpbWl0cz8uaW5wdXQuZGF0YVR5cGVzLmluY2x1ZGVzKGRhdGFUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICEhb3BMaW1pdHM/Lm91dHB1dC5kYXRhVHlwZXMuaW5jbHVkZXMoZGF0YVR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBmbHVzaCgpOiB2b2lkIHtcbiAgICAvLyBVbmxpa2UgdGhlIFdlYkdQVSBiYWNrZW5kLCB0aGUgV2ViTk4gYmFja2VuZCBkb2VzIG5vdCBuZWVkIHRvIGZsdXNoIGFueSBwZW5kaW5nIG9wZXJhdGlvbnMuXG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vdGVuc29yLXZpZXcnO1xuXG5pbXBvcnQgeyBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL29wcy9jb21tb24nO1xuXG5leHBvcnQgdHlwZSBTZXNzaW9uU3RhdGUgPSAnZGVmYXVsdCcgfCAnY2FwdHVyaW5nJyB8ICdyZXBsYXlpbmcnO1xuXG5leHBvcnQgZW51bSBHcHVEYXRhVHlwZSB7XG4gIGRlZmF1bHQgPSAwLFxuICB1cGxvYWQgPSAxLFxuICBwcm9maWxlID0gMixcbn1cbmV4cG9ydCB0eXBlIEdwdURhdGFJZCA9IG51bWJlcjtcblxuZXhwb3J0IHR5cGUgR3B1QXJjaGl0ZWN0dXJlID0gJ2FtcGVyZScgfCAnZ2VuLTEybHAnO1xuZXhwb3J0IHR5cGUgR3B1VmVuZG9yID0gJ2FtZCcgfCAnaW50ZWwnIHwgJ252aWRpYSc7XG5leHBvcnQgaW50ZXJmYWNlIEFkYXB0ZXJJbmZvIHtcbiAgaXNBcmNoaXRlY3R1cmU6IChhcmNoaXRlY3R1cmU6IEdwdUFyY2hpdGVjdHVyZSkgPT4gYm9vbGVhbjtcbiAgaXNWZW5kb3I6ICh2ZW5kb3I6IEdwdVZlbmRvcikgPT4gYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcHVEYXRhIHtcbiAgdHlwZTogR3B1RGF0YVR5cGU7XG4gIGlkOiBHcHVEYXRhSWQ7XG4gIGJ1ZmZlcjogR1BVQnVmZmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckluZm8ge1xuICBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgZGF0YVR5cGU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtVW5pZm9ybSB7XG4gIHR5cGU6IERhdGFUeXBlO1xuICBkYXRhOiBudW1iZXIgfCByZWFkb25seSBudW1iZXJbXTtcbn1cblxuZXhwb3J0IHR5cGUgUHJvZ3JhbVVuaWZvcm1WYXJpYWJsZUluZm8gPSBbdHlwZTogRGF0YVR5cGUsIGxlbmd0aDogbnVtYmVyXTtcblxuLyoqXG4gKiBSZXByZXNlbnQgdGhlIGRlcGVuZGVuY3kgb2YgYSBwcm9ncmFtIG9uIGEgc3BlY2lmaWMgaW5wdXQgdGVuc29yLlxuICpcbiAqIC0gJ25vbmUnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZG9lcyBub3QgZGVwZW5kIG9uIHRoaXMgaW5wdXQncyBpbmZvXG4gKiAtICd0eXBlJzogdGhlIHNoYWRlci91bmlmb3JtIGRlcGVuZHMgb24gZGF0YSB0eXBlIG9mIHRoaXMgaW5wdXRcbiAqIC0gJ3JhbmsnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZGVwZW5kcyBvbiBkYXRhIHR5cGUgYW5kIHRoZSByYW5rIG9mIHRoaXMgaW5wdXRcbiAqIC0gJ2RpbXMnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZGVwZW5kcyBvbiBkYXRhIHR5cGUgYW5kIHRoZSBkaW1zIG9mIHRoaXMgaW5wdXRcbiAqIC0gJ2RhdGEnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZGVwZW5kcyBvbiBkYXRhIHR5cGUsIHRoZSBkaW1zIGFuZCB0aGUgZGF0YSBvZiB0aGlzIGlucHV0XG4gKi9cbmV4cG9ydCB0eXBlIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5ID0gJ25vbmUnIHwgJ3R5cGUnIHwgJ3JhbmsnIHwgJ2RpbXMnIHwgJ2RhdGEnO1xuXG4vKipcbiAqIFJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIHByb2dyYW0ncyBjYWNoZSBmb3Igc2hhZGVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1TaGFkZXJDYWNoZUluZm8ge1xuICAvKipcbiAgICogYW4gb3B0aW9uYWwgc3RyaW5nIGFzIGEgY2FjaGUgaGludCBpbiB0aGUgYXJ0aWZhY3QgY2FjaGUuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlIGNhY2hlIGhpbnQgd2lsbCBiZSBlbXB0eS5cbiAgICpcbiAgICogVGhpcyBoaW50IHN0cmluZyBzaG91bGQgb25seSBjb250YWlucyBpbml0aWFsaXppbmctdGltZSBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgYXR0cmlidXRlcyBvciBhbnkgaW5mb3JtYXRpb24gb2ZcbiAgICogaW5pdGlhbGl6ZXJzLiBJdCBzaG91bGQgTk9UIGNvbnRhaW4gYW55IHJ1bnRpbWUgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIHNoYXBlIG9mIGlucHV0cy5cbiAgICovXG4gIGhpbnQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIGxpc3Qgb2YgZGVwZW5kZW5jaWVzIG9mIHRoZSBwcm9ncmFtIG9uIHRoZSBpbnB1dCB0ZW5zb3JzLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBwcm9ncmFtIGRlcGVuZHNcbiAgICogb24gJ2RpbXMnIG9mIGFsbCBpbnB1dHMuXG4gICAqL1xuICBpbnB1dERlcGVuZGVuY2llcz86IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W107XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGluZm9ybWF0aW9uIGFib3V0IGEgcHJvZ3JhbSdzIGNhY2hlIGZvciB1bmlmb3JtLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1Vbmlmb3JtQ2FjaGVJbmZvIHtcbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIHN0cmluZyBhcyBhIGNhY2hlIGhpbnQgaW4gdGhlIHVuaWZvcm0gY2FjaGUuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlIGNhY2hlIGhpbnQgd2lsbCBiZSBlbXB0eS5cbiAgICpcbiAgICogVGhpcyBoaW50IHN0cmluZyBzaG91bGQgb25seSBjb250YWlucyBydW50aW1lIGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSBzaGFwZSBvZiBpbnB1dHMuXG4gICAqL1xuICBoaW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBsaXN0IG9mIGRlcGVuZGVuY2llcyBvZiB0aGUgcHJvZ3JhbSBvbiB0aGUgaW5wdXQgdGVuc29ycy4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgcHJvZ3JhbSBkZXBlbmRzXG4gICAqIG9uICdub25lJyBvZiBhbGwgaW5wdXRzLlxuICAgKi9cbiAgaW5wdXREZXBlbmRlbmNpZXM/OiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdO1xufVxuXG4vKipcbiAqIEEgc2V0IG9mIGRhdGEgdGhhdCByZXByZXNlbnQgYSBzaGFkZXIgcHJvZ3JhbVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1JbmZvIHtcbiAgLyoqXG4gICAqIHRoZSBuYW1lIG9mIHRoZSBwcm9ncmFtLiB1c2VkIGZvciBkZWJ1Z2dpbmcgYW5kIHByb2ZpbGluZ1xuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBvYmplY3QgZGVzY3JpYmluZyB0aGUgY2FjaGUgaW5mb3JtYXRpb24gb2YgdGhlIHByb2dyYW0gc2hhZGVyLlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBoaW50IGlzIGVtcHR5IGFuZCBpbnB1dERlcGVuZGVuY2llcyBhcmUgWydkaW1zJ10gZm9yIGFsbCBpbnB1dHMuXG4gICAqL1xuICBzaGFkZXJDYWNoZT86IFByb2dyYW1TaGFkZXJDYWNoZUluZm87XG5cbiAgLyoqXG4gICAqIHRoZSBzaGFkZXIncyBwcm9jZXNzaW5nIHNvdXJjZSBjb2RlLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gc2hhZGVyIGNhY2hlIG1pc3NlZC5cbiAgICovXG4gIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdG8gZ2V0IHJ1biBkYXRhIHJlcXVpcmVkIHRvIHJ1biB0aGUgcHJvZ3JhbS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBwcm9ncmFtIGlzIGV4ZWN1dGVkLiBTaG91bGQga2VlcCB0aGlzIGZ1bmN0aW9uIGFzIHNpbXBsZSBhcyBwb3NzaWJsZS5cbiAgICovXG4gIGdldFJ1bkRhdGE6IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSkgPT4ge1xuICAgIG91dHB1dHM6IHJlYWRvbmx5IFRlbnNvckluZm9bXTtcbiAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IG51bWJlcjsgeT86IG51bWJlcjsgej86IG51bWJlciB9O1xuICAgIHByb2dyYW1Vbmlmb3Jtcz86IHJlYWRvbmx5IFByb2dyYW1Vbmlmb3JtW107XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJ0aWZhY3Qge1xuICBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm87XG4gIGNvbXB1dGVQaXBlbGluZTogR1BVQ29tcHV0ZVBpcGVsaW5lO1xuICB1bmlmb3JtVmFyaWFibGVzSW5mbzogcmVhZG9ubHkgUHJvZ3JhbVVuaWZvcm1WYXJpYWJsZUluZm9bXSB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nIHtcbiAgLyoqXG4gICAqIHNwZWNpZnkgdGhlIG1hcHBpbmcgdG8gdGhlIHByb2dyYW0ncyBpbnB1dHMuIHRoZSB2YWx1ZSBjYW4gYmUgYSBudW1iZXIgb3IgYSB0ZW5zb3Igdmlldy5cbiAgICogLSBpZiBpdCdzIGEgbnVtYmVyLCBpdCdzIHRoZSBpbmRleCBvZiB0aGUga2VybmVsJ3MgaW5wdXRcbiAgICogLSBpZiBpdCdzIGEgdGVuc29yIHZpZXcsIGl0J3MgYW4gZXhpc3RpbmcgdGVuc29yIHZpZXcgdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGlucHV0XG4gICAqXG4gICAqIGlmIGlucHV0cyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbWFwcGluZyB3aWxsIGJlIHRoZSBrZXJuZWwncyBpbnB1dHMgaW4gb3JkZXIuXG4gICAqL1xuICByZWFkb25seSBpbnB1dHM/OiBSZWFkb25seUFycmF5PFRlbnNvclZpZXcgfCBudW1iZXI+O1xuICAvKipcbiAgICogc3BlY2lmeSB0aGUgbWFwcGluZyB0byB0aGUgcHJvZ3JhbSdzIG91dHB1dHMuIHRoZSB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLlxuICAgKiAtIGlmIGl0J3MgYSBub24tbmVnYXRpdmUgbnVtYmVyLCBpdCdzIHRoZSBpbmRleCBvZiB0aGUga2VybmVsJ3Mgb3V0cHV0XG4gICAqIC0gaWYgaXQncyAtMSwgaXQncyBhbiBvdXRwdXQgdGhhdCB3aWxsIGJlIGNyZWF0ZWQgYXMgYSB0ZW1wb3JhcnkgdmFsdWUuIHRoaXMgdmFsdWUgd2lsbCBiZSByZWxlYXNlZCBhZnRlclxuICAgKiB0aGUga2VybmVsIGlzIGV4ZWN1dGVkLlxuICAgKiAtIGlmIGl0J3MgLTIsIGl0J3MgYW4gb3V0cHV0IHRoYXQgd2lsbCBiZSBjcmVhdGVkIGFzIGEgcGVyc2lzdGVudCB2YWx1ZS4gdGhpcyB2YWx1ZSB3aWxsIGJlIHJlbGVhc2VkIHdoZW4gdGhlXG4gICAqIGtlcm5lbCBpcyByZWxlYXNlZC5cbiAgICpcbiAgICogaWYgb3V0cHV0cyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbWFwcGluZyB3aWxsIGJlIHRoZSBrZXJuZWwncyBvdXRwdXRzIGluIG9yZGVyLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0cz86IHJlYWRvbmx5IG51bWJlcltdO1xufVxuXG4vKipcbiAqIEEgQ29tcHV0ZUNvbnRleHQgaW5zdGFuY2UgY2FycmllcyB0aGUgc3RhdGVzIHRoYXQgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHJ1bm5pbmcgb2YgYSBrZXJuZWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcHV0ZUNvbnRleHQge1xuICAvKipcbiAgICogZ3B1IGFkYXB0ZXIgaW5mb1xuICAgKi9cbiAgcmVhZG9ubHkgYWRhcHRlckluZm86IEFkYXB0ZXJJbmZvO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIHBvaW50ZXIgdG8gT3BLZXJuZWxDb250ZXh0XG4gICAqL1xuICByZWFkb25seSBvcEtlcm5lbENvbnRleHQ6IG51bWJlcjtcblxuICAvKipcbiAgICogYSBsaXN0IG9mIGlucHV0cywgZWFjaCBpbnB1dCBpcyBhbiBpbnN0YW5jZSBvZiBUZW5zb3JWaWV3XG4gICAqL1xuICByZWFkb25seSBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXTtcblxuICAvKipcbiAgICogYSBjdXN0b20gZGF0YSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhbnkgZGF0YSB0aGF0IGlzIG5lZWRlZCBieSB0aGUga2VybmVsXG4gICAqL1xuICByZWFkb25seSBrZXJuZWxDdXN0b21EYXRhOiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfTtcblxuICAvKipcbiAgICogYSBidWZmZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBhY2Nlc3MgY3VzdG9tIGRhdGEgY3JlYXRlZCBlYWNoIHRpbWUgdGhlIGtlcm5lbCBpcyBleGVjdXRlZFxuICAgKi9cbiAgcmVhZG9ubHkgY3VzdG9tRGF0YUJ1ZmZlcjogVWludDhBcnJheTtcblxuICAvKipcbiAgICogYSBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhlIG5vZGVcbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dENvdW50OiBudW1iZXI7XG5cbiAgY29tcHV0ZShwcm9ncmFtOiBQcm9ncmFtSW5mbywgaW5wdXRzT3V0cHV0c01hcHBpbmc/OiBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nKTogVGVuc29yVmlld1tdO1xuICBvdXRwdXQoaW5kZXg6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIFRpbWVzdGFtcFF1ZXJ5ID0gJ25vbmUnIHwgJ2luc2lkZS1wYXNzZXMnIHwgJ2F0LXBhc3Nlcyc7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFdlYkdwdUJhY2tlbmQgfSBmcm9tICcuLi9iYWNrZW5kLXdlYmdwdSc7XG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi9sb2cnO1xuXG5pbXBvcnQgeyBHcHVEYXRhLCBHcHVEYXRhSWQsIEdwdURhdGFUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogbWFuYWdlcyBHcHVEYXRhSWQgLT4gR3B1QnVmZmVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR3B1RGF0YU1hbmFnZXIge1xuICAvKipcbiAgICogY29weSBkYXRhIGZyb20gQ1BVIHRvIEdQVS5cbiAgICovXG4gIHVwbG9hZChpZDogR3B1RGF0YUlkLCBkYXRhOiBVaW50OEFycmF5KTogdm9pZDtcbiAgLyoqXG4gICAqIGNvcHkgZGF0YSBmcm9tIEdQVSB0byBHUFUuXG4gICAqL1xuICBtZW1jcHkoc291cmNlSWQ6IEdwdURhdGFJZCwgZGVzdGluYXRpb25JZDogR3B1RGF0YUlkKTogdm9pZDtcbiAgLyoqXG4gICAqIGNyZWF0ZSBuZXcgZGF0YSBvbiBHUFUuXG4gICAqL1xuICBjcmVhdGUoc2l6ZTogbnVtYmVyLCB1c2FnZT86IG51bWJlcik6IEdwdURhdGE7XG4gIC8qKlxuICAgKiBnZXQgR1BVIGRhdGEgYnkgSUQuXG4gICAqL1xuICBnZXQoaWQ6IEdwdURhdGFJZCk6IEdwdURhdGEgfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiByZWxlYXNlIHRoZSBkYXRhIG9uIEdQVSBieSBJRC5cbiAgICpcbiAgICogQHJldHVybiBzaXplIG9mIHRoZSBkYXRhIHJlbGVhc2VkXG4gICAqL1xuICByZWxlYXNlKGlkOiBHcHVEYXRhSWQpOiBudW1iZXI7XG4gIC8qKlxuICAgKiBjb3B5IGRhdGEgZnJvbSBHUFUgdG8gQ1BVLlxuICAgKi9cbiAgZG93bmxvYWQoaWQ6IEdwdURhdGFJZCwgZ2V0VGFyZ2V0QnVmZmVyOiAoKSA9PiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogcmVmcmVzaCB0aGUgYnVmZmVycyB0aGF0IG1hcmtlZCBmb3IgcmVsZWFzZS5cbiAgICpcbiAgICogd2hlbiByZWxlYXNlKCkgaXMgY2FsbGVkLCB0aGUgYnVmZmVyIGlzIG5vdCByZWxlYXNlZCBpbW1lZGlhdGVseS4gdGhpcyBpcyBiZWNhdXNlIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIGNvbW1hbmRzXG4gICAqIHRvIGJlIHN1Ym1pdHRlZCB0byB0aGUgR1BVLiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgY29tbWFuZHMgYXJlIHN1Ym1pdHRlZCBzbyB0aGF0IHRoZSBidWZmZXJzIGNhbiBiZVxuICAgKiBhY3R1YWxseSByZWxlYXNlZC5cbiAgICovXG4gIHJlZnJlc2hQZW5kaW5nQnVmZmVycygpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiByZWdpc3RlciBhbiBleHRlcm5hbCBidWZmZXIgZm9yIElPIEJpbmRpbmcuIElmIHRoZSBidWZmZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkLCByZXR1cm4gdGhlIGV4aXN0aW5nIEdQVSBkYXRhIElELlxuICAgKlxuICAgKiBHUFUgZGF0YSBtYW5hZ2VyIG9ubHkgbWFuYWdlcyBhIG1hcHBpbmcgYmV0d2VlbiB0aGUgYnVmZmVyIGFuZCB0aGUgR1BVIGRhdGEgSUQuIEl0IHdpbGwgbm90IG1hbmFnZSB0aGUgbGlmZWN5Y2xlIG9mXG4gICAqIHRoZSBleHRlcm5hbCBidWZmZXIuXG4gICAqL1xuICByZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlcjogR1BVQnVmZmVyLCBvcmlnaW5hbFNpemU6IG51bWJlciwgcHJldmlvdXM/OiBbR3B1RGF0YUlkLCBHUFVCdWZmZXJdKTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiB1bnJlZ2lzdGVyIGFuIGV4dGVybmFsIGJ1ZmZlciBmb3IgSU8gQmluZGluZy5cbiAgICovXG4gIHVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihpZDogR3B1RGF0YUlkKTogdm9pZDtcblxuICAvKipcbiAgICogZGVzdHJveSBhbGwgZ3B1IGJ1ZmZlcnMuXG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBzZXNzaW9uIHJlbGF0ZWQgZGF0YS5cbiAgICovXG4gIG9uQ3JlYXRlU2Vzc2lvbigpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiByZWxlYXNlIHNlc3Npb24gcmVsYXRlZCBkYXRhLlxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIC0gc3BlY2lmeSB0aGUgc2Vzc2lvbiBJRC5cbiAgICovXG4gIG9uUmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgU3RvcmFnZUNhY2hlVmFsdWUge1xuICBncHVEYXRhOiBHcHVEYXRhO1xuICBvcmlnaW5hbFNpemU6IG51bWJlcjtcbn1cblxuY29uc3QgYnVja2V0RnJlZWxpc3Q6IE1hcDxudW1iZXIsIG51bWJlcj4gPSBuZXcgTWFwKFtcbiAgWzY0LCAyNTBdLFxuICBbMTI4LCAyMDBdLFxuICBbMjU2LCAyMDBdLFxuICBbNTEyLCAyMDBdLFxuICBbMjA0OCwgMjMwXSxcbiAgWzQwOTYsIDIwMF0sXG4gIFs4MTkyLCA1MF0sXG4gIFsxNjM4NCwgNTBdLFxuICBbMzI3NjgsIDUwXSxcbiAgWzY1NTM2LCA1MF0sXG4gIFsxMzEwNzIsIDUwXSxcbiAgWzI2MjE0NCwgNTBdLFxuICBbNTI0Mjg4LCA1MF0sXG4gIFsxMDQ4NTc2LCA1MF0sXG4gIFsyMDk3MTUyLCAzMF0sXG4gIFs0MTk0MzA0LCAyMF0sXG4gIFs4Mzg4NjA4LCAxMF0sXG4gIFsxMjU4MjkxMiwgMTBdLFxuICBbMTY3NzcyMTYsIDEwXSxcbiAgWzI2MjE0NDAwLCAxNV0sXG4gIFszMzU1NDQzMiwgMjJdLFxuICBbNDQyMzY4MDAsIDJdLFxuICBbNTg5ODI0MDAsIDZdLFxuICAvLyB3ZSBkb24ndCB3YW50IHRvIGNhY2hlIHRoZSBidWNrZXQgc2l6ZXMgYmVsb3cgYnV0IG5vdCBjYWNoaW5nIHRoZW1cbiAgLy8gcmVzdWx0cyBpbiBzb21lIG1ham9yIHBlcmZvcm1hbmNlIGhpdHMgZm9yIG1vZGVscyBsaWtlIHNkLXR1cmJvLlxuICBbNjcxMDg4NjQsIDZdLFxuICBbMTM0MjE3NzI4LCA2XSxcbiAgWzE2Nzc3MjE2MCwgNl0sXG5dKTtcblxuY29uc3QgYnVja2V0QXJyOiBudW1iZXJbXSA9IFtdO1xuXG4vKipcbiAqIG5vcm1hbGl6ZSB0aGUgYnVmZmVyIHNpemUgc28gdGhhdCBpdCBmaXRzIHRoZSAxMjgtYml0cyAoMTYgYnl0ZXMpIGFsaWdubWVudC5cbiAqL1xuY29uc3QgY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplID0gKHNpemU6IG51bWJlcikgPT4gTWF0aC5jZWlsKE51bWJlcihzaXplKSAvIDE2KSAqIDE2O1xuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgYnVmZmVyIHNpemUgc28gdGhhdCBpdCBmaXRzIGludG8gYnVja2V0cy5cbiAqL1xuY29uc3QgY2FsY0J1Y2tldEJ1ZmZlclNpemUgPSAoc2l6ZTogbnVtYmVyKSA9PiB7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGJ1Y2tldEFyci5sZW5ndGg7IGlkeCsrKSB7XG4gICAgY29uc3Qgc2l6ZUZvckJ1Y2tldCA9IGJ1Y2tldEFycltpZHhdO1xuICAgIGlmIChzaXplIDw9IHNpemVGb3JCdWNrZXQpIHtcbiAgICAgIHJldHVybiBzaXplRm9yQnVja2V0O1xuICAgIH1cbiAgfVxuICAvLyBub3QgaW4gYnVja2V0IGxpc3QgLT4gY2FsbGVyIHdpbGwgbm90IGNhY2hlLCByb3VuZCB1cCB0byAxNi5cbiAgcmV0dXJuIE1hdGguY2VpbChzaXplIC8gMTYpICogMTY7XG59O1xuXG5sZXQgZ3VpZCA9IDE7XG5jb25zdCBjcmVhdGVOZXdHcHVEYXRhSWQgPSAoKSA9PiBndWlkKys7XG5cbi8qKlxuICogZXhwb3J0ZWQgc3RhbmRhcmQgZG93bmxvYWQgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSB0aGUgc2Vzc2lvbiB0byBkb3dubG9hZCB0aGUgZGF0YSBmcm9tIEdQVSwgYW5kIGFsc28gYnlcbiAqIGZhY3RvcnkgdG8gY3JlYXRlIEdQVSB0ZW5zb3JzIHdpdGggdGhlIGNhcGFjaXR5IG9mIGRvd25sb2FkaW5nIGRhdGEgZnJvbSBHUFUuXG4gKlxuICogQHBhcmFtIGJhY2tlbmQgLSB0aGUgV2ViR1BVIGJhY2tlbmRcbiAqIEBwYXJhbSBncHVCdWZmZXIgLSB0aGUgR1BVIGJ1ZmZlciB0byBkb3dubG9hZFxuICogQHBhcmFtIG9yaWdpbmFsU2l6ZSAtIHRoZSBvcmlnaW5hbCBzaXplIG9mIHRoZSBkYXRhXG4gKiBAcGFyYW0gZ2V0VGFyZ2V0QnVmZmVyIC0gb3B0aW9uYWwuIElmIHByb3ZpZGVkLCB0aGUgZGF0YSB3aWxsIGJlIGNvcGllZCB0byB0aGUgdGFyZ2V0IGJ1ZmZlci4gT3RoZXJ3aXNlLCBhIG5ldyBidWZmZXJcbiAqIHdpbGwgYmUgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBkb3dubG9hZEdwdURhdGEgPSBhc3luYyAoXG4gIGJhY2tlbmQ6IFdlYkdwdUJhY2tlbmQsXG4gIGdwdUJ1ZmZlcjogR1BVQnVmZmVyLFxuICBvcmlnaW5hbFNpemU6IG51bWJlcixcbiAgZ2V0VGFyZ2V0QnVmZmVyPzogKCkgPT4gVWludDhBcnJheSxcbik6IFByb21pc2U8VWludDhBcnJheT4gPT4ge1xuICBjb25zdCBidWZmZXJTaXplID0gY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplKG9yaWdpbmFsU2l6ZSk7XG4gIGNvbnN0IGdwdVJlYWRCdWZmZXIgPSBiYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICB7IHNpemU6IGJ1ZmZlclNpemUsIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEIH0sXG4gICk7XG4gIHRyeSB7XG4gICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSBiYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7XG4gICAgYmFja2VuZC5lbmRDb21wdXRlUGFzcygpO1xuICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcbiAgICAgIGdwdUJ1ZmZlciAvKiBzb3VyY2UgYnVmZmVyICovLFxuICAgICAgMCAvKiBzb3VyY2Ugb2Zmc2V0ICovLFxuICAgICAgZ3B1UmVhZEJ1ZmZlciAvKiBkZXN0aW5hdGlvbiBidWZmZXIgKi8sXG4gICAgICAwIC8qIGRlc3RpbmF0aW9uIG9mZnNldCAqLyxcbiAgICAgIGJ1ZmZlclNpemUgLyogc2l6ZSAqLyxcbiAgICApO1xuICAgIGJhY2tlbmQuZmx1c2goKTtcblxuICAgIGF3YWl0IGdwdVJlYWRCdWZmZXIubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKTtcblxuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gZ3B1UmVhZEJ1ZmZlci5nZXRNYXBwZWRSYW5nZSgpO1xuICAgIGlmIChnZXRUYXJnZXRCdWZmZXIpIHtcbiAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIENQVSBidWZmZXIgdG8gYWNjZXB0IHRoZSBkYXRhLCBubyBuZWVkIHRvIGNsb25lIHRoZSBBcnJheUJ1ZmZlci5cbiAgICAgIGNvbnN0IHRhcmdldEJ1ZmZlciA9IGdldFRhcmdldEJ1ZmZlcigpO1xuICAgICAgdGFyZ2V0QnVmZmVyLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgMCwgb3JpZ2luYWxTaXplKSk7XG4gICAgICByZXR1cm4gdGFyZ2V0QnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGUgbWFwcGVkIEFycmF5QnVmZmVyIHdpbGwgYmUgcmVsZWFzZWQgd2hlbiB0aGUgR1BVIGJ1ZmZlciBpcyBkZXN0cm95ZWQuIE5lZWQgdG8gY2xvbmUgdGhlXG4gICAgICAvLyBBcnJheUJ1ZmZlci5cbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlci5zbGljZSgwLCBvcmlnaW5hbFNpemUpKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgZ3B1UmVhZEJ1ZmZlci5kZXN0cm95KCk7XG4gIH1cbn07XG5cbmNsYXNzIEdwdURhdGFNYW5hZ2VySW1wbCBpbXBsZW1lbnRzIEdwdURhdGFNYW5hZ2VyIHtcbiAgLy8gR1BVIERhdGEgSUQgPT4gR1BVIERhdGEgKCBzdG9yYWdlIGJ1ZmZlciApXG4gIHByaXZhdGUgc3RvcmFnZUNhY2hlOiBNYXA8R3B1RGF0YUlkLCBTdG9yYWdlQ2FjaGVWYWx1ZT47XG5cbiAgLy8gcGVuZGluZyBidWZmZXJzIGZvciBjb21wdXRpbmdcbiAgcHJpdmF0ZSBidWZmZXJzUGVuZGluZzogR1BVQnVmZmVyW107XG5cbiAgLy8gVGhlIHJldXNhYmxlIHN0b3JhZ2UgYnVmZmVycyBmb3IgY29tcHV0aW5nLlxuICBwcml2YXRlIGZyZWVCdWZmZXJzOiBNYXA8bnVtYmVyLCBHUFVCdWZmZXJbXT47XG4gIC8vIFRoZSByZXVzYWJsZSB1bmlmb3JtIGJ1ZmZlcnNcbiAgcHJpdmF0ZSBmcmVlVW5pZm9ybUJ1ZmZlcnM6IE1hcDxudW1iZXIsIEdQVUJ1ZmZlcltdPjtcblxuICAvLyBUaGUgcGVuZGluZ0J1ZmZlcnMgZm9yIGNhcHR1cmUgZ3JhcGguXG4gIC8vIGEgU2Vzc2lvbklEIC0+IEdQVUJ1ZmZlcltdIG1hcHBpbmcuXG4gIHByaXZhdGUgY2FwdHVyZWRQZW5kaW5nQnVmZmVyczogTWFwPG51bWJlciwgR1BVQnVmZmVyW10+O1xuXG4gIC8vIFRoZSBzZXNzaW9uIGNvdW50LlxuICBwcml2YXRlIHNlc3Npb25Db3VudDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYmFja2VuZDogV2ViR3B1QmFja2VuZCkge1xuICAgIHRoaXMuc3RvcmFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZnJlZUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5idWZmZXJzUGVuZGluZyA9IFtdO1xuICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycyA9IG5ldyBNYXAoKTtcblxuICAgIGZvciAoY29uc3QgW2tleV0gb2YgYnVja2V0RnJlZWxpc3QpIHtcbiAgICAgIGJ1Y2tldEFyci5wdXNoKGtleSk7XG4gICAgICB0aGlzLmZyZWVCdWZmZXJzLnNldChrZXksIFtdKTtcbiAgICAgIHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLnNldChrZXksIFtdKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlc3Npb25Db3VudCA9IDA7XG4gIH1cblxuICB1cGxvYWQoaWQ6IEdwdURhdGFJZCwgZGF0YTogVWludDhBcnJheSk6IHZvaWQge1xuICAgIGNvbnN0IHNyY0FycmF5QnVmZmVyID0gZGF0YS5idWZmZXI7XG4gICAgY29uc3Qgc3JjT2Zmc2V0ID0gZGF0YS5ieXRlT2Zmc2V0O1xuICAgIGNvbnN0IHNyY0xlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBzaXplID0gY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplKHNyY0xlbmd0aCk7XG5cbiAgICAvLyBnZXQgZGVzdGluYXRpb24gZ3B1IGJ1ZmZlclxuICAgIGNvbnN0IGdwdURhdGFDYWNoZSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChpZCk7XG4gICAgaWYgKCFncHVEYXRhQ2FjaGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ3B1IGRhdGEgZm9yIHVwbG9hZGluZyBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgICBpZiAoTnVtYmVyKGdwdURhdGFDYWNoZS5vcmlnaW5hbFNpemUpICE9PSBzcmNMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW5jb25zaXN0ZW50IGRhdGEgc2l6ZS4gZ3B1IGRhdGEgc2l6ZT0ke2dwdURhdGFDYWNoZS5vcmlnaW5hbFNpemV9LCBkYXRhIHNpemU9JHtzcmNMZW5ndGh9YCk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGdwdSBidWZmZXJcbiAgICBjb25zdCBncHVCdWZmZXJGb3JVcGxvYWRpbmcgPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICB7IG1hcHBlZEF0Q3JlYXRpb246IHRydWUsIHNpemUsIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5NQVBfV1JJVEUgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyB9LFxuICAgICk7XG5cbiAgICAvLyBjb3B5ICh1cGxvYWQpIGRhdGFcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGdwdUJ1ZmZlckZvclVwbG9hZGluZy5nZXRNYXBwZWRSYW5nZSgpO1xuICAgIG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKS5zZXQobmV3IFVpbnQ4QXJyYXkoc3JjQXJyYXlCdWZmZXIsIHNyY09mZnNldCwgc3JjTGVuZ3RoKSk7XG4gICAgZ3B1QnVmZmVyRm9yVXBsb2FkaW5nLnVubWFwKCk7XG5cbiAgICAvLyBHUFUgY29weVxuICAgIGNvbnN0IGNvbW1hbmRFbmNvZGVyID0gdGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihncHVCdWZmZXJGb3JVcGxvYWRpbmcsIDAsIGdwdURhdGFDYWNoZS5ncHVEYXRhLmJ1ZmZlciwgMCwgc2l6ZSk7XG4gICAgdGhpcy5iYWNrZW5kLmRldmljZS5xdWV1ZS5zdWJtaXQoW2NvbW1hbmRFbmNvZGVyLmZpbmlzaCgpXSk7XG4gICAgZ3B1QnVmZmVyRm9yVXBsb2FkaW5nLmRlc3Ryb3koKTtcblxuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51cGxvYWQoaWQ9JHtpZH0pYCk7XG4gIH1cblxuICBtZW1jcHkoc291cmNlSWQ6IEdwdURhdGFJZCwgZGVzdGluYXRpb25JZDogR3B1RGF0YUlkKTogdm9pZCB7XG4gICAgLy8gZ2V0IHNvdXJjZSBncHUgYnVmZmVyXG4gICAgY29uc3Qgc291cmNlR3B1RGF0YUNhY2hlID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHNvdXJjZUlkKTtcbiAgICBpZiAoIXNvdXJjZUdwdURhdGFDYWNoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgICAvLyBnZXQgZGVzdGluYXRpb24gZ3B1IGJ1ZmZlclxuICAgIGNvbnN0IGRlc3RpbmF0aW9uR3B1RGF0YUNhY2hlID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGRlc3RpbmF0aW9uSWQpO1xuICAgIGlmICghZGVzdGluYXRpb25HcHVEYXRhQ2FjaGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGVzdGluYXRpb24gZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgICBpZiAoc291cmNlR3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZSAhPT0gZGVzdGluYXRpb25HcHVEYXRhQ2FjaGUub3JpZ2luYWxTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29uc2lzdGVudCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGdwdSBkYXRhIHNpemUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaXplID0gY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplKHNvdXJjZUdwdURhdGFDYWNoZS5vcmlnaW5hbFNpemUpO1xuXG4gICAgLy8gR1BVIGNvcHlcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO1xuICAgIHRoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpO1xuICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcbiAgICAgIHNvdXJjZUdwdURhdGFDYWNoZS5ncHVEYXRhLmJ1ZmZlcixcbiAgICAgIDAsXG4gICAgICBkZXN0aW5hdGlvbkdwdURhdGFDYWNoZS5ncHVEYXRhLmJ1ZmZlcixcbiAgICAgIDAsXG4gICAgICBzaXplLFxuICAgICk7XG4gIH1cblxuICByZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlcjogR1BVQnVmZmVyLCBvcmlnaW5hbFNpemU6IG51bWJlciwgcHJldmlvdXM/OiBbR3B1RGF0YUlkLCBHUFVCdWZmZXJdKTogbnVtYmVyIHtcbiAgICBsZXQgaWQ6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgIGlkID0gcHJldmlvdXNbMF07XG4gICAgICBpZiAoYnVmZmVyID09PSBwcmV2aW91c1sxXSkge1xuICAgICAgICBMT0dfREVCVUcoXG4gICAgICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgICAgICgpID0+XG4gICAgICAgICAgICBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7b3JpZ2luYWxTaXplfSkgPT4gaWQ9JHtpZH0sIGJ1ZmZlciBpcyB0aGUgc2FtZSwgc2tpcC5gLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYmFja2VuZC5jYXB0dXJlZENvbW1hbmRMaXN0Lmhhcyh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVnaXN0ZXJpbmcgYSBkaWZmZXJlbnQgZXh0ZXJuYWwgYnVmZmVyIHVuZGVyIGdyYXBoIGNhcHR1cmUgbW9kZSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cbiAgICAgICAgICAgICBQbGVhc2UgdXNlIHRoZSBwcmV2aW91cyBleHRlcm5hbCBidWZmZXIhYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkID0gY3JlYXRlTmV3R3B1RGF0YUlkKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KGlkLCB7IGdwdURhdGE6IHsgaWQsIHR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQsIGJ1ZmZlciB9LCBvcmlnaW5hbFNpemUgfSk7XG4gICAgTE9HX0RFQlVHKFxuICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke29yaWdpbmFsU2l6ZX0pID0+IGlkPSR7aWR9LCByZWdpc3RlcmVkLmAsXG4gICAgKTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICB1bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoaWQ6IEdwdURhdGFJZCk6IHZvaWQge1xuICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUoaWQpO1xuICAgICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcigpID0+IGlkPSR7aWR9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgY3JlYXRlKHNpemU6IG51bWJlciwgdXNhZ2UgPSBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCk6IEdwdURhdGEge1xuICAgIGNvbnN0IGJ1ZmZlclNpemUgPSBjYWxjQnVja2V0QnVmZmVyU2l6ZShzaXplKTtcblxuICAgIGxldCBncHVCdWZmZXI7XG4gICAgLy8gQ3VycmVudGx5LCBvbmx5IHN0b3JhZ2UgYnVmZmVycyBhcmUgcmV1c2VkLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgY29uc3QgaXNTdG9yYWdlID0gKHVzYWdlICYgR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSkgPT09IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0U7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBjb25zdCBpc1VuaWZvcm0gPSAodXNhZ2UgJiBHUFVCdWZmZXJVc2FnZS5VTklGT1JNKSA9PT0gR1BVQnVmZmVyVXNhZ2UuVU5JRk9STTtcbiAgICBpZiAoaXNTdG9yYWdlIHx8IGlzVW5pZm9ybSkge1xuICAgICAgY29uc3QgZnJlZUJ1ZmZlcnMgPSBpc1N0b3JhZ2UgPyB0aGlzLmZyZWVCdWZmZXJzIDogdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM7XG4gICAgICBjb25zdCBidWZmZXJzID0gZnJlZUJ1ZmZlcnMuZ2V0KGJ1ZmZlclNpemUpO1xuICAgICAgaWYgKCFidWZmZXJzKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggYnVja2V0L2ZyZWVsaXN0IC0gY3JlYXRlIGdwdSBidWZmZXJcbiAgICAgICAgZ3B1QnVmZmVyID0gdGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoeyBzaXplOiBidWZmZXJTaXplLCB1c2FnZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChidWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBpbiBmcmVlbGlzdCwgdXNlIGl0XG4gICAgICAgICAgZ3B1QnVmZmVyID0gYnVmZmVycy5wb3AoKSBhcyBHUFVCdWZmZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYnVja2V0IGVtcHR5LCBjcmVhdGUgZ3B1IGJ1ZmZlclxuICAgICAgICAgIGdwdUJ1ZmZlciA9IHRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHsgc2l6ZTogYnVmZmVyU2l6ZSwgdXNhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIGdwdSBidWZmZXJcbiAgICAgIGdwdUJ1ZmZlciA9IHRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHsgc2l6ZTogYnVmZmVyU2l6ZSwgdXNhZ2UgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ3B1RGF0YSA9IHsgaWQ6IGNyZWF0ZU5ld0dwdURhdGFJZCgpLCB0eXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0LCBidWZmZXI6IGdwdUJ1ZmZlciB9O1xuICAgIHRoaXMuc3RvcmFnZUNhY2hlLnNldChncHVEYXRhLmlkLCB7IGdwdURhdGEsIG9yaWdpbmFsU2l6ZTogTnVtYmVyKHNpemUpIH0pO1xuXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLmNyZWF0ZShzaXplPSR7c2l6ZX0pID0+IGlkPSR7Z3B1RGF0YS5pZH1gKTtcbiAgICByZXR1cm4gZ3B1RGF0YTtcbiAgfVxuXG4gIGdldChpZDogR3B1RGF0YUlkKTogR3B1RGF0YSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLmdldChpZCk/LmdwdURhdGE7XG4gIH1cblxuICByZWxlYXNlKGlkSW5wdXQ6IEdwdURhdGFJZCk6IG51bWJlciB7XG4gICAgY29uc3QgaWQgPSB0eXBlb2YgaWRJbnB1dCA9PT0gJ2JpZ2ludCcgPyBOdW1iZXIoaWRJbnB1dCkgOiBpZElucHV0O1xuICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQoaWQpO1xuICAgIGlmICghY2FjaGVkRGF0YSkge1xuICAgICAgaWYgKHRoaXMuc3RvcmFnZUNhY2hlLnNpemUgPT09IDApIHtcbiAgICAgICAgLy8gY2FjaGUgd2FzIHByZXZpb3VzbHkgY2xlYXJlZCwgbm8gbmVlZCB0byByZWxlYXNlIGFueXRoaW5nLlxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVsZWFzaW5nIGRhdGEgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVsZWFzZShpZD0ke2lkfSksIGdwdURhdGFJZD0ke2NhY2hlZERhdGEuZ3B1RGF0YS5pZH1gKTtcblxuICAgIHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZShpZCk7XG4gICAgdGhpcy5idWZmZXJzUGVuZGluZy5wdXNoKGNhY2hlZERhdGEuZ3B1RGF0YS5idWZmZXIpO1xuICAgIC8vIGNhY2hlZERhdGEuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpO1xuXG4gICAgcmV0dXJuIGNhY2hlZERhdGEub3JpZ2luYWxTaXplO1xuICB9XG5cbiAgYXN5bmMgZG93bmxvYWQoaWQ6IEdwdURhdGFJZCwgZ2V0VGFyZ2V0QnVmZmVyOiAoKSA9PiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChOdW1iZXIoaWQpKTtcbiAgICBpZiAoIWNhY2hlZERhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YSBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgICBhd2FpdCBkb3dubG9hZEdwdURhdGEodGhpcy5iYWNrZW5kLCBjYWNoZWREYXRhLmdwdURhdGEuYnVmZmVyLCBjYWNoZWREYXRhLm9yaWdpbmFsU2l6ZSwgZ2V0VGFyZ2V0QnVmZmVyKTtcbiAgfVxuXG4gIHJlZnJlc2hQZW5kaW5nQnVmZmVycygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5idWZmZXJzUGVuZGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXMgPT09ICdkZWZhdWx0Jykge1xuICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgdGhpcy5idWZmZXJzUGVuZGluZykge1xuICAgICAgICBjb25zdCBtYXhJbkZyZWVMaXN0ID0gYnVja2V0RnJlZWxpc3QuZ2V0KGJ1ZmZlci5zaXplKTtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICBpZiAoKGJ1ZmZlci51c2FnZSAmIEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpID09PSBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKSB7XG4gICAgICAgICAgLy8gUHV0IHRoZSBwZW5kaW5nIGJ1ZmZlciB0byBmcmVlQnVmZmVycyBsaXN0IGluc3RlYWQgb2YgcmVhbGx5IGRlc3Ryb3lpbmcgaXQgZm9yIGJ1ZmZlciByZXVzaW5nLlxuICAgICAgICAgIGNvbnN0IGZyZWVsaXN0ID0gdGhpcy5mcmVlQnVmZmVycy5nZXQoYnVmZmVyLnNpemUpIHx8IFtdO1xuICAgICAgICAgIGlmIChtYXhJbkZyZWVMaXN0ID09PSB1bmRlZmluZWQgfHwgZnJlZWxpc3QubGVuZ3RoID49IG1heEluRnJlZUxpc3QpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyZWVsaXN0LnB1c2goYnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgfSBlbHNlIGlmICgoYnVmZmVyLnVzYWdlICYgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSkgPT09IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pIHtcbiAgICAgICAgICAvLyBQdXQgdGhlIHBlbmRpbmcgYnVmZmVyIHRvIGZyZWVVbmlmb3JtQnVmZmVycyBsaXN0IGluc3RlYWQgb2YgcmVhbGx5IGRlc3Ryb3lpbmcgaXQgZm9yIGJ1ZmZlciByZXVzaW5nLlxuICAgICAgICAgIGNvbnN0IGZyZWVsaXN0ID0gdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuZ2V0KGJ1ZmZlci5zaXplKSB8fCBbXTtcbiAgICAgICAgICBpZiAobWF4SW5GcmVlTGlzdCA9PT0gdW5kZWZpbmVkIHx8IGZyZWVsaXN0Lmxlbmd0aCA+PSBtYXhJbkZyZWVMaXN0KSB7XG4gICAgICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmVlbGlzdC5wdXNoKGJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRG9uJ3QgcmVsZWFzZSBpbnRlcm1lZGlhdGUgdGVuc29ycyBpbiBub24tZGVmYXVsdCBtb2RlLlxuICAgICAgLy8gVE9ETzogcmV1c2UgdGhlIHN0b3JhZ2UgYnVmZmVycyBpbiBub24tZGVmYXVsdCBtb2RlLlxuICAgICAgbGV0IGNhcHR1cmVkQnVmZmVycyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQhKTtcbiAgICAgIGlmICghY2FwdHVyZWRCdWZmZXJzKSB7XG4gICAgICAgIGNhcHR1cmVkQnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuc2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkISwgY2FwdHVyZWRCdWZmZXJzKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpIHtcbiAgICAgICAgY2FwdHVyZWRCdWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcgPSBbXTtcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZnJlZUJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVycykgPT4ge1xuICAgICAgYnVmZmVycy5mb3JFYWNoKChidWZmZXIpID0+IHtcbiAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmZvckVhY2goKGJ1ZmZlcnMpID0+IHtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiB7XG4gICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2goKHN0b3JhZ2UpID0+IHtcbiAgICAgIHN0b3JhZ2UuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmZvckVhY2goKGJ1ZmZlcnMpID0+IHtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiB7XG4gICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnN0b3JhZ2VDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmZyZWVCdWZmZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIG9uQ3JlYXRlU2Vzc2lvbigpIHtcbiAgICB0aGlzLnNlc3Npb25Db3VudCArPSAxO1xuICB9XG5cbiAgb25SZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQ6IG51bWJlcikge1xuICAgIC8vIHJlbGVhc2UgdGhlIGNhcHR1cmVkIHBlbmRpbmcgYnVmZmVycy5cbiAgICBjb25zdCBwZW5kaW5nQnVmZmVycyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQoc2Vzc2lvbklkKTtcbiAgICBpZiAocGVuZGluZ0J1ZmZlcnMpIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJzLmZvckVhY2goKGJ1ZmZlcikgPT4ge1xuICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgfVxuXG4gICAgLy8gcmVsZWFzZSB0aGUgc3RvcmFnZSBjYWNoZSBpZiBubyBhY3RpdmUgc2Vzc2lvbnMuXG4gICAgdGhpcy5zZXNzaW9uQ291bnQgLT0gMTtcbiAgICBpZiAodGhpcy5zZXNzaW9uQ291bnQgPT09IDApIHtcbiAgICAgIExPR19ERUJVRygnd2FybmluZycsICgpID0+ICdbV2ViR1BVXSBDbGVhcmluZyB3ZWJncHUgYnVmZmVyIGNhY2hlJyk7XG4gICAgICB0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG4gICAgICAgIHN0b3JhZ2UuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0b3JhZ2VDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUdwdURhdGFNYW5hZ2VyID0gKC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczx0eXBlb2YgR3B1RGF0YU1hbmFnZXJJbXBsPik6IEdwdURhdGFNYW5hZ2VyID0+XG4gIG5ldyBHcHVEYXRhTWFuYWdlckltcGwoLi4uYXJncyk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmNsYXNzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleUltcGwge1xuICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBhdHRyaWJ1dGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBrZXk6IHN0cmluZztcbiAgcHVibGljIGdldCBjYWNoZUtleSgpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5rZXkpIHtcbiAgICAgIHRoaXMua2V5ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcylcbiAgICAgICAgLnNvcnQoKVxuICAgICAgICAubWFwKChuYW1lKSA9PiBgJHsodGhpcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbbmFtZV19YClcbiAgICAgICAgLmpvaW4oJzsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMua2V5O1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgY2FjaGVLZXk6IHN0cmluZztcbn1cblxuLyoqXG4gKiBjcmVhdGUgYSBuZXcgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGF0dHJpYnV0ZSwgYW5kIGFkZCBhIGNhY2hlS2V5IHByb3BlcnR5IHRvIGl0XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgPSA8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgYXR0cmlidXRlOiBULFxuKTogVCAmIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSA9PiBuZXcgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbChhdHRyaWJ1dGUpIGFzIHVua25vd24gYXMgVCAmIEF0dHJpYnV0ZVdpdGhDYWNoZUtleTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IFByb2dyYW1Vbmlmb3JtLCBQcm9ncmFtVW5pZm9ybVZhcmlhYmxlSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBjb25zdGFudCB2YWx1ZSBmb3IgYSB3b3JrZ3JvdXAgc2l6ZS5cbiAqXG4gKiBXZSBkZWZpbml0ZWx5IGNhbiBkbyBmdXJ0aGVyIG9wdGltaXphdGlvbiBpbiBmdXR1cmUsIGJ1dCBmb3Igbm93IHdlIHVzZSA2NC5cbiAqXG4gKiBydWxlIG9mIHRodW1iOiBVc2UgW2Egd29ya2dyb3VwIHNpemUgb2ZdIDY0IHVubGVzcyB5b3Uga25vdyB3aGF0IEdQVSB5b3UgYXJlIHRhcmdldGluZyBvciB0aGF0IHlvdXIgd29ya2xvYWRcbiAqICAgICAgICAgICAgICAgIG5lZWRzIHNvbWV0aGluZyBkaWZmZXJlbnQuXG4gKlxuICogZnJvbTogaHR0cHM6Ly9zdXJtYS5kZXYvdGhpbmdzL3dlYmdwdS9cbiAqKi9cbmV4cG9ydCBjb25zdCBXT1JLR1JPVVBfU0laRSA9IDY0O1xuXG5pbnRlcmZhY2UgSW5kaWNlc0hlbHBlclR5cGVzIHtcbiAgLyoqXG4gICAqIFdHU0wgdHlwZSBvZiBpbmRpY2VzIGV4cHJlc3Npb25cbiAgICovXG4gIHJlYWRvbmx5IGluZGljZXM6IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCB0eXBlIG9mIGEgdmFsdWVcbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgdHlwZSBvZiBzdG9yYWdlIHR5cGUgcmVwcmVzZW50aW5nIGEgdmFsdWVcbiAgICpcbiAgICogVGhpcyBpcyB1c3VhbGx5IHRoZSBzYW1lIHRvIGB2YWx1ZWAsIGJ1dCBmb3Igc29tZSB0eXBlIChlZy4gYm9vbCksIHdlIG5lZWQgdG8gdXNlIGB1MzJgIGFzIHN0b3JhZ2UgdHlwZSBmb3JcbiAgICogdmFsdWUgdHlwZSBgdmVjNDxib29sPmBcbiAgICovXG4gIHJlYWRvbmx5IHN0b3JhZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogdGVuc29yIHR5cGUgYXMgcmVwcmVzZW50ZWQgaW4gVGVuc29yVmlld1xuICAgKi9cbiAgcmVhZG9ubHkgdGVuc29yOiBudW1iZXI7XG59XG5cbi8qKlxuICogQSBoZWxwZXIgY2xhc3MgZm9yIGdlbmVyYXRpbmcgV0dTTCBjb2RlIGZvciBtYW5pcHVsYXRpbmcgaW5kaWNlcyBhbmQgZGF0YSBmb3IgYSBzaGFkZXIncyBpbnB1dCBvciBvdXRwdXQuXG4gKlxuICogVGhpcyBjbGFzcyBpcyBkZXNpZ25lZCB0byBvZmZlciBhIHVuaWZpZWQgd2F5IHRvIGdlbmVyYXRlIFdHU0wgY29kZSBmb3IgbWFuaXB1bGF0aW5nIGluZGljZXMgYW5kIGRhdGEgZm9yIGEgc2hhZGVyJ3NcbiAqIGlucHV0IG9yIG91dHB1dC5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGlzIGEgbGlzdCBvZiB0ZXJtaW5vbG9naWVzIHVzZWQgaW4gdGhpcyBjbGFzczpcbiAqIC0gYG9mZnNldGA6IGEgdWludDMyIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0IG9mIGFuIGVsZW1lbnQgaW4gdGhlIGRhdGEgYnVmZmVyLlxuICogLSBgaW5kaWNlc2A6IGFuIGFic3RyYWN0aW9uIG9mIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkncyBpbmRpY2VzIHJlcHJlc2VudGluZyB0aGUgZGF0YSdzIGluZGV4IG9uIGVhY2ggZGltZW5zaW9uLlxuICogLSBgdmFsdWVgOiBhIHZhbHVlIG9mIGEgZGF0YSBlbGVtZW50LlxuICpcbiAqIFVzZXJzIGFyZSBleHBlY3RlZCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBmb3IgZWFjaCBzaGFkZXIncyBpbnB1dCBvciBvdXRwdXQsIGFuZCB1c2UgdGhlIGluc3RhbmNlIHRvXG4gKiBnZW5lcmF0ZSBXR1NMIGNvZGUgZm9yIG1hbmlwdWxhdGluZyBpbmRpY2VzIGFuZCBkYXRhLiBUaGUgZm9sbG93aW5nIDIgZXhwb3J0ZWQgZnVuY3Rpb25zIGFyZSBmb3IgdXNlcnMgdG8gY2FsbCB0b1xuICogY3JlYXRlIGFuIGluc3RhbmNlIG9mIGFuIGluZGljZXMgaGVscGVyOlxuICogLSBgaW5wdXRWYXJpYWJsZSgpYDogY3JlYXRlIGFuIGluZGljZXMgaGVscGVyIGluc3RhbmNlIGZvciBhbiBpbnB1dC5cbiAqIC0gYG91dHB1dFZhcmlhYmxlKClgOiBjcmVhdGUgYW4gaW5kaWNlcyBoZWxwZXIgaW5zdGFuY2UgZm9yIGFuIG91dHB1dC5cbiAqIC0gYGludGVybmFsVmFyaWFibGUoKWA6IGNyZWF0ZSBhbiBpbmRpY2VzIGhlbHBlciBpbnN0YW5jZSBmb3IgYW4gaW50ZXJuYWwgdmFyaWFibGUuXG4gKlxuICogQW4gaW5kaWNlcyBoZWxwZXIgaW5zdGFuY2UgY29udGFpbnMgaGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIGZvbGxvd2luZyBvcGVyYXRpb25zOlxuICogLSBhY2Nlc3MgcmVhZG9ubHkgYmFzaWMgaW5mb3JtYXRpb24sIGluY2x1ZGluZzogYG5hbWVgKHRoZSBuYW1lIG9mIHRoZSBpbnB1dCBvciBvdXRwdXQpLCBgdXNhZ2VgKHdoZXRoZXIgaXQncyBhblxuICogaW5wdXQsIGFuIG91dHB1dCBvciBhbiBpbnRlcm5hbCB2YXJpYWJsZSkgYW5kIGBzaGFwZWAodGhlIHBhc3NlZCBpbiBzaGFwZSkuXG4gKiAtIGB0eXBlYDogYWNjZXNzIHJlYWRvbmx5IHR5cGUgaW5mb3JtYXRpb24sIGluY2x1ZGluZzogYGluZGljZXNgKHRoZSB0eXBlIG9mIGluZGljZXMpLCBgdmFsdWVgKHRoZSB0eXBlIG9mIHZhbHVlIGF0XG4gKiBydW50aW1lKSwgYHN0b3JhZ2VgKHRoZSB0eXBlIG9mIHZhbHVlIGF0IHN0b3JhZ2UpIGFuZCBgdGVuc29yYCh0aGUgdGVuc29yIHR5cGUgYXMgcmVwcmVzZW50ZWQgaW4gVGVuc29yVmlldykuXG4gKiAtIGdlbmVyYXRlIFdHU0wgY29kZSBmb3IgZ2V0dGluZyBpbmRpY2VzIGZyb20gb2Zmc2V0LiBVc2UgYG9mZnNldFRvSW5kaWNlcygpYCBmb3IgV0dTTCBjb2RlIHNuaXBwZXQgdG8gY2FsY3VsYXRlXG4gKiBpbmRpY2VzIGZyb20gb2Zmc2V0LCBhbmQgdXNlIGBpbmRpY2VzVG9PZmZzZXQoKWAgZm9yIFdHU0wgY29kZSBzbmlwcGV0IHRvIGNhbGN1bGF0ZSBvZmZzZXQgZnJvbSBpbmRpY2VzLlxuICogLSB0byBtYW5pcHVsYXRlIGFuIGluc3RhbmNlIG9mIGluZGljZXMsIHVzZSBgc2V0SW5kaWNlcygpYCBhbmQgYGdldEluZGljZXMoKWAgdG8gc2V0IGFuZCBnZXQgdGhlIGluZGljZXMgb24gYW5cbiAqIGluZGljZXMgdmFyaWFibGUuXG4gKiAtIHRvIG1hbmlwdWxhdGUgZGF0YSwgdXNlIGBzZXQoKWAvYGdldCgpYCB0byBhY2Nlc3MgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcyBmcm9tIHBhcmFtZXRlciBsaXN0LCB1c2VcbiAqIGBzZXRCeUluZGljZXMoKWAvYGdldEJ5SW5kaWNlcygpYCB0byBhY2Nlc3MgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcyBmcm9tIGFuIGluZGljZXMgdmFyaWFibGUsIGFuZCB1c2VcbiAqIGBzZXRCeU9mZnNldCgpYC9gZ2V0QnlPZmZzZXQoKWAgdG8gYWNjZXNzIGRhdGEgYXQgdGhlIGdpdmVuIG9mZnNldC5cbiAqIC0gYGltcGxgOiBnZXQgV0dTTCBjb2RlIG9mIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIGZvciB0aGUgdXRpbCBmdW5jdGlvbnMgbWVudGlvbmVkIGFib3ZlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEluZGljZXNIZWxwZXIge1xuICAvKipcbiAgICogZ2V0IFdHU0wgY29kZSBvZiBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHV0aWwgZnVuY3Rpb25zLlxuICAgKlxuICAgKi9cbiAgcmVhZG9ubHkgaW1wbDogKCkgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBnZXQgdHlwZSBpbmZvXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBJbmRpY2VzSGVscGVyVHlwZXM7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBhIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgaW5kaWNlcyBmcm9tIG9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIHZhck9mZnNldCAtIGEgdTMyIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQuXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGB0eXBlLmluZGljZXNgIGV4cHJlc3Npb25cbiAgICovXG4gIHJlYWRvbmx5IG9mZnNldFRvSW5kaWNlczogKHZhck9mZnNldDogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBhbiBgdTMyYCBleHByZXNzaW9uIGZvciBnZXR0aW5nIG9mZnNldCBmcm9tIGluZGljZXMuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSBgdHlwZS5pbmRpY2VzYCBleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGUgaW5kaWNlcy5cbiAgICpcbiAgICogQHJldHVybnMgYW4gYHUzMmAgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlc1RvT2Zmc2V0OiAodmFySW5kaWNlczogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBhbiBgdTMyYCBleHByZXNzaW9uIGZvciBnZXR0aW5nIG9yaWdpbmFsIG9mZnNldCBmcm9tIGJyb2FkY2FzdGVkIGluZGljZXMuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSBgdHlwZS5pbmRpY2VzYCBleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGUgb3V0cHV0IGluZGljZXMuXG4gICAqIEBwYXJhbSBvdXRwdXQgLSBvdXRwdXQgSW5kaWNlc0hlbHBlci5cbiAgICpcbiAgICogQHJldHVybnMgYW4gYHUzMmAgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6ICh2YXJJbmRpY2VzOiBzdHJpbmcsIG91dHB1dDogSW5kaWNlc0hlbHBlcikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgb2YgZ2VuZXJhdGluZyBhbiBpbmRpY2VzIGxpdGVyYWxcbiAgICpcbiAgICogQHBhcmFtIGluaXQgLSBpbml0aWFsIHZhbHVlLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlczogKC4uLmluaXQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgb2YgYSBzdGF0ZW1lbnQgZm9yIHNldHRpbmcgaW5kaWNlcy5cbiAgICpcbiAgICogQHBhcmFtIHZhckluZGljZXMgLSBhIHZhcmlhYmxlIG5hbWUgZm9yIHRoZSBpbmRpY2VzLlxuICAgKiBAcGFyYW0gaWR4IC0gdGhlIGluZGV4IG9mIHRoZSBpbmRpY2VzIHRvIHNldC4gY2FuIGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pLlxuICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gc2V0LiBjYW4gYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgV0dTTCBzdGF0ZW1lbnRcbiAgICovXG4gIHJlYWRvbmx5IGluZGljZXNTZXQ6ICh2YXJJbmRpY2VzOiBzdHJpbmcsIGlkeDogbnVtYmVyIHwgc3RyaW5nLCB2YWx1ZTogbnVtYmVyIHwgc3RyaW5nKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgb2YgYW4gYHUzMmAgZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXG4gICAqIEBwYXJhbSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIGluZGljZXMgdG8gZ2V0LiBjYW4gYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikuXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGB1MzJgIGV4cHJlc3Npb25cbiAgICovXG4gIHJlYWRvbmx5IGluZGljZXNHZXQ6ICh2YXJJbmRpY2VzOiBzdHJpbmcsIGlkeDogbnVtYmVyIHwgc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBmb3IgYSBzdGF0ZW1lbnQgZm9yIHNldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcy5cbiAgICpcbiAgICogQHBhcmFtIGluZGljZXNBbmRWYWx1ZSAtIGFuIGFycmF5IG9mIG51bWJlcnMgb3Igc3RyaW5ncyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKSByZXByZXNlbnRpbmcgdGhlIGluZGljZXMsIGZvbGxvd2VkXG4gICAqICAgICBieSB0aGUgdmFsdWUgdG8gc2V0LiBUaGlzIGFycmF5IHNob3VsZCBoYXZlIGV4YWN0bHkgYHNoYXBlLmxlbmd0aCArIDFgIGVsZW1lbnRzLlxuICAgKi9cbiAgcmVhZG9ubHkgc2V0OiAoLi4uaW5kaWNlc0FuZFZhbHVlOiBSZWFkb25seUFycmF5PG51bWJlciB8IHN0cmluZz4pID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIGZvciBhIHN0YXRlbWVudCBmb3Igc2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzIHZhcmlhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuIHNob3VsZCBiZSBhIFdHU0wgZXhwcmVzc2lvbi5cbiAgICovXG4gIHJlYWRvbmx5IHNldEJ5SW5kaWNlczogKHZhckluZGljZXM6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGEgc3RhdGVtZW50IGZvciBzZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIG9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIG9mZnNldCAtIGEgbnVtYmVyIG9yIGEgc3RyaW5nIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0LlxuICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gc2V0LiBzaG91bGQgYmUgYSBXR1NMIGV4cHJlc3Npb24uXG4gICAqL1xuICByZWFkb25seSBzZXRCeU9mZnNldDogKG9mZnNldDogbnVtYmVyIHwgc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBmb3IgYW4gZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5kaWNlcyAtIGFuIGFycmF5IG9mIG51bWJlcnMgb3Igc3RyaW5ncyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKSByZXByZXNlbnRpbmcgdGhlIGluZGljZXMuXG4gICAqL1xuICByZWFkb25seSBnZXQ6ICguLi5pbmRpY2VzOiBSZWFkb25seUFycmF5PG51bWJlciB8IHN0cmluZz4pID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIGZvciBhbiBleHByZXNzaW9uIGZvciBnZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kaWNlcy5cbiAgICovXG4gIHJlYWRvbmx5IGdldEJ5SW5kaWNlczogKHZhckluZGljZXM6IHN0cmluZykgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGFuIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQuXG4gICAqL1xuICByZWFkb25seSBnZXRCeU9mZnNldDogKG9mZnNldDogbnVtYmVyIHwgc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIG5hbWUgb2YgdGhlIGRhdGEgdmFyaWFibGVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogd2hldGhlciB0aGUgaGVscGVyIGlzIGZvciBhbiBpbnB1dCwgYW4gb3V0cHV0IG9yIGFuIGludGVybmFsIHZhcmlhYmxlLlxuICAgKi9cbiAgcmVhZG9ubHkgdXNhZ2U6ICdpbnB1dCcgfCAnb3V0cHV0JyB8ICdhdG9taWNPdXRwdXQnIHwgJ2ludGVybmFsJztcblxuICAvKipcbiAgICogdGhlIHJhbmsgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHJhbms6IG51bWJlcjtcblxuICAvKipcbiAgICogYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHNoYXBlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFyaWFibGUgbmFtZSBmb3IgdGhlIHN0cmlkZXMgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHN0cmlkZXM6IHN0cmluZztcbn1cblxuY29uc3QgZ2V0V2dzbE1hcHBlZFR5cGUgPSAodHlwZTogbnVtYmVyLCBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0KTogc3RyaW5nIHwgW3N0cmluZywgc3RyaW5nXSA9PiB7XG4gIGlmIChjb21wb25lbnRzID09PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2ZWMzIGhhcyBzYW1lIGFsaWdubWVudCBhcyB2ZWM0LCB1c2UgdmVjNCBpbnN0ZWFkJyk7XG4gIH1cblxuICAvLyByZXR1cm4gdHlwZSBpcyBbIHN0b3JhZ2UgdHlwZSwgcnVudGltZSB0eXBlIF0gb3IgYSBzaW5nbGUgc3RyaW5nIGZvciBib3RoXG4gIHN3aXRjaCAoTnVtYmVyKHR5cGUpKSB7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDE2OlxuICAgICAgcmV0dXJuIGNvbXBvbmVudHMgPiAxID8gYHZlYyR7Y29tcG9uZW50c308ZjE2PmAgOiAnZjE2JztcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0OlxuICAgICAgcmV0dXJuIGNvbXBvbmVudHMgPiAxID8gYHZlYyR7Y29tcG9uZW50c308ZjMyPmAgOiAnZjMyJztcbiAgICBjYXNlIERhdGFUeXBlLmludDMyOlxuICAgICAgcmV0dXJuIGNvbXBvbmVudHMgPiAxID8gYHZlYyR7Y29tcG9uZW50c308aTMyPmAgOiAnaTMyJztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQzMjpcbiAgICAgIHJldHVybiBjb21wb25lbnRzID4gMSA/IGB2ZWMke2NvbXBvbmVudHN9PHUzMj5gIDogJ3UzMic7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQ2NDpcbiAgICAgIGlmIChjb21wb25lbnRzID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsndmVjMjx1MzI+JywgJ2kzMiddO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDY0OlxuICAgICAgaWYgKGNvbXBvbmVudHMgPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gWyd2ZWMyPHUzMj4nLCAndTMyJ107XG4gICAgY2FzZSBEYXRhVHlwZS5ib29sOlxuICAgICAgaWYgKGNvbXBvbmVudHMgIT09IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib29sIG11c3QgYmUgdmVjNCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsndTMyJywgJ3ZlYzQ8Ym9vbD4nXTtcbiAgICBjYXNlIERhdGFUeXBlLmludDQ6XG4gICAgICByZXR1cm4gJ2kzMic7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50NDpcbiAgICAgIHJldHVybiAndTMyJztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgdHlwZTogJHt0eXBlfWApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlID0gKHR5cGU6IERhdGFUeXBlLCBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0ID0gMSkgPT4ge1xuICBjb25zdCBtYXBwZWRUeXBlID0gZ2V0V2dzbE1hcHBlZFR5cGUodHlwZSwgY29tcG9uZW50cyk7XG4gIHJldHVybiB0eXBlb2YgbWFwcGVkVHlwZSA9PT0gJ3N0cmluZycgPyBtYXBwZWRUeXBlIDogbWFwcGVkVHlwZVswXTtcbn07XG5cbmV4cG9ydCBjb25zdCB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlID0gKHR5cGU6IERhdGFUeXBlLCBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0ID0gMSkgPT4ge1xuICBjb25zdCBtYXBwZWRUeXBlID0gZ2V0V2dzbE1hcHBlZFR5cGUodHlwZSwgY29tcG9uZW50cyk7XG4gIHJldHVybiB0eXBlb2YgbWFwcGVkVHlwZSA9PT0gJ3N0cmluZycgPyBtYXBwZWRUeXBlIDogbWFwcGVkVHlwZVsxXTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyA9ICguLi5kaW1zOiBSZWFkb25seUFycmF5PHJlYWRvbmx5IG51bWJlcltdPik6IFByb2dyYW1Vbmlmb3JtW10gPT4ge1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXTtcbiAgZGltcy5mb3JFYWNoKChkaW0pID0+IHtcbiAgICBpZiAoZGltLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBkaW0gfSxcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhkaW0pIH0sXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcm9ncmFtVW5pZm9ybXM7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdldCBtYXhpbXVtIHZlY3RvciBzaXplIGZvciBzcGVjaWZpZWQgZGF0YSBsZW5ndGhcbiAqIEBwYXJhbSBzaXplXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRNYXhDb21wb25lbnRzID0gKHNpemU6IG51bWJlcikgPT4ge1xuICAvLyB3ZSBjYW5ub3QgdXNlIHZlYzMgdHlwZSBzaW5jZSBpdCBoYXMgYWxpZ25tZW50IG9mIDE2IGJ5dGVzXG4gIGlmIChzaXplICUgNCA9PT0gMCkge1xuICAgIHJldHVybiA0O1xuICB9IGVsc2UgaWYgKHNpemUgJSAyID09PSAwKSB7XG4gICAgcmV0dXJuIDI7XG4gIH1cblxuICByZXR1cm4gMTtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyB2YXJpYWJsZSBhcyBhIHNjYWxhciBvciB2ZWN0b3IuIGUuZy4gZjMyKDApIG9yIHZlYzRmKDAsMCwwLDApXG4gKiBAcGFyYW0gZGF0YVR5cGVcbiAqIEBwYXJhbSBjb21wb25lbnRzXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbGxWZWN0b3IgPSAoZGF0YVR5cGUgPSAnZjMyJywgY29tcG9uZW50cz86IG51bWJlciwgdmFsdWUgPSAnMCcpID0+IHtcbiAgaWYgKCFjb21wb25lbnRzIHx8IGNvbXBvbmVudHMgPT09IDEpIHtcbiAgICByZXR1cm4gYCR7ZGF0YVR5cGV9KCR7dmFsdWV9KWA7XG4gIH1cblxuICByZXR1cm4gYHZlYyR7Y29tcG9uZW50c308JHtkYXRhVHlwZX0+KCR7dmFsdWV9KWA7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgY2FzdHMgdmFsdWUgb3IgdmVjdG9yIHRvIGYzMlxuICogQHBhcmFtIGRhdGFUeXBlXG4gKiBAcGFyYW0gY29tcG9uZW50c1xuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBjYXN0VG9GMzIgPSAoZGF0YVR5cGU6IHN0cmluZywgY29tcG9uZW50czogbnVtYmVyLCB2YWx1ZTogc3RyaW5nKSA9PiB7XG4gIGlmIChkYXRhVHlwZSA9PT0gJ2YzMicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGNvbXBvbmVudHMgPT09IDEpIHtcbiAgICByZXR1cm4gYGYzMigke3ZhbHVlfSlgO1xuICB9XG5cbiAgcmV0dXJuIGB2ZWMke2NvbXBvbmVudHN9PGYzMj4oJHt2YWx1ZX0pYDtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHNjYWxhciBvciBzdW1zIGFsbCBjb21wb25lbnRzIG9mIGEgdmVjdG9yXG4gKiBAcGFyYW0gbmFtZVxuICogQHBhcmFtIGNvbXBvbmVudHNcbiAqL1xuZXhwb3J0IGNvbnN0IHN1bVZlY3RvciA9IChuYW1lOiBzdHJpbmcsIGNvbXBvbmVudHM6IG51bWJlcikgPT4ge1xuICBpZiAoY29tcG9uZW50cyA9PT0gNCkge1xuICAgIHJldHVybiBgKCR7bmFtZX0ueCArICR7bmFtZX0ueSArICR7bmFtZX0ueiArICR7bmFtZX0udylgO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudHMgPT09IDIpIHtcbiAgICByZXR1cm4gYCgke25hbWV9LnggKyAke25hbWV9LnkpYDtcbiAgfSBlbHNlIGlmIChjb21wb25lbnRzID09PSAzKSB7XG4gICAgcmV0dXJuIGAoJHtuYW1lfS54ICsgJHtuYW1lfS55ICsgJHtuYW1lfS56KWA7XG4gIH1cblxuICByZXR1cm4gbmFtZTtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHZhcmlhYmxlIGVsZW1lbnQgYXQgaW5kZXguXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHZhcmlhYmxlLlxuICogQHBhcmFtIGluZGV4IC0gdGhlIGluZGV4IG9mIHZhcmlhYmxlIGVsZW1lbnQuXG4gKiBAcGFyYW0gbGVuZ3RoIC0gdGhlIGxlbmd0aCBvZiB2YXJpYWJsZS5cbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHR5cGUgb2YgdmFyaWFibGUsIG9wdGlvbmFsLlxuICovXG5leHBvcnQgY29uc3QgZ2V0RWxlbWVudEF0ID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIGluZGV4OiBudW1iZXIgfCBzdHJpbmcsXG4gIGxlbmd0aDogbnVtYmVyLFxuICB0eXBlPzogVW5pZm9ybURhdGFFbGVtZW50VHlwZSxcbik6IHN0cmluZyA9PiB7XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ3VuaWZvcm1zLicpICYmIGxlbmd0aCA+IDQpIHtcbiAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGUgPT09ICdmMTYnKSB7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfVsoJHtpbmRleH0pIC8gOF1bKCR7aW5kZXh9KSAlIDggLyA0XVsoJHtpbmRleH0pICUgOCAlIDRdYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfVsoJHtpbmRleH0pIC8gNF1bKCR7aW5kZXh9KSAlIDRdYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09ICdmMTYnKSB7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfVske01hdGguZmxvb3IoaW5kZXggLyA4KX1dWyR7TWF0aC5mbG9vcigoaW5kZXggJSA4KSAvIDQpfV1bJHsoaW5kZXggJSA4KSAlIDR9XWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtNYXRoLmZsb29yKGluZGV4IC8gNCl9XVske2luZGV4ICUgNH1dYDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxlbmd0aCA+IDEgPyBgJHtuYW1lfVske2luZGV4fV1gIDogbmFtZTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZXQgYSBJbmRpY2VzSGVscGVyIGZvciBhIGdpdmVuIGlucHV0IG9yIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBpbnB1dCBvciBvdXRwdXQuXG4gKiBAcGFyYW0gdGVuc29yVHlwZSAtIHRoZSB0ZW5zb3IgdHlwZSBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICogQHBhcmFtIHVzYWdlIC0gdGhlIHVzYWdlIG9mIHRoZSBpbmRpY2VzIGhlbHBlci5cbiAqIEBwYXJhbSBjb21wb25lbnRzIC0gaW5kaWNhdGVzIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiBlYWNoIGVsZW1lbnQuIDEgZm9yIHNjYWxhciwgMiBmb3IgdmVjMiwgMyBmb3IgdmVjMywgNCBmb3JcbiAqICAgIHZlYzQuXG4gKi9cbmNvbnN0IGNyZWF0ZUluZGljZXNIZWxwZXIgPSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgdGVuc29yVHlwZTogbnVtYmVyLFxuICBzaGFwZU9yUmFuazogbnVtYmVyIHwgcmVhZG9ubHkgbnVtYmVyW10sXG4gIHVzYWdlOiBJbmRpY2VzSGVscGVyWyd1c2FnZSddLFxuICBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0LFxuKTogSW5kaWNlc0hlbHBlciA9PiB7XG4gIGNvbnN0IHVzZVVuaWZvcm0gPSB0eXBlb2Ygc2hhcGVPclJhbmsgPT09ICdudW1iZXInO1xuICBjb25zdCByYW5rID0gdXNlVW5pZm9ybSA/IHNoYXBlT3JSYW5rIDogc2hhcGVPclJhbmsubGVuZ3RoO1xuICBjb25zdCByYW5rSWRlbnRpdHkgPSBbLi4ubmV3IEFycmF5KHJhbmspLmtleXMoKV07XG4gIGNvbnN0IGluZGljZXNUeXBlID0gcmFuayA8IDIgPyAndTMyJyA6IHJhbmsgPD0gNCA/IGB2ZWMke3Jhbmt9PHUzMj5gIDogYGFycmF5PHUzMiwgJHtyYW5rfT5gO1xuICBjb25zdCBtYXBwZWRUeXBlID0gZ2V0V2dzbE1hcHBlZFR5cGUodGVuc29yVHlwZSwgY29tcG9uZW50cyk7XG4gIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiBtYXBwZWRUeXBlID09PSAnc3RyaW5nJyA/IG1hcHBlZFR5cGUgOiBtYXBwZWRUeXBlWzFdO1xuICBjb25zdCBzdG9yYWdlVHlwZSA9IHR5cGVvZiBtYXBwZWRUeXBlID09PSAnc3RyaW5nJyA/IG1hcHBlZFR5cGUgOiBtYXBwZWRUeXBlWzBdO1xuICBjb25zdCB0eXBlID0geyBpbmRpY2VzOiBpbmRpY2VzVHlwZSwgdmFsdWU6IHZhbHVlVHlwZSwgc3RvcmFnZTogc3RvcmFnZVR5cGUsIHRlbnNvcjogdGVuc29yVHlwZSB9O1xuXG4gIGNvbnN0IG5vcm1hbGl6ZURpbSA9IChkaW06IG51bWJlciB8IHN0cmluZyk6IHN0cmluZyA9PiAodHlwZW9mIGRpbSA9PT0gJ3N0cmluZycgPyBkaW0gOiBgJHtkaW19dWApO1xuXG4gIGNvbnN0IGltcGxlbWVudGF0aW9uVXNlZCA9IHtcbiAgICBvZmZzZXRUb0luZGljZXM6IGZhbHNlLFxuICAgIGluZGljZXNUb09mZnNldDogZmFsc2UsXG4gICAgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6IGZhbHNlLFxuICAgIHNldDogZmFsc2UsXG4gICAgc2V0QnlJbmRpY2VzOiBmYWxzZSxcbiAgICBnZXQ6IGZhbHNlLFxuICAgIGdldEJ5SW5kaWNlczogZmFsc2UsXG4gIH07XG5cbiAgY29uc3QgdW5pZm9ybVByZWZpeCA9IHVzZVVuaWZvcm0gPyAndW5pZm9ybXMuJyA6ICcnO1xuICBjb25zdCBzaGFwZSA9IGAke3VuaWZvcm1QcmVmaXh9JHtuYW1lfV9zaGFwZWA7XG4gIGNvbnN0IHN0cmlkZXMgPSBgJHt1bmlmb3JtUHJlZml4fSR7bmFtZX1fc3RyaWRlc2A7XG5cbiAgbGV0IG8yaVNuaXBwZXQgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMTsgaSsrKSB7XG4gICAgbzJpU25pcHBldCArPSBgXG4gICAgbGV0IGRpbSR7aX0gPSBjdXJyZW50IC8gJHtnZXRFbGVtZW50QXQoc3RyaWRlcywgaSwgcmFuayl9O1xuICAgIGxldCByZXN0JHtpfSA9IGN1cnJlbnQgJSAke2dldEVsZW1lbnRBdChzdHJpZGVzLCBpLCByYW5rKX07XG4gICAgaW5kaWNlc1ske2l9XSA9IGRpbSR7aX07XG4gICAgY3VycmVudCA9IHJlc3Qke2l9O1xuICAgIGA7XG4gIH1cbiAgbzJpU25pcHBldCArPSBgaW5kaWNlc1ske3JhbmsgLSAxfV0gPSBjdXJyZW50O2A7XG5cbiAgY29uc3Qgb2Zmc2V0VG9JbmRpY2VzSW1wbGVtZW50YXRpb24gPVxuICAgIHJhbmsgPCAyXG4gICAgICA/ICcnXG4gICAgICA6IGBcbiAgZm4gbzJpXyR7bmFtZX0ob2Zmc2V0OiB1MzIpIC0+ICR7dHlwZS5pbmRpY2VzfSB7XG4gICAgdmFyIGluZGljZXM6ICR7dHlwZS5pbmRpY2VzfTtcbiAgICB2YXIgY3VycmVudCA9IG9mZnNldDtcbiAgICAke28yaVNuaXBwZXR9XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1gO1xuXG4gIGNvbnN0IG9mZnNldFRvSW5kaWNlcyA9ICh2YXJPZmZzZXQ6IHN0cmluZykgPT4ge1xuICAgIGltcGxlbWVudGF0aW9uVXNlZC5vZmZzZXRUb0luZGljZXMgPSB0cnVlO1xuICAgIHJldHVybiByYW5rIDwgMiA/IHZhck9mZnNldCA6IGBvMmlfJHtuYW1lfSgke3Zhck9mZnNldH0pYDtcbiAgfTtcblxuICBjb25zdCBvZmZzZXRzOiBzdHJpbmdbXSA9IFtdO1xuICBpZiAocmFuayA+PSAyKSB7XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgb2Zmc2V0cy5wdXNoKGAke2dldEVsZW1lbnRBdChzdHJpZGVzLCBpLCByYW5rKX0gKiAoaW5kaWNlc1ske2l9XSlgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBpbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbiA9XG4gICAgcmFuayA8IDJcbiAgICAgID8gJydcbiAgICAgIDogYFxuICBmbiBpMm9fJHtuYW1lfShpbmRpY2VzOiAke3R5cGUuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgcmV0dXJuICR7b2Zmc2V0cy5qb2luKCcrJyl9O1xuICB9YDtcblxuICBjb25zdCBpbmRpY2VzVG9PZmZzZXQgPSAodmFySW5kaWNlczogc3RyaW5nKSA9PiB7XG4gICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgcmV0dXJuIHJhbmsgPCAyID8gdmFySW5kaWNlcyA6IGBpMm9fJHtuYW1lfSgke3ZhckluZGljZXN9KWA7XG4gIH07XG5cbiAgY29uc3QgaW5kaWNlcyA9ICguLi5pbml0OiBSZWFkb25seUFycmF5PG51bWJlciB8IHN0cmluZz4pID0+XG4gICAgcmFuayA9PT0gMCA/ICcwdScgOiBgJHt0eXBlLmluZGljZXN9KCR7aW5pdC5tYXAobm9ybWFsaXplRGltKS5qb2luKCcsJyl9KWA7XG5cbiAgY29uc3QgaW5kaWNlc0dldCA9ICh2YXJJbmRpY2VzOiBzdHJpbmcsIGlkeDogbnVtYmVyIHwgc3RyaW5nKSA9PiB7XG4gICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICByZXR1cm4gYCR7dmFySW5kaWNlc31gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYCR7Z2V0RWxlbWVudEF0KHZhckluZGljZXMsIGlkeCwgcmFuayl9YDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaW5kaWNlc1NldCA9ICh2YXJJbmRpY2VzOiBzdHJpbmcsIGlkeDogbnVtYmVyIHwgc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICByZXR1cm4gYCR7dmFySW5kaWNlc309JHt2YWx1ZX07YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGAke2dldEVsZW1lbnRBdCh2YXJJbmRpY2VzLCBpZHgsIHJhbmspfT0ke3ZhbHVlfTtgO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gIGNvbnN0IGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0ID0gKHZhckluZGljZXM6IHN0cmluZywgb3V0cHV0OiBJbmRpY2VzSGVscGVyKSA9PiB7XG4gICAgaW1wbGVtZW50YXRpb25Vc2VkLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcbiAgICBjb25zdCBpbXBsS2V5ID0gYCR7b3V0cHV0Lm5hbWV9YnJvYWRjYXN0ZWRJbmRpY2VzVG8ke25hbWV9T2Zmc2V0YDtcbiAgICBpZiAoaW1wbEtleSBpbiBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uKSB7XG4gICAgICByZXR1cm4gYCR7aW1wbEtleX0oJHt2YXJJbmRpY2VzfSlgO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgaWR4ID0gb3V0cHV0LmluZGljZXNHZXQoJ291dHB1dEluZGljZXMnLCBpICsgb3V0cHV0LnJhbmsgLSByYW5rKTtcbiAgICAgIG9mZnNldHMucHVzaChgJHtpbmRpY2VzR2V0KHN0cmlkZXMsIGkpfSAqICgke2lkeH0gJSAke2luZGljZXNHZXQoc2hhcGUsIGkpfSlgKTtcbiAgICB9XG4gICAgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbltpbXBsS2V5XSA9IGBmbiAke2ltcGxLZXl9KG91dHB1dEluZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgICAgICAgICAgcmV0dXJuICR7b2Zmc2V0cy5sZW5ndGggPiAwID8gb2Zmc2V0cy5qb2luKCcrJykgOiAnMHUnfTtcbiAgICAgICAgICAgfWA7XG5cbiAgICByZXR1cm4gYCR7aW1wbEtleX0oJHt2YXJJbmRpY2VzfSlgO1xuICB9O1xuXG4gIGNvbnN0IHNldEJ5T2Zmc2V0ID0gKG9mZnNldDogbnVtYmVyIHwgc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PlxuICAgICgoKSA9PiB7XG4gICAgICBpZiAodHlwZS5zdG9yYWdlID09PSB0eXBlLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dPSR7dmFsdWV9O2A7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3ZlYzI8dTMyPicgJiYgdHlwZS52YWx1ZSA9PT0gJ2kzMicpIHtcbiAgICAgICAgLy8gaW50NjQsIGNvbXBvbmVudHMgPT09IDFcbiAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7b2Zmc2V0fV09dmVjMjx1MzI+KHUzMigke3ZhbHVlfSksIHNlbGVjdCgwdSwgMHhGRkZGRkZGRnUsICR7dmFsdWV9IDwgMCkpO2A7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3ZlYzI8dTMyPicgJiYgdHlwZS52YWx1ZSA9PT0gJ3UzMicpIHtcbiAgICAgICAgLy8gdWludDY0LCBjb21wb25lbnRzID09PSAxXG4gICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dPXZlYzI8dTMyPih1MzIoJHt2YWx1ZX0pLCAwdSk7YDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndTMyJyAmJiB0eXBlLnZhbHVlID09PSAndmVjNDxib29sPicpIHtcbiAgICAgICAgLy8gYm9vbCwgY29tcG9uZW50cyA9PT0gNFxuICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XT1kb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPigke3ZhbHVlfSkpO2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7dHlwZS5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke3R5cGUudmFsdWV9IHlldGApO1xuICAgICAgfVxuICAgIH0pKCk7XG5cbiAgY29uc3QgZ2V0QnlPZmZzZXQgPSAob2Zmc2V0OiBudW1iZXIgfCBzdHJpbmcpID0+XG4gICAgKCgpID0+IHtcbiAgICAgIGlmICh0eXBlLnN0b3JhZ2UgPT09IHR5cGUudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7b2Zmc2V0fV1gO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd2ZWMyPHUzMj4nICYmIHR5cGUudmFsdWUgPT09ICdpMzInKSB7XG4gICAgICAgIC8vIGludDY0LCBjb21wb25lbnRzID09PSAxXG4gICAgICAgIHJldHVybiBgaTMyKCR7bmFtZX1bJHtvZmZzZXR9XS54KWA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3ZlYzI8dTMyPicgJiYgdHlwZS52YWx1ZSA9PT0gJ3UzMicpIHtcbiAgICAgICAgLy8gdWludDY0LCBjb21wb25lbnRzID09PSAxXG4gICAgICAgIHJldHVybiBgdTMyKCR7bmFtZX1bJHtvZmZzZXR9XS54KWA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3UzMicgJiYgdHlwZS52YWx1ZSA9PT0gJ3ZlYzQ8Ym9vbD4nKSB7XG4gICAgICAgIC8vIGJvb2wsIGNvbXBvbmVudHMgPT09IDRcbiAgICAgICAgcmV0dXJuIGB2ZWM0PGJvb2w+KGJvb2woJHtuYW1lfVske29mZnNldH1dICYgMHhGRnUpLCBib29sKCR7bmFtZX1bJHtvZmZzZXR9XSAmIDB4RkYwMHUpLCBib29sKCR7bmFtZX1bJHtcbiAgICAgICAgICBvZmZzZXRcbiAgICAgICAgfV0gJiAweEZGMDAwMHUpLCBib29sKCR7bmFtZX1bJHtvZmZzZXR9XSAmIDB4RkYwMDAwMDB1KSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke3R5cGUuc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHt0eXBlLnZhbHVlfSB5ZXRgKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuXG4gIGNvbnN0IGdldEJ5SW5kaWNlc0ltcGxlbWVudGF0aW9uID1cbiAgICByYW5rIDwgMlxuICAgICAgPyAnJ1xuICAgICAgOiBgXG4gIGZuIGdldF8ke25hbWV9QnlJbmRpY2VzKGluZGljZXM6ICR7dHlwZS5pbmRpY2VzfSkgLT4gJHt2YWx1ZVR5cGV9IHtcbiAgICByZXR1cm4gJHtnZXRCeU9mZnNldChgaTJvXyR7bmFtZX0oaW5kaWNlcylgKX07XG4gIH1gO1xuXG4gIGNvbnN0IGdldEltcGxlbWVudGF0aW9uID1cbiAgICByYW5rIDwgMlxuICAgICAgPyAnJ1xuICAgICAgOiAoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUGFyYW1zID0gcmFua0lkZW50aXR5Lm1hcCgoaSkgPT4gYGQke2l9OiB1MzJgKS5qb2luKCcsICcpO1xuICAgICAgICAgIGNvbnN0IGRpbXNQYXJhbXMgPSByYW5rSWRlbnRpdHkubWFwKChpKSA9PiBgZCR7aX1gKS5qb2luKCcsICcpO1xuICAgICAgICAgIHJldHVybiBgXG4gIGZuIGdldF8ke25hbWV9KCR7ZnVuY3Rpb25QYXJhbXN9KSAtPiAke3ZhbHVlVHlwZX0ge1xuICAgIHJldHVybiBnZXRfJHtuYW1lfUJ5SW5kaWNlcygke2luZGljZXMoZGltc1BhcmFtcyl9KTtcbiAgfWA7XG4gICAgICAgIH0pKCk7XG5cbiAgY29uc3QgZ2V0ID0gKC4uLmluZGljZXM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT4ge1xuICAgIGlmIChpbmRpY2VzLmxlbmd0aCAhPT0gcmFuaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmRpY2VzIGxlbmd0aCBtdXN0IGJlICR7cmFua31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBub3JtYWxpemVkSW5kaWNlcyA9IGluZGljZXMubWFwKG5vcm1hbGl6ZURpbSkuam9pbignLCcpO1xuXG4gICAgaWYgKHJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBnZXRCeU9mZnNldCgnMHUnKTtcbiAgICB9IGVsc2UgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgIHJldHVybiBnZXRCeU9mZnNldChub3JtYWxpemVkSW5kaWNlc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5nZXQgPSB0cnVlO1xuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmdldEJ5SW5kaWNlcyA9IHRydWU7XG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBgZ2V0XyR7bmFtZX0oJHtub3JtYWxpemVkSW5kaWNlc30pYDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZ2V0QnlJbmRpY2VzID0gKHZhckluZGljZXM6IHN0cmluZykgPT4ge1xuICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgcmV0dXJuIGdldEJ5T2Zmc2V0KHZhckluZGljZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuZ2V0QnlJbmRpY2VzID0gdHJ1ZTtcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGBnZXRfJHtuYW1lfUJ5SW5kaWNlcygke3ZhckluZGljZXN9KWA7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHNldEJ5SW5kaWNlc0ltcGxlbWVudGF0aW9uID1cbiAgICByYW5rIDwgMlxuICAgICAgPyAnJ1xuICAgICAgOiBgXG4gIGZuIHNldF8ke25hbWV9QnlJbmRpY2VzKGluZGljZXM6ICR7dHlwZS5pbmRpY2VzfSwgdmFsdWU6ICR7dmFsdWVUeXBlfSkge1xuICAgICR7c2V0QnlPZmZzZXQoYGkyb18ke25hbWV9KGluZGljZXMpYCwgJ3ZhbHVlJyl9XG4gIH1gO1xuXG4gIGNvbnN0IHNldEltcGxlbWVudGF0aW9uID1cbiAgICByYW5rIDwgMlxuICAgICAgPyAnJ1xuICAgICAgOiAoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUGFyYW1zID0gcmFua0lkZW50aXR5Lm1hcCgoaSkgPT4gYGQke2l9OiB1MzJgKS5qb2luKCcsICcpO1xuICAgICAgICAgIGNvbnN0IGRpbXNQYXJhbXMgPSByYW5rSWRlbnRpdHkubWFwKChpKSA9PiBgZCR7aX1gKS5qb2luKCcsICcpO1xuICAgICAgICAgIHJldHVybiBgXG4gIGZuIHNldF8ke25hbWV9KCR7ZnVuY3Rpb25QYXJhbXN9LCB2YWx1ZTogJHt2YWx1ZVR5cGV9KSB7XG4gICAgc2V0XyR7bmFtZX1CeUluZGljZXMoJHtpbmRpY2VzKGRpbXNQYXJhbXMpfSwgdmFsdWUpO1xuICB9YDtcbiAgICAgICAgfSkoKTtcblxuICBjb25zdCBzZXQgPSAoLi4uaW5kaWNlc0FuZFZhbHVlOiBSZWFkb25seUFycmF5PG51bWJlciB8IHN0cmluZz4pID0+IHtcbiAgICBpZiAoaW5kaWNlc0FuZFZhbHVlLmxlbmd0aCAhPT0gcmFuayArIDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3Jhbmt9YCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gaW5kaWNlc0FuZFZhbHVlW3JhbmtdO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9ybWFsaXplZEluZGljZXMgPSBpbmRpY2VzQW5kVmFsdWUuc2xpY2UoMCwgcmFuaykubWFwKG5vcm1hbGl6ZURpbSkuam9pbignLCcpO1xuXG4gICAgaWYgKHJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBzZXRCeU9mZnNldCgnMHUnLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChyYW5rID09PSAxKSB7XG4gICAgICByZXR1cm4gc2V0QnlPZmZzZXQobm9ybWFsaXplZEluZGljZXNbMF0sIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLnNldCA9IHRydWU7XG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuc2V0QnlJbmRpY2VzID0gdHJ1ZTtcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGBzZXRfJHtuYW1lfSgke25vcm1hbGl6ZWRJbmRpY2VzfSwgJHt2YWx1ZX0pYDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2V0QnlJbmRpY2VzID0gKHZhckluZGljZXM6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4ge1xuICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgcmV0dXJuIHNldEJ5T2Zmc2V0KHZhckluZGljZXMsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLnNldEJ5SW5kaWNlcyA9IHRydWU7XG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBgc2V0XyR7bmFtZX1CeUluZGljZXMoJHt2YXJJbmRpY2VzfSwgJHt2YWx1ZX0pO2A7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGltcGwgPSAoKSA9PiB7XG4gICAgY29uc3QgaW1wbHMgPSBbXTtcbiAgICBsZXQgbmVlZFNoYXBlU3RyaWRlcyA9IGZhbHNlO1xuICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQub2Zmc2V0VG9JbmRpY2VzKSB7XG4gICAgICBpbXBscy5wdXNoKG9mZnNldFRvSW5kaWNlc0ltcGxlbWVudGF0aW9uKTtcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCkge1xuICAgICAgaW1wbHMucHVzaChpbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbik7XG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCkge1xuICAgICAgT2JqZWN0LnZhbHVlcyhicm9hZGNhc3RlZEluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uKS5mb3JFYWNoKChpbXBsKSA9PiBpbXBscy5wdXNoKGltcGwpKTtcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLnNldCkge1xuICAgICAgaW1wbHMucHVzaChzZXRJbXBsZW1lbnRhdGlvbik7XG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5zZXRCeUluZGljZXMpIHtcbiAgICAgIGltcGxzLnB1c2goc2V0QnlJbmRpY2VzSW1wbGVtZW50YXRpb24pO1xuICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuZ2V0KSB7XG4gICAgICBpbXBscy5wdXNoKGdldEltcGxlbWVudGF0aW9uKTtcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLmdldEJ5SW5kaWNlcykge1xuICAgICAgaW1wbHMucHVzaChnZXRCeUluZGljZXNJbXBsZW1lbnRhdGlvbik7XG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF1c2VVbmlmb3JtICYmIG5lZWRTaGFwZVN0cmlkZXMpIHtcbiAgICAgIGltcGxzLnVuc2hpZnQoXG4gICAgICAgIGBjb25zdCAke3NoYXBlfSA9ICR7dHlwZS5pbmRpY2VzfSgke3NoYXBlT3JSYW5rLmpvaW4oJywnKX0pO2AsXG4gICAgICAgIGBjb25zdCAke3N0cmlkZXN9ID0gJHt0eXBlLmluZGljZXN9KCR7U2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHNoYXBlT3JSYW5rKS5qb2luKCcsJyl9KTtgLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGltcGxzLmpvaW4oJ1xcbicpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgaW1wbCxcbiAgICB0eXBlLFxuICAgIG9mZnNldFRvSW5kaWNlcyxcbiAgICBpbmRpY2VzVG9PZmZzZXQsXG4gICAgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQsXG4gICAgaW5kaWNlcyxcbiAgICBpbmRpY2VzR2V0LFxuICAgIGluZGljZXNTZXQsXG4gICAgc2V0LFxuICAgIHNldEJ5T2Zmc2V0LFxuICAgIHNldEJ5SW5kaWNlcyxcbiAgICBnZXQsXG4gICAgZ2V0QnlPZmZzZXQsXG4gICAgZ2V0QnlJbmRpY2VzLFxuICAgIC8vIGlzVmVjNCxcbiAgICB1c2FnZSxcbiAgICBuYW1lLFxuICAgIHN0cmlkZXMsXG4gICAgc2hhcGUsXG4gICAgcmFuayxcbiAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgSW5kaWNlc0hlbHBlciBmb3IgYW4gaW5wdXQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0ZW5zb3IgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gc2hhcGVPclJhbmsgLSB0aGUgdGVuc29yIHNoYXBlIG9yIHRoZSByYW5rIG9mIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBjb21wb25lbnRzIC0gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIG9mIHRoZSBpbnB1dC4gYXZhaWxhYmxlIHZhbHVlcyBhcmUgMSwgMiwgMywgNC4gZGVmYXVsdCBpcyAxLlxuICogQHJldHVybnMgYW4gSW5kaWNlc0hlbHBlciBmb3IgdGhlIGlucHV0LlxuICovXG5leHBvcnQgY29uc3QgaW5wdXRWYXJpYWJsZSA9IChcbiAgbmFtZTogc3RyaW5nLFxuICB0eXBlOiBudW1iZXIsXG4gIHNoYXBlT3JSYW5rOiBudW1iZXIgfCByZWFkb25seSBudW1iZXJbXSxcbiAgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCA9IDEsXG4pOiBJbmRpY2VzSGVscGVyID0+IGNyZWF0ZUluZGljZXNIZWxwZXIobmFtZSwgdHlwZSwgc2hhcGVPclJhbmssICdpbnB1dCcsIGNvbXBvbmVudHMpO1xuXG4vKipcbiAqIENyZWF0ZSBhIEluZGljZXNIZWxwZXIgZm9yIGFuIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBvdXRwdXQuXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0ZW5zb3IgdHlwZSBvZiB0aGUgb3V0cHV0LlxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgb3V0cHV0LlxuICogQHBhcmFtIGNvbXBvbmVudHMgLSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgb2YgdGhlIG91dHB1dC4gYXZhaWxhYmxlIHZhbHVlcyBhcmUgMSwgMiwgMywgNC4gZGVmYXVsdCBpcyAxLlxuICogQHJldHVybnMgYW4gSW5kaWNlc0hlbHBlciBmb3IgdGhlIG91dHB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IG91dHB1dFZhcmlhYmxlID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIHR5cGU6IG51bWJlcixcbiAgc2hhcGVPclJhbms6IG51bWJlciB8IHJlYWRvbmx5IG51bWJlcltdLFxuICBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0ID0gMSxcbik6IEluZGljZXNIZWxwZXIgPT4gY3JlYXRlSW5kaWNlc0hlbHBlcihuYW1lLCB0eXBlLCBzaGFwZU9yUmFuaywgJ291dHB1dCcsIGNvbXBvbmVudHMpO1xuXG4vKipcbiAqIENyZWF0ZSBhIEluZGljZXNIZWxwZXIgZm9yIGFuIGF0b21pYyBvdXRwdXQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgb3V0cHV0LlxuICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIG91dHB1dC5cbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIG91dHB1dC5cbiAqIEByZXR1cm5zIGFuIEluZGljZXNIZWxwZXIgZm9yIHRoZSBvdXRwdXQuXG4gKi9cbmV4cG9ydCBjb25zdCBhdG9taWNPdXRwdXRWYXJpYWJsZSA9IChcbiAgbmFtZTogc3RyaW5nLFxuICB0eXBlOiBudW1iZXIsXG4gIHNoYXBlT3JSYW5rOiBudW1iZXIgfCByZWFkb25seSBudW1iZXJbXSxcbik6IEluZGljZXNIZWxwZXIgPT4gY3JlYXRlSW5kaWNlc0hlbHBlcihuYW1lLCB0eXBlLCBzaGFwZU9yUmFuaywgJ2F0b21pY091dHB1dCcsIDEpO1xuXG4vKipcbiAqIENyZWF0ZSBhIEluZGljZXNIZWxwZXIgZm9yIGFuIGludGVybmFsIHZhcmlhYmxlLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlLlxuICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIHZhcmlhYmxlLlxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgdmFyaWFibGUuXG4gKiBAcGFyYW0gY29tcG9uZW50cyAtIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiB0aGUgdmFyaWFibGUuIGF2YWlsYWJsZSB2YWx1ZXMgYXJlIDEsIDIsIDMsIDQuIGRlZmF1bHQgaXMgMS5cbiAqIEByZXR1cm5zIGFuIEluZGljZXNIZWxwZXIgZm9yIHRoZSB2YXJpYWJsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGludGVybmFsVmFyaWFibGUgPSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgdHlwZTogbnVtYmVyLFxuICBzaGFwZU9yUmFuazogbnVtYmVyIHwgcmVhZG9ubHkgbnVtYmVyW10sXG4gIGNvbXBvbmVudHM6IDEgfCAyIHwgMyB8IDQgPSAxLFxuKTogSW5kaWNlc0hlbHBlciA9PiBjcmVhdGVJbmRpY2VzSGVscGVyKG5hbWUsIHR5cGUsIHNoYXBlT3JSYW5rLCAnaW50ZXJuYWwnLCBjb21wb25lbnRzKTtcblxuZXhwb3J0IHR5cGUgVW5pZm9ybURhdGFFbGVtZW50VHlwZSA9ICd1MzInIHwgJ2YxNicgfCAnZjMyJyB8ICdpMzInO1xuZXhwb3J0IHR5cGUgVW5pZm9ybXNBcnJheVR5cGUgPSBBcnJheTx7IG5hbWU6IHN0cmluZzsgdHlwZTogVW5pZm9ybURhdGFFbGVtZW50VHlwZTsgbGVuZ3RoPzogbnVtYmVyIH0+O1xuXG4vKipcbiAqIEEgU2hhZGVySGVscGVyIGlzIGEgaGVscGVyIGNsYXNzIGZvciBnZW5lcmF0aW5nIFdHU0wgY29kZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTaGFkZXJIZWxwZXIge1xuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIHN0YXJ0IG9mIG1haW4gZnVuY3Rpb24gaW4gV0dTTCBzb3VyY2UgY29kZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAqICAuLi5cbiAgICpcbiAgICogICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgKiAgICAvLyB5b3VyIGNvZGUgaGVyZSBpbnNpZGUgbWFpbigpIGZ1bmN0aW9uXG4gICAqICAgIC4uLlxuICAgKiAgfVxuICAgKiBgO1xuICAgKlxuICAgKiBAcGFyYW0gd29ya2dyb3VwU2l6ZSAtIGFuIG9wdGlvbmFsIHdvcmtncm91cCBzaXplLiBkZWZhdWx0IGlzIFdPUktHUk9VUF9TSVpFLlxuICAgKi9cbiAgbWFpblN0YXJ0KHdvcmtncm91cFNpemU/OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHNuaXBwZXQgZm9yIGd1YXJkaW5nIGFnYWluc3Qgb3V0LW9mLWJvdW5kcyBzaXplLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICogIC4uLlxuICAgKlxuICAgKiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAqICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMob3V0cHV0U2l6ZSl9XG4gICAqXG4gICAqICAgIC8vIHlvdXIgY29kZSBoZXJlIGluc2lkZSBtYWluKCkgZnVuY3Rpb25cbiAgICogICAgLi4uXG4gICAqICB9XG4gICAqIGA7XG4gICAqXG4gICAqIEBwYXJhbSBzaXplIC0gdGhlIHNpemUgb2YgdGhlIGRhdGEgdG8gZ3VhcmQgYWdhaW5zdC4gY2FuIGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pLlxuICAgKi9cbiAgZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhzaXplOiB1bmtub3duKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgY29kZSBzbmlwcGV0IGZvciBkZWNsYXJpbmcgbXVsdGlwbGUgaW5wdXRzIG9yIG91dHB1dHMuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJpYWJsZXMgLSBhbiBhcnJheSBvZiBJbmRpY2VzSGVscGVyIGZvciB0aGUgdmFyaWFibGVzLlxuICAgKi9cbiAgZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSk6IHN0cmluZztcblxuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgb25lIHVuaWZvcm0uIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gcmVnaXN0ZXIgbXVsdGlwbGUgdW5pZm9ybXMuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHVuaWZvcm0uXG4gICAqIEBwYXJhbSB0eXBlIC0gdGhlIHR5cGUgb2YgdGhlIHVuaWZvcm0uXG4gICAqIEBwYXJhbSBsZW5ndGggLSB0aGUgbGVuZ3RoIG9mIHRoZSB1bmlmb3JtLCBkZWZhdWx0IHRvIDEgd2hlbiBpdCBpcyBub3QgcHJvdmlkZWQuXG4gICAqL1xuICByZWdpc3RlclVuaWZvcm0obmFtZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIGxlbmd0aD86IG51bWJlcik6IFNoYWRlckhlbHBlcjtcblxuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgbXVsdGlwbGUgdW5pZm9ybXMuIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gcmVnaXN0ZXIgbXVsdGlwbGUgdW5pZm9ybXMuXG4gICAqXG4gICAqIEBwYXJhbSB1bmlmb3JtcyAtIGFuIGFycmF5IG9mIHVuaWZvcm1zLiBFYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IGlzIGFuIG9iamVjdCB3aXRoIDIgcHJvcGVydGllczogYG5hbWVgIGFuZFxuICAgKiAgICAgYHR5cGVgLlxuICAgKi9cbiAgcmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUpOiBTaGFkZXJIZWxwZXI7XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIG11bHRpcGxlIGludGVybmFsIHZhcmlhYmxlcy4gQ2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byByZWdpc3RlciBtdWx0aXBsZVxuICAgKiBpbnRlcm5hbCB2YXJpYWJsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJpYWJsZXMgLSBhbiBhcnJheSBvZiBJbmRpY2VzSGVscGVyIGZvciB0aGUgdmFyaWFibGVzLlxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyguLi52YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSk6IFNoYWRlckhlbHBlcjtcbn1cblxuY2xhc3MgU2hhZGVySGVscGVySW1wbCBpbXBsZW1lbnRzIFNoYWRlckhlbHBlciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgbm9ybWFsaXplZERpc3BhdGNoR3JvdXA6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICBwcml2YXRlIGxpbWl0czogR1BVU3VwcG9ydGVkTGltaXRzLFxuICApIHt9XG5cbiAgZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhzaXplOiBudW1iZXIgfCBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIEd1YXJkIGFnYWluc3Qgb3V0LW9mLWJvdW5kcyB3b3JrIGdyb3VwIHNpemVzXG4gICAgY29uc3Qgc2l6ZUluQ29kZSA9IHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyA/IGAke3NpemV9dWAgOiBzaXplO1xuICAgIHJldHVybiBgaWYgKGdsb2JhbF9pZHggPj0gJHtzaXplSW5Db2RlfSkgeyByZXR1cm47IH1gO1xuICB9XG5cbiAgbWFpblN0YXJ0KHdvcmtncm91cFNpemU6IG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFdPUktHUk9VUF9TSVpFKSB7XG4gICAgY29uc3Qgd29ya2dyb3VwU2l6ZVggPSB0eXBlb2Ygd29ya2dyb3VwU2l6ZSA9PT0gJ251bWJlcicgPyB3b3JrZ3JvdXBTaXplIDogd29ya2dyb3VwU2l6ZVswXTtcbiAgICBjb25zdCB3b3JrZ3JvdXBTaXplWSA9IHR5cGVvZiB3b3JrZ3JvdXBTaXplID09PSAnbnVtYmVyJyA/IDEgOiB3b3JrZ3JvdXBTaXplWzFdO1xuICAgIGNvbnN0IHdvcmtncm91cFNpemVaID0gdHlwZW9mIHdvcmtncm91cFNpemUgPT09ICdudW1iZXInID8gMSA6IHdvcmtncm91cFNpemVbMl07XG5cbiAgICBpZiAoXG4gICAgICB3b3JrZ3JvdXBTaXplWCA+IHRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCB8fFxuICAgICAgd29ya2dyb3VwU2l6ZVkgPiB0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVkgfHxcbiAgICAgIHdvcmtncm91cFNpemVaID4gdGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVaXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB3b3JrZ3JvdXAgc2l6ZSBbJHt3b3JrZ3JvdXBTaXplWH0sICR7d29ya2dyb3VwU2l6ZVl9LCAke1xuICAgICAgICAgIHdvcmtncm91cFNpemVaXG4gICAgICAgIH1dIGV4Y2VlZHMgdGhlIG1heGltdW0gd29ya2dyb3VwIHNpemUgWyR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYfSwgJHtcbiAgICAgICAgICB0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVlcbiAgICAgICAgfSwgJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVp9XS5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAod29ya2dyb3VwU2l6ZVggKiB3b3JrZ3JvdXBTaXplWSAqIHdvcmtncm91cFNpemVaID4gdGhpcy5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB3b3JrZ3JvdXAgc2l6ZSBbJHt3b3JrZ3JvdXBTaXplWH0sICR7d29ya2dyb3VwU2l6ZVl9LCAke1xuICAgICAgICAgIHdvcmtncm91cFNpemVaXG4gICAgICAgIH1dIGV4Y2VlZHMgdGhlIG1heGltdW0gd29ya2dyb3VwIGludm9jYXRpb25zICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwfS5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBpczFEaW1lbnNpb25EaXNwYXRjaCA9IHRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV0gPT09IDEgJiYgdGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXSA9PT0gMTtcbiAgICBjb25zdCBwYXJhbUxpc3QgPSBpczFEaW1lbnNpb25EaXNwYXRjaFxuICAgICAgPyBgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pZHggOiB1MzIsXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj5gXG4gICAgICA6IGBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgbG9jYWxfaWR4IDogdTMyLFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKG51bV93b3JrZ3JvdXBzKSBudW1fd29ya2dyb3VwcyA6IHZlYzM8dTMyPmA7XG4gICAgY29uc3QgZ2xvYmFsSWR4RGVmaW5pdGlvbiA9IGlzMURpbWVuc2lvbkRpc3BhdGNoXG4gICAgICA/IGBsZXQgZ2xvYmFsX2lkeCA9IGdsb2JhbF9pZC54O1xuICAgICAgICAgbGV0IHdvcmtncm91cF9pbmRleCA9IHdvcmtncm91cF9pZC54O2BcbiAgICAgIDogYGxldCB3b3JrZ3JvdXBfaW5kZXggPSB3b3JrZ3JvdXBfaWQueiAqIG51bV93b3JrZ3JvdXBzWzBdICogbnVtX3dvcmtncm91cHNbMV0gK1xuICAgICAgICAgICAgIHdvcmtncm91cF9pZC55ICogbnVtX3dvcmtncm91cHNbMF0gKyB3b3JrZ3JvdXBfaWQueDtcbiAgICAgICAgIGxldCBnbG9iYWxfaWR4ID0gd29ya2dyb3VwX2luZGV4ICogJHt3b3JrZ3JvdXBTaXplWCAqIHdvcmtncm91cFNpemVZICogd29ya2dyb3VwU2l6ZVp9dSArIGxvY2FsX2lkeDtgO1xuXG4gICAgcmV0dXJuIGBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt3b3JrZ3JvdXBTaXplWH0sICR7d29ya2dyb3VwU2l6ZVl9LCAke3dvcmtncm91cFNpemVafSlcbiAgZm4gbWFpbigke3BhcmFtTGlzdH0pIHtcbiAgICAke2dsb2JhbElkeERlZmluaXRpb259XG4gIGA7XG4gIH1cblxuICBwcml2YXRlIGFwcGVuZFZhcmlhYmxlVW5pZm9ybXModmFyaWFibGU6IEluZGljZXNIZWxwZXIpOiB2b2lkIHtcbiAgICBpZiAodmFyaWFibGUucmFuayAhPT0gMCkge1xuICAgICAgaWYgKHZhcmlhYmxlLnNoYXBlLnN0YXJ0c1dpdGgoJ3VuaWZvcm1zLicpKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMucHVzaCh7IG5hbWU6IHZhcmlhYmxlLnNoYXBlLnJlcGxhY2UoJ3VuaWZvcm1zLicsICcnKSwgdHlwZTogJ3UzMicsIGxlbmd0aDogdmFyaWFibGUucmFuayB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh2YXJpYWJsZS5zdHJpZGVzLnN0YXJ0c1dpdGgoJ3VuaWZvcm1zLicpKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMucHVzaCh7IG5hbWU6IHZhcmlhYmxlLnN0cmlkZXMucmVwbGFjZSgndW5pZm9ybXMuJywgJycpLCB0eXBlOiAndTMyJywgbGVuZ3RoOiB2YXJpYWJsZS5yYW5rIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGVjbGFyZVZhcmlhYmxlKHZhcmlhYmxlOiBJbmRpY2VzSGVscGVyLCBiaW5kaW5nSW5kZXg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgaWYgKHZhcmlhYmxlLnVzYWdlID09PSAnaW50ZXJuYWwnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCB1c2UgaW50ZXJuYWwgdmFyaWFibGUgd2l0aCBkZWNsYXJlVmFyaWFibGUoKS4gdXNlIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoKSBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICB0aGlzLnZhcmlhYmxlcy5wdXNoKHZhcmlhYmxlKTtcbiAgICB0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModmFyaWFibGUpO1xuICAgIGNvbnN0IGFjY2VzcyA9IHZhcmlhYmxlLnVzYWdlID09PSAnaW5wdXQnID8gJ3JlYWQnIDogJ3JlYWRfd3JpdGUnO1xuICAgIGNvbnN0IHN0b3JhZ2VUeXBlID0gdmFyaWFibGUudXNhZ2UgPT09ICdhdG9taWNPdXRwdXQnID8gYGF0b21pYzxpMzI+YCA6IHZhcmlhYmxlLnR5cGUuc3RvcmFnZTtcbiAgICByZXR1cm4gYEBncm91cCgwKSBAYmluZGluZygke2JpbmRpbmdJbmRleH0pIHZhcjxzdG9yYWdlLCAke2FjY2Vzc30+ICR7dmFyaWFibGUubmFtZX06IGFycmF5PCR7c3RvcmFnZVR5cGV9PjtgO1xuICB9XG5cbiAgZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHZhcmlhYmxlcy5tYXAoKHYpID0+IHRoaXMuZGVjbGFyZVZhcmlhYmxlKHYsIHRoaXMudmFyaWFibGVJbmRleCsrKSkuam9pbignXFxuJyk7XG4gIH1cblxuICBwcml2YXRlIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSh2YXJpYWJsZTogSW5kaWNlc0hlbHBlcik6IHZvaWQge1xuICAgIGlmICh2YXJpYWJsZS51c2FnZSAhPT0gJ2ludGVybmFsJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnY2Fubm90IHVzZSBpbnB1dCBvciBvdXRwdXQgdmFyaWFibGUgd2l0aCByZWdpc3RlckludGVybmFsVmFyaWFibGUoKS4gdXNlIGRlY2xhcmVWYXJpYWJsZXMoKSBpbnN0ZWFkLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZXJuYWxWYXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XG4gICAgdGhpcy5hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHZhcmlhYmxlKTtcbiAgfVxuXG4gIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoLi4udmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10pOiBTaGFkZXJIZWxwZXIge1xuICAgIHZhcmlhYmxlcy5mb3JFYWNoKCh2KSA9PiB0aGlzLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSh2KSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZWdpc3RlclVuaWZvcm0obmFtZTogc3RyaW5nLCB0eXBlOiBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLCBsZW5ndGggPSAxKTogU2hhZGVySGVscGVyIHtcbiAgICB0aGlzLnVuaWZvcm1zLnB1c2goeyBuYW1lLCB0eXBlLCBsZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZWdpc3RlclVuaWZvcm1zKGFkZGl0aW9uYWxVbmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUpOiBTaGFkZXJIZWxwZXIge1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zLmNvbmNhdChhZGRpdGlvbmFsVW5pZm9ybXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHJpdmF0ZSBpbnRlcm5hbFZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdID0gW107XG4gIHByaXZhdGUgdmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10gPSBbXTtcbiAgcHJpdmF0ZSB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXTtcbiAgcHJpdmF0ZSB1bmlmb3JtRGVjbGFyYXRpb24oKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy51bmlmb3Jtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBjb25zdCB1bmlmb3JtU25pcHBldHM6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChjb25zdCB7IG5hbWUsIHR5cGUsIGxlbmd0aCB9IG9mIHRoaXMudW5pZm9ybXMpIHtcbiAgICAgIGlmIChsZW5ndGggJiYgbGVuZ3RoID4gNCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2YxNicpIHtcbiAgICAgICAgICB1bmlmb3JtU25pcHBldHMucHVzaChgQGFsaWduKDE2KSAke25hbWV9OmFycmF5PG1hdDJ4NDwke3R5cGV9PiwgJHtNYXRoLmNlaWwobGVuZ3RoIC8gOCl9PmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuaWZvcm1TbmlwcGV0cy5wdXNoKGAke25hbWV9OmFycmF5PHZlYzQ8JHt0eXBlfT4sICR7TWF0aC5jZWlsKGxlbmd0aCAvIDQpfT5gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHlwZVRlbXAgPSBsZW5ndGggPT0gbnVsbCB8fCBsZW5ndGggPT09IDEgPyB0eXBlIDogYHZlYyR7bGVuZ3RofTwke3R5cGV9PmA7XG4gICAgICAgIHVuaWZvcm1TbmlwcGV0cy5wdXNoKGAke25hbWV9OiR7dHlwZVRlbXB9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGBcbiAgICAgIHN0cnVjdCBVbmlmb3JtcyB7ICR7dW5pZm9ybVNuaXBwZXRzLmpvaW4oJywgJyl9IH07XG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHt0aGlzLnZhcmlhYmxlSW5kZXh9KSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO2A7XG4gIH1cbiAgcHJpdmF0ZSB2YXJpYWJsZUluZGV4ID0gMDtcblxuICAvKipcbiAgICogR2V0IGFkZGl0aW9uYWwgaW1wbGVtZW50YXRpb24gdGhhdCBuZWVkcyB0byBiZSBhZGRlZCB0byB0aGUgc2hhZGVyIHNvdXJjZS5cbiAgICovXG4gIGdldCBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMudW5pZm9ybURlY2xhcmF0aW9uKCkgK1xuICAgICAgdGhpcy52YXJpYWJsZXMubWFwKChpKSA9PiBpLmltcGwoKSkuam9pbignXFxuJykgK1xuICAgICAgdGhpcy5pbnRlcm5hbFZhcmlhYmxlcy5tYXAoKGkpID0+IGkuaW1wbCgpKS5qb2luKCdcXG4nKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YXJpYWJsZSBpbmZvIG9mIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICovXG4gIGdldCB2YXJpYWJsZXNJbmZvKCk6IFByb2dyYW1Vbmlmb3JtVmFyaWFibGVJbmZvW10gfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLnVuaWZvcm1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCB1bmlmb3JtV2dzbFR5cGVUb0RhdGFUeXBlID0gKHR5cGU6IFVuaWZvcm1EYXRhRWxlbWVudFR5cGUpID0+XG4gICAgICBbRGF0YVR5cGUudWludDMyLCBEYXRhVHlwZS5mbG9hdDE2LCBEYXRhVHlwZS5mbG9hdCwgRGF0YVR5cGUuaW50MzJdW1sndTMyJywgJ2YxNicsICdmMzInLCAnaTMyJ10uaW5kZXhPZih0eXBlKV07XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWFwKCh1KSA9PiBbdW5pZm9ybVdnc2xUeXBlVG9EYXRhVHlwZSh1LnR5cGUpLCB1Lmxlbmd0aCA/PyAxXSk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNoYWRlckhlbHBlciA9IChkaXNwYXRjaEdyb3VwOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGxpbWl0czogR1BVU3VwcG9ydGVkTGltaXRzKSA9PlxuICBuZXcgU2hhZGVySGVscGVySW1wbChkaXNwYXRjaEdyb3VwLCBsaW1pdHMpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNwb3NlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IHBlcm06IG51bWJlcltdO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgcGVybTogcmVhZG9ubHkgbnVtYmVyW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cblxuICBpZiAocGVybS5sZW5ndGggIT09IDAgJiYgcGVybS5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGVybSBzaXplICR7cGVybS5sZW5ndGh9IGRvZXMgbm90IG1hdGNoIGlucHV0IHJhbmsgJHtpbnB1dHNbMF0uZGltcy5sZW5ndGh9YCk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEFkanVzdGVkUGVybSA9IChpbnB1dFJhbms6IG51bWJlciwgcGVybTogbnVtYmVyW10pOiBudW1iZXJbXSA9PlxuICBwZXJtLmxlbmd0aCAhPT0gMCA/IHBlcm0gOiBbLi4ubmV3IEFycmF5KGlucHV0UmFuaykua2V5cygpXS5yZXZlcnNlKCk7XG5cbmNvbnN0IGdldE91dHB1dFNoYXBlID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBwZXJtOiBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdID0+XG4gIFNoYXBlVXRpbC5zb3J0QmFzZWRPblBlcm0oaW5wdXRTaGFwZSwgZ2V0QWRqdXN0ZWRQZXJtKGlucHV0U2hhcGUubGVuZ3RoLCBwZXJtKSk7XG5cbmNvbnN0IHBlcm1GdW5jdGlvbkJvZHkgPSAocGVybTogbnVtYmVyW10sIHJhbms6IG51bWJlciwgaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlcik6IHN0cmluZyA9PiB7XG4gIGxldCByZXZlcnNlRnVuYyA9IGBmbiBwZXJtKGk6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7aW5wdXQudHlwZS5pbmRpY2VzfSB7XG4gICAgdmFyIGE6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtgO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7ICsraSkge1xuICAgIC8vIGlucHV0IGluZGljZXMgYW5kIG91dHB1dCBpbmRpY2VzIHNob3VsZCBhbHdheXMgYmUgbGFyZ2VyIG9yIGVxdWFsIHRvIDIsXG4gICAgLy8gc28gaW5kZXhlciBpcyBhbHdheXMgdmFsaWQgdG8gYmUgdXNlZCBvbiBgYWAgYW5kIGBpYC5cbiAgICByZXZlcnNlRnVuYyArPSBgYVske3Blcm1baV19XT1pWyR7aX1dO2A7XG4gIH1cbiAgcmV0dXJuIChyZXZlcnNlRnVuYyArPSAncmV0dXJuIGE7fScpO1xufTtcblxuY29uc3Qgc3F1ZWV6ZVNoYXBlID0gKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgYWRqdXN0ZWRQZXJtOiBudW1iZXJbXSk6IHsgbmV3U2hhcGU6IG51bWJlcltdOyBuZXdQZXJtOiBudW1iZXJbXSB9ID0+IHtcbiAgY29uc3QgbmV3U2hhcGU6IG51bWJlcltdID0gW107XG4gIGNvbnN0IG5ld1Blcm06IG51bWJlcltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoc2hhcGVbaV0gIT09IDEpIHtcbiAgICAgIG5ld1NoYXBlLnB1c2goc2hhcGVbaV0pO1xuICAgIH1cbiAgICBpZiAoc2hhcGVbYWRqdXN0ZWRQZXJtW2ldXSAhPT0gMSkge1xuICAgICAgbmV3UGVybS5wdXNoKGFkanVzdGVkUGVybVtpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IG5ld1NoYXBlLCBuZXdQZXJtIH07XG59O1xuXG5jb25zdCBpc1RyYW5zcG9zZVJlc2hhcGUgPSAocGVybTogbnVtYmVyW10sIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4ge1xuICAvLyBBcyBsb25nIGFzIHRoZSBkaW1zIHdpdGggdmFsdWVzID4gMSBzdGF5IGluIHRoZSBzYW1lIG9yZGVyLCBpdCdzIGEgcmVzaGFwZS5cbiAgLy8gRXhhbXBsZTogU2hhcGU9KDEsMSwxMDI0LDQwOTYpIC0+IHBlcm09KDIsMCwzLDEpLlxuICBsZXQgbGFzdFBlcm11dGVkQXhpcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGVybS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChzaGFwZVtwZXJtW2ldXSA9PT0gMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwZXJtW2ldIDwgbGFzdFBlcm11dGVkQXhpcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsYXN0UGVybXV0ZWRBeGlzID0gcGVybVtpXTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyA9IChpbnB1dFRlbnNvcjogVGVuc29yVmlldywgcGVybUF0dHI6IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dERhdGFUeXBlID0gaW5wdXRUZW5zb3IuZGF0YVR5cGU7XG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0VGVuc29yLmRpbXMubGVuZ3RoO1xuICBjb25zdCBwZXJtID0gZ2V0QWRqdXN0ZWRQZXJtKGlucHV0UmFuaywgcGVybUF0dHIpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGdldE91dHB1dFNoYXBlKGlucHV0VGVuc29yLmRpbXMsIHBlcm0pO1xuICBsZXQgbmV3SW5wdXRTaGFwZSA9IGlucHV0VGVuc29yLmRpbXM7XG4gIGxldCBuZXdPdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICBjb25zdCB0cmFuc3Bvc2VBc1Jlc2hhcGUgPSBpbnB1dFJhbmsgPCAyIHx8IGlzVHJhbnNwb3NlUmVzaGFwZShwZXJtLCBpbnB1dFRlbnNvci5kaW1zKTtcbiAgbGV0IGdldFNoYWRlclNvdXJjZTtcbiAgaWYgKHRyYW5zcG9zZUFzUmVzaGFwZSkge1xuICAgIGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0RGF0YVR5cGUsIG5ld0lucHV0U2hhcGUsIDQpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0RGF0YVR5cGUsIG5ld091dHB1dFNoYXBlLCA0KTtcbiAgICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTtcbiAgfWA7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnVHJhbnNwb3NlQ29weScsXG4gICAgICBzaGFkZXJDYWNoZTogeyBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJ10gfSxcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0VGVuc29yLmRhdGFUeXBlIH1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyAvIDQgLyogY29tcG9uZW50cyAqLykgfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA0KSB9XSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgfTtcbiAgfVxuICBjb25zdCB7IG5ld1NoYXBlLCBuZXdQZXJtIH0gPSBzcXVlZXplU2hhcGUoaW5wdXRUZW5zb3IuZGltcywgcGVybSk7XG4gIGNvbnN0IGNoYW5uZWxzTGFzdCA9IFNoYXBlVXRpbC5hcmVFcXVhbChuZXdQZXJtLCBbMiwgMywgMV0pO1xuICBjb25zdCBjaGFubmVsc0ZpcnN0ID0gU2hhcGVVdGlsLmFyZUVxdWFsKG5ld1Blcm0sIFszLCAxLCAyXSk7XG4gIGNvbnN0IHVzZVNoYXJlZCA9IG5ld1NoYXBlLmxlbmd0aCA9PT0gMiB8fCBjaGFubmVsc0xhc3QgfHwgY2hhbm5lbHNGaXJzdDtcbiAgaWYgKHVzZVNoYXJlZCkge1xuICAgIG5ld0lucHV0U2hhcGUgPSBjaGFubmVsc0xhc3RcbiAgICAgID8gW25ld1NoYXBlWzBdLCBuZXdTaGFwZVsxXSAqIG5ld1NoYXBlWzJdXVxuICAgICAgOiBjaGFubmVsc0ZpcnN0XG4gICAgICAgID8gW25ld1NoYXBlWzBdICogbmV3U2hhcGVbMV0sIG5ld1NoYXBlWzJdXVxuICAgICAgICA6IG5ld1NoYXBlO1xuICAgIG5ld091dHB1dFNoYXBlID0gW25ld0lucHV0U2hhcGVbMV0sIG5ld0lucHV0U2hhcGVbMF1dO1xuICAgIGNvbnN0IHRpbGVTaXplID0gMTY7XG4gICAgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dERhdGFUeXBlLCBuZXdJbnB1dFNoYXBlLmxlbmd0aCk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXREYXRhVHlwZSwgbmV3T3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgdmFyPHdvcmtncm91cD4gdGlsZSA6IGFycmF5PGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke3RpbGVTaXplICsgMX0+LCAke3RpbGVTaXplfT47XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbdGlsZVNpemUsIHRpbGVTaXplLCAxXSl9XG4gICAgbGV0IHN0cmlkZSA9ICh1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV0gLSAxKSAvICR7dGlsZVNpemV9ICsgMTtcbiAgICBsZXQgd29ya2dyb3VwX2lkX3ggPSB3b3JrZ3JvdXBfaW5kZXggJSBzdHJpZGU7XG4gICAgbGV0IHdvcmtncm91cF9pZF95ID0gd29ya2dyb3VwX2luZGV4IC8gc3RyaWRlO1xuICAgIGxldCBpbnB1dF9jb2wgPSB3b3JrZ3JvdXBfaWRfeSAqICR7dGlsZVNpemV9dSArIGxvY2FsX2lkLng7XG4gICAgbGV0IGlucHV0X3JvdyA9IHdvcmtncm91cF9pZF94ICogJHt0aWxlU2l6ZX11ICsgbG9jYWxfaWQueTtcbiAgICBpZiAoaW5wdXRfcm93IDwgdW5pZm9ybXMuYV9zaGFwZVswXSAmJiBpbnB1dF9jb2wgPCB1bmlmb3Jtcy5hX3NoYXBlWzFdKSB7XG4gICAgICB0aWxlW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtpbnB1dC5nZXRCeUluZGljZXMoYCR7aW5wdXQudHlwZS5pbmRpY2VzfShpbnB1dF9yb3csIGlucHV0X2NvbClgKX07XG4gICAgfVxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIGxldCBvdXRwdXRfY29sID0gd29ya2dyb3VwX2lkX3ggKiAke3RpbGVTaXplfXUgKyBsb2NhbF9pZC54O1xuICAgIGxldCBvdXRwdXRfcm93ID0gd29ya2dyb3VwX2lkX3kgKiAke3RpbGVTaXplfXUgKyBsb2NhbF9pZC55O1xuICAgIGlmIChvdXRwdXRfcm93IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzBdICYmIG91dHB1dF9jb2wgPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV0pIHtcbiAgICAgICR7b3V0cHV0LnNldEJ5SW5kaWNlcyhgJHtvdXRwdXQudHlwZS5pbmRpY2VzfShvdXRwdXRfcm93LCBvdXRwdXRfY29sKWAsICd0aWxlW2xvY2FsX2lkLnhdW2xvY2FsX2lkLnldJyl9XG4gICAgfVxuICB9YDtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnVHJhbnNwb3NlU2hhcmVkJyxcbiAgICAgIHNoYWRlckNhY2hlOiB7IGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnXSB9LFxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4ge1xuICAgICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRUZW5zb3IuZGF0YVR5cGUgfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwobmV3T3V0cHV0U2hhcGVbMV0gLyB0aWxlU2l6ZSksIHk6IE1hdGguY2VpbChuZXdPdXRwdXRTaGFwZVswXSAvIHRpbGVTaXplKSB9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAgICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG5ld0lucHV0U2hhcGUsIG5ld091dHB1dFNoYXBlKSxcbiAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXREYXRhVHlwZSwgbmV3SW5wdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dERhdGFUeXBlLCBuZXdPdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cblxuICAke3Blcm1GdW5jdGlvbkJvZHkocGVybSwgaW5wdXRSYW5rLCBpbnB1dCwgb3V0cHV0KX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuXG4gICAgbGV0IGluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgaW5wdXQuZ2V0QnlJbmRpY2VzKCdhSW5kaWNlcycpKX1cbiAgfWA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1RyYW5zcG9zZScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7cGVybUF0dHJ9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRUZW5zb3IuZGF0YVR5cGUgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhuZXdJbnB1dFNoYXBlLCBuZXdPdXRwdXRTaGFwZSksXG4gICAgICAgIF0sXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHRyYW5zcG9zZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogVHJhbnNwb3NlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcy5wZXJtKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCBhdHRyaWJ1dGVzLnBlcm0pKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHBlcm06IGF0dHJpYnV0ZXMucGVybSBhcyBudW1iZXJbXSB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cywgUmVkdWNlQXR0cmlidXRlcyB9IGZyb20gJy4vcmVkdWNlJztcbmltcG9ydCB7IGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvIH0gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5jb25zdCByZWR1Y2VPcHM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gIG1heDogJ3NlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKScsXG4gIG1pbjogJ3NlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKScsXG4gIG1lYW46ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBzdW06ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBwcm9kOiAnYmVzdFZhbHVlICogY2FuZGlkYXRlJyxcbiAgc3VtU3F1YXJlOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlJyxcbiAgbG9nU3VtRXhwOiAnYmVzdFZhbHVlICsgZXhwKGNhbmRpZGF0ZSknLFxuICBsMTogJ2Jlc3RWYWx1ZSArIGFicyhjYW5kaWRhdGUpJyxcbiAgbDI6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGUnLFxuICBsb2dTdW06ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxufTtcblxuY29uc3QgcmVkdWNlU2hhcmVkT3BzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICBtYXg6ICdzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSknLFxuICBtaW46ICdzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSknLFxuICBtZWFuOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgc3VtOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgcHJvZDogJ2Jlc3RWYWx1ZSAqIGNhbmRpZGF0ZScsXG4gIHN1bVNxdWFyZTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIGxvZ1N1bUV4cDogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIGwxOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgbDI6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBsb2dTdW06ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxufTtcblxuY29uc3QgcmVkdWNlSW5pdFZhbHVlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgbWF4OiAnX0Fbb2Zmc2V0XScsXG4gIG1pbjogJ19BW29mZnNldF0nLFxuICBtZWFuOiAnMCcsXG4gIHN1bTogJzAnLFxuICBwcm9kOiAnMScsXG4gIHN1bVNxdWFyZTogJzAnLFxuICBsb2dTdW1FeHA6ICcwJyxcbiAgbDE6ICcwJyxcbiAgbDI6ICcwJyxcbiAgbG9nU3VtOiAnMCcsXG59O1xuXG5jb25zdCByZWR1Y2VPdXRwdXRWYWx1ZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gIG1heDogJ2Jlc3RWYWx1ZScsXG4gIG1pbjogJ2Jlc3RWYWx1ZScsXG4gIHN1bTogJ2Jlc3RWYWx1ZScsXG4gIHByb2Q6ICdiZXN0VmFsdWUnLFxuICBzdW1TcXVhcmU6ICdiZXN0VmFsdWUnLFxuICBsb2dTdW1FeHA6ICdsb2coYmVzdFZhbHVlKScsXG4gIGwxOiAnYmVzdFZhbHVlJyxcbiAgbDI6ICdzcXJ0KGJlc3RWYWx1ZSknLFxuICBsb2dTdW06ICdsb2coYmVzdFZhbHVlKScsXG59O1xuXG5jb25zdCBnZXRJbm5lck1vc3RBeGVzID0gKG51bUlubmVyQXhlczogbnVtYmVyLCByYW5rOiBudW1iZXIpOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gcmFuayAtIG51bUlubmVyQXhlczsgaSA8IHJhbms7ICsraSkge1xuICAgIHJlcy5wdXNoKGkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5jb25zdCBjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzID0gKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10pOiBbbnVtYmVyW10sIG51bWJlcltdXSA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW107XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IHJhbms7IGRpbSsrKSB7XG4gICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xuICAgICAgb3V0cHV0U2hhcGUucHVzaChzaGFwZVtkaW1dKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVkdWNlU2hhcGUgPSBheGVzLm1hcCgoZGltKSA9PiBzaGFwZVtkaW1dKTtcbiAgcmV0dXJuIFtvdXRwdXRTaGFwZSwgcmVkdWNlU2hhcGVdO1xufTtcblxuY29uc3QgZXhwYW5kU2hhcGVUb0tlZXBEaW0gPSAoc2hhcGU6IG51bWJlcltdLCBheGVzOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aCArIGF4ZXMubGVuZ3RoO1xuICBjb25zdCBleHBhbmRTaGFwZSA9IFtdO1xuICBsZXQgc2hhcGVJZHggPSAwO1xuICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCByYW5rOyBkaW0rKykge1xuICAgIGlmIChheGVzLmluZGV4T2YoZGltKSA9PT0gLTEpIHtcbiAgICAgIGV4cGFuZFNoYXBlLnB1c2goc2hhcGVbc2hhcGVJZHgrK10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBhbmRTaGFwZS5wdXNoKDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwYW5kU2hhcGU7XG59O1xuXG5jb25zdCBhcmVBeGVzSW5uZXJNb3N0RGltcyA9IChheGVzOiBudW1iZXJbXSwgcmFuazogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChheGVzW2F4ZXMubGVuZ3RoIC0gaSAtIDFdICE9PSByYW5rIC0gMSAtIGkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBnZXRBeGVzUGVybXV0YXRpb24gPSAoYXhlczogbnVtYmVyW10sIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcmVzID0gW107XG4gIGlmICghYXJlQXhlc0lubmVyTW9zdERpbXMoYXhlcywgcmFuaykpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7ICsraSkge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihpKSA9PT0gLTEpIHtcbiAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF4ZXMuZm9yRWFjaCgoYXhpcykgPT4gcmVzLnB1c2goYXhpcykpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUmVkdWNlU2hhcmVkUHJvZ3JhbUluZm8gPSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgY2FjaGVLZXk6IHN0cmluZyxcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIHJlZHVjZVR5cGU6IHN0cmluZyxcbiAgb3V0cHV0RGF0YVR5cGU6IERhdGFUeXBlLFxuICBvdXRwdXRTaGFwZTogbnVtYmVyW10sXG4gIHJlZHVjZVNoYXBlOiBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHJlZHVjZVNpemUgPSBTaGFwZVV0aWwuc2l6ZShyZWR1Y2VTaGFwZSk7XG5cbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdfQScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRTaGFwZSk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBvdXRwdXREYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuXG4gIGxldCB3b3JrZ3JvdXBTaXplID0gNjQ7XG4gIC8vIElmIG9ubHkgb25lIHdvcmtncm91cCBpcyBkaXNwYXRjaGVkLCBpbmNyZWFzZSB3b3JrZ3JvdXBTaXplIHRvIGltcHJvdmUgcGFyYWxsZWxpc20uXG4gIGlmIChvdXRwdXRTaXplID09PSAxKSB7XG4gICAgd29ya2dyb3VwU2l6ZSA9IDI1NjtcbiAgfVxuXG4gIGNvbnN0IHNoYXJlZE1lbW9yeVNuaXBwZXQgPSBgXG4gICAgICAgICAgdmFyPHdvcmtncm91cD4gYUJlc3RWYWx1ZXMgOiBhcnJheTxmMzIsICR7d29ya2dyb3VwU2l6ZX0+O1xuICAgICAgIGA7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgncmVkdWNlU2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuICAgICAgICAke3NoYXJlZE1lbW9yeVNuaXBwZXR9XG4gICAgICAgIGZuIERJVl9DRUlMKGEgOiB1MzIsIGIgOiB1MzIpIC0+IHUzMiB7XG4gICAgICAgICAgcmV0dXJuICgoYSAtIDF1KSAvIGIgKyAxdSk7XG4gICAgICAgICB9XG4gICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQod29ya2dyb3VwU2l6ZSl9XG5cbiAgICAgICAgICBsZXQgb3V0cHV0SW5kZXggPSBnbG9iYWxfaWR4IC8gJHt3b3JrZ3JvdXBTaXplfTtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gb3V0cHV0SW5kZXggKiB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuXG4gICAgICAgICAgdmFyIGJlc3RWYWx1ZSA9IGYzMigke3JlZHVjZUluaXRWYWx1ZXNbcmVkdWNlVHlwZV19KTtcbiAgICAgICAgICBsZXQgTGVuZ3RoID0gdW5pZm9ybXMucmVkdWNlU2l6ZTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gbG9jYWxfaWR4OyBrIDwgTGVuZ3RoOyBrID0gayArICR7d29ya2dyb3VwU2l6ZX0pIHtcbiAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGYzMigke2lucHV0LmdldEJ5T2Zmc2V0KCdvZmZzZXQgKyBrJyl9KTtcbiAgICAgICAgICAgYmVzdFZhbHVlID0gJHtyZWR1Y2VPcHNbcmVkdWNlVHlwZV19O1xuICAgICAgICAgIH1cbiAgICAgICAgICBhQmVzdFZhbHVlc1tsb2NhbF9pZHhdID0gYmVzdFZhbHVlO1xuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgdmFyIHJlZHVjZVNpemUgPSBtaW4oTGVuZ3RoLCAke3dvcmtncm91cFNpemV9dSk7XG4gICAgICAgICBmb3IgKHZhciBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydTsgcmVkdWNlU2l6ZSA+IDF1O1xuICAgICAgICAgICAgIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1KSB7XG4gICAgICAgICAgIGxldCBpbnRlcnZhbCA9IERJVl9DRUlMKHJlZHVjZVNpemUsIDJ1KTtcbiAgICAgICAgICAgaWYgKGxvY2FsX2lkeCA8IGN1cnJlbnRTaXplKSB7XG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gYUJlc3RWYWx1ZXNbbG9jYWxfaWR4ICsgaW50ZXJ2YWxdO1xuICAgICAgICAgICAgYmVzdFZhbHVlID0gJHtyZWR1Y2VTaGFyZWRPcHNbcmVkdWNlVHlwZV19O1xuICAgICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZWR1Y2VTaXplID0gaW50ZXJ2YWw7XG4gICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKGxvY2FsX2lkeCA9PSAwdSkge1xuICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KFxuICAgICAgICAgICAgJ291dHB1dEluZGV4JyxcbiAgICAgICAgICAgIGAke1xuICAgICAgICAgICAgICByZWR1Y2VUeXBlID09PSAnbWVhbidcbiAgICAgICAgICAgICAgICA/IGAke291dHB1dC50eXBlLnN0b3JhZ2V9KGJlc3RWYWx1ZSAvIGYzMih1bmlmb3Jtcy5yZWR1Y2VTaXplKSlgXG4gICAgICAgICAgICAgICAgOiBgJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgke3JlZHVjZU91dHB1dFZhbHVlc1tyZWR1Y2VUeXBlXX0pYFxuICAgICAgICAgICAgfWAsXG4gICAgICAgICAgKX07XG4gICAgICAgICB9XG4gICAgICAgIH1gO1xuXG4gIC8vIE9uZSB3b3JrIGdyb3VwIGlzIHJlc3BvbnNpYmxlIGZvciBvbmx5IG9uZSBlbGVtZW50IG9mIG91dHB1dC5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIC8vIE5vdGUgdGhhdCBpbiBKU0VQLCBXRyBzaXplIGlzIG5vdCBpbmNsdWRlZCBpbiBjYWNoZSBieSBkZWZhdWx0LCBidXQgV2ViR1BVIEVQIGl0IGlzLlxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2NhY2hlS2V5fTske3dvcmtncm91cFNpemV9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZSddIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBvdXRwdXRTaXplIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcmVkdWNlU2l6ZSB9XSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmNvbnN0IHJlZHVjZUNvbW1vbiA9IChcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXG4gIG5hbWU6IHN0cmluZyxcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbiAgcmVkdWNlVHlwZTogJ3N1bScgfCAnc3VtU3F1YXJlJyB8ICdwcm9kJyB8ICdtaW4nIHwgJ21heCcgfCAnbWVhbicgfCAnbG9nU3VtRXhwJyB8ICdsMScgfCAnbDInIHwgJ2xvZ1N1bScsXG4pOiB2b2lkID0+IHtcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMgPVxuICAgIGNvbnRleHQuaW5wdXRzLmxlbmd0aCA9PT0gMSA/IGF0dHJpYnV0ZXMgOiBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG5cbiAgbGV0IHVwZGF0ZWRBeGVzID0gdXBkYXRlZEF0dHJpYnV0ZXMuYXhlcztcbiAgaWYgKHVwZGF0ZWRBeGVzLmxlbmd0aCA9PT0gMCAmJiAhdXBkYXRlZEF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpIHtcbiAgICB1cGRhdGVkQXhlcyA9IGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubWFwKChfZGltLCBpKSA9PiBpKTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVBeGVzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXModXBkYXRlZEF4ZXMsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcblxuICBsZXQgYXhlcyA9IG5vcm1hbGl6ZUF4ZXM7XG4gIGxldCBpbnB1dCA9IGNvbnRleHQuaW5wdXRzWzBdO1xuICBjb25zdCBwZXJtdXRlZEF4ZXMgPSBnZXRBeGVzUGVybXV0YXRpb24oYXhlcywgY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICBpZiAocGVybXV0ZWRBeGVzLmxlbmd0aCA+IDApIHtcbiAgICBpbnB1dCA9IGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgcGVybXV0ZWRBeGVzKSwge1xuICAgICAgaW5wdXRzOiBbMF0sXG4gICAgICBvdXRwdXRzOiBbLTFdLFxuICAgIH0pWzBdO1xuICAgIGF4ZXMgPSBnZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCBpbnB1dC5kaW1zLmxlbmd0aCk7XG4gIH1cblxuICBjb25zdCBbb3V0cHV0U2hhcGUsIHJlZHVjZVNoYXBlXSA9IGNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoaW5wdXQuZGltcywgYXhlcyk7XG4gIGxldCBmaW5hbE91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gIGlmICh1cGRhdGVkQXR0cmlidXRlcy5rZWVwRGltcykge1xuICAgIGZpbmFsT3V0cHV0U2hhcGUgPSBleHBhbmRTaGFwZVRvS2VlcERpbShvdXRwdXRTaGFwZSwgbm9ybWFsaXplQXhlcyk7XG4gIH1cblxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlUmVkdWNlU2hhcmVkUHJvZ3JhbUluZm8oXG4gICAgICBuYW1lLFxuICAgICAgdXBkYXRlZEF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgICBbaW5wdXRdLFxuICAgICAgcmVkdWNlVHlwZSxcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLFxuICAgICAgZmluYWxPdXRwdXRTaGFwZSxcbiAgICAgIHJlZHVjZVNoYXBlLFxuICAgICksXG4gICAgeyBpbnB1dHM6IFtpbnB1dF0gfSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNZWFuU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTWVhblNoYXJlZCcsIGF0dHJpYnV0ZXMsICdtZWFuJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTDFTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VMMVNoYXJlZCcsIGF0dHJpYnV0ZXMsICdsMScpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUwyU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTDJTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbDInKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW1FeHBTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VMb2dTdW1FeHBTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbG9nU3VtRXhwJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTWF4U2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTWF4U2hhcmVkJywgYXR0cmlidXRlcywgJ21heCcpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1pblNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZU1pblNoYXJlZCcsIGF0dHJpYnV0ZXMsICdtaW4nKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VQcm9kU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlUHJvZFNoYXJlZCcsIGF0dHJpYnV0ZXMsICdwcm9kJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlU3VtU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlU3VtU2hhcmVkJywgYXR0cmlidXRlcywgJ3N1bScpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVN1bVNxdWFyZVNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZVN1bVNxdWFyZVNoYXJlZCcsIGF0dHJpYnV0ZXMsICdzdW1TcXVhcmUnKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW1TaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VMb2dTdW1TaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbG9nU3VtJyk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVNoYWRlckNhY2hlSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQge1xuICByZWR1Y2VMMVNoYXJlZCxcbiAgcmVkdWNlTDJTaGFyZWQsXG4gIHJlZHVjZUxvZ1N1bUV4cFNoYXJlZCxcbiAgcmVkdWNlTG9nU3VtU2hhcmVkLFxuICByZWR1Y2VNYXhTaGFyZWQsXG4gIHJlZHVjZU1lYW5TaGFyZWQsXG4gIHJlZHVjZU1pblNoYXJlZCxcbiAgcmVkdWNlUHJvZFNoYXJlZCxcbiAgcmVkdWNlU3VtU2hhcmVkLFxuICByZWR1Y2VTdW1TcXVhcmVTaGFyZWQsXG59IGZyb20gJy4vcmVkdWNlLXNoYXJlZCc7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPT09IDAgfHwgaW5wdXRzLmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZSBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDIgJiYgaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGF4ZXMgaW5wdXQgZGltcy4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBSZWR1Y2VBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAga2VlcERpbXM6IGJvb2xlYW47XG4gIG5vb3BXaXRoRW1wdHlBeGVzOiBib29sZWFuO1xuICBheGVzOiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IHR5cGUgUmVkdWNlT3AgPSAoXG4gIGlucHV0OiBJbmRpY2VzSGVscGVyLFxuICBvdXRwdXQ6IEluZGljZXNIZWxwZXIsXG4gIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuKSA9PiBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nLCAuLi5zdHJpbmdbXV07XG5cbmNvbnN0IG5vT3A6IFJlZHVjZU9wID0gKGlucHV0KSA9PiBbJycsICcnLCBgdmFyIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCwgJyddO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIHNoYWRlckNhY2hlOiBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgcmVkdWNlT3A6IFJlZHVjZU9wLFxuICBheGVzSW5wdXQ6IG51bWJlcltdLFxuICBvdXRwdXREYXRhVHlwZTogRGF0YVR5cGUsXG4gIGtlZXBEaW1zID0gZmFsc2UsXG4gIG5vb3BXaXRoRW1wdHlBeGVzID0gZmFsc2UsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBheGVzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXMoYXhlc0lucHV0LCBpbnB1dFJhbmspO1xuICBjb25zdCByZWR1Y2VPbkFsbEF4ZXMgPSAhbm9vcFdpdGhFbXB0eUF4ZXMgJiYgYXhlcy5sZW5ndGggPT09IDA7XG4gIGlucHV0U2hhcGUuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgIGlmIChyZWR1Y2VPbkFsbEF4ZXMgfHwgYXhlcy5pbmRleE9mKGkpID49IDApIHtcbiAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKDEpO1xuICAgICAgfSAvLyBlbHNlIHsgLy8gc2tpcCB0aGlzIGF4aXN9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dFNoYXBlLnB1c2goZCk7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgb3V0cHV0UmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaWR4Q29weTogc3RyaW5nW10gPSBbXTsgLy8gY29weSBvdXRwdXQgaW5kZXhlcyB0byBpbnB1dCBpbmRleGVzXG5cbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ19BJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFJhbmspO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBvdXRwdXREYXRhVHlwZSwgb3V0cHV0UmFuayk7XG4gICAgY29uc3Qgb3BzID0gcmVkdWNlT3AoaW5wdXQsIG91dHB1dCwgYXhlcyk7XG4gICAgbGV0IHJlZHVjZU9wcyA9IG9wc1syXTtcblxuICAgIGZvciAobGV0IGsgPSAwLCBsID0gMDsgayA8IGlucHV0UmFuazsgaysrKSB7XG4gICAgICAvLyBpZiB0aGlzIGF4aXMgaXMgcmVkdWNlZFxuICAgICAgaWYgKHJlZHVjZU9uQWxsQXhlcyB8fCBheGVzLmluZGV4T2YoaykgPj0gMCkge1xuICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICBsKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vcCBvdmVyIHRoZSBkLXRoIGF4aXNcbiAgICAgICAgcmVkdWNlT3BzID0gYGZvcih2YXIgaiR7a306IHUzMiA9IDA7IGoke2t9IDwgJHtpbnB1dFNoYXBlW2tdfTsgaiR7a30rKykge1xuICAgICAgICAgICAgICAgICAgJHtvcHNbMl0uaW5jbHVkZXMoJ2xhc3RfaW5kZXgnKSA/IGBsZXQgbGFzdF9pbmRleCA9IGoke2t9O2AgOiAnJ31cbiAgICAgICAgICAgICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGssIGBqJHtrfWApfVxuICAgICAgICAgICAgICAgICAgJHtyZWR1Y2VPcHN9XG4gICAgICAgICAgICAgICAgfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHhDb3B5LnB1c2goYCR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGssIG91dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsIGwpKX07YCk7XG4gICAgICAgIGwrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGBcblxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG5cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcblxuICAgICAgICAgICR7aWR4Q29weS5qb2luKCdcXG4nKX1cbiAgICAgICAgICAke29wc1swXX0gICAgICAgLy8gaW5pdCBvcHMgZm9yIHJlZHVjZSBtYXgvbWluXG4gICAgICAgICAgJHtvcHNbMV19XG4gICAgICAgICAgJHtyZWR1Y2VPcHN9XG4gICAgICAgICAgJHtvcHNbM119XG4gICAgICAgICAgJHtvcHMubGVuZ3RoID09PSA0ID8gb3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJykgOiBvcHMuc2xpY2UoNCkuam9pbignXFxuJyl9XG4gICAgICAgIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBzaGFkZXJDYWNoZSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUpLFxuICAgICAgXSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMsXG4pOiBSZWR1Y2VBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgYXhlczogbnVtYmVyW10gPSBbXTtcbiAgaWYgKGlucHV0c1sxXS5kaW1zWzBdID4gMCkge1xuICAgIGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCgodikgPT4gYXhlcy5wdXNoKE51bWJlcih2KSkpO1xuICB9XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIGF4ZXMsXG4gICAga2VlcERpbXM6IGF0dHJpYnV0ZXMua2VlcERpbXMsXG4gICAgbm9vcFdpdGhFbXB0eUF4ZXM6IGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMsXG4gIH0pO1xufTtcblxuY29uc3QgcnVuUmVkdWNlUHJvZ3JhbSA9IChcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXG4gIG5hbWU6IHN0cmluZyxcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbiAgcmVkdWNlT3A6IFJlZHVjZU9wLFxuKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICBjb25zdCB1cGRhdGVkQXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyA9XG4gICAgaW5wdXRzLmxlbmd0aCA9PT0gMSA/IGF0dHJpYnV0ZXMgOiBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpO1xuXG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbyhcbiAgICAgIG5hbWUsXG4gICAgICB7IGhpbnQ6IHVwZGF0ZWRBdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcbiAgICAgIFtpbnB1dHNbMF1dLFxuICAgICAgdXBkYXRlZEF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMgJiYgdXBkYXRlZEF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPT09IDAgPyBub09wIDogcmVkdWNlT3AsXG4gICAgICB1cGRhdGVkQXR0cmlidXRlcy5heGVzLFxuICAgICAgaW5wdXRzWzBdLmRhdGFUeXBlLFxuICAgICAgdXBkYXRlZEF0dHJpYnV0ZXMua2VlcERpbXMsXG4gICAgICB1cGRhdGVkQXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcyxcbiAgICApLFxuICAgIHsgaW5wdXRzOiBbMF0gfSxcbiAgKTtcbn07XG5cbmNvbnN0IHJlZHVjZUxvZ1N1bU5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcbiAgICBgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgwKTtgLFxuICAgICcnLFxuICAgIGB2YWx1ZSArPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxuICAgICd2YWx1ZSA9IGxvZyh2YWx1ZSk7JyxcbiAgXTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTG9nU3VtJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlTDFOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PiBbXG4gICAgYHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oMCk7YCxcbiAgICAnJyxcbiAgICBgdmFsdWUgKz0gYWJzKCR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxuICAgICcnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMMScsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZUwyTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xuICAgIGB2YXIgdCA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTtgLFxuICAgICcnLFxuICAgIGB0ID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07IHZhbHVlICs9ICh0ICogdCk7YCxcbiAgICAndmFsdWUgPSBzcXJ0KHZhbHVlKTsnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMMicsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZUxvZ1N1bUV4cE5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcbiAgICBgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgwKTtgLFxuICAgICcnLFxuICAgIGB2YWx1ZSArPSBleHAoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXG4gICAgJ3ZhbHVlID0gbG9nKHZhbHVlKTsnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMb2dTdW1FeHAnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VNYXhOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgX291dHB1dCwgYXhlcykgPT4ge1xuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlkeFplcm8ucHVzaChpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaywgMCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICBgJHtpZHhaZXJvLmpvaW4oJ1xcbicpfWAsXG4gICAgICBgdmFyIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCxcbiAgICAgIGB2YWx1ZSA9IG1heCh2YWx1ZSwgJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXG4gICAgICAnJyxcbiAgICBdO1xuICB9O1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VNYXgnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VNZWFuTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCwgYXhlcykgPT4ge1xuICAgIGxldCBzaXplID0gMS4wO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBkZXBlbmRzIG9uIHRoZSBpbnB1dCBkaW1zLiBJZiB3ZSB3YW50IHRvIHVzZSB1bmlmb3JtLCB0aGlzIG5lZWQgdG8gYmUgdXBkYXRlZC5cbiAgICAgICAgc2l6ZSAqPSBjb250ZXh0LmlucHV0c1swXS5kaW1zW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICAndmFyIHN1bSA9IGYzMigwKTsnLFxuICAgICAgJycsXG4gICAgICBgc3VtICs9IGYzMigke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSk7YCxcbiAgICAgIGBsZXQgdmFsdWUgPSAke291dHB1dC50eXBlLnZhbHVlfShzdW0gLyAke3NpemV9KTtgLFxuICAgIF07XG4gIH07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZU1lYW4nLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VNaW5OYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgX291dHB1dCwgYXhlcykgPT4ge1xuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRfaW5kaWNlc1ske2t9XSA9IDA7YCk7IC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgYCR7aWR4WmVyby5qb2luKCdcXG4nKX1gLFxuICAgICAgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXG4gICAgICBgdmFsdWUgPSBtaW4odmFsdWUsICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxuICAgICAgJycsXG4gICAgXTtcbiAgfTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTWluJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlUHJvZE5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcbiAgICBgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgxKTtgLFxuICAgICcnLFxuICAgIGB2YWx1ZSAqPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxuICAgICcnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VQcm9kJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlU3VtTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xuICAgIGB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDApO2AsXG4gICAgJycsXG4gICAgYHZhbHVlICs9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXG4gICAgJycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZVN1bScsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZVN1bVNxdWFyZU5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcbiAgICBgdmFyIHQgPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7YCxcbiAgICAnJyxcbiAgICBgdCA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9OyB2YWx1ZSArPSB0ICogdDtgLFxuICAgICcnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VTdW1TcXVhcmUnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCB1c2VOYWl2ZVJlZHVjZU1ldGhvZCA9IChcbiAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBheGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgbm9vcFdpdGhFbXB0eUF4ZXM6IGJvb2xlYW4sXG4pOiBib29sZWFuID0+IHtcbiAgaWYgKGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5vb3BXaXRoRW1wdHlBeGVzO1xuICB9XG5cbiAgbGV0IG91dHB1dFNpemUgPSAxO1xuICBsZXQgcmVkdWNlU2l6ZSA9IDE7XG4gIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGF4ZXMubGVuZ3RoOyBkaW0rKykge1xuICAgIGlmIChheGVzLmluZGV4T2YoZGltKSA9PT0gLTEpIHtcbiAgICAgIG91dHB1dFNpemUgKj0gc2hhcGVbZGltXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkdWNlU2l6ZSAqPSBzaGFwZVtkaW1dO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoZSBjb25kaXRpb24gZGF0YSBpcyB2ZXJ5IHJvdWdoLCBhbHRob3VnaCBjb25zaWRlcmluZyB0aGUgY291bnQgb2YgRXhlY3V0aW9uIFVuaXQgKEVVKSwgdGhlIHBvdGVudGlhbFxuICAvLyB3b3JrIGdyb3VwcyBpbiBhIEVVIGFuZCB0aGUgY291bnRzIG9mIGxvb3BzIGluIHRoZSBuYWl2ZSBhbmQgc2hhcmVkIG1ldGhvZHMsIGFsc28gZG9pbmcgZXhwZXJpbWVudHNcbiAgLy8gb24gc29tZSBtYWNoaW5lcy5cbiAgcmV0dXJuIHJlZHVjZVNpemUgPCAzMiAmJiBvdXRwdXRTaXplID4gMTAyNDtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNZWFuID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlTWVhbk5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZU1lYW5TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMMSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZUwxTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlTDFTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMMiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZUwyTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlTDJTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW1FeHAgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VMb2dTdW1FeHBOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VMb2dTdW1FeHBTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNYXggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VNYXhOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VNYXhTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNaW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VNaW5OYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VNaW5TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VQcm9kID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlUHJvZE5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZVByb2RTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VTdW0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VTdW1OYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VTdW1TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VTdW1TcXVhcmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VTdW1TcXVhcmVOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VTdW1TcXVhcmVTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VMb2dTdW1OYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VMb2dTdW1TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFRPRE86IHRoaXMgaXMgdGhlIHNhbWUgbmFpdmUgaW1wbGVtZW50YXRpb24gd2UgdXNlIGZvciByZWR1Y2UgdGhhdCBoYXNcbi8vIHBlcmZvcm1hbmNlIGxpbWl0YXRpb25zIHdoZW4gdGhlIHJlZHVjZWQgYXhpcyBpcyBsb25nLiBOZWVkIHRvIGFkZFxuLy8gYSBvcHRpbWl6ZWQgY29kZXBhdGggZm9yIHRoaXMuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbywgUmVkdWNlT3AgfSBmcm9tICcuL3JlZHVjZSc7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPT09IDAgfHwgaW5wdXRzLmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ01pbk1heE9wIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBBcmdNaW5NYXhBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAga2VlcERpbXM6IGJvb2xlYW47XG4gIGF4aXM6IG51bWJlcjtcbiAgc2VsZWN0TGFzdEluZGV4OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBhcmdNaW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFyZ01pbk1heEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCBhcmdNaW5NYXhPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCwgYXhlcykgPT4ge1xuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRfaW5kaWNlc1ske2t9XSA9IDA7YCk7IC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIGAke2lkeFplcm8uam9pbignXFxuJyl9YCxcbiAgICAgIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcXG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxcbiAgICAgIGBpZiAoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0gJHthdHRyaWJ1dGVzLnNlbGVjdExhc3RJbmRleCA+IDAgPyAnPD0nIDogJzwnfSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XG4gICAgICAgfWAsXG4gICAgICAnJyxcbiAgICAgIG91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdiZXN0X2luZGV4JyksXG4gICAgXTtcbiAgfTtcblxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8oXG4gICAgICAnQXJnTWluJyxcbiAgICAgIHsgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXG4gICAgICBbY29udGV4dC5pbnB1dHNbMF1dLFxuICAgICAgYXJnTWluTWF4T3AsXG4gICAgICBbYXR0cmlidXRlcy5heGlzXSxcbiAgICAgIERhdGFUeXBlLmludDY0LFxuICAgICAgYXR0cmlidXRlcy5rZWVwRGltcyxcbiAgICApLFxuICAgIHsgaW5wdXRzOiBbMF0gfSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhcmdNYXggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFyZ01pbk1heEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCBhcmdNaW5NYXhPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCwgYXhlcykgPT4ge1xuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRfaW5kaWNlc1ske2t9XSA9IDA7YCk7IC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIGAke2lkeFplcm8uam9pbignXFxuJyl9YCxcbiAgICAgIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcXG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxcbiAgICAgIGBpZiAoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0gJHthdHRyaWJ1dGVzLnNlbGVjdExhc3RJbmRleCA+IDAgPyAnPj0nIDogJz4nfSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XG4gICAgICAgfWAsXG4gICAgICAnJyxcbiAgICAgIG91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdiZXN0X2luZGV4JyksXG4gICAgXTtcbiAgfTtcblxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8oXG4gICAgICAnYXJnTWF4JyxcbiAgICAgIHsgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXG4gICAgICBbY29udGV4dC5pbnB1dHNbMF1dLFxuICAgICAgYXJnTWluTWF4T3AsXG4gICAgICBbYXR0cmlidXRlcy5heGlzXSxcbiAgICAgIERhdGFUeXBlLmludDY0LFxuICAgICAgYXR0cmlidXRlcy5rZWVwRGltcyxcbiAgICApLFxuICAgIHsgaW5wdXRzOiBbMF0gfSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUFyZ01pbk1heEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBBcmdNaW5NYXhBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIE9taXQ8QXJnTWluTWF4QXR0cmlidXRlcywga2V5b2YgQXR0cmlidXRlV2l0aENhY2hlS2V5Pik7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIEdwdURhdGFUeXBlLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGdldE1heENvbXBvbmVudHMsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcbiAgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSxcbiAgVW5pZm9ybURhdGFFbGVtZW50VHlwZSxcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGNvbnN0IGVudW0gQXR0ZW50aW9uUWt2Rm9ybWF0IHtcbiAgdW5rbm93biwgLy8gZW51bSB2YWx1ZSBub3Qgc2V0LCBvciBkZXBlbmRzIG9uIHFrdiBwcm9qZWN0aW9uIGltcGxlbWVudGF0aW9uIGRldGFpbHNcbiAgcWt2Qk5TSCwgLy8gZm9yIG5vbi1wYWNrZWQgcWt2LCBwZXJtdXRlZFxuICBxa3ZCU05ILCAvLyBmb3Igbm9uLXBhY2tlZCBxa3YsIG5vdCBwZXJtdXRlZCwgdXNlZCBieSBtZW1vcnkgZWZmaWNpZW50IGF0dGVudGlvbiBvciBNdWx0aUhlYWRBdHRlbnRpb25cbiAgcWt2QlNOM0gsIC8vIGZvciBUUlQgZnVzZWQgYXR0ZW50aW9uLCBxa3YgYXJlIHBhY2tlZFxuICBxa3ZCTlNIcWt2QlMzTkgsIC8vIGZvciBUUlQgZnVzZWQgY2F1c2FsIGF0dGVudGlvbiwgZGF0YSBoYXMgdHdvIGZvcm1hdHMgKHFrdiBpcyAzQk5TSCwgZ2VtbV9idWZmZXIgaXMgQlMzTkgpXG4gIHFLdkJTTkh4QlNOMkgsIC8vIGZvciBUUlQgZnVzZWQgY3Jvc3MgYXR0ZW50aW9uLCBrdiBhcmUgcGFja2VkXG4gIHFrdlROSCwgLy8gZm9yIG1lbW9yeSBlZmZpY2llbnQgYXR0ZW50aW9uLCBxa3YgYXJlIG5vdCBwYWNrZWQsIGFuZCBwYWRkaW5ncyBhcmUgcmVtb3ZlZC5cbiAgcWt2VE4zSCwgLy8gZm9yIFRSVCBmdXNlZCBhdHRlbnRpb24sIHFrdiBhcmUgcGFja2VkIGFuZCBwYWRkaW5ncyBhcmUgcmVtb3ZlZFxufVxuXG5leHBvcnQgY29uc3QgZW51bSBBdHRlbnRpb25NYXNrVHlwZSB7XG4gIG5vbmUsIC8vIE5vIG1hc2tcbiAgbWFzazFkS2V5U2VxTGVuLCAvLyBbYmF0Y2hfc2l6ZV0sIGtleSBzZXF1ZW5jZSBsZW5ndGhcbiAgbWFzazFkRW5kU3RhcnQsIC8vIFsyICogYmF0Y2hfc2l6ZV0gd2l0aCBlbmQgcG9zaXRpb25zIGFuZCBzdGFydCBwb3NpdGlvbnNcbiAgbWFzazFES2V5U2VxTGVuU3RhcnQsIC8vIFszICogYmF0Y2hfc2l6ZSArIDJdIHdpdGggW2tleV9sZW5bMF0sIC4uLiwga2V5X2xlbltiYXRjaF9zaXplIC0gMV0sIHF1ZXJ5X3N0YXJ0WzBdLFxuICAvLyAuLi4sIHF1ZXJ5X3N0YXJ0W2JhdGNoX3NpemUgLSAxXSwgcXVlcnlfZW5kW2JhdGNoX3NpemUgLSAxXSwga2V5X3N0YXJ0WzBdLCAuLi4sXG4gIC8vIGtleV9zdGFydFtiYXRjaF9zaXplIC0gMV0sIGtleV9lbmRbYmF0Y2hfc2l6ZSAtIDFdXVxuICBtYXNrMmREdW1teSwgLy8gZHVtbXkgbWFzayB3aXRoIHNoYXBlIFsxLCAxXSBvciBbYmF0Y2hfc2l6ZSwgMV0uIEl0IGhhcyBzYW1lIGVmZmVjdCBhcyBubyBtYXNrLlxuICBtYXNrMmRLZXlQYWRkaW5nLCAvLyBbYmF0Y2hfc2l6ZSwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoXVxuICBtYXNrM2RBdHRlbnRpb24sIC8vIFtiYXRjaF9zaXplLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aF1cbiAgbWFzazRkTWVnYXRyb24sIC8vIE1lZ2F0cm9uIGNhdXNhbCBtYXNrIHdpdGggc2hhcGUgW2JhdGNoX3NpemUsIDEsIG1heF9zZXF1ZW5jZV9sZW5ndGgsIG1heF9zZXF1ZW5jZV9sZW5ndGhdXG4gIG1hc2tVbmtub3duLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF0dGVudGlvblBhcmFtZXRlcnMge1xuICBiYXRjaFNpemU6IG51bWJlcjtcbiAgc2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAgcGFzdFNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIGt2U2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAgdG90YWxTZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICBtYXhTZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICBpbnB1dEhpZGRlblNpemU6IG51bWJlcjtcbiAgaGlkZGVuU2l6ZTogbnVtYmVyO1xuICB2SGlkZGVuU2l6ZTogbnVtYmVyO1xuICBoZWFkU2l6ZTogbnVtYmVyO1xuICB2SGVhZFNpemU6IG51bWJlcjtcbiAgbnVtSGVhZHM6IG51bWJlcjtcbiAga3ZOdW1IZWFkcz86IG51bWJlcjtcbiAgblJlcHM/OiBudW1iZXI7XG4gIGlzVW5pZGlyZWN0aW9uYWw/OiBib29sZWFuO1xuICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBib29sZWFuO1xuICBtYXNrRmlsdGVyVmFsdWU/OiBudW1iZXI7XG4gIG1hc2tUeXBlOiBBdHRlbnRpb25NYXNrVHlwZTtcbiAgc2NhbGU6IG51bWJlcjtcbiAgYnJvYWRjYXN0UmVzUG9zQmlhczogYm9vbGVhbjtcbiAgcGFzc1Bhc3RJbkt2OiBib29sZWFuO1xuICBxa3ZGb3JtYXQ6IEF0dGVudGlvblFrdkZvcm1hdDtcbiAgc29mdGNhcD86IG51bWJlcjtcbiAgZG9Sb3Rhcnk/OiBudW1iZXI7XG4gIHJvdGFyeUludGVyTGVhdmVkPzogbnVtYmVyO1xuICBzb21tb290aFNvZnRtYXg/OiBudW1iZXI7XG4gIGxvY2FsV2luZG93c1NpemU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXR0ZW50aW9uQXR0cnMge1xuICBudW1IZWFkczogbnVtYmVyO1xuICBpc1VuaWRpcmVjdGlvbmFsOiBudW1iZXI7XG4gIG1hc2tGaWx0ZXJWYWx1ZTogbnVtYmVyO1xuICBzY2FsZTogbnVtYmVyO1xuICBkb1JvdGFyeTogbnVtYmVyO1xuICBxa3ZIaWRkZW5TaXplczogbnVtYmVyW107XG4gIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGJvb2xlYW47XG59XG5cbmNvbnN0IHZhbGlkYXRlQXR0ZW50aW9uSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IEF0dGVudGlvblBhcmFtZXRlcnMgPT4ge1xuICAvLyBBYmJyZXZpYXRpb24gYW5kIE1lYW5pbmdzOlxuICAvLyAgIEI6ICAgIGJhdGNoX3NpemVcbiAgLy8gICBTOiAgICBzZXF1ZW5jZV9sZW5ndGggKGlucHV0IHNlcXVlbmNlIGxlbmd0aCBvZiBxdWVyeSlcbiAgLy8gICBQOiAgICBwYXN0X3NlcXVlbmNlX2xlbmd0aCAocGFzdCBzZXF1ZW5jZSBsZW5ndGggb2Yga2V5IG9yIHZhbHVlKVxuICAvLyAgIEw6ICAgIGt2X3NlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIGtleSBvciB2YWx1ZSlcbiAgLy8gICBNOiAgICBtYXhfc2VxdWVuY2VfbGVuZ3RoXG4gIC8vICAgVDogICAgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggKyBrdl9zZXF1ZW5jZV9sZW5ndGhcbiAgLy8gICBOOiAgICBudW1faGVhZHNcbiAgLy8gICBIOiAgICBoZWFkIHNpemUgZm9yIFEgYW5kIEssIGFrYSBxX2hlYWRfc2l6ZSBvciBrX2hlYWRfc2l6ZSBvciBxa19oZWFkX3NpemVcbiAgLy8gICBIX3Y6ICB2X2hlYWRfc2l6ZVxuICAvLyAgIERfaTogIGlucHV0IGhpZGRlbiBzaXplXG4gIC8vICAgRDogICAgaGlkZGVuIHNpemUgZm9yIFEgYW5kIEsgKEQgPSBOICogSCksIGFrYSBxX2hpZGRlbl9zaXplIG9yIGtfaGlkZGVuX3NpemUgb3IgcWtfaGlkZGVuX3NpemVcbiAgLy8gICBEX3Y6ICB2X2hpZGRlbl9zaXplID0gbnVtX2hlYWRzICogdl9oZWFkX3NpemVcblxuICAvLyBXaGVuIHBhc3Qgc3RhdGUgaXMgdXNlZCwgUSwgSyBhbmQgViBzaG91bGQgaGF2ZSBzYW1lIGhpZGRlbiBzaXplICh1bmxlc3Mgd2Ugc3BsaXQgaXQgaW50byBwYXN0X2tleSBhbmQgcGFzdF92YWx1ZSkuXG5cbiAgLy8gSW5wdXQgc2hhcGVzOlxuICAvLyAgIGlucHV0ICAgICAgICAoUS9LL1YpICAgIDogKEIsIFMsIERfaSlcbiAgLy8gICB3ZWlnaHRzICAgICAgKFEvSy9WKSAgICA6IChEX2ksIEQgKyBEICsgRF92KVxuICAvLyAgIGJpYXMgICAgICAgICAoUS9LL1YpICAgIDogKEQgKyBEICsgRF92KVxuICAvLyAgIG1hc2tfaW5kZXggICAgICAgICAgICAgIDogc2VlIGJlbG93XG4gIC8vICAgcGFzdCAgICAgICAgIChLL1YpICAgICAgOiAoMiwgQiwgTiwgUCwgSCkgb3IgTlVMTFxuICAvLyAgIGF0dGVudGlvbl9iaWFzICAgICAgICAgIDogKEIsIE4sIFMsIFQpIG9yIE5VTExcblxuICAvLyBGb3IgbWFza19pbmRleCwgdGhlIGZvbGxvd2luZyBzaGFwZXMgYXJlIHN1cHBvcnRlZDpcbiAgLy8gICAgIE5VTEwsIChCLCAxKSwgKDEsIDEpXG4gIC8vICAgICAoQiksICgyICogQiksICgzICogQiArIDIpXG4gIC8vICAgICAoQiwgVClcbiAgLy8gICAgIChCLCBTLCBUKVxuICAvLyAgICAgKEIsIDEsIE0sIE0pXG4gIC8vXG4gIC8vIFdoZW4gYSBtb2RlbCBpcyBwcnVuZWQgKGxpa2Ugc29tZSBhdHRlbnRpb24gaGVhZHMgYXJlIHJlbW92ZWQgaW4gUS9LL1YpLCBpbnB1dF9oaWRkZW5fc2l6ZSBjb3VsZCBiZSBsYXJnZXJcbiAgLy8gdGhhbiBoaWRkZW4gZGltZW5zaW9uIG9mIFEsIEsgYW5kIFYuXG5cbiAgY29uc3QgaW5wdXQgPSBpbnB1dHNbMF07XG4gIGNvbnN0IHdlaWdodHMgPSBpbnB1dHNbMV07XG4gIGNvbnN0IGJpYXMgPSBpbnB1dHNbMl07XG4gIGNvbnN0IG1hc2tJbmRleCA9IGlucHV0c1szXTtcbiAgY29uc3QgcGFzdCA9IGlucHV0c1s0XTtcbiAgY29uc3QgYXR0ZW50aW9uQmlhcyA9IGlucHV0c1s1XTtcblxuICBpZiAocGFzdCAmJiBhdHRlbnRpb25CaWFzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbnRpb24gY2Fubm90IGhhdmUgYm90aCBwYXN0IGFuZCBhdHRlbnRpb25fYmlhcycpO1xuICB9XG5cbiAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImlucHV0XCIgbXVzdCBoYXZlIDMgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXQuZGltc1swXTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBpbnB1dC5kaW1zWzFdO1xuICBjb25zdCBpbnB1dEhpZGRlblNpemUgPSBpbnB1dC5kaW1zWzJdO1xuXG4gIGlmIChiaWFzLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgaWYgKHdlaWdodHMuZGltcy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwid2VpZ2h0c1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBpZiAod2VpZ2h0cy5kaW1zWzBdICE9PSBpbnB1dEhpZGRlblNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IDEgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDIgb2YgaW5wdXQgMCcpO1xuICB9XG5cbiAgaWYgKGJpYXMuZGltc1swXSAhPT0gd2VpZ2h0cy5kaW1zWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMSBvZiBpbnB1dCBcIndlaWdodHNcIicpO1xuICB9XG5cbiAgbGV0IHFIaWRkZW5TaXplID0gYmlhcy5kaW1zWzBdIC8gMztcbiAgbGV0IGtIaWRkZW5TaXplID0gcUhpZGRlblNpemU7XG4gIGxldCB2SGlkZGVuU2l6ZSA9IGtIaWRkZW5TaXplO1xuICBpZiAoYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Frdl9oaWRkZW5fc2l6ZXMgYXR0cmlidXRlIHNob3VsZCBoYXZlIDMgZWxlbWVudHMnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzeiBvZiBhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzKSB7XG4gICAgICBpZiAoc3ogJSBhdHRyaWJ1dGVzLm51bUhlYWRzICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncWt2X2hpZGRlbl9zaXplcyBzaG91bGQgYmUgZGl2aXNpYmxlIGJ5IG51bV9oZWFkcycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHFIaWRkZW5TaXplID0gYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplc1swXTtcbiAgICBrSGlkZGVuU2l6ZSA9IGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXNbMV07XG4gICAgdkhpZGRlblNpemUgPSBhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzWzJdO1xuICB9XG5cbiAgY29uc3Qga3ZTZXF1ZW5jZUxlbmd0aCA9IHNlcXVlbmNlTGVuZ3RoO1xuXG4gIGlmIChxSGlkZGVuU2l6ZSAhPT0ga0hpZGRlblNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Frdl9oaWRkZW5fc2l6ZXMgZmlyc3QgZWxlbWVudCBzaG91bGQgYmUgc2FtZSBhcyB0aGUgc2Vjb25kJyk7XG4gIH1cblxuICBpZiAoYmlhcy5kaW1zWzBdICE9PSBxSGlkZGVuU2l6ZSArIGtIaWRkZW5TaXplICsgdkhpZGRlblNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIHN1bSBvZiBRL0svViBoaWRkZW4gc2l6ZXMnKTtcbiAgfVxuXG4gIGxldCBwYXN0U2VxdWVuY2VMZW5ndGggPSAwO1xuICBpZiAocGFzdCkge1xuICAgIGlmIChrSGlkZGVuU2l6ZSAhPT0gdkhpZGRlblNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZXhwZWN0IGtfaGlkZGVuX3NpemUgPT0gdl9oaWRkZW5fc2l6ZScpO1xuICAgIH1cbiAgICBpZiAocGFzdC5kaW1zLmxlbmd0aCAhPT0gNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBtdXN0IGhhdmUgNSBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIGlmIChwYXN0LmRpbXNbMF0gIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlyc3QgZGltZW5zaW9uIG11c3QgYmUgMicpO1xuICAgIH1cbiAgICBpZiAocGFzdC5kaW1zWzFdICE9PSBiYXRjaFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgc2Vjb25kIGRpbWVuc2lvbiBtdXN0IGJlIGJhdGNoX3NpemUnKTtcbiAgICB9XG4gICAgaWYgKHBhc3QuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiB0aGlyZCBkaW1lbnNpb24gbXVzdCBiZSBudW1faGVhZHMnKTtcbiAgICB9XG4gICAgaWYgKHBhc3QuZGltc1s0XSAhPT0ga0hpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGZpZnRoIGRpbWVuc2lvbiBtdXN0IGJlIGtfaGlkZGVuX3NpemUgLyBudW1faGVhZHMnKTtcbiAgICB9XG5cbiAgICBpZiAoIWF0dHJpYnV0ZXMucGFzdFByZXNlbnRTaGFyZUJ1ZmZlcikge1xuICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoID0gcGFzdC5kaW1zWzNdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBoYW5kbGUgcGFzdF9zZXFfbGVuXG4gIH1cblxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0ga3ZTZXF1ZW5jZUxlbmd0aCArIHBhc3RTZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgbWF4U2VxdWVuY2VMZW5ndGggPSAtMTtcblxuICBjb25zdCBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm5vbmU7XG4gIGlmIChtYXNrSW5kZXgpIHtcbiAgICAvLyBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLk1BU0tfVU5LTk9XTjtcbiAgICAvLyBUT0RPOiBoYW5kbGUgbWFza1xuICAgIHRocm93IG5ldyBFcnJvcignTWFzayBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICBpZiAocGFzdCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFzdCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICBpZiAoYXR0ZW50aW9uQmlhcykge1xuICAgIGlmIChhdHRlbnRpb25CaWFzLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYXR0ZW50aW9uX2JpYXNcIiBtdXN0IGhhdmUgNCBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogc3VwcG9ydCBicm9hZGNhc3RpbmcgdGhlIGZpcnN0IGFuZCBzZWNvbmQgZGltZW5zaW9ucyBvZiBhdHRlbnRpb25fYmlhc1xuICAgIGlmIChcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1swXSAhPT0gYmF0Y2hTaXplIHx8XG4gICAgICBhdHRlbnRpb25CaWFzLmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHxcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1syXSAhPT0gc2VxdWVuY2VMZW5ndGggfHxcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1szXSAhPT0gdG90YWxTZXF1ZW5jZUxlbmd0aFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJhdHRlbnRpb25fYmlhc1wiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHNlcXVlbmNlX2xlbmd0aCwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKScpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmF0Y2hTaXplLFxuICAgIHNlcXVlbmNlTGVuZ3RoLFxuICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCxcbiAgICBrdlNlcXVlbmNlTGVuZ3RoLFxuICAgIHRvdGFsU2VxdWVuY2VMZW5ndGgsXG4gICAgbWF4U2VxdWVuY2VMZW5ndGgsXG4gICAgaW5wdXRIaWRkZW5TaXplLFxuICAgIGhpZGRlblNpemU6IHFIaWRkZW5TaXplLFxuICAgIHZIaWRkZW5TaXplLFxuICAgIGhlYWRTaXplOiBNYXRoLmZsb29yKHFIaWRkZW5TaXplIC8gYXR0cmlidXRlcy5udW1IZWFkcyksXG4gICAgdkhlYWRTaXplOiBNYXRoLmZsb29yKHZIaWRkZW5TaXplIC8gYXR0cmlidXRlcy5udW1IZWFkcyksXG4gICAgbnVtSGVhZHM6IGF0dHJpYnV0ZXMubnVtSGVhZHMsXG4gICAgaXNVbmlkaXJlY3Rpb25hbDogZmFsc2UsXG4gICAgcGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjogZmFsc2UsXG4gICAgbWFza0ZpbHRlclZhbHVlOiBhdHRyaWJ1dGVzLm1hc2tGaWx0ZXJWYWx1ZSxcbiAgICBtYXNrVHlwZSxcbiAgICBzY2FsZTogYXR0cmlidXRlcy5zY2FsZSxcbiAgICBicm9hZGNhc3RSZXNQb3NCaWFzOiBmYWxzZSxcbiAgICBwYXNzUGFzdEluS3Y6IGZhbHNlLFxuICAgIHFrdkZvcm1hdDogQXR0ZW50aW9uUWt2Rm9ybWF0LnFrdkJOU0gsXG4gIH07XG59O1xuXG5jb25zdCBpbml0VmFyU3R1YiA9IChcbiAgc2VxTGVuc0lucHV0OiBJbmRpY2VzSGVscGVyIHwgdW5kZWZpbmVkLFxuICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQ6IEluZGljZXNIZWxwZXIgfCB1bmRlZmluZWQsXG4gIGluaXRQYXN0U2VxdWVuY2VMZW5ndGg6IGJvb2xlYW4sXG4pID0+IHtcbiAgLy8gSW4gdGhlIGNhc2Ugb2YgR1FBLCByZWRlZmluZSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgsIHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoIGFuZCBwYXN0X3NlcXVlbmNlX2xlbmd0aCBiYXNlZCBvbiBzZXFsZW5fayBpbnB1dFxuICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0ICYmIHNlcUxlbnNJbnB1dCkge1xuICAgIHJldHVybiBgXG4gICAgICBsZXQgdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0ID0gdTMyKCR7dG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LmdldEJ5T2Zmc2V0KCcwJyl9KTtcbiAgICAgIGxldCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCA9IG1heCh0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQsIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoKTtcbiAgICAgIGxldCBpc19zdWJzZXF1ZW50X3Byb21wdDogYm9vbCA9IHNlcXVlbmNlX2xlbmd0aCA+IDEgJiYgc2VxdWVuY2VfbGVuZ3RoICE9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dDtcbiAgICAgIGxldCBpc19maXJzdF9wcm9tcHQ6IGJvb2wgPSBpc19zdWJzZXF1ZW50X3Byb21wdCA9PSBmYWxzZSAmJiBzZXF1ZW5jZV9sZW5ndGggPT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0O1xuICAgICAgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdTMyKCR7c2VxTGVuc0lucHV0Py5nZXRCeU9mZnNldCgnYmF0Y2hJZHgnKX0pICsgMTtcbiAgICAgIHZhciBwYXN0X3NlcXVlbmNlX2xlbmd0aDogdTMyID0gMDtcbiAgICAgIGlmIChpc19maXJzdF9wcm9tcHQgPT0gZmFsc2UpIHtcbiAgICAgICAgcGFzdF9zZXF1ZW5jZV9sZW5ndGggPSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggLSBzZXF1ZW5jZV9sZW5ndGg7XG4gICAgICB9XG4gICAgICAgYDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYFxuICAgICR7aW5pdFBhc3RTZXF1ZW5jZUxlbmd0aCA/ICdsZXQgcGFzdF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aCcgOiAnJ307XG4gICAgbGV0IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoID0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoO1xuICAgIGA7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUluUGxhY2VTb2Z0bWF4UHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxuICBiYXRjaFNpemU6IG51bWJlcixcbiAgbnVtSGVhZHM6IG51bWJlcixcbiAgcGFzdFNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXG4gIHRvdGFsU2VxdWVuY2VMZW5ndGg6IG51bWJlcixcbiAgc2VxTGVuczogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcbiAgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0OiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuKSA9PiB7XG4gIC8vIFNldCBjb21wb25lbnRzIHRvIDEgaWYgc2VxTGVucyBpcyBzcGVjaWZpZWQsIGkuZS4gR3JvdXBRdWVyeUF0dGVudGlvbi5cbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoc2VxTGVucyA/IDEgOiB0b3RhbFNlcXVlbmNlTGVuZ3RoKTtcbiAgbGV0IFdHID0gNjQ7XG4gIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGhDb21wID0gdG90YWxTZXF1ZW5jZUxlbmd0aCAvIGNvbXBvbmVudHM7XG4gIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoQ29tcCA8IFdHKSB7XG4gICAgV0cgPSAzMjtcbiAgfVxuICBjb25zdCBlbGVtZW50c1BlclRocmVhZCA9IE1hdGguY2VpbCh0b3RhbFNlcXVlbmNlTGVuZ3RoIC8gY29tcG9uZW50cyAvIFdHKTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBiYXRjaFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogbnVtSGVhZHMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFzdFNlcXVlbmNlTGVuZ3RoIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNlcXVlbmNlTGVuZ3RoIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHRvdGFsU2VxdWVuY2VMZW5ndGhDb21wIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGVsZW1lbnRzUGVyVGhyZWFkIH0sXG4gIF07XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0LmRhdGFUeXBlLCBjb21wb25lbnRzKTtcbiAgY29uc3QgZjMyVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoRGF0YVR5cGUuZmxvYXQsIGNvbXBvbmVudHMpO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZSddO1xuICBpZiAoc2VxTGVucykge1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcbiAgfVxuICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KSB7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xuICB9XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGlucHV0SGVscGVyID0gb3V0cHV0VmFyaWFibGUoJ3gnLCBpbnB1dC5kYXRhVHlwZSwgaW5wdXQuZGltcywgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5wdXRIZWxwZXJzID0gW2lucHV0SGVscGVyXTtcbiAgICBjb25zdCBzZXFMZW5zSW5wdXRIZWxwZXIgPSBzZXFMZW5zID8gaW5wdXRWYXJpYWJsZSgnc2VxX2xlbnMnLCBzZXFMZW5zLmRhdGFUeXBlLCBzZXFMZW5zLmRpbXMpIDogdW5kZWZpbmVkO1xuICAgIGlmIChzZXFMZW5zSW5wdXRIZWxwZXIpIHtcbiAgICAgIGlucHV0SGVscGVycy5wdXNoKHNlcUxlbnNJbnB1dEhlbHBlcik7XG4gICAgfVxuXG4gICAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0SGVscGVyID0gdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0XG4gICAgICA/IGlucHV0VmFyaWFibGUoJ3RvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCcsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dC5kYXRhVHlwZSwgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LmRpbXMpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0SGVscGVyKSB7XG4gICAgICBpbnB1dEhlbHBlcnMucHVzaCh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRIZWxwZXIpO1xuICAgIH1cbiAgICBjb25zdCBlbGVtVmFsdWVUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShpbnB1dC5kYXRhVHlwZSk7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnYmF0Y2hfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAncGFzdF9zZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ3RvdGFsX3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdlbGVtZW50c19wZXJfdGhyZWFkJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuXG4gICAgcmV0dXJuIGBcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX21heDogYXJyYXk8ZjMyLCAke1dHfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRocmVhZF9zdW06IGFycmF5PGYzMiwgJHtXR30+O1xuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0SGVscGVycyl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbV0csIDEsIDFdKX1cbiAgICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGg7XG4gICAgdmFyIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICAke2luaXRWYXJTdHViKHNlcUxlbnNJbnB1dEhlbHBlciwgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0SGVscGVyLCBmYWxzZSl9XG4gICAgbGV0IGxvY2FsX29mZnNldCA9IGxvY2FsX2lkeCAqIHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQ7XG4gICAgbGV0IG9mZnNldCA9IChnbG9iYWxfaWR4IC8gJHtXR30pICogdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoICsgbG9jYWxfb2Zmc2V0O1xuICAgIGxldCBzZXFfY2F1c2FsX2xlbmd0aCA9ICR7c2VxTGVucyA/ICd1MzIocGFzdF9zZXF1ZW5jZV9sZW5ndGggKyB3b3JrZ3JvdXBfaWQueSArIDEpJyA6ICd0b3RhbF9zZXF1ZW5jZV9sZW5ndGgnfTtcbiAgICB2YXIgdGhyZWFkX21heF92ZWN0b3IgPSAke2YzMlR5cGV9KC0zLjQwMjgyM2UrMzhmKTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xuICAgICAgdGhyZWFkX21heF92ZWN0b3IgPSBtYXgoJHtmMzJUeXBlfSh4W29mZnNldCArIGldKSwgdGhyZWFkX21heF92ZWN0b3IpO1xuICAgIH1cbiAgICB0aHJlYWRfbWF4W2xvY2FsX2lkeF0gPSAkeygoKSA9PiB7XG4gICAgICBzd2l0Y2ggKGNvbXBvbmVudHMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAndGhyZWFkX21heF92ZWN0b3InO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuICdtYXgodGhyZWFkX21heF92ZWN0b3IueCwgdGhyZWFkX21heF92ZWN0b3IueSknO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuICdtYXgobWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpLCBtYXgodGhyZWFkX21heF92ZWN0b3IueiwgdGhyZWFkX21heF92ZWN0b3IudykpJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7Y29tcG9uZW50c31gKTtcbiAgICAgIH1cbiAgICB9KSgpfTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICB2YXIgbWF4X3ZhbHVlID0gIGYzMigtMy40MDI4MjNlKzM4Zik7XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtXR307IGkrKykge1xuICAgICAgbWF4X3ZhbHVlID0gbWF4KHRocmVhZF9tYXhbaV0sIG1heF92YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHN1bV92ZWN0b3IgPSAke2YzMlR5cGV9KDApO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICBzdW1fdmVjdG9yICs9IGV4cCgke2YzMlR5cGV9KHhbb2Zmc2V0ICsgaV0pIC0gbWF4X3ZhbHVlKTtcbiAgICB9XG4gICAgdGhyZWFkX3N1bVtsb2NhbF9pZHhdID0gJHsoKCkgPT4ge1xuICAgICAgc3dpdGNoIChjb21wb25lbnRzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gJ3N1bV92ZWN0b3InO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuICdzdW1fdmVjdG9yLnggKyBzdW1fdmVjdG9yLnknO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuICdzdW1fdmVjdG9yLnggKyBzdW1fdmVjdG9yLnkgKyBzdW1fdmVjdG9yLnogKyBzdW1fdmVjdG9yLncnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHtjb21wb25lbnRzfWApO1xuICAgICAgfVxuICAgIH0pKCl9O1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIHZhciBzdW06IGYzMiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtXR307IGkrKykge1xuICAgICAgc3VtICs9IHRocmVhZF9zdW1baV07XG4gICAgfVxuXG4gICAgaWYgKHN1bSA9PSAwKSB7XG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xuICAgICAgICB4W29mZnNldCArIGldID0gJHtpbnB1dEhlbHBlci50eXBlLnZhbHVlfSgke2VsZW1WYWx1ZVR5cGV9KDEuMCkgLyAke2VsZW1WYWx1ZVR5cGV9KHNlcV9jYXVzYWxfbGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmMzJpbnB1dCA9ICR7ZjMyVHlwZX0oeFtvZmZzZXQgKyBpXSk7XG4gICAgICAgIHhbb2Zmc2V0ICsgaV0gPSAke2lucHV0SGVscGVyLnR5cGUudmFsdWV9KGV4cChmMzJpbnB1dCAtIG1heF92YWx1ZSkgLyBzdW0pO1xuICAgICAgfVxuICAgIH1cbiAgICAgICR7XG4gICAgICAgIHNlcUxlbnNcbiAgICAgICAgICA/IGBcbiAgICAgICAgZm9yICh2YXIgdG90YWxfc2VxX2lkOiB1MzIgPSBzZXFfY2F1c2FsX2xlbmd0aDsgdG90YWxfc2VxX2lkICsgbG9jYWxfb2Zmc2V0IDwgdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoOyB0b3RhbF9zZXFfaWQrKykge1xuICAgICAgICAgIHhbb2Zmc2V0ICsgdG90YWxfc2VxX2lkXSA9ICR7aW5wdXRIZWxwZXIudHlwZS52YWx1ZX0oJHtlbGVtVmFsdWVUeXBlfSgwKSk7XG4gICAgICAgIH1gXG4gICAgICAgICAgOiAnJ1xuICAgICAgfTtcbiAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQXR0ZW50aW9uUHJvYnNTb2Z0bWF4JyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtXR307JHtkYXRhVHlwZX07JHtjb21wb25lbnRzfWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbXSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogMSwgeTogc2VxdWVuY2VMZW5ndGgsIHo6IGJhdGNoU2l6ZSAqIG51bUhlYWRzIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVBdHRlbnRpb25Qcm9ic1Byb2dyYW1JbmZvID0gKFxuICBvdXRwdXRDb3VudDogbnVtYmVyLFxuICBxOiBUZW5zb3JWaWV3LFxuICBrZXk6IFRlbnNvclZpZXcsXG4gIHBhc3RLZXk6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4gIGF0dGVudGlvbkJpYXM6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4gIHBhcmFtZXRlcnM6IEF0dGVudGlvblBhcmFtZXRlcnMsXG4gIHBhc3RTZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxuICBzZXFMZW5zOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQ6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4pID0+IHtcbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IHBhc3RTZXF1ZW5jZUxlbmd0aCArIHBhcmFtZXRlcnMua3ZTZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgcHJvYnNTaGFwZSA9IFtwYXJhbWV0ZXJzLmJhdGNoU2l6ZSwgcGFyYW1ldGVycy5udW1IZWFkcywgcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCwgdG90YWxTZXF1ZW5jZUxlbmd0aF07XG4gIGNvbnN0IHByZXNlbnRLZXkgPSBvdXRwdXRDb3VudCA+IDEgJiYgcGFzdEtleTtcbiAgY29uc3Qga3ZOdW1IZWFkcyA9IHBhcmFtZXRlcnMua3ZOdW1IZWFkcyA/IHBhcmFtZXRlcnMua3ZOdW1IZWFkcyA6IHBhcmFtZXRlcnMubnVtSGVhZHM7XG4gIGNvbnN0IHByZXNlbnRLZXlTaGFwZSA9IHByZXNlbnRLZXlcbiAgICA/IFtwYXJhbWV0ZXJzLmJhdGNoU2l6ZSwga3ZOdW1IZWFkcywgdG90YWxTZXF1ZW5jZUxlbmd0aCwgcGFyYW1ldGVycy5oZWFkU2l6ZV1cbiAgICA6IHVuZGVmaW5lZDtcbiAgY29uc3QgblJlcHMgPSBwYXJhbWV0ZXJzLm5SZXBzID8gcGFyYW1ldGVycy5uUmVwcyA6IDE7XG4gIC8vIFRPRE86IGhhbmRsZSBtYXNrXG5cbiAgY29uc3QgYWxwaGEgPSBwYXJhbWV0ZXJzLnNjYWxlID09PSAwID8gMS4wIC8gTWF0aC5zcXJ0KHBhcmFtZXRlcnMuaGVhZFNpemUpIDogcGFyYW1ldGVycy5zY2FsZTtcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMocGFyYW1ldGVycy5oZWFkU2l6ZSk7XG4gIGNvbnN0IHZlY3Rvcml6ZWRIZWFkU2l6ZSA9IHBhcmFtZXRlcnMuaGVhZFNpemUgLyBjb21wb25lbnRzO1xuICBjb25zdCBUSUxFX1NJWkUgPSAxMjtcbiAgY29uc3QgZGlzcGF0Y2ggPSB7XG4gICAgeDogTWF0aC5jZWlsKHRvdGFsU2VxdWVuY2VMZW5ndGggLyBUSUxFX1NJWkUpLFxuICAgIHk6IE1hdGguY2VpbChwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoIC8gVElMRV9TSVpFKSxcbiAgICB6OiBwYXJhbWV0ZXJzLmJhdGNoU2l6ZSAqIHBhcmFtZXRlcnMubnVtSGVhZHMsXG4gIH07XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiB2ZWN0b3JpemVkSGVhZFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdG90YWxTZXF1ZW5jZUxlbmd0aCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLm51bUhlYWRzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMuaGVhZFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhbHBoYSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXN0U2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5rdlNlcXVlbmNlTGVuZ3RoIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG5SZXBzIH0sXG4gIF07XG4gIC8vIEZlZWQgcGFzdEtleSB0byB0aGUgc2hhZGVyLWNvZGUgb25seSBpZiBpdCBpcyBub24temVybyBhbmQgcHJlc2VudEtleSBpcyBiZWluZyBwcm9kdWNlZFxuICBjb25zdCBmZWVkUGFzdEtleSA9IHByZXNlbnRLZXkgJiYgcGFzdEtleSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0S2V5LmRpbXMpID4gMDtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuICBpZiAoZmVlZFBhc3RLZXkpIHtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gIH1cbiAgaWYgKGF0dGVudGlvbkJpYXMpIHtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gIH1cbiAgaWYgKHNlcUxlbnMpIHtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gIH1cbiAgaWYgKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCkge1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcbiAgfVxuICBjb25zdCBvdXRwdXRzID0gW3sgZGltczogcHJvYnNTaGFwZSwgZGF0YVR5cGU6IHEuZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0IH1dO1xuICBpZiAocHJlc2VudEtleSkge1xuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IHByZXNlbnRLZXlTaGFwZSEsIGRhdGFUeXBlOiBxLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9KTtcbiAgfVxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBxSW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdxJywgcS5kYXRhVHlwZSwgcS5kaW1zLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBrSW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdrZXknLCBrZXkuZGF0YVR5cGUsIGtleS5kaW1zLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBpbnB1dFZhcnMgPSBbcUlucHV0LCBrSW5wdXRdO1xuICAgIGlmIChmZWVkUGFzdEtleSkge1xuICAgICAgY29uc3QgcGFzdEtleUlucHV0ID0gaW5wdXRWYXJpYWJsZSgncGFzdF9rZXknLCBwYXN0S2V5LmRhdGFUeXBlLCBwYXN0S2V5LmRpbXMsIGNvbXBvbmVudHMpO1xuICAgICAgaW5wdXRWYXJzLnB1c2gocGFzdEtleUlucHV0KTtcbiAgICB9XG4gICAgaWYgKGF0dGVudGlvbkJpYXMpIHtcbiAgICAgIGlucHV0VmFycy5wdXNoKGlucHV0VmFyaWFibGUoJ2F0dGVudGlvbl9iaWFzJywgYXR0ZW50aW9uQmlhcy5kYXRhVHlwZSwgYXR0ZW50aW9uQmlhcy5kaW1zKSk7XG4gICAgfVxuICAgIGNvbnN0IHNlcUxlbnNJbnB1dFZhcmlhYmxlID0gc2VxTGVucyA/IGlucHV0VmFyaWFibGUoJ3NlcV9sZW5zJywgc2VxTGVucy5kYXRhVHlwZSwgc2VxTGVucy5kaW1zKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoc2VxTGVuc0lucHV0VmFyaWFibGUpIHtcbiAgICAgIGlucHV0VmFycy5wdXNoKHNlcUxlbnNJbnB1dFZhcmlhYmxlKTtcbiAgICB9XG4gICAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0VmFyaWFibGUgPSB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRcbiAgICAgID8gaW5wdXRWYXJpYWJsZSgndG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0JywgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LmRhdGFUeXBlLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQuZGltcylcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRWYXJpYWJsZSkge1xuICAgICAgaW5wdXRWYXJzLnB1c2godG90YWxTZXF1ZW5jZUxlbmd0aElucHV0VmFyaWFibGUpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgcS5kYXRhVHlwZSwgcHJvYnNTaGFwZSk7XG4gICAgY29uc3Qgb3V0cHV0VmFycyA9IFtvdXRwdXRdO1xuICAgIGlmIChwcmVzZW50S2V5KSB7XG4gICAgICBvdXRwdXRWYXJzLnB1c2gob3V0cHV0VmFyaWFibGUoJ3ByZXNlbnRfa2V5JywgcS5kYXRhVHlwZSwgcHJlc2VudEtleVNoYXBlISwgY29tcG9uZW50cykpO1xuICAgIH1cbiAgICBjb25zdCBmMzJUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShEYXRhVHlwZS5mbG9hdCwgY29tcG9uZW50cyk7XG5cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnaGVhZF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2FscGhhJywgdHlwZTogJ2YzMicgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9LFxuICAgICAgeyBuYW1lOiAncGFzdF9zZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAna3Zfc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ25fcmVwcycsIHR5cGU6ICd1MzInIH0sXG4gICAgXTtcbiAgICByZXR1cm4gYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke1RJTEVfU0laRX11O1xuXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVROiBhcnJheTwke3FJbnB1dC50eXBlLnN0b3JhZ2V9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlSzogYXJyYXk8JHtxSW5wdXQudHlwZS5zdG9yYWdlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIC4uLm91dHB1dFZhcnMpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1RJTEVfU0laRSwgVElMRV9TSVpFLCAxXSl9XG4gICAgLy8geCBob2xkcyB0aGUgTiBhbmQgeSBob2xkcyB0aGUgTVxuICAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IGt2SGVhZElkeCA9ICR7blJlcHMgPT09IDEgPyAnaGVhZElkeCcgOiAnaGVhZElkeCAvIHVuaWZvcm1zLm5fcmVwcyd9O1xuICAgIGxldCBrdl9udW1faGVhZHMgPSAke25SZXBzID09PSAxID8gJ3VuaWZvcm1zLm51bV9oZWFkcycgOiAndW5pZm9ybXMubnVtX2hlYWRzIC8gdW5pZm9ybXMubl9yZXBzJ307XG4gICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSB3b3JrZ3JvdXBfaWQueSAqIFRJTEVfU0laRTtcbiAgICBsZXQgbiA9IHdvcmtncm91cF9pZC54ICogVElMRV9TSVpFO1xuICAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5NO1xuICAgIHZhciB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5OO1xuICAgICR7aW5pdFZhclN0dWIoc2VxTGVuc0lucHV0VmFyaWFibGUsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFZhcmlhYmxlLCB0cnVlKX1cbiAgICBsZXQgYWJzS3ZIZWFkSWR4ID0gYmF0Y2hJZHggKiBrdl9udW1faGVhZHMgKyBrdkhlYWRJZHg7XG4gICAgbGV0IHFPZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LICsgbSAqIHVuaWZvcm1zLks7XG4gICAgJHtmZWVkUGFzdEtleSAmJiBwcmVzZW50S2V5ID8gJ2xldCBwYXN0S2V5T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LOycgOiAnJ307XG4gICAgbGV0IGtPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LO1xuICAgICR7cHJlc2VudEtleSA/ICdsZXQgcHJlc2VudEtleU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LOycgOiAnJ31cbiAgICB2YXIgdmFsdWUgPSAke2YzMlR5cGV9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChnbG9iYWxfaWQueSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHFbcU9mZnNldCArIGxvY2FsX2lkLnkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xuICAgICAgJHsoKCkgPT4ge1xuICAgICAgICBpZiAoZmVlZFBhc3RLZXkgJiYgcHJlc2VudEtleSkge1xuICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IHBhc3Rfa2V5W3Bhc3RLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBrZXlba09mZnNldCArIChuICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgICAgIH1gO1xuICAgICAgICB9XG4gICAgICB9KSgpfVxuICAgICAgJHtcbiAgICAgICAgcHJlc2VudEtleVxuICAgICAgICAgID8gYGlmIChuICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgIHByZXNlbnRfa2V5W3ByZXNlbnRLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XSA9IHRpbGVLW2lkeF07XG4gICAgICB9YFxuICAgICAgICAgIDogJydcbiAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCBUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgICAgdmFsdWUgKz0gJHtmMzJUeXBlfSh0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlS1tUSUxFX1NJWkUgKiBsb2NhbF9pZC54ICsga10pO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiBnbG9iYWxfaWQueCA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgbGV0IGhlYWRPZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgICAgbGV0IG91dHB1dElkeCA9IGhlYWRPZmZzZXQgKyBnbG9iYWxfaWQueSAqIHVuaWZvcm1zLk4gKyBnbG9iYWxfaWQueDtcbiAgICAgIHZhciBzdW06IGYzMiA9ICR7KCgpID0+IHtcbiAgICAgICAgc3dpdGNoIChjb21wb25lbnRzKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuICd2YWx1ZSc7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuICd2YWx1ZS54ICsgdmFsdWUueSc7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuICd2YWx1ZS54ICsgdmFsdWUueSArIHZhbHVlLnogKyB2YWx1ZS53JztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2NvbXBvbmVudHN9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pKCl9O1xuICAgICAgICBvdXRwdXRbb3V0cHV0SWR4XSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9IChzdW0gKiB1bmlmb3Jtcy5hbHBoYSkgKyAke1xuICAgICAgICAgIGF0dGVudGlvbkJpYXMgPyAnYXR0ZW50aW9uX2JpYXNbb3V0cHV0SWR4XScgOiAnMC4wJ1xuICAgICAgICB9O1xuICAgIH1cbiAgfWA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0F0dGVudGlvblByb2JzJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7Y29tcG9uZW50c307JHthdHRlbnRpb25CaWFzICE9PSB1bmRlZmluZWR9OyR7cGFzdEtleSAhPT0gdW5kZWZpbmVkfTske291dHB1dENvdW50fWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llcyxcbiAgICB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7IG91dHB1dHMsIGRpc3BhdGNoR3JvdXA6IGRpc3BhdGNoLCBwcm9ncmFtVW5pZm9ybXMgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlVnhBdHRlbnRpb25TY29yZVByb2dyYW1JbmZvID0gKFxuICBvdXRwdXRDb3VudDogbnVtYmVyLFxuICBwcm9iczogVGVuc29yVmlldyxcbiAgdjogVGVuc29yVmlldyxcbiAgcGFzdFZhbHVlOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICBwYXJhbXM6IEF0dGVudGlvblBhcmFtZXRlcnMsXG4gIHBhc3RTZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxuICBzZXFMZW5zOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkLFxuICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQ6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXG4pID0+IHtcbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IHBhc3RTZXF1ZW5jZUxlbmd0aCArIHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBuUmVwcyA9IHBhcmFtcy5uUmVwcyA/IHBhcmFtcy5uUmVwcyA6IDE7XG4gIGNvbnN0IHJlcGVhdGVkVkhpZGRlblNpemUgPSBwYXJhbXMudkhpZGRlblNpemUgKiBuUmVwcztcbiAgY29uc3QgcHJlc2VudFZhbHVlID0gb3V0cHV0Q291bnQgPiAxICYmIHBhc3RWYWx1ZTtcbiAgY29uc3Qga3ZOdW1IZWFkcyA9IHBhcmFtcy5rdk51bUhlYWRzID8gcGFyYW1zLmt2TnVtSGVhZHMgOiBwYXJhbXMubnVtSGVhZHM7XG4gIGNvbnN0IHByZXNlbnRWYWx1ZVNoYXBlID0gcHJlc2VudFZhbHVlXG4gICAgPyBbcGFyYW1zLmJhdGNoU2l6ZSwga3ZOdW1IZWFkcywgdG90YWxTZXF1ZW5jZUxlbmd0aCwgcGFyYW1zLmhlYWRTaXplXVxuICAgIDogdW5kZWZpbmVkO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMuc2VxdWVuY2VMZW5ndGgsIHJlcGVhdGVkVkhpZGRlblNpemVdO1xuICBjb25zdCBUSUxFX1NJWkUgPSAxMjtcbiAgY29uc3QgZGlzcGF0Y2ggPSB7XG4gICAgeDogTWF0aC5jZWlsKHBhcmFtcy52SGVhZFNpemUgLyBUSUxFX1NJWkUpLFxuICAgIHk6IE1hdGguY2VpbChwYXJhbXMuc2VxdWVuY2VMZW5ndGggLyBUSUxFX1NJWkUpLFxuICAgIHo6IHBhcmFtcy5iYXRjaFNpemUgKiBwYXJhbXMubnVtSGVhZHMsXG4gIH07XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMuc2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdG90YWxTZXF1ZW5jZUxlbmd0aCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMudkhlYWRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtcy5udW1IZWFkcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMuaGVhZFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcmVwZWF0ZWRWSGlkZGVuU2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXN0U2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogblJlcHMgfSxcbiAgXTtcbiAgLy8gRmVlZCBwYXN0VmFsdWUgdG8gdGhlIHNoYWRlci1jb2RlIG9ubHkgaWYgaXQgaXMgbm9uLWVtcHR5IGFuZCBwcmVzZW50VmFsdWUgaXMgYmVpbmcgcHJvZHVjZWRcbiAgY29uc3QgZmVlZFBhc3RWYWx1ZSA9IHByZXNlbnRWYWx1ZSAmJiBwYXN0VmFsdWUgJiYgU2hhcGVVdGlsLnNpemUocGFzdFZhbHVlLmRpbXMpID4gMDtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuICBpZiAoZmVlZFBhc3RWYWx1ZSkge1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcbiAgfVxuICBpZiAoc2VxTGVucykge1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcbiAgfVxuICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KSB7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xuICB9XG4gIGNvbnN0IG91dHB1dHMgPSBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IHByb2JzLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9XTtcbiAgaWYgKHByZXNlbnRWYWx1ZSkge1xuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IHByZXNlbnRWYWx1ZVNoYXBlISwgZGF0YVR5cGU6IHByb2JzLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9KTtcbiAgfVxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBwcm9ic0hlbHBlciA9IGlucHV0VmFyaWFibGUoJ3Byb2JzJywgcHJvYnMuZGF0YVR5cGUsIHByb2JzLmRpbXMpO1xuICAgIGNvbnN0IHZIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCd2Jywgdi5kYXRhVHlwZSwgdi5kaW1zKTtcbiAgICBjb25zdCBpbnB1dFZhcnMgPSBbcHJvYnNIZWxwZXIsIHZIZWxwZXJdO1xuICAgIGlmIChmZWVkUGFzdFZhbHVlKSB7XG4gICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdwYXN0X3ZhbHVlJywgcGFzdFZhbHVlLmRhdGFUeXBlLCBwYXN0VmFsdWUuZGltcykpO1xuICAgIH1cbiAgICBjb25zdCBzZXFMZW5zSW5wdXRWYXJpYWJsZSA9IHNlcUxlbnMgPyBpbnB1dFZhcmlhYmxlKCdzZXFfbGVucycsIHNlcUxlbnMuZGF0YVR5cGUsIHNlcUxlbnMuZGltcykgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHNlcUxlbnMpIHtcbiAgICAgIGlucHV0VmFycy5wdXNoKHNlcUxlbnNJbnB1dFZhcmlhYmxlISk7XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFZhcmlhYmxlID0gdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0XG4gICAgICA/IGlucHV0VmFyaWFibGUoJ3RvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCcsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dC5kYXRhVHlwZSwgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LmRpbXMpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KSB7XG4gICAgICBpbnB1dFZhcnMucHVzaCh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRWYXJpYWJsZSEpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgcHJvYnMuZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBvdXRwdXRWYXJzID0gW291dHB1dF07XG4gICAgaWYgKHByZXNlbnRWYWx1ZSkge1xuICAgICAgb3V0cHV0VmFycy5wdXNoKG91dHB1dFZhcmlhYmxlKCdwcmVzZW50X3ZhbHVlJywgcHJvYnMuZGF0YVR5cGUsIHByZXNlbnRWYWx1ZVNoYXBlISkpO1xuICAgIH1cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnaGVhZF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ3ZfaGlkZGVuX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAncGFzdF9zZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAna3Zfc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ25fcmVwcycsIHR5cGU6ICd1MzInIH0sXG4gICAgXTtcbiAgICByZXR1cm4gYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke1RJTEVfU0laRX11O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtwcm9ic0hlbHBlci50eXBlLnZhbHVlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVY6IGFycmF5PCR7cHJvYnNIZWxwZXIudHlwZS52YWx1ZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCAuLi5vdXRwdXRWYXJzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFtUSUxFX1NJWkUsIFRJTEVfU0laRSwgMV0pfVxuICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGt2SGVhZElkeCA9ICR7blJlcHMgPT09IDEgPyAnaGVhZElkeCcgOiAnaGVhZElkeCAvIHVuaWZvcm1zLm5fcmVwcyd9O1xuICAgbGV0IGt2X251bV9oZWFkcyA9ICR7blJlcHMgPT09IDEgPyAndW5pZm9ybXMubnVtX2hlYWRzJyA6ICd1bmlmb3Jtcy5udW1faGVhZHMgLyB1bmlmb3Jtcy5uX3JlcHMnfTtcbiAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XG4gICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk07XG4gICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuSztcbiAgICR7aW5pdFZhclN0dWIoc2VxTGVuc0lucHV0VmFyaWFibGUsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFZhcmlhYmxlLCB0cnVlKX1cbiAgIGxldCBvZmZzZXRBID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xuICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4OyAvLyBrdkhlYWRJZHggaXMgcmVsYXRpdmUgdG8gdGhlIGJhdGNoXG4gICAke2ZlZWRQYXN0VmFsdWUgJiYgcHJlc2VudFZhbHVlID8gJ2xldCBwYXN0VmFsdWVPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKyBuOycgOiAnJ307XG4gICBsZXQgdk9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGggKyBuO1xuICAgJHtwcmVzZW50VmFsdWUgPyAnbGV0IHByZXNlbnRWYWx1ZU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LICsgbjsnIDogJyd9XG4gICB2YXIgdmFsdWUgPSAke3Byb2JzSGVscGVyLnR5cGUuc3RvcmFnZX0oMCk7XG4gICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHByb2JzW29mZnNldEEgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHZhciBpZHggPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueDtcbiAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgIGlmIChmZWVkUGFzdFZhbHVlICYmIHByZXNlbnRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgcGFzdF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICB0aWxlVltpZHhdID0gcGFzdF92YWx1ZVtwYXN0VmFsdWVPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XG4gICAgICAgIH0gZWxzZSBpZiAodyArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgIHRpbGVWW2lkeF0gPSB2W3ZPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgICB0aWxlVltpZHhdID0gdlt2T2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICAgICAgfWA7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpfVxuICAgICAgICAke1xuICAgICAgICAgIHByZXNlbnRWYWx1ZVxuICAgICAgICAgICAgPyBgXG4gICAgICAgICAgICBpZiAodyArIGxvY2FsX2lkLnkgPCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgIHByZXNlbnRfdmFsdWVbcHJlc2VudFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dID0gdGlsZVZbaWR4XTtcbiAgICAgICAgfWBcbiAgICAgICAgICAgIDogJydcbiAgICAgICAgfVxuICAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDsgaysrKSB7XG4gICAgICAgdmFsdWUgKz0gdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZVZbVElMRV9TSVpFICogayArIGxvY2FsX2lkLnhdO1xuICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgIH1cblxuICAgLy8gd2UgbmVlZCB0byB0cmFuc3Bvc2Ugb3V0cHV0IGZyb20gQk5TSF92IHRvIEJTTkRfdlxuICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgIGxldCBvdXRwdXRJZHggPSBiYXRjaElkeCAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplICsgbSAqIHVuaWZvcm1zLnZfaGlkZGVuX3NpemVcbiAgICAgICArIGhlYWRJZHggKiB1bmlmb3Jtcy5OICsgbjtcbiAgICAgb3V0cHV0W291dHB1dElkeF0gPSB2YWx1ZTtcbiAgIH1cbiAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQXR0ZW50aW9uU2NvcmUnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke3Bhc3RWYWx1ZSAhPT0gdW5kZWZpbmVkfTske291dHB1dENvdW50fWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHsgb3V0cHV0cywgZGlzcGF0Y2hHcm91cDogZGlzcGF0Y2gsIHByb2dyYW1Vbmlmb3JtcyB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgYXBwbHlBdHRlbnRpb24gPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBxOiBUZW5zb3JWaWV3LFxuICBrOiBUZW5zb3JWaWV3LFxuICB2OiBUZW5zb3JWaWV3LFxuICBfbWFza0luZGV4OiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICBfcGFzdDogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcbiAgcGFzdEtleTogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcbiAgcGFzdFZhbHVlOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICBhdHRlbnRpb25CaWFzSW5wdXQ6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4gIHBhcmFtZXRlcnM6IEF0dGVudGlvblBhcmFtZXRlcnMsXG4gIHNlcUxlbnM6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXG4gIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dDogVGVuc29yVmlldyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbikgPT4ge1xuICAvLyBBc3N1bXB0aW9uIGlzIHRoYXQgcHJlc2VudEtleS9wcmVzZW50VmFsdWUgZXhpc3RzIG9ubHkgaWYgcGFzdEtleS9wYXN0VmFsdWUgZXhpc3RzLlxuICBjb25zdCBvdXRwdXRDb3VudCA9IE1hdGgubWluKGNvbnRleHQub3V0cHV0Q291bnQsIDEgKyAocGFzdEtleSA/IDEgOiAwKSArIChwYXN0VmFsdWUgPyAxIDogMCkpO1xuICBjb25zdCBwYXN0U2VxdWVuY2VMZW5ndGggPSBvdXRwdXRDb3VudCA+IDEgPyBwYXJhbWV0ZXJzLnBhc3RTZXF1ZW5jZUxlbmd0aCA6IDA7XG4gIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGggPSBwYXN0U2VxdWVuY2VMZW5ndGggKyBwYXJhbWV0ZXJzLmt2U2VxdWVuY2VMZW5ndGg7XG4gIGNvbnN0IGF0dGVudGlvbkJpYXMgPVxuICAgIGF0dGVudGlvbkJpYXNJbnB1dCAmJiBTaGFwZVV0aWwuc2l6ZShhdHRlbnRpb25CaWFzSW5wdXQuZGltcykgPiAwID8gYXR0ZW50aW9uQmlhc0lucHV0IDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IGlucHV0c0sgPSBbcSwga107XG4gIGlmIChvdXRwdXRDb3VudCA+IDEgJiYgcGFzdEtleSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0S2V5LmRpbXMpID4gMCkge1xuICAgIGlucHV0c0sucHVzaChwYXN0S2V5KTtcbiAgfVxuICBpZiAoYXR0ZW50aW9uQmlhcykge1xuICAgIGlucHV0c0sucHVzaChhdHRlbnRpb25CaWFzKTtcbiAgfVxuICBpZiAoc2VxTGVucykge1xuICAgIGlucHV0c0sucHVzaChzZXFMZW5zKTtcbiAgfVxuICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KSB7XG4gICAgaW5wdXRzSy5wdXNoKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCk7XG4gIH1cbiAgLy8gUnVuIEF0dGVudGlvblByb2JzXG4gIGNvbnN0IHByb2JzID0gY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUF0dGVudGlvblByb2JzUHJvZ3JhbUluZm8oXG4gICAgICBvdXRwdXRDb3VudCxcbiAgICAgIHEsXG4gICAgICBrLFxuICAgICAgcGFzdEtleSxcbiAgICAgIGF0dGVudGlvbkJpYXMsXG4gICAgICBwYXJhbWV0ZXJzLFxuICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxuICAgICAgc2VxTGVucyxcbiAgICAgIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCxcbiAgICApLFxuICAgIHsgaW5wdXRzOiBpbnB1dHNLLCBvdXRwdXRzOiBvdXRwdXRDb3VudCA+IDEgPyBbLTEsIDFdIDogWy0xXSB9LFxuICApWzBdO1xuXG4gIC8vIFJ1biBTb2Z0bWF4XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVJblBsYWNlU29mdG1heFByb2dyYW1JbmZvKFxuICAgICAgcHJvYnMsXG4gICAgICBwYXJhbWV0ZXJzLmJhdGNoU2l6ZSxcbiAgICAgIHBhcmFtZXRlcnMubnVtSGVhZHMsXG4gICAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXG4gICAgICBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoLFxuICAgICAgdG90YWxTZXF1ZW5jZUxlbmd0aCxcbiAgICAgIHNlcUxlbnMsXG4gICAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQsXG4gICAgKSxcbiAgICB7IGlucHV0czogc2VxTGVucyAmJiB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQgPyBbcHJvYnMsIHNlcUxlbnMsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dF0gOiBbcHJvYnNdLCBvdXRwdXRzOiBbXSB9LFxuICApO1xuXG4gIC8vIFJ1biBBdHRlbnRpb25TY29yZVxuICBjb25zdCBpbnB1dHNWID0gW3Byb2JzLCB2XTtcbiAgaWYgKG91dHB1dENvdW50ID4gMSAmJiBwYXN0VmFsdWUgJiYgU2hhcGVVdGlsLnNpemUocGFzdFZhbHVlLmRpbXMpID4gMCkge1xuICAgIGlucHV0c1YucHVzaChwYXN0VmFsdWUpO1xuICB9XG4gIGlmIChzZXFMZW5zKSB7XG4gICAgaW5wdXRzVi5wdXNoKHNlcUxlbnMpO1xuICB9XG4gIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQpIHtcbiAgICBpbnB1dHNWLnB1c2godG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KTtcbiAgfVxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlVnhBdHRlbnRpb25TY29yZVByb2dyYW1JbmZvKFxuICAgICAgb3V0cHV0Q291bnQsXG4gICAgICBwcm9icyxcbiAgICAgIHYsXG4gICAgICBwYXN0VmFsdWUsXG4gICAgICBwYXJhbWV0ZXJzLFxuICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxuICAgICAgc2VxTGVucyxcbiAgICAgIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCxcbiAgICApLFxuICAgIHtcbiAgICAgIGlucHV0czogaW5wdXRzVixcbiAgICAgIG91dHB1dHM6IG91dHB1dENvdW50ID4gMSA/IFswLCAyXSA6IFswXSxcbiAgICB9LFxuICApO1xufTtcblxuY29uc3QgcHJlcGFyZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgcGFyYW1ldGVyczogQXR0ZW50aW9uUGFyYW1ldGVycykgPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtwYXJhbWV0ZXJzLmJhdGNoU2l6ZSwgcGFyYW1ldGVycy5udW1IZWFkcywgcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCwgcGFyYW1ldGVycy5oZWFkU2l6ZV07XG4gIGNvbnN0IE0gPSBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBLID0gcGFyYW1ldGVycy5pbnB1dEhpZGRlblNpemU7XG4gIGNvbnN0IE4gPSBwYXJhbWV0ZXJzLmhlYWRTaXplO1xuICBjb25zdCBUSUxFX1NJWkUgPSAxMjtcbiAgY29uc3QgZGlzcGF0Y2ggPSB7XG4gICAgeDogTWF0aC5jZWlsKHBhcmFtZXRlcnMuaGVhZFNpemUgLyBUSUxFX1NJWkUpLFxuICAgIHk6IE1hdGguY2VpbChwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoIC8gVElMRV9TSVpFKSxcbiAgICB6OiBwYXJhbWV0ZXJzLmJhdGNoU2l6ZSAqIHBhcmFtZXRlcnMubnVtSGVhZHMsXG4gIH07XG4gIGNvbnN0IGlucHV0cyA9IFtjb250ZXh0LmlucHV0c1swXSwgY29udGV4dC5pbnB1dHNbMV0sIGNvbnRleHQuaW5wdXRzWzJdXTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IEsgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTiB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLm51bUhlYWRzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMuaGVhZFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5oaWRkZW5TaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMuaGlkZGVuU2l6ZSArIHBhcmFtZXRlcnMuaGlkZGVuU2l6ZSArIHBhcmFtZXRlcnMudkhpZGRlblNpemUgfSxcbiAgXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBvdXRwdXRRID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dF9xJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgY29uc3Qgb3V0cHV0SyA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXRfaycsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IG91dHB1dFYgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0X3YnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcyk7XG4gICAgY29uc3Qgd2VpZ2h0ID0gaW5wdXRWYXJpYWJsZSgnd2VpZ2h0JywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcyk7XG4gICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGlucHV0LnR5cGUuc3RvcmFnZTtcblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ00nLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnSycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdOJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ251bV9oZWFkcycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdoZWFkX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnaGlkZGVuX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnbGRiJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuICAgIHJldHVybiBgXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7VElMRV9TSVpFfXU7XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVJbnB1dDogYXJyYXk8JHtkYXRhVHlwZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRROiBhcnJheTwke2RhdGFUeXBlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodEs6IGFycmF5PCR7ZGF0YVR5cGV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0VjogYXJyYXk8JHtkYXRhVHlwZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIHdlaWdodCwgYmlhcywgb3V0cHV0USwgb3V0cHV0Sywgb3V0cHV0Vil9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbVElMRV9TSVpFLCBUSUxFX1NJWkUsIDFdKX1cbiAgICBsZXQgYmF0Y2hJbmRleCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkTnVtYmVyID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuXG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmF0Y2hJbmRleCAqICh1bmlmb3Jtcy5NICogdW5pZm9ybXMuSykgKyBtICogdW5pZm9ybXMuSztcbiAgICBsZXQgYmlhc09mZnNldFEgPSBoZWFkTnVtYmVyICogdW5pZm9ybXMuaGVhZF9zaXplO1xuICAgIGxldCBiaWFzT2Zmc2V0SyA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldFE7XG4gICAgbGV0IGJpYXNPZmZzZXRWID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0SztcblxuICAgIHZhciB2YWx1ZVEgPSAke2RhdGFUeXBlfSgwKTtcbiAgICB2YXIgdmFsdWVLID0gJHtkYXRhVHlwZX0oMCk7XG4gICAgdmFyIHZhbHVlViA9ICR7ZGF0YVR5cGV9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZUlucHV0W1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IGlucHV0W2lucHV0T2Zmc2V0ICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gbiArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5sZGI7XG4gICAgICAgIHRpbGVXZWlnaHRRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0USArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0SyArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRWW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0ViArIG9mZnNldF07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazxUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgIGxldCBpbnB1dFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgaztcbiAgICAgICAgbGV0IHdlaWdodFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueDtcbiAgICAgICAgdmFsdWVRICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFFbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICAgIHZhbHVlSyArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRLW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgICB2YWx1ZVYgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0Vlt3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgIGxldCBoZWFkT2Zmc2V0ID0gKG0gKiB1bmlmb3Jtcy5OICsgbikgJSB1bmlmb3Jtcy5oZWFkX3NpemU7XG4gICAgdmFsdWVRICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRRXTtcbiAgICB2YWx1ZUsgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldEtdO1xuICAgIHZhbHVlViArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0Vl07XG5cbiAgICBsZXQgb2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuTjtcbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIGxldCBvdXRwdXRJZHggPSBvZmZzZXQgKyBtICogdW5pZm9ybXMuTiArIG47XG4gICAgICBvdXRwdXRfcVtvdXRwdXRJZHhdID0gdmFsdWVRO1xuICAgICAgb3V0cHV0X2tbb3V0cHV0SWR4XSA9IHZhbHVlSztcbiAgICAgIG91dHB1dF92W291dHB1dElkeF0gPSB2YWx1ZVY7XG4gICAgfVxuICB9YDtcbiAgfTtcblxuICByZXR1cm4gY29udGV4dC5jb21wdXRlKFxuICAgIHtcbiAgICAgIG5hbWU6ICdBdHRlbnRpb25QcmVwYXJlJyxcbiAgICAgIHNoYWRlckNhY2hlOiB7IGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnLCAndHlwZScsICd0eXBlJ10gfSxcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICB7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0IH0sXG4gICAgICAgICAgeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9LFxuICAgICAgICAgIHsgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogZGlzcGF0Y2gsXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICAgIH0pLFxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIH0sXG4gICAgeyBpbnB1dHMsIG91dHB1dHM6IFstMSwgLTEsIC0xXSB9LFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGF0dGVudGlvbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiB2b2lkID0+IHtcbiAgY29uc3QgcGFyYW1zID0gdmFsaWRhdGVBdHRlbnRpb25JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuXG4gIGNvbnN0IFtxLCBrLCB2XSA9IHByZXBhcmUoY29udGV4dCwgcGFyYW1zKTtcblxuICByZXR1cm4gYXBwbHlBdHRlbnRpb24oXG4gICAgY29udGV4dCxcbiAgICBxLFxuICAgIGssXG4gICAgdixcbiAgICBjb250ZXh0LmlucHV0c1s0XSxcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZCxcbiAgICBjb250ZXh0LmlucHV0c1s1XSxcbiAgICBwYXJhbXMsXG4gICk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBlbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGdldE1heENvbXBvbmVudHMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hOb3JtQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGVwc2lsb246IG51bWJlcjtcbiAgcmVhZG9ubHkgbW9tZW50dW06IG51bWJlcjtcbiAgcmVhZG9ubHkgc3BhdGlhbDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgdHJhaW5pbmdNb2RlOiBib29sZWFuO1xuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJyB8ICdOQ0hXJztcbiAgcmVhZG9ubHkgb3V0cHV0Q291bnQ6IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEJhdGNoTm9ybUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2hOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDUgaW5wdXRzJyk7XG4gIH1cblxuICBjb25zdCBjaGVja1NoYXBlRXF1YWwgPSAoYWN0dWFsOiByZWFkb25seSBudW1iZXJbXSwgZXhwZWN0ZWQ6IHJlYWRvbmx5IG51bWJlcltdLCBtZXNzYWdlOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGlmIChyICE9PSBhY3R1YWwubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX06IG51bSBkaW1lbnNpb25zICE9ICR7cn1gKTtcbiAgICB9XG4gICAgZXhwZWN0ZWQuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgaWYgKHYgIT09IGFjdHVhbFtpXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX06IGRpbVske2l9XSBkbyBub3QgbWF0Y2hgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IHNoYXBlID1cbiAgICAgIGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQydcbiAgICAgICAgPyBhdHRyaWJ1dGVzLnNwYXRpYWxcbiAgICAgICAgICA/IGlucHV0c1swXS5kaW1zLnNsaWNlKC0xKVxuICAgICAgICAgIDogaW5wdXRzWzBdLmRpbXMuc2xpY2UoLTEpLmNvbmNhdChpbnB1dHNbMF0uZGltcy5zbGljZSgxLCBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxKSlcbiAgICAgICAgOiBpbnB1dHNbMF0uZGltcy5zbGljZSgxLCBhdHRyaWJ1dGVzLnNwYXRpYWwgPyAyIDogdW5kZWZpbmVkKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzFdLmRpbXMsIHNoYXBlLCAnSW52YWxpZCBpbnB1dCBzY2FsZScpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbMl0uZGltcywgc2hhcGUsICdJbnZhbGlkIGlucHV0IEInKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzNdLmRpbXMsIHNoYXBlLCAnSW52YWxpZCBpbnB1dCBtZWFuJyk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1s0XS5kaW1zLCBzaGFwZSwgJ0ludmFsaWQgaW5wdXQgdmFyJyk7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1sxXS5kaW1zLCBbMV0sICdJbnZhbGlkIGlucHV0IHNjYWxlJyk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1syXS5kaW1zLCBbMV0sICdJbnZhbGlkIGlucHV0IEInKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzNdLmRpbXMsIFsxXSwgJ0ludmFsaWQgaW5wdXQgbWVhbicpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbNF0uZGltcywgWzFdLCAnSW52YWxpZCBpbnB1dCB2YXInKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlQmF0Y2hOb3JtSW5mZXJlbmNlUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1BdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCB7IGVwc2lsb24sIHNwYXRpYWwsIGZvcm1hdCB9ID0gYXR0cmlidXRlcztcbiAgY29uc3QgeVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBzcGF0aWFsID8gZ2V0TWF4Q29tcG9uZW50cyh5U2hhcGVbeVNoYXBlLmxlbmd0aCAtIDFdKSA6IDE7XG4gIGNvbnN0IGNDb21wb25lbnRzID0gZm9ybWF0ID09PSAnTkhXQycgJiYgeVNoYXBlLmxlbmd0aCA+IDEgPyBjb21wb25lbnRzIDogMTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKHlTaGFwZSkgLyBjb21wb25lbnRzO1xuICAvLyBPbmx5IHN1cHBvcnQgdW5pZm9ybXMgZm9yIG9wc2V0IHZlcnNpb24gPj0gOSAoc3BhdGlhbCA9IHRydWUpLlxuICBjb25zdCB1c2VTaGFwZXNVbmlmb3JtcyA9IHNwYXRpYWw7XG4gIGNvbnN0IHNoYXBlT3JSYW5rID0gdXNlU2hhcGVzVW5pZm9ybXMgPyB5U2hhcGUubGVuZ3RoIDogeVNoYXBlO1xuICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpO1xuICBjb25zdCBzY2FsZSA9IGlucHV0VmFyaWFibGUoJ3NjYWxlJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcywgY0NvbXBvbmVudHMpO1xuICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMsIGNDb21wb25lbnRzKTtcbiAgY29uc3QgaW5wdXRNZWFuID0gaW5wdXRWYXJpYWJsZSgnaW5wdXRNZWFuJywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcywgY0NvbXBvbmVudHMpO1xuICBjb25zdCBpbnB1dFZhciA9IGlucHV0VmFyaWFibGUoJ2lucHV0VmFyJywgaW5wdXRzWzRdLmRhdGFUeXBlLCBpbnB1dHNbNF0uZGltcywgY0NvbXBvbmVudHMpO1xuICBjb25zdCB5ID0gb3V0cHV0VmFyaWFibGUoJ3knLCBpbnB1dHNbMF0uZGF0YVR5cGUsIHNoYXBlT3JSYW5rLCBjb21wb25lbnRzKTtcbiAgLy8gVE9ETzogc3VwcG9ydCBpbnB1dHMgd2l0aCBkaWZmZXJlbnQgZGF0YSB0eXBlLiBDdXJyZW50IHdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCBpbnB1dHMgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuXG4gIC8vIE90aGVyd2lzZSwgdGhlIHNoYWRlciBjb21waWxhdGlvbiB3aWxsIGZhaWwuXG4gIGNvbnN0IGNhbGNDT2Zmc2V0ID0gKCk6IHN0cmluZyA9PiB7XG4gICAgbGV0IGNPZmZzZXQgPSAnJztcbiAgICBpZiAoc3BhdGlhbCkge1xuICAgICAgY09mZnNldCA9IGBsZXQgY09mZnNldCA9ICR7XG4gICAgICAgIHlTaGFwZS5sZW5ndGggPT09IDFcbiAgICAgICAgICA/ICcwdSdcbiAgICAgICAgICA6IGZvcm1hdCA9PT0gJ05IV0MnXG4gICAgICAgICAgICA/IGBvdXRwdXRJbmRpY2VzWyR7eVNoYXBlLmxlbmd0aCAtIDF9XSAvICR7Y29tcG9uZW50c31gXG4gICAgICAgICAgICA6ICdvdXRwdXRJbmRpY2VzWzFdJ1xuICAgICAgfTtgO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZm9ybWF0ID09PSAnTkNIVycpIHtcbiAgICAgICAgY09mZnNldCA9IGBcbiAgICAgICAgICAgICR7eS5pbmRpY2VzU2V0KCdvdXRwdXRJbmRpY2VzJywgJzAnLCAnMCcpfVxuICAgICAgICAgICAgbGV0IGNPZmZzZXQgPSAke3kuaW5kaWNlc1RvT2Zmc2V0KCdvdXRwdXRJbmRpY2VzJyl9O2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgQyBjaGFubmVsLlxuICAgICAgICBjT2Zmc2V0ID0gYHZhciBjSW5kaWNlcyA9ICR7c2NhbGUudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgY0luZGljZXNbMF0gPSBvdXRwdXRJbmRpY2VzWyR7eVNoYXBlLmxlbmd0aCAtIDF9XTtgO1xuICAgICAgICAvLyB1cGRhdGUgRDEgeCAuLi4geCBEbiBjaGFubmVscy5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzY2FsZS5yYW5rOyBpKyspIHtcbiAgICAgICAgICBjT2Zmc2V0ICs9IGBjSW5kaWNlc1ske2l9XSA9IG91dHB1dEluZGljZXNbJHtpfV07YDtcbiAgICAgICAgfVxuICAgICAgICBjT2Zmc2V0ICs9IGBsZXQgY09mZnNldCA9ICR7c2NhbGUuaW5kaWNlc1RvT2Zmc2V0KCdjSW5kaWNlcycpfTtgO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY09mZnNldDtcbiAgfTtcbiAgY29uc3QgZ2V0SW5mZXJlbmNlTW9kZVNoYWRlclNvdXJjZSA9IChoZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICBjb25zdCBlcHNpbG9uID0gJHtlcHNpbG9ufTtcbiAgJHtoZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoeCwgc2NhbGUsIGJpYXMsIGlucHV0TWVhbiwgaW5wdXRWYXIsIHkpfVxuICAke2hlbHBlci5tYWluU3RhcnQoKX1cbiAgJHtoZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgIHZhciBvdXRwdXRJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqICR7Y29tcG9uZW50c31gKX07XG4gICAgJHtjYWxjQ09mZnNldCgpfVxuICAgIGxldCBzY2FsZSA9ICR7c2NhbGUuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07XG4gICAgbGV0IGJpYXMgPSAke2JpYXMuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07XG4gICAgbGV0IGlucHV0TWVhbiA9ICR7aW5wdXRNZWFuLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O1xuICAgIGxldCBpbnB1dFZhciA9ICR7aW5wdXRWYXIuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07XG4gICAgbGV0IHggPSAke3guZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgbGV0IHZhbHVlID0gKHggLSBpbnB1dE1lYW4pICogaW52ZXJzZVNxcnQoaW5wdXRWYXIgKyBlcHNpbG9uKSAqIHNjYWxlICsgYmlhcztcbiAgICAke3kuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX1cbiAgfWA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0JhdGNoTm9ybWFsaXphdGlvbicsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuZXBzaWxvbn1fJHthdHRyaWJ1dGVzLmZvcm1hdH1fJHtzcGF0aWFsfV8ke2NvbXBvbmVudHN9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiB1c2VTaGFwZXNVbmlmb3JtcyA/IFsncmFuaycsICd0eXBlJywgJ3R5cGUnLCAndHlwZScsICd0eXBlJ10gOiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2U6IGdldEluZmVyZW5jZU1vZGVTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IGlucHV0c1swXS5kaW1zLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiB1c2VTaGFwZXNVbmlmb3Jtc1xuICAgICAgICA/IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyh5U2hhcGUpXVxuICAgICAgICA6IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9XSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUJhdGNoTm9ybUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBCYXRjaE5vcm1BdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIE9taXQ8QmF0Y2hOb3JtQXR0cmlidXRlcywga2V5b2YgQXR0cmlidXRlV2l0aENhY2hlS2V5Pik7XG5cbmV4cG9ydCBjb25zdCBiYXRjaE5vcm0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdm9pZCA9PiB7XG4gIGNvbnN0IHsgaW5wdXRzLCBvdXRwdXRDb3VudCB9ID0gY29udGV4dDtcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXMgPSBwYXJzZUJhdGNoTm9ybUF0dHJpYnV0ZXMoeyAuLi5hdHRyaWJ1dGVzLCBvdXRwdXRDb3VudCB9KTtcbiAgaWYgKGVudi53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQpIHtcbiAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy50cmFpbmluZ01vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoTm9ybWFsaXphdGlvbiB0cmFpbmluZ01vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUJhdGNoTm9ybUluZmVyZW5jZVByb2dyYW1JbmZvKGlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmICghWzMyMCwgNjQwLCAxMjgwXS5pbmNsdWRlcyhpbnB1dHNbMF0uZGltc1syXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBvZiBjaGFubmVscyBzaG91bGQgYmUgMzIwLCA2NDAgb3IgMTI4MCcpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zWzJdICE9PSBpbnB1dHNbMV0uZGltc1swXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZScpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVCaWFzQWRkUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG5cbiAgY29uc3QgY2hhbm5lbHMgPSBpbnB1dHNbMF0uZGltc1syXTtcbiAgLy8gc2luY2UgY2hhbm5lbCBudW1iZXIgY2FuIGJlIG9ubHkgMzIwLzY0MC8xMjgwLCBpdCdzIGFsd2F5cyBkaXZpc2libGUgYnkgNFxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNDtcblxuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XG4gIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgZGF0YVR5cGUsIFtjaGFubmVsc10sIDQpO1xuICBjb25zdCByZXNpZHVhbCA9IGlucHV0VmFyaWFibGUoJ3Jlc2lkdWFsJywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLCA0KTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gIGNvbnN0IGNoYW5uZWxzID0gJHtjaGFubmVsc311IC8gNDtcbiAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgYmlhcywgcmVzaWR1YWwsIG91dHB1dCl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvdXRwdXRTaXplKX1cbiAgICBsZXQgdmFsdWUgPSAke2lucHV0LmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4Jyl9XG4gICAgICArICR7Ymlhcy5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCAlIGNoYW5uZWxzJyl9ICsgJHtyZXNpZHVhbC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfVxuICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdCaWFzQWRkJyxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGJpYXNBZGQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQmlhc0FkZFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUsXG4gIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbnR5cGUgQnVpbHRpbkZ1bmN0aW9uTmFtZSA9IHN0cmluZztcbnR5cGUgRWxlbWVudHdpc2VDdXN0b21FeHByZXNzaW9uID0gKGV4cHJlc3Npb246IHN0cmluZykgPT4gc3RyaW5nO1xudHlwZSBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbCA9IEJ1aWx0aW5GdW5jdGlvbk5hbWUgfCBFbGVtZW50d2lzZUN1c3RvbUV4cHJlc3Npb247XG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbVNoYWRlciA9IChcbiAgc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIsXG4gIGRhdGFzaXplOiBudW1iZXIsXG4gIGlucHV0RGF0YVR5cGU6IG51bWJlcixcbiAgb3V0cHV0RGF0YVR5cGU6IG51bWJlcixcbiAgZnVuY0NhbGw6IEVsZW1lbnR3aXNlRnVuY3Rpb25DYWxsLFxuICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24/OiBzdHJpbmcsXG4gIGFkZGl0aW9uYWxVbmlmb3Jtc1R5cGU/OiBVbmlmb3Jtc0FycmF5VHlwZSxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHZlY1NpemUgPSBNYXRoLmNlaWwoZGF0YXNpemUgLyA0KTtcblxuICBsZXQgZXhwcmVzc2lvbiA9ICcnO1xuICBpZiAodHlwZW9mIGZ1bmNDYWxsID09PSAnc3RyaW5nJykge1xuICAgIGV4cHJlc3Npb24gPSBgJHtmdW5jQ2FsbH0oYSlgO1xuICB9IGVsc2Uge1xuICAgIGV4cHJlc3Npb24gPSBmdW5jQ2FsbCgnYScpO1xuICB9XG5cbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dERhdGEnLCBpbnB1dERhdGFUeXBlLCBbdmVjU2l6ZV0sIDQpO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0RGF0YScsIG91dHB1dERhdGFUeXBlLCBbdmVjU2l6ZV0sIDQpO1xuICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbeyBuYW1lOiAndmVjX3NpemUnLCB0eXBlOiAndTMyJyB9XTtcbiAgaWYgKGFkZGl0aW9uYWxVbmlmb3Jtc1R5cGUpIHtcbiAgICB1bmlmb3Jtcy5wdXNoKC4uLmFkZGl0aW9uYWxVbmlmb3Jtc1R5cGUpO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG5cbiAgJHthZGRpdGlvbmFsSW1wbGVtZW50YXRpb24gPz8gJyd9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cblxuICAgIGxldCBhID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGV4cHJlc3Npb24pfVxuICB9YDtcbn07XG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bmNDYWxsOiBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbCxcbiAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uPzogc3RyaW5nLFxuICBjYWNoZUtleT86IHN0cmluZyxcbiAgb3V0cHV0RGF0YVR5cGU6IG51bWJlciA9IGlucHV0LmRhdGFUeXBlLFxuICBhZGRpdGlvbmFsVW5pZm9ybXM/OiBQcm9ncmFtVW5pZm9ybVtdLFxuICBhZGRpdGlvbmFsVW5pZm9ybXNUeXBlPzogVW5pZm9ybXNBcnJheVR5cGUsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKGlucHV0LmRpbXMpIC8gNCkgfSxcbiAgXTtcbiAgaWYgKGFkZGl0aW9uYWxVbmlmb3Jtcykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmFkZGl0aW9uYWxVbmlmb3Jtcyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnXSB9LFxuICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcikgPT5cbiAgICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbVNoYWRlcihcbiAgICAgICAgc2hhZGVySGVscGVyLFxuICAgICAgICBTaGFwZVV0aWwuc2l6ZShpbnB1dC5kaW1zKSxcbiAgICAgICAgaW5wdXQuZGF0YVR5cGUsXG4gICAgICAgIG91dHB1dERhdGFUeXBlLFxuICAgICAgICBmdW5jQ2FsbCxcbiAgICAgICAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uLFxuICAgICAgICBhZGRpdGlvbmFsVW5pZm9ybXNUeXBlLFxuICAgICAgKSxcbiAgICBnZXRSdW5EYXRhOiAoaW5wdXRUZW5zb3JzKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogaW5wdXQuZGltcywgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge1xuICAgICAgICB4OiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUoaW5wdXRUZW5zb3JzWzBdLmRpbXMpIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8gLyA0IC8qIHZlYyBzaXplICovKSxcbiAgICAgIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgYWJzID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWJzJywgJ2FicycpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhY29zID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWNvcycsICdhY29zJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGFjb3NoID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWNvc2gnLCAnYWNvc2gnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgYXNpbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0FzaW4nLCAnYXNpbicpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhc2luaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0FzaW5oJywgJ2FzaW5oJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGF0YW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBdGFuJywgJ2F0YW4nKSk7XG59O1xuZXhwb3J0IGNvbnN0IGF0YW5oID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQXRhbmgnLCAnYXRhbmgnKSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENhc3RBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgdG86IG51bWJlcjtcbiAgcmVhZG9ubHkgc2F0dXJhdGU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgcGFyc2VDYXN0QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IENhc3RBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIHsgdG86IG51bWJlciB9KTtcblxuZXhwb3J0IGNvbnN0IGNhc3QgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENhc3RBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGxldCBmdW5jOiBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbDtcbiAgc3dpdGNoIChhdHRyaWJ1dGVzLnRvKSB7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDE2OlxuICAgICAgZnVuYyA9ICd2ZWM0PGYxNj4nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDpcbiAgICAgIGZ1bmMgPSAndmVjNDxmMzI+JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDMyOlxuICAgICAgZnVuYyA9ICd2ZWM0PHUzMj4nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQzMjpcbiAgICAgIGZ1bmMgPSAndmVjNDxpMzI+JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcbiAgICAgIGZ1bmMgPSAndmVjNDxib29sPic7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYG5vdCBzdXBwb3J0ZWQgdHlwZSAoc3BlY2lmaWVkIGluIGF0dHJpYnV0ZSAndG8nIGZyb20gJ0Nhc3QnIG9wZXJhdG9yKTogJHthdHRyaWJ1dGVzLnRvfWApO1xuICB9XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQ2FzdCcsIGZ1bmMsIHVuZGVmaW5lZCwgYXR0cmlidXRlcy5jYWNoZUtleSwgYXR0cmlidXRlcy50byksXG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsaXBBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgbWluOiBudW1iZXI7XG4gIHJlYWRvbmx5IG1heDogbnVtYmVyO1xufVxuXG5jb25zdCBnZW5lcmF0ZUNsaXBBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IENsaXBBdHRyaWJ1dGVzID0+IHtcbiAgbGV0IG1pbjogbnVtYmVyO1xuICBsZXQgbWF4OiBudW1iZXI7XG4gIGNvbnN0IGhhc01pbiA9IGlucHV0cy5sZW5ndGggPj0gMiAmJiBpbnB1dHNbMV0uZGF0YSAhPT0gMDtcbiAgY29uc3QgaGFzTWF4ID0gaW5wdXRzLmxlbmd0aCA+PSAzICYmIGlucHV0c1syXS5kYXRhICE9PSAwO1xuXG4gIHN3aXRjaCAoaW5wdXRzWzBdLmRhdGFUeXBlKSB7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDpcbiAgICAgIG1pbiA9IGhhc01pbiA/IGlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXSA6IC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzg7XG4gICAgICBtYXggPSBoYXNNYXggPyBpbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF0gOiAzLjQwMjgyMzQ2NjM4NTI4ODZlMzg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0MTY6XG4gICAgICBtaW4gPSBoYXNNaW4gPyBpbnB1dHNbMV0uZ2V0VWludDE2QXJyYXkoKVswXSA6IDY0NTExOyAvLyB1aW50MTYoNjQ1MTEpIDwtPiBmbG9hdDE2KC02NTUwNC4wKVxuICAgICAgbWF4ID0gaGFzTWF4ID8gaW5wdXRzWzJdLmdldFVpbnQxNkFycmF5KClbMF0gOiAzMTc0MzsgLy8gdWludDE2KDMxNzQzKSA8LT4gZmxvYXQxNig2NTUwNC4wKVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0IGRhdGEgdHlwZScpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IG1pbiwgbWF4IH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGNsaXAgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGNsaXBBdHRyaWJ1dGVzOiBDbGlwQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gY2xpcEF0dHJpYnV0ZXMgPyBjbGlwQXR0cmlidXRlcyA6IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdDbGlwJyxcbiAgICAgIChhKSA9PiBgY2xhbXAoJHthfSwgdmVjNDwke2RhdGFUeXBlfT4odW5pZm9ybXMubWluKSwgdmVjNDwke2RhdGFUeXBlfT4odW5pZm9ybXMubWF4KSlgLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIFtcbiAgICAgICAgeyB0eXBlOiBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZGF0YTogYXR0cmlidXRlcy5taW4gfSxcbiAgICAgICAgeyB0eXBlOiBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZGF0YTogYXR0cmlidXRlcy5tYXggfSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIHsgbmFtZTogJ21pbicsIHR5cGU6IGRhdGFUeXBlIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgfSxcbiAgICAgICAgeyBuYW1lOiAnbWF4JywgdHlwZTogZGF0YVR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9LFxuICAgICAgXSxcbiAgICApLFxuICAgIHsgaW5wdXRzOiBbMF0gfSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjZWlsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQ2VpbCcsICdjZWlsJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0NvcycsICdjb3MnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgY29zaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Nvc2gnLCAnY29zaCcpKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWxwaGFBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYWxwaGE6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlQWxwaGFBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQWxwaGFBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIHsgYWxwaGE6IG51bWJlciB9KTtcblxuZXhwb3J0IGNvbnN0IGVsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQWxwaGFBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgICAnRWx1JyxcbiAgICAgIChhKSA9PiBgZWx1X3ZmMzIoJHthfSlgLFxuICAgICAgYFxuICBjb25zdCBlbHVfYWxwaGFfID0gJHtkYXRhVHlwZX0oJHthdHRyaWJ1dGVzLmFscGhhfSk7XG5cbiAgZm4gZWx1X2YzMihhOiAke2RhdGFUeXBlfSkgLT4gJHtkYXRhVHlwZX0ge1xuICByZXR1cm4gc2VsZWN0KChleHAoYSkgLSAxLjApICogZWx1X2FscGhhXywgYSwgYSA+PSAwLjApO1xuICB9XG5cbiAgZm4gZWx1X3ZmMzIodjogdmVjNDwke2RhdGFUeXBlfT4pIC0+IHZlYzQ8JHtkYXRhVHlwZX0+IHtcbiAgcmV0dXJuIHZlYzQoZWx1X2YzMih2LngpLCBlbHVfZjMyKHYueSksIGVsdV9mMzIodi56KSwgZWx1X2YzMih2LncpKTtcbiAgfWAsXG4gICAgICBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICksXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZXJmSW1wbCA9ICh2YXJUeXBlID0gJ2YzMicpID0+IGBcbmNvbnN0IHIwOiAke3ZhclR5cGV9ID0gMC4zMjc1OTExO1xuY29uc3QgcjE6ICR7dmFyVHlwZX0gPSAwLjI1NDgyOTU5MjtcbmNvbnN0IHIyOiAke3ZhclR5cGV9ID0gLTAuMjg0NDk2NzM2O1xuY29uc3QgcjM6ICR7dmFyVHlwZX0gPSAxLjQyMTQxMzc0MTtcbmNvbnN0IHI0OiAke3ZhclR5cGV9ID0gLTEuNDUzMTUyMDI3O1xuY29uc3QgcjU6ICR7dmFyVHlwZX0gPSAxLjA2MTQwNTQyOTtcblxuZm4gZXJmX3ZmMzIodjogdmVjNDwke3ZhclR5cGV9PikgLT4gdmVjNDwke3ZhclR5cGV9PiB7XG4gIGxldCBhYnN2ID0gYWJzKHYpO1xuICBsZXQgeCA9IDEuMCAvICgxLjAgKyByMCAqIGFic3YpO1xuICByZXR1cm4gc2lnbih2KSAqICgxLjAgLSAoKCgocjUgKiB4ICsgcjQpICogeCArIHIzKSAqIHggKyByMikgKiB4ICsgcjEpICogeCAqIGV4cCgtYWJzdiAqIGFic3YpKTtcbn1gO1xuXG5leHBvcnQgY29uc3QgZXJmID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnRXJmJywgKGEpID0+IGBlcmZfdmYzMigke2F9KWAsIGVyZkltcGwoZGF0YVR5cGUpKSk7XG59O1xuXG5leHBvcnQgY29uc3QgZXhwID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnRXhwJywgJ2V4cCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmbG9vciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Zsb29yJywgJ2Zsb29yJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdHZWx1JyxcbiAgICAgIChhKSA9PiBgMC41ICogJHthfSAqICgxLjAgKyBlcmZfdmYzMigke2F9ICogMC43MDcxMDY3ODExODY1NDc1KSlgLFxuICAgICAgZXJmSW1wbChkYXRhVHlwZSksXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBsZWFreVJlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLFxuICAgICAgJ0xlYWt5UmVsdScsXG4gICAgICAoYSkgPT4gYHNlbGVjdChsZWFreV9yZWx1X2FscGhhXyAqICR7YX0sICR7YX0sICR7YX0gPj0gdmVjNDwke2RhdGFUeXBlfT4oMC4wKSlgLFxuICAgICAgYGNvbnN0IGxlYWt5X3JlbHVfYWxwaGFfID0gJHtkYXRhVHlwZX0oJHthdHRyaWJ1dGVzLmFscGhhfSk7YCxcbiAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBub3QgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdOb3QnLCAoYSkgPT4gYCEke2F9YCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IG5lZyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ05lZycsIChhKSA9PiBgLSR7YX1gKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVjaXByb2NhbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1JlY2lwcm9jYWwnLCAoYSkgPT4gYDEuMC8ke2F9YCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdSZWx1JyxcbiAgICAgIChhKSA9PiBgc2VsZWN0KHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCksICR7YX0sICR7YX0gPiB2ZWM0PCR7ZGF0YVR5cGV9PigwLjApKWAsXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzaWdtb2lkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnU2lnbW9pZCcsIChhKSA9PiBgKDEuMCAvICgxLjAgKyBleHAoLSR7YX0pKSlgKSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEhhcmRTaWdtb2lkQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGFscGhhOiBudW1iZXI7XG4gIHJlYWRvbmx5IGJldGE6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlSGFyZFNpZ21vaWRBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogSGFyZFNpZ21vaWRBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShcbiAgICBhdHRyaWJ1dGVzIGFzIHtcbiAgICAgIGFscGhhOiBudW1iZXI7XG4gICAgICBiZXRhOiBudW1iZXI7XG4gICAgfSxcbiAgKTtcblxuZXhwb3J0IGNvbnN0IGhhcmRTaWdtb2lkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBIYXJkU2lnbW9pZEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdIYXJkU2lnbW9pZCcsXG4gICAgICAoYSkgPT5cbiAgICAgICAgYG1heCh2ZWM0PCR7ZGF0YVR5cGV9PigwLjApLCBtaW4odmVjNDwke2RhdGFUeXBlfT4oMS4wKSwgJHthdHRyaWJ1dGVzLmFscGhhfSAqICR7YX0gKyB2ZWM0PCR7ZGF0YVR5cGV9Pigke2F0dHJpYnV0ZXMuYmV0YX0pKSlgLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICApLFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHNpbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NpbicsICdzaW4nKSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2luaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NpbmgnLCAnc2luaCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzcXJ0ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnU3FydCcsICdzcXJ0JykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRhbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1RhbicsICd0YW4nKSk7XG59O1xuXG5leHBvcnQgY29uc3QgdGFuaEV4cHJlc3Npb24gPSAoYTogc3RyaW5nKSA9PiBgc2lnbigke2F9KSAqICgxIC0gZXhwKC0yICogYWJzKCR7YX0pKSkgLyAoMSArIGV4cCgtMiAqIGFicygke2F9KSkpYDtcblxuZXhwb3J0IGNvbnN0IHRhbmggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgLy8gVE9ETzogcmV2aXNpdCBhZnRlciBodHRwczovL2dpdGh1Yi5jb20vZ3B1d2ViL2dwdXdlYi9pc3N1ZXMvNDQ1OCBpcyByZXNvbHZlZFxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1RhbmgnLCB0YW5oRXhwcmVzc2lvbikpO1xufTtcblxuZXhwb3J0IGNvbnN0IGZhc3RHZWx1SW1wbCA9ICh2YXJUeXBlID0gJ2YzMicpID0+IGBcbmNvbnN0IGZhc3RfZ2VsdV9hOiAke3ZhclR5cGV9ID0gMC41O1xuY29uc3QgZmFzdF9nZWx1X2I6ICR7dmFyVHlwZX0gPSAwLjc5Nzg4NDU2MDgwMjg2NTQ7XG5jb25zdCBmYXN0X2dlbHVfYzogJHt2YXJUeXBlfSA9IDAuMDM1Njc3NDA4MTM2MzAwMTI1O1xuXG5mbiB0YW5oX3YodjogdmVjNDwke3ZhclR5cGV9PikgLT4gdmVjNDwke3ZhclR5cGV9PiB7XG4gIHJldHVybiAke3RhbmhFeHByZXNzaW9uKCd2Jyl9O1xufVxuYDtcblxuZXhwb3J0IGNvbnN0IGZhc3RHZWx1RXhwcmVzc2lvbiA9ICh4OiBzdHJpbmcpID0+XG4gIGAoZmFzdF9nZWx1X2EgKyBmYXN0X2dlbHVfYSAqIHRhbmhfdigke3h9ICogKGZhc3RfZ2VsdV9jICogJHt4fSAqICR7eH0gKyBmYXN0X2dlbHVfYikpKSAqICR7eH1gO1xuXG5leHBvcnQgY29uc3QgZmFzdEdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdGYXN0R2VsdScsXG4gICAgICBmYXN0R2VsdUV4cHJlc3Npb24sXG4gICAgICBmYXN0R2VsdUltcGwoZGF0YVR5cGUpLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCB0aHJlc2hvbGRlZFJlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IG51bWJlciA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgICAnVGhyZXNob2xkZWRSZWx1JyxcbiAgICAgIChhKSA9PiBgc2VsZWN0KHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCksICR7YX0sICR7YX0gPiB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXylgLFxuICAgICAgYGNvbnN0IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfID0gdmVjNDwke2RhdGFUeXBlfT4oJHthdHRyaWJ1dGVzLmFscGhhfSk7YCxcbiAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgKSxcbiAgKTtcbiAgcmV0dXJuIDA7XG59O1xuXG5leHBvcnQgY29uc3QgbG9nID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnTG9nJywgJ2xvZycpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBxdWlja0dlbHVJbXBsID0gKHZhclR5cGU6IHN0cmluZywgYWxwaGE6IG51bWJlcikgPT4gYFxuY29uc3QgYWxwaGEgPSB2ZWM0PCR7dmFyVHlwZX0+KCR7YWxwaGF9KTtcbmNvbnN0IG9uZSA9ICR7dmFyVHlwZX0oMS4wKTtcbmNvbnN0IHplcm8gPSAke3ZhclR5cGV9KDAuMCk7XG5cbmZuIHF1aWNrX2dlbHVfaW1wbCh4OiB2ZWM0PCR7dmFyVHlwZX0+KSAtPiB2ZWM0PCR7dmFyVHlwZX0+IHtcbiAgbGV0IHYgPSB4ICphbHBoYTtcbiAgdmFyIHgxIDogdmVjNDwke3ZhclR5cGV9PjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpID0gaSArIDEpIHtcbiAgICBpZiAodltpXSA+PSB6ZXJvKSB7XG4gICAgICB4MVtpXSA9IG9uZSAvIChvbmUgKyBleHAoLXZbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDFbaV0gPSBvbmUgLSBvbmUgLyAob25lICsgZXhwKHZbaV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHggKiB4MTtcbn1cbmA7XG5cbmV4cG9ydCBjb25zdCBxdWlja0dlbHVFeHByZXNzaW9uID0gKHg6IHN0cmluZykgPT4gYHF1aWNrX2dlbHVfaW1wbCgke3h9KWA7XG5cbmV4cG9ydCBjb25zdCBxdWlja2dlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBkVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLFxuICAgICAgJ1F1aWNrR2VsdScsXG4gICAgICBxdWlja0dlbHVFeHByZXNzaW9uLFxuICAgICAgcXVpY2tHZWx1SW1wbChkVHlwZSwgYXR0cmlidXRlcy5hbHBoYSksXG4gICAgICBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgKSxcbiAgKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlIH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgZXJmSW1wbCB9IGZyb20gJy4vdW5hcnktb3AnO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmICghWzI1NjAsIDUxMjAsIDEwMjQwXS5pbmNsdWRlcyhpbnB1dHNbMF0uZGltc1syXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2hpZGRlbiBzdGF0ZSBzaG91bGQgYmUgMjU2MCwgNTEyMCBvciAxMDI0MCcpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zWzJdICE9PSBpbnB1dHNbMV0uZGltc1swXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZScpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVCaWFzU3BsaXRHZWx1UHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgb3V0cHV0U2hhcGVbMl0gPSBvdXRwdXRTaGFwZVsyXSAvIDI7XG5cbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIDQpO1xuICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1swXS5kYXRhVHlwZSwgW2lucHV0c1swXS5kaW1zWzJdXSwgNCk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLCA0KTtcblxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNDtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgY29uc3QgTV9TUVJUMiA9IHNxcnQoMi4wKTtcbiAgY29uc3QgaGFsZkNoYW5uZWxzID0gJHtpbnB1dHNbMF0uZGltc1syXSAvIDQgLyAyfXU7XG5cbiAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgYmlhcywgb3V0cHV0KX1cblxuICAke2VyZkltcGwoZGF0YVR5cGUpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMob3V0cHV0U2l6ZSl9XG4gICAgbGV0IGJpYXNJZHggPSBnbG9iYWxfaWR4ICUgaGFsZkNoYW5uZWxzO1xuICAgIGxldCBiYXRjaEluZGV4ID0gZ2xvYmFsX2lkeCAvIGhhbGZDaGFubmVscztcbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBiaWFzSWR4ICsgYmF0Y2hJbmRleCAqIGhhbGZDaGFubmVscyAqIDI7XG4gICAgbGV0IHZhbHVlTGVmdCA9IGlucHV0W2lucHV0T2Zmc2V0XSArIGJpYXNbYmlhc0lkeF07XG4gICAgbGV0IHZhbHVlUmlnaHQgPSBpbnB1dFtpbnB1dE9mZnNldCArIGhhbGZDaGFubmVsc10gKyBiaWFzW2JpYXNJZHggKyBoYWxmQ2hhbm5lbHNdO1xuICAgIGxldCBnZWx1UmlnaHQgPSB2YWx1ZVJpZ2h0ICogMC41ICogKGVyZl92ZjMyKHZhbHVlUmlnaHQgLyBNX1NRUlQyKSArIDEpO1xuXG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWVMZWZ0ICogZ2VsdVJpZ2h0Jyl9XG4gIH1gO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0JpYXNTcGxpdEdlbHUnLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgYmlhc1NwbGl0R2VsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVCaWFzU3BsaXRHZWx1UHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IEJyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxudHlwZSBCdWlsdGluRnVuY3Rpb25OYW1lID0gc3RyaW5nO1xudHlwZSBCaW5hcnlDdXN0b21FeHByZXNzaW9uID0gKGV4cHJlc3Npb25BOiBzdHJpbmcsIGV4cHJlc3Npb25COiBzdHJpbmcpID0+IHN0cmluZztcbnR5cGUgQmluYXJ5RnVuY3Rpb25DYWxsID1cbiAgfCBCdWlsdGluRnVuY3Rpb25OYW1lXG4gIHwgQmluYXJ5Q3VzdG9tRXhwcmVzc2lvblxuICB8IHtcbiAgICAgIHNjYWxhcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcbiAgICAgIHZlY3RvcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVCaW5hcnlPcFByb2dyYW1TaGFkZXIgPSAoXG4gIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLFxuICBkaW1zQTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGRpbXNCOiByZWFkb25seSBudW1iZXJbXSxcbiAgZGltc091dHB1dDogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHZlY3Rvcml6ZTogYm9vbGVhbixcbiAgZG9Ccm9hZGNhc3Q6IGJvb2xlYW4sXG4gIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NDogYm9vbGVhbixcbiAgZnVuY0NhbGw6IEJpbmFyeUZ1bmN0aW9uQ2FsbCxcbiAgdHlwZUE6IG51bWJlcixcbiAgdHlwZUI6IG51bWJlcixcbiAgdHlwZU91dHB1dDogbnVtYmVyLFxuICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24/OiBzdHJpbmcsXG4pID0+IHtcbiAgbGV0IGV4cHJlc3Npb25TY2FsYXI6IEJpbmFyeUN1c3RvbUV4cHJlc3Npb247XG4gIGxldCBleHByZXNzaW9uVmVjdG9yOiBCaW5hcnlDdXN0b21FeHByZXNzaW9uO1xuICBpZiAodHlwZW9mIGZ1bmNDYWxsID09PSAnc3RyaW5nJykge1xuICAgIGV4cHJlc3Npb25TY2FsYXIgPSBleHByZXNzaW9uVmVjdG9yID0gKGEsIGIpID0+IGAke2Z1bmNDYWxsfSgoJHthfSksKCR7Yn0pKWA7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmNDYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXhwcmVzc2lvblNjYWxhciA9IGV4cHJlc3Npb25WZWN0b3IgPSBmdW5jQ2FsbDtcbiAgfSBlbHNlIHtcbiAgICBleHByZXNzaW9uU2NhbGFyID0gZnVuY0NhbGwuc2NhbGFyO1xuICAgIGV4cHJlc3Npb25WZWN0b3IgPSBmdW5jQ2FsbC52ZWN0b3I7XG4gIH1cblxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0RGF0YScsIHR5cGVPdXRwdXQsIGRpbXNPdXRwdXQubGVuZ3RoLCA0KTtcbiAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2FEYXRhJywgdHlwZUEsIGRpbXNBLmxlbmd0aCwgNCk7XG4gIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiRGF0YScsIHR5cGVCLCBkaW1zQi5sZW5ndGgsIDQpO1xuXG4gIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XG4gIGlmICh2ZWN0b3JpemUpIHtcbiAgICBpZiAoZG9Ccm9hZGNhc3QpIHtcbiAgICAgIGNvbnN0IGlzQU9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShkaW1zQSkgPT09IDE7XG4gICAgICBjb25zdCBpc0JPbmVFbGVtZW50ID0gU2hhcGVVdGlsLnNpemUoZGltc0IpID09PSAxO1xuICAgICAgY29uc3QgYUxhc3REaW1EaXZpc2libGVCeTQgPSBkaW1zQS5sZW5ndGggPiAwICYmIGRpbXNBW2RpbXNBLmxlbmd0aCAtIDFdICUgNCA9PT0gMDtcbiAgICAgIGNvbnN0IGJMYXN0RGltRGl2aXNpYmxlQnk0ID0gZGltc0IubGVuZ3RoID4gMCAmJiBkaW1zQltkaW1zQi5sZW5ndGggLSAxXSAlIDQgPT09IDA7XG4gICAgICBpZiAoaXNBT25lRWxlbWVudCB8fCBpc0JPbmVFbGVtZW50KSB7XG4gICAgICAgIGFzc2lnbm1lbnQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoXG4gICAgICAgICAgJ2dsb2JhbF9pZHgnLFxuICAgICAgICAgIGV4cHJlc3Npb25WZWN0b3IoXG4gICAgICAgICAgICBpc0FPbmVFbGVtZW50ID8gYCR7YS50eXBlLnZhbHVlfSgke2EuZ2V0QnlPZmZzZXQoJzAnKX0ueClgIDogYS5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpLFxuICAgICAgICAgICAgaXNCT25lRWxlbWVudCA/IGAke2IudHlwZS52YWx1ZX0oJHtiLmdldEJ5T2Zmc2V0KCcwJyl9LngpYCA6IGIuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4ICogNHUnKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIgPSAke2IuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ291dHB1dEluZGljZXMnLCBvdXRwdXQpfTtcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KFxuICAgICAgICAgICAgICAnZ2xvYmFsX2lkeCcsXG4gICAgICAgICAgICAgIGV4cHJlc3Npb25WZWN0b3IoXG4gICAgICAgICAgICAgICAgc2hhcmVkRGltZW5zaW9uRGl2aXNpYmxlQnk0IHx8IGFMYXN0RGltRGl2aXNpYmxlQnk0XG4gICAgICAgICAgICAgICAgICA/IGEuZ2V0QnlPZmZzZXQoJ29mZnNldEEgLyA0dScpXG4gICAgICAgICAgICAgICAgICA6IGAke2EudHlwZS52YWx1ZX0oJHthLmdldEJ5T2Zmc2V0KCdvZmZzZXRBIC8gNHUnKX1bb2Zmc2V0QSAlIDR1XSlgLFxuICAgICAgICAgICAgICAgIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCB8fCBiTGFzdERpbURpdmlzaWJsZUJ5NFxuICAgICAgICAgICAgICAgICAgPyBiLmdldEJ5T2Zmc2V0KCdvZmZzZXRCIC8gNHUnKVxuICAgICAgICAgICAgICAgICAgOiBgJHtiLnR5cGUudmFsdWV9KCR7Yi5nZXRCeU9mZnNldCgnb2Zmc2V0QiAvIDR1Jyl9W29mZnNldEIgJSA0dV0pYCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWdubWVudCA9IG91dHB1dC5zZXRCeU9mZnNldChcbiAgICAgICAgJ2dsb2JhbF9pZHgnLFxuICAgICAgICBleHByZXNzaW9uVmVjdG9yKGEuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSwgYi5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpKSxcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghZG9Ccm9hZGNhc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiB7XG4gICAgICBjb25zdCBleHByZXNzaW9uQSA9IGBhRGF0YVtpbmRleEEke3h9XVtjb21wb25lbnRBJHt4fV1gO1xuICAgICAgY29uc3QgZXhwcmVzc2lvbkIgPSBgYkRhdGFbaW5kZXhCJHt4fV1bY29tcG9uZW50QiR7eH1dYDtcbiAgICAgIHJldHVybiBgXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7eH11YCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEEke3h9ID0gJHthLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIke3h9ID0gJHtiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IGluZGV4QSR7eH0gPSBvZmZzZXRBJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4QiR7eH0gPSBvZmZzZXRCJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEEke3h9ID0gb2Zmc2V0QSR7eH0gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRCJHt4fSA9IG9mZnNldEIke3h9ICUgNHU7XG4gICAgICAgICAgICAke3Jlc1N0cn1bJHt4fV0gPSAke3R5cGVDYXN0fSgke2V4cHJlc3Npb25TY2FsYXIoZXhwcmVzc2lvbkEsIGV4cHJlc3Npb25CKX0pO1xuICAgICAgICAgIGA7XG4gICAgfTtcbiAgICBpZiAodHlwZU91dHB1dCA9PT0gRGF0YVR5cGUuYm9vbCkge1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMCwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMSwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMiwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMywgJ3UzMicpfVxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXREYXRhW2dsb2JhbF9pZHhdJywgMCl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dERhdGFbZ2xvYmFsX2lkeF0nLCAxKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0RGF0YVtnbG9iYWxfaWR4XScsIDIpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXREYXRhW2dsb2JhbF9pZHhdJywgMyl9XG4gICAgICAgICAgYDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYFxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3ZlY19zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoYSwgYiwgb3V0cHV0KX1cblxuICAgICAgICAke2FkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbiA/PyAnJ31cblxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cbiAgICAgICAgJHthc3NpZ25tZW50fVxuICAgICAgfWA7XG59O1xuXG5jb25zdCBjcmVhdGVCaW5hcnlPcFByb2dyYW1JbmZvID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIGNhY2hlS2V5OiBzdHJpbmcsXG4gIGE6IFRlbnNvclZpZXcsXG4gIGI6IFRlbnNvclZpZXcsXG4gIGZ1bmNDYWxsOiBCaW5hcnlGdW5jdGlvbkNhbGwsXG4gIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyxcbiAgb3V0cHV0RGF0YVR5cGU6IG51bWJlciA9IGEuZGF0YVR5cGUsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGFEaW1zID0gYS5kaW1zLm1hcCgoeCkgPT4gTnVtYmVyKHgpID8/IDEpO1xuICBjb25zdCBiRGltcyA9IGIuZGltcy5tYXAoKHgpID0+IE51bWJlcih4KSA/PyAxKTtcbiAgY29uc3QgaXNCcm9hZGNhc3QgPSAhU2hhcGVVdGlsLmFyZUVxdWFsKGFEaW1zLCBiRGltcyk7XG4gIGxldCBvdXRwdXRTaGFwZSA9IGFEaW1zO1xuICBsZXQgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKGFEaW1zKTtcblxuICBsZXQgdmVjdG9yaXplID0gZmFsc2U7XG4gIGxldCBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQgPSBmYWxzZTtcblxuICAvLyBUT0RPOiBkZWFsIHdpdGggemVyby1zaXplZCB0ZW5zb3JzIChlZy4gZGltcz1bMSwwXSlcbiAgY29uc3QgY2FjaGVLZXlBdXggPSBbaXNCcm9hZGNhc3RdO1xuICBpZiAoaXNCcm9hZGNhc3QpIHtcbiAgICBjb25zdCBjYWxjdWxhdGVkU2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShhRGltcywgYkRpbXMsIGZhbHNlKTtcbiAgICBpZiAoIWNhbGN1bGF0ZWRTaGFwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7XG4gICAgfVxuICAgIG91dHB1dFNoYXBlID0gY2FsY3VsYXRlZFNoYXBlLnNsaWNlKCk7XG4gICAgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBpc0FPbmVFbGVtZW50ID0gU2hhcGVVdGlsLnNpemUoYURpbXMpID09PSAxO1xuICAgIGNvbnN0IGlzQk9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShiRGltcykgPT09IDE7XG4gICAgY29uc3QgYUxhc3REaW1EaXZpc2libGVCeTQgPSBhRGltcy5sZW5ndGggPiAwICYmIGFEaW1zW2FEaW1zLmxlbmd0aCAtIDFdICUgNCA9PT0gMDtcbiAgICBjb25zdCBiTGFzdERpbURpdmlzaWJsZUJ5NCA9IGJEaW1zLmxlbmd0aCA+IDAgJiYgYkRpbXNbYkRpbXMubGVuZ3RoIC0gMV0gJSA0ID09PSAwO1xuICAgIGNhY2hlS2V5QXV4LnB1c2goaXNBT25lRWxlbWVudCk7XG4gICAgY2FjaGVLZXlBdXgucHVzaChpc0JPbmVFbGVtZW50KTtcbiAgICBjYWNoZUtleUF1eC5wdXNoKGFMYXN0RGltRGl2aXNpYmxlQnk0KTtcbiAgICBjYWNoZUtleUF1eC5wdXNoKGJMYXN0RGltRGl2aXNpYmxlQnk0KTtcbiAgICAvLyBjaGVjayB3aGV0aGVyIHZlY3Rvcml6ZSBjYW4gYmUgZW5hYmxlZFxuICAgIGxldCBzaGFyZWREaW1lbnNpb24gPSAxO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb3V0cHV0U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRpbUEgPSBhRGltc1thRGltcy5sZW5ndGggLSBpXTtcbiAgICAgIGNvbnN0IGRpbUIgPSBiRGltc1tiRGltcy5sZW5ndGggLSBpXTtcbiAgICAgIGlmIChkaW1BID09PSBkaW1CKSB7XG4gICAgICAgIHNoYXJlZERpbWVuc2lvbiAqPSBkaW1BO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaGFyZWREaW1lbnNpb24gJSA0ID09PSAwKSB7XG4gICAgICBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQgPSB0cnVlO1xuICAgICAgdmVjdG9yaXplID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQU9uZUVsZW1lbnQgfHwgaXNCT25lRWxlbWVudCB8fCBhTGFzdERpbURpdmlzaWJsZUJ5NCB8fCBiTGFzdERpbURpdmlzaWJsZUJ5NCkge1xuICAgICAgdmVjdG9yaXplID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxlbWVudC13aXNlXG4gICAgdmVjdG9yaXplID0gdHJ1ZTtcbiAgfVxuICBjYWNoZUtleUF1eC5wdXNoKHZlY3Rvcml6ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBjYWNoZUtleSArIGNhY2hlS2V5QXV4Lm1hcCgoeCkgPT4geC50b1N0cmluZygpKS5qb2luKCdfJyksXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJywgJ3JhbmsnXSxcbiAgICB9LFxuICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcikgPT5cbiAgICAgIGNyZWF0ZUJpbmFyeU9wUHJvZ3JhbVNoYWRlcihcbiAgICAgICAgc2hhZGVySGVscGVyLFxuICAgICAgICBhRGltcyxcbiAgICAgICAgYkRpbXMsXG4gICAgICAgIG91dHB1dFNoYXBlLFxuICAgICAgICB2ZWN0b3JpemUsXG4gICAgICAgIGlzQnJvYWRjYXN0LFxuICAgICAgICBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQsXG4gICAgICAgIGZ1bmNDYWxsLFxuICAgICAgICBhLmRhdGFUeXBlLFxuICAgICAgICBiLmRhdGFUeXBlLFxuICAgICAgICBvdXRwdXREYXRhVHlwZSxcbiAgICAgICAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uLFxuICAgICAgKSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyAvIDQgLyogY29tcG9uZW50IHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA0KSB9LFxuICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhhRGltcywgYkRpbXMsIG91dHB1dFNoYXBlKSxcbiAgICAgIF0sXG4gICAgfSksXG4gIH07XG59O1xuXG5jb25zdCBydW5CaW5hcnlPcCA9IChcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVuY0NhbGw6IEJpbmFyeUZ1bmN0aW9uQ2FsbCxcbiAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uPzogc3RyaW5nLFxuICBjYWNoZUtleT86IHN0cmluZyxcbiAgb3V0cHV0RGF0YVR5cGU/OiBudW1iZXIsXG4pOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUJpbmFyeU9wUHJvZ3JhbUluZm8oXG4gICAgICBuYW1lLFxuICAgICAgY2FjaGVLZXkgPz8gJycsXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgIGNvbnRleHQuaW5wdXRzWzFdLFxuICAgICAgZnVuY0NhbGwsXG4gICAgICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24sXG4gICAgICBvdXRwdXREYXRhVHlwZSxcbiAgICApLFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGFkZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChjb250ZXh0LCAnQWRkJywgKGEsIGIpID0+IGAke2F9KyR7Yn1gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBkaXYgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ0RpdicsIChhLCBiKSA9PiBgJHthfS8ke2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZXF1YWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoXG4gICAgY29udGV4dCxcbiAgICAnRXF1YWwnLFxuICAgIHsgc2NhbGFyOiAoYSwgYikgPT4gYHUzMigke2F9PT0ke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGB2ZWM0PHUzMj4oJHthfT09JHtifSlgIH0sXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZCxcbiAgICBEYXRhVHlwZS5ib29sLFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IG11bCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChjb250ZXh0LCAnTXVsJywgKGEsIGIpID0+IGAke2F9KiR7Yn1gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwb3cgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgdHlwZSA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXMpLnR5cGUudmFsdWU7XG4gIGNvbnN0IHJvdW5kU3RyID0gdHlwZSA9PT0gJ2kzMicgPyAncm91bmQnIDogJyc7XG4gIHJ1bkJpbmFyeU9wKFxuICAgIGNvbnRleHQsXG4gICAgJ1BvdycsXG4gICAgeyBzY2FsYXI6IChhLCBiKSA9PiBgcG93X2N1c3RvbSgke2F9LCR7Yn0pYCwgdmVjdG9yOiAoYSwgYikgPT4gYHBvd192ZWN0b3JfY3VzdG9tKCR7YX0sJHtifSlgIH0sXG4gICAgYFxuICAgIGZuIHBvd19jdXN0b20oYSA6ICR7dHlwZX0sIGIgOiAke3R5cGV9KSAtPiAke3R5cGV9IHtcbiAgICAgIGlmIChiID09ICR7dHlwZX0oMC4wKSkge1xuICAgICAgICByZXR1cm4gJHt0eXBlfSgxLjApO1xuICAgICAgfSBlbHNlIGlmIChhIDwgJHt0eXBlfSgwLjApICYmIGYzMihiKSAhPSBmbG9vcihmMzIoYikpKSB7XG4gICAgICAgIHJldHVybiAke3R5cGV9KHBvdyhmMzIoYSksIGYzMihiKSkpOyAvLyBOYU5cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3Qoc2lnbihhKSwgJHt0eXBlfSgxLjApLCByb3VuZChmMzIoYWJzKGIpICUgJHt0eXBlfSgyLjApKSkgIT0gMS4wKSAqICR7dHlwZX0oJHtyb3VuZFN0cn0ocG93KGYzMihhYnMoYSkpLCBmMzIoYikpKSk7XG4gICAgfVxuICAgIGZuIHBvd192ZWN0b3JfY3VzdG9tKGEgOiB2ZWM0PCR7dHlwZX0+LCBiIDogdmVjNDwke3R5cGV9PikgLT4gdmVjNDwke3R5cGV9PiB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdmVjdG9yaXplZCBwb3dcbiAgICAgIHJldHVybiB2ZWM0PCR7dHlwZX0+KHBvd19jdXN0b20oYS54LCBiLngpLCBwb3dfY3VzdG9tKGEueSwgYi55KSwgcG93X2N1c3RvbShhLnosIGIueiksIHBvd19jdXN0b20oYS53LCBiLncpKTtcbiAgICB9XG4gICAgICBgLFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHN1YiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChjb250ZXh0LCAnU3ViJywgKGEsIGIpID0+IGAke2F9LSR7Yn1gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBncmVhdGVyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHJ1bkJpbmFyeU9wKFxuICAgIGNvbnRleHQsXG4gICAgJ0dyZWF0ZXInLFxuICAgIHsgc2NhbGFyOiAoYSwgYikgPT4gYHUzMigke2F9PiR7Yn0pYCwgdmVjdG9yOiAoYSwgYikgPT4gYHZlYzQ8dTMyPigke2F9PiR7Yn0pYCB9LFxuICAgIHVuZGVmaW5lZCxcbiAgICB1bmRlZmluZWQsXG4gICAgRGF0YVR5cGUuYm9vbCxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBsZXNzID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHJ1bkJpbmFyeU9wKFxuICAgIGNvbnRleHQsXG4gICAgJ0xlc3MnLFxuICAgIHsgc2NhbGFyOiAoYSwgYikgPT4gYHUzMigke2F9PCR7Yn0pYCwgdmVjdG9yOiAoYSwgYikgPT4gYHZlYzQ8dTMyPigke2F9PCR7Yn0pYCB9LFxuICAgIHVuZGVmaW5lZCxcbiAgICB1bmRlZmluZWQsXG4gICAgRGF0YVR5cGUuYm9vbCxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBncmVhdGVyT3JFcXVhbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChcbiAgICBjb250ZXh0LFxuICAgICdHcmVhdGVyT3JFcXVhbCcsXG4gICAgeyBzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX0+PSR7Yn0pYCwgdmVjdG9yOiAoYSwgYikgPT4gYHZlYzQ8dTMyPigke2F9Pj0ke2J9KWAgfSxcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkLFxuICAgIERhdGFUeXBlLmJvb2wsXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgbGVzc09yRXF1YWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoXG4gICAgY29udGV4dCxcbiAgICAnTGVzc09yRXF1YWwnLFxuICAgIHsgc2NhbGFyOiAoYSwgYikgPT4gYHUzMigke2F9PD0ke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGB2ZWM0PHUzMj4oJHthfTw9JHtifSlgIH0sXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZCxcbiAgICBEYXRhVHlwZS5ib29sLFxuICApO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29uY2F0QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4aXM6IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF4aXM6IG51bWJlcik6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcbiAgfVxuICBjb25zdCByZWZlcmVuY2VJbmRleCA9IDA7XG4gIGNvbnN0IHJlZmVyZW5jZUlucHV0ID0gaW5wdXRzW3JlZmVyZW5jZUluZGV4XTtcbiAgY29uc3QgaW5wdXRUeXBlID0gcmVmZXJlbmNlSW5wdXQuZGF0YVR5cGU7XG4gIGNvbnN0IGlucHV0UmFuayA9IHJlZmVyZW5jZUlucHV0LmRpbXMubGVuZ3RoO1xuICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGkpID0+IHtcbiAgICBpZiAoaSA9PT0gcmVmZXJlbmNlSW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHR5cGVzIG9mIGFsbCBpbnB1dHMgbWF0Y2hcbiAgICBpZiAoaW5wdXQuZGF0YVR5cGUgIT09IGlucHV0VHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCB0ZW5zb3JzIHNob3VsZCBiZSBvbmUgdHlwZScpO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgdGhlIGRpbWVuc2lvbmFsaXR5IG9mIGFsbCBpbnB1dHMgYXJlIHRoZSBzYW1lXG4gICAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSBpbnB1dFJhbmspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29ycyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzaGFwZScpO1xuICAgIH1cbiAgICBpbnB1dC5kaW1zLmZvckVhY2goKGRpbSwgaSkgPT4ge1xuICAgICAgaWYgKGkgIT09IGF4aXMgJiYgZGltICE9PSByZWZlcmVuY2VJbnB1dC5kaW1zW2ldKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2gnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVJbnB1dEluZGV4SW1wbCA9IChudW1iZXJPZlRlbnNvcnM6IG51bWJlciwgc2l6ZUluQ29uY2F0QXhpc1N0cjogc3RyaW5nKTogc3RyaW5nID0+IGBcbiAgZm4gY2FsY3VsYXRlSW5wdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xuICAgIGxldCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke251bWJlck9mVGVuc29yc311Pigke3NpemVJbkNvbmNhdEF4aXNTdHJ9KTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7bnVtYmVyT2ZUZW5zb3JzfTsgaSArPSAxdSApIHtcbiAgICAgIGlmIChpbmRleCA8IHNpemVJbkNvbmNhdEF4aXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAke251bWJlck9mVGVuc29yc311O1xuICB9YDtcblxuY29uc3QgYXNzaWduT3V0cHV0RGF0YSA9IChpbnB1dHM6IHJlYWRvbmx5IEluZGljZXNIZWxwZXJbXSwgb3V0cHV0OiBJbmRpY2VzSGVscGVyKSA9PiB7XG4gIGNvbnN0IG51bWJlck9mVGVuc29ycyA9IGlucHV0cy5sZW5ndGg7XG5cbiAgY29uc3QgY29kZUxpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mVGVuc29yczsgKytpKSB7XG4gICAgY29uc3QgcmV0dXJuU25pcHBldCA9IG91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGlucHV0c1tpXS5nZXRCeUluZGljZXMoJ2luZGljZXMnKSk7XG4gICAgaWYgKG51bWJlck9mVGVuc29ycyA9PT0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2gocmV0dXJuU25pcHBldCk7XG4gICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChgaWYgKGlucHV0SW5kZXggPT0gJHtpfXUpIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XG4gICAgfSBlbHNlIGlmIChpID09PSBudW1iZXJPZlRlbnNvcnMgLSAxKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChgZWxzZSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlTGluZXMucHVzaChgZWxzZSBpZiAoaW5wdXRJbmRleCA9PSAke2l9KSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29kZUxpbmVzLmpvaW4oJ1xcbicpO1xufTtcblxuY29uc3QgY3JlYXRlQ29uY2F0UHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhZGp1c3RlZEF4aXM6IG51bWJlcixcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdLFxuICBkYXRhVHlwZTogRGF0YVR5cGUsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG5cbiAgY29uc3Qgc2l6ZUluQ29uY2F0QXhpcyA9IG5ldyBBcnJheTxudW1iZXI+KGlucHV0cy5sZW5ndGgpO1xuICBjb25zdCBpbnB1dFZhcnMgPSBuZXcgQXJyYXk8SW5kaWNlc0hlbHBlcj4oaW5wdXRzLmxlbmd0aCk7XG5cbiAgbGV0IHByZXZpb3VzU3VtID0gMDtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbXTtcbiAgY29uc3QgaW5wdXRSYW5rcyA9IFtdO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgcHJldmlvdXNTdW0gKz0gaW5wdXRzW2ldLmRpbXNbYWRqdXN0ZWRBeGlzXTtcbiAgICBzaXplSW5Db25jYXRBeGlzW2ldID0gcHJldmlvdXNTdW07XG4gICAgaW5wdXRSYW5rcy5wdXNoKGlucHV0c1tpXS5kaW1zLmxlbmd0aCk7XG4gICAgaW5wdXRWYXJzW2ldID0gaW5wdXRWYXJpYWJsZShgaW5wdXQke2l9YCwgZGF0YVR5cGUsIGlucHV0UmFua3NbaV0pO1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3JhbmsnKTtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCh7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc2l6ZUluQ29uY2F0QXhpc1tpXSB9KTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1tpXS5kaW1zKSk7XG4gIH1cbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcblxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IGluZGljZXNBeGlzID0gb3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBhZGp1c3RlZEF4aXMpO1xuICBjb25zdCBzaXplSW5Db25jYXRBeGlzU3RyID0gQXJyYXkuZnJvbShBcnJheShzaXplSW5Db25jYXRBeGlzLmxlbmd0aCkua2V5cygpKVxuICAgIC5tYXAoKGkpID0+IGB1bmlmb3Jtcy5zaXplSW5Db25jYXRBeGlzJHtpfWApXG4gICAgLmpvaW4oJywnKTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG5cbiAgJHsoKCkgPT4ge1xuICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oYHNpemVJbkNvbmNhdEF4aXMke2l9YCwgJ3UzMicpO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCBvdXRwdXQpO1xuICB9KSgpfVxuXG4gICR7Y2FsY3VsYXRlSW5wdXRJbmRleEltcGwoc2l6ZUluQ29uY2F0QXhpcy5sZW5ndGgsIHNpemVJbkNvbmNhdEF4aXNTdHIpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgbGV0IGlucHV0SW5kZXggPSBjYWxjdWxhdGVJbnB1dEluZGV4KCR7aW5kaWNlc0F4aXN9KTtcbiAgICBpZiAoaW5wdXRJbmRleCAhPSAwdSkge1xuICAgICAgbGV0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7c2l6ZUluQ29uY2F0QXhpcy5sZW5ndGh9dT4oJHtzaXplSW5Db25jYXRBeGlzU3RyfSk7XG4gICAgICAke2luZGljZXNBeGlzfSAtPSBzaXplSW5Db25jYXRBeGlzW2lucHV0SW5kZXggLSAxdV07XG4gICAgfVxuXG4gICAgJHthc3NpZ25PdXRwdXREYXRhKGlucHV0VmFycywgb3V0cHV0KX1cbiAgfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQ29uY2F0JyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHthZGp1c3RlZEF4aXN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb25jYXQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENvbmNhdEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgaW5wdXRzID0gY29udGV4dC5pbnB1dHM7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgYWRqdXN0ZWRBeGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cywgYWRqdXN0ZWRBeGlzKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKCk7XG4gIG91dHB1dFNoYXBlW2FkanVzdGVkQXhpc10gPSBpbnB1dHMucmVkdWNlKFxuICAgIChzdW0sIGlucHV0KSA9PiBzdW0gKyAoaW5wdXQuZGltcy5sZW5ndGggPiBhZGp1c3RlZEF4aXMgPyBpbnB1dC5kaW1zW2FkanVzdGVkQXhpc10gOiAwKSxcbiAgICAwLFxuICApO1xuICAvLyAwIGxlbmd0aCB0ZW5zb3JzIGFyZSB2YWxpZCBmb3IgY29uY2F0LCByZW1vdmUgdGhlbVxuICBjb25zdCBub25FbXB0eUlucHV0cyA9IGlucHV0cy5maWx0ZXIoKGlucHV0KSA9PiBTaGFwZVV0aWwuc2l6ZShpbnB1dC5kaW1zKSA+IDApO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQ29uY2F0UHJvZ3JhbUluZm8obm9uRW1wdHlJbnB1dHMsIGFkanVzdGVkQXhpcywgb3V0cHV0U2hhcGUsIGlucHV0c1swXS5kYXRhVHlwZSksIHtcbiAgICBpbnB1dHM6IG5vbkVtcHR5SW5wdXRzLFxuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDb25jYXRBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXIgfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgTUFYX0NMSVAsIE1JTl9DTElQIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgVW5pZm9ybXNBcnJheVR5cGUgfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IGFjdGl2YXRpb246IHN0cmluZztcbiAgcmVhZG9ubHkgY2xpcE1pbj86IG51bWJlcjtcbiAgcmVhZG9ubHkgY2xpcE1heD86IG51bWJlcjtcbiAgcmVhZG9ubHkgYWxwaGE/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGJldGE/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRBY3RpdmF0aW9uU25pcHBldCA9IChcbiAgYXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcbiAgdmFsdWVUeXBlOiBzdHJpbmcsXG4gIGJhc2VUeXBlID0gJ2YzMicsXG4pOiBzdHJpbmcgPT4ge1xuICBzd2l0Y2ggKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbikge1xuICAgIGNhc2UgJ1JlbHUnOlxuICAgICAgcmV0dXJuIGB2YWx1ZSA9IG1heCh2YWx1ZSwgJHt2YWx1ZVR5cGV9KDAuMCkpO2A7XG4gICAgY2FzZSAnU2lnbW9pZCc6XG4gICAgICByZXR1cm4gYHZhbHVlID0gKCR7dmFsdWVUeXBlfSgxLjApIC8gKCR7dmFsdWVUeXBlfSgxLjApICsgZXhwKC12YWx1ZSkpKTtgO1xuICAgIGNhc2UgJ0NsaXAnOlxuICAgICAgcmV0dXJuIGB2YWx1ZSA9IGNsYW1wKHZhbHVlLCAke3ZhbHVlVHlwZX0oJHtiYXNlVHlwZX0odW5pZm9ybXMuY2xpcF9taW4pKSwgJHt2YWx1ZVR5cGV9KCR7XG4gICAgICAgIGJhc2VUeXBlXG4gICAgICB9KHVuaWZvcm1zLmNsaXBfbWF4KSkpO2A7XG4gICAgY2FzZSAnSGFyZFNpZ21vaWQnOlxuICAgICAgcmV0dXJuIGB2YWx1ZSA9IG1heCgke3ZhbHVlVHlwZX0oMC4wKSwgbWluKCR7dmFsdWVUeXBlfSgxLjApLCAke2Jhc2VUeXBlfSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSArICR7XG4gICAgICAgIGJhc2VUeXBlXG4gICAgICB9KHVuaWZvcm1zLmJldGEpKSk7YDtcbiAgICBjYXNlICdMZWFreVJlbHUnOlxuICAgICAgcmV0dXJuIGB2YWx1ZSA9IHNlbGVjdCgke2Jhc2VUeXBlfSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSwgdmFsdWUsIHZhbHVlID49ICR7dmFsdWVUeXBlfSgwLjApKTtgO1xuICAgIGNhc2UgJ1RhbmgnOlxuICAgICAgcmV0dXJuIGBsZXQgZTJ4ID0gZXhwKC0yLjAgKiBhYnModmFsdWUpKTtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzaWduKHZhbHVlKSAqICgxLjAgLSBlMngpIC8gKDEuMCArIGUyeCk7XG4gICAgICAgIGA7XG4gICAgY2FzZSAnJzpcbiAgICAgIHJldHVybiAnJztcbiAgICAvLyBUT0RPOiBhZGRpbmcgb3RoZXIgYWN0aXZhdGlvbnMgdGhhdCBjYW4gYmUgZnVzZWQuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWN0aXZhdGlvbiAke2F0dHJpYnV0ZXMuYWN0aXZhdGlvbn1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEgPSAoXG4gIGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG4gIHByb2dyYW1Vbmlmb3JtOiBQcm9ncmFtVW5pZm9ybVtdLFxuKSA9PiB7XG4gIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdDbGlwJykge1xuICAgIHByb2dyYW1Vbmlmb3JtLnB1c2goXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmNsaXBNYXghIH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmNsaXBNaW4hIH0sXG4gICAgKTtcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdIYXJkU2lnbW9pZCcpIHtcbiAgICBwcm9ncmFtVW5pZm9ybS5wdXNoKFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5hbHBoYSEgfSxcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYmV0YSEgfSxcbiAgICApO1xuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbiA9PT0gJ0xlYWt5UmVsdScpIHtcbiAgICBwcm9ncmFtVW5pZm9ybS5wdXNoKHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYWxwaGEhIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zID0gKGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSkgPT4ge1xuICBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnQ2xpcCcpIHtcbiAgICB1bmlmb3Jtcy5wdXNoKHsgbmFtZTogJ2NsaXBfbWF4JywgdHlwZTogJ2YzMicgfSwgeyBuYW1lOiAnY2xpcF9taW4nLCB0eXBlOiAnZjMyJyB9KTtcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdIYXJkU2lnbW9pZCcpIHtcbiAgICB1bmlmb3Jtcy5wdXNoKHsgbmFtZTogJ2FscGhhJywgdHlwZTogJ2YzMicgfSwgeyBuYW1lOiAnYmV0YScsIHR5cGU6ICdmMzInIH0pO1xuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbiA9PT0gJ0xlYWt5UmVsdScpIHtcbiAgICB1bmlmb3Jtcy5wdXNoKHsgbmFtZTogJ2FscGhhJywgdHlwZTogJ2YzMicgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPSAoXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgdW5kZWZpbmVkLFxuKTogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFjdGl2YXRpb24gPSAoYXR0cmlidXRlcz8uYWN0aXZhdGlvbiBhcyBzdHJpbmcpIHx8ICcnO1xuICBpZiAoYWN0aXZhdGlvbiA9PT0gJ0hhcmRTaWdtb2lkJykge1xuICAgIGNvbnN0IFthbHBoYSwgYmV0YV0gPSAoYXR0cmlidXRlcz8uYWN0aXZhdGlvbl9wYXJhbXMgYXMgW251bWJlciwgbnVtYmVyXSkgfHwgWzAuMiwgMC41XTtcbiAgICByZXR1cm4geyBhY3RpdmF0aW9uLCBhbHBoYSwgYmV0YSB9O1xuICB9IGVsc2UgaWYgKGFjdGl2YXRpb24gPT09ICdDbGlwJykge1xuICAgIGNvbnN0IFtjbGlwTWluLCBjbGlwTWF4XSA9IChhdHRyaWJ1dGVzPy5hY3RpdmF0aW9uX3BhcmFtcyBhcyBbbnVtYmVyLCBudW1iZXJdKSB8fCBbTUlOX0NMSVAsIE1BWF9DTElQXTtcbiAgICByZXR1cm4geyBhY3RpdmF0aW9uLCBjbGlwTWF4LCBjbGlwTWluIH07XG4gIH0gZWxzZSBpZiAoYWN0aXZhdGlvbiA9PT0gJ0xlYWt5UmVsdScpIHtcbiAgICBjb25zdCBbYWxwaGFdID0gKGF0dHJpYnV0ZXM/LmFjdGl2YXRpb25fcGFyYW1zIGFzIFtudW1iZXJdKSB8fCBbMC4wMV07XG4gICAgcmV0dXJuIHsgYWN0aXZhdGlvbiwgYWxwaGEgfTtcbiAgfVxuICByZXR1cm4geyBhY3RpdmF0aW9uIH07XG59O1xuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLy8gc2FtcGxlZCBmcm9tIFtAdGVuc29yZmxvdy90ZmpzXSB0ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9hY3RpdmF0aW9uX3V0aWwudHNcbi8vXG4vLyBtb2RpZmllZCB0byBmaXQgdGhlIG5lZWRzIG9mIHRoZSBwcm9qZWN0XG5cbmV4cG9ydCBjb25zdCB0eXBlU25pcHBldCA9IChjb21wb25lbnQ6IG51bWJlciwgZGF0YVR5cGU6IHN0cmluZykgPT4ge1xuICBzd2l0Y2ggKGNvbXBvbmVudCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBkYXRhVHlwZTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gYHZlYzI8JHtkYXRhVHlwZX0+YDtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gYHZlYzM8JHtkYXRhVHlwZX0+YDtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gYHZlYzQ8JHtkYXRhVHlwZX0+YDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbXBvbmVudH0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBiaWFzU25pcHBldCA9IChoYXNCaWFzOiBib29sZWFuKTogc3RyaW5nID0+IGBcbiAgICAgICR7aGFzQmlhcyA/ICd2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3Jkcyk7JyA6ICcnfVxuICAgICAgYDtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1jb3JlL3NyYy9vcHMvY29udl91dGlsLnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5leHBvcnQgY29uc3QgdXRpbEZ1bmN0aW9ucyA9IChzdHJpZGVTdHI6IHN0cmluZykgPT4gYFxuZm4gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmRzIDogdmVjNDxpMzI+LCBzaGFwZSA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcbiAgICAgIHNoYXBlLnkgKiBzaGFwZS56ICogc2hhcGUudywgc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLncsIDEpKTtcbn1cbmZuIGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgaTMyKCR7c3RyaWRlU3RyfS54KSwgaTMyKCR7c3RyaWRlU3RyfS55KSwgaTMyKCR7c3RyaWRlU3RyfS56KSwgMSkpO1xufVxuYDtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRFbGVtZW50QXQsXG4gIGdldE1heENvbXBvbmVudHMsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIGludGVybmFsVmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7XG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyxcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSxcbiAgZ2V0QWN0aXZhdGlvblNuaXBwZXQsXG4gIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG59IGZyb20gJy4vZnVzZS11dGlscyc7XG5cbi8vIEhlbHBlciB0aGF0IGNvbnZlcnQgb3V0cHV0IGJhdGNoIGluZGljZXMgdG8gaW5wdXQgYmF0Y2ggaW5kaWNlcyB1c2luZyBvbmx5IHRoZSByYW5rIGFuZFxuLy8gdGhlIHNoYXBlIGluZm9ybWF0aW9uIGluIHVuaWZvcm1cbmV4cG9ydCBjb25zdCBjb252ZXJ0T3V0cHV0QmF0Y2hJbmRpY2VzVG9JbnB1dEJhdGNoSW5kaWNlcyA9IChcbiAgdGFyZ2V0SW5kaWNlc05hbWU6IHN0cmluZyxcbiAgaW5wdXRWYXJpYWJsZTogSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRCYXRjaFJhbms6IG51bWJlcixcbiAgb3V0cHV0QmF0Y2hSYW5rOiBudW1iZXIsXG4gIGJhdGNoSW5kaWNlc05hbWU6IHN0cmluZyxcbikgPT4ge1xuICAvLyBBc3N1bWUgb3V0cHV0QmF0Y2hSYW5rID49IGlucHV0QmF0Y2hSYW5rLCB0aGUgZmlyc3Qgb3V0cHV0QmF0Y2hSYW5rIC0gaW5wdXRCYXRjaFJhbmsgb2ZcbiAgLy8gb3V0cHV0QmF0Y2hSYW5rIHNob3VsZCBiZSBpZ25vcmVkLlxuICBjb25zdCBleHRlbmRpbmdJbnB1dFJhbmsgPSBvdXRwdXRCYXRjaFJhbmsgLSBpbnB1dEJhdGNoUmFuaztcbiAgcmV0dXJuIGBcbiAgICAgICR7QXJyYXkuZnJvbSh7IGxlbmd0aDogaW5wdXRCYXRjaFJhbmsgfSlcbiAgICAgICAgLm1hcChcbiAgICAgICAgICAoXywgaSkgPT4gYFxuICAgICAgaWYgKCR7Z2V0RWxlbWVudEF0KGlucHV0VmFyaWFibGUuc2hhcGUsIGksIGlucHV0VmFyaWFibGUucmFuayl9ICE9IDEpIHtcbiAgICAgICAgJHtpbnB1dFZhcmlhYmxlLmluZGljZXNTZXQodGFyZ2V0SW5kaWNlc05hbWUsIGksIGdldEVsZW1lbnRBdChiYXRjaEluZGljZXNOYW1lLCBpICsgZXh0ZW5kaW5nSW5wdXRSYW5rLCBvdXRwdXRCYXRjaFJhbmspKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7aW5wdXRWYXJpYWJsZS5pbmRpY2VzU2V0KHRhcmdldEluZGljZXNOYW1lLCBpLCAwKX1cbiAgICAgIH1gLFxuICAgICAgICApXG4gICAgICAgIC5qb2luKCcnKX1cbmA7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTmFpdmVNYXRtdWxQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGFjdGl2YXRpb25BdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHJlc2hhcGVkT3V0cHV0U2hhcGU/OiByZWFkb25seSBudW1iZXJbXSxcbiAgaXNDaGFubmVsc0xhc3QgPSBmYWxzZSAvKiBvbmx5IHVzZWQgZm9yIGNvbnYyZEJ5TWF0TXVsKi8sXG4gIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uPzogKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4gbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGFTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBiU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcblxuICBjb25zdCBNID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAyXTtcbiAgY29uc3QgTiA9IGJTaGFwZVtiU2hhcGUubGVuZ3RoIC0gMV07XG4gIGNvbnN0IEsgPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDFdO1xuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhOKTtcbiAgY29uc3QgYUNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKEspO1xuICBjb25zdCBvdXRwdXROdW1iZXIgPSBnZXRNYXhDb21wb25lbnRzKE0pO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cyAvIG91dHB1dE51bWJlcjtcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICBjb25zdCBvdXRlckRpbXMgPSByZXNoYXBlZE91dHB1dFNoYXBlID8gcmVzaGFwZWRPdXRwdXRTaGFwZS5zbGljZSgwLCAtMikgOiBvdXRwdXRTaGFwZS5zbGljZSgwLCAtMik7XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dGVyRGltcyk7XG4gIGNvbnN0IG91dHB1dFNoYXBlSW5TaGFkZXIgPSBbYmF0Y2hTaXplLCBNLCBOXTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBOIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IEsgfSxcbiAgXTtcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhY3RpdmF0aW9uQXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0ZXJEaW1zLCBhU2hhcGUsIGJTaGFwZSkpO1xuICBpZiAoaGFzQmlhcykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gIH1cbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGVJblNoYWRlcikpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGJhdGNoRGltcyA9IGludGVybmFsVmFyaWFibGUoJ2JhdGNoX2RpbXMnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dGVyRGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBhU2hhcGUubGVuZ3RoLCBhQ29tcG9uZW50cyk7XG4gICAgY29uc3QgYiA9IGlucHV0VmFyaWFibGUoJ2InLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGJTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlSW5TaGFkZXIubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBiYXNlVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShvdXRwdXQudHlwZS50ZW5zb3IpO1xuICAgIGNvbnN0IGFwcGx5QWN0aXZhdGlvbiA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGFjdGl2YXRpb25BdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSwgYmFzZVR5cGUpO1xuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2EsIGJdO1xuICAgIGxldCBwcm9jZXNzQmlhcyA9ICcnO1xuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBjb25zdCBiaWFzQ29tcG9uZW50cyA9IGlzQ2hhbm5lbHNMYXN0ID8gY29tcG9uZW50cyA6IDE7XG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgYmlhc0NvbXBvbmVudHMpKTtcbiAgICAgIHByb2Nlc3NCaWFzID0gYCR7XG4gICAgICAgIGlzQ2hhbm5lbHNMYXN0ID8gYHZhbHVlICs9IGJpYXNbY29sIC8gJHtiaWFzQ29tcG9uZW50c31dO2AgOiBgdmFsdWUgKz0gJHtvdXRwdXQudHlwZS52YWx1ZX0oYmlhc1tyb3cgKyBpXSk7YFxuICAgICAgfWA7XG4gICAgfVxuXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnTScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdOJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGFjdGl2YXRpb25BdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG5cbiAgICBjb25zdCBjYWxjUmVzdWx0ID0gKCk6IHN0cmluZyA9PiB7XG4gICAgICBsZXQgY2FsY1N0ciA9IGB2YXIgYV9kYXRhOiAke2EudHlwZS52YWx1ZX07YDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYUNvbXBvbmVudHM7IGkrKykge1xuICAgICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICAgICAgbGV0IGJfZGF0YSR7aX0gPSBiWyhiX29mZnNldCArIChrICsgJHtpfSkgKiB1bmlmb3Jtcy5OICsgY29sKSAvICR7Y29tcG9uZW50c31dO2A7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dE51bWJlcjsgaSsrKSB7XG4gICAgICAgIGNhbGNTdHIgKz0gYGFfZGF0YSA9IGFbKGFfb2Zmc2V0ICsgKHJvdyArICR7aX0pICogdW5pZm9ybXMuSyArIGspIC8gJHthQ29tcG9uZW50c31dO2A7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhQ29tcG9uZW50czsgaisrKSB7XG4gICAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICB2YWx1ZXNbJHtpfV0gPSBmbWEoJHtiLnR5cGUudmFsdWV9KGFfZGF0YSR7YUNvbXBvbmVudHMgPT09IDEgPyAnJyA6IGBbJHtqfV1gfSksIGJfZGF0YSR7an0sIHZhbHVlc1ske2l9XSk7XFxuYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGNTdHI7XG4gICAgfTtcblxuICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyXG4gICAgLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpXG4gICAgLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoYmF0Y2hEaW1zKVxuICAgIC5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgIGxldCBjb2wgPSAoZ2xvYmFsX2lkeCAlICh1bmlmb3Jtcy5OIC8gJHtjb21wb25lbnRzfSkpICogJHtjb21wb25lbnRzfTtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5OIC8gJHtjb21wb25lbnRzfSk7XG4gICAgbGV0IHN0cmlkZTEgPSB1bmlmb3Jtcy5NIC8gJHtvdXRwdXROdW1iZXJ9O1xuICAgIGxldCByb3cgPSAoaW5kZXgxICUgc3RyaWRlMSkgKiAke291dHB1dE51bWJlcn07XG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gc3RyaWRlMTtcblxuICAgICR7b3V0cHV0U2hhcGUubGVuZ3RoID09PSAyID8gJycgOiBgbGV0IGJhdGNoX2luZGljZXMgPSAke2JhdGNoRGltcy5vZmZzZXRUb0luZGljZXMoJ2JhdGNoJyl9O2B9XG5cbiAgICB2YXIgYV9pbmRpY2VzOiAke2EudHlwZS5pbmRpY2VzfTtcbiAgICAke2NvbnZlcnRPdXRwdXRCYXRjaEluZGljZXNUb0lucHV0QmF0Y2hJbmRpY2VzKCdhX2luZGljZXMnLCBhLCBhLnJhbmsgLSAyLCBiYXRjaERpbXMucmFuaywgJ2JhdGNoX2luZGljZXMnKX1cbiAgICAke2EuaW5kaWNlc1NldCgnYV9pbmRpY2VzJywgYS5yYW5rIC0gMiwgMCl9XG4gICAgJHthLmluZGljZXNTZXQoJ2FfaW5kaWNlcycsIGEucmFuayAtIDEsIDApfVxuICAgIGxldCBhX29mZnNldCA9ICR7YS5pbmRpY2VzVG9PZmZzZXQoJ2FfaW5kaWNlcycpfTtcblxuICAgIHZhciBiX2luZGljZXM6ICR7Yi50eXBlLmluZGljZXN9O1xuICAgICR7Y29udmVydE91dHB1dEJhdGNoSW5kaWNlc1RvSW5wdXRCYXRjaEluZGljZXMoJ2JfaW5kaWNlcycsIGIsIGIucmFuayAtIDIsIGJhdGNoRGltcy5yYW5rLCAnYmF0Y2hfaW5kaWNlcycpfVxuICAgICR7Yi5pbmRpY2VzU2V0KCdiX2luZGljZXMnLCBiLnJhbmsgLSAyLCAwKX1cbiAgICAke2IuaW5kaWNlc1NldCgnYl9pbmRpY2VzJywgYi5yYW5rIC0gMSwgMCl9XG4gICAgbGV0IGJfb2Zmc2V0ID0gJHtiLmluZGljZXNUb09mZnNldCgnYl9pbmRpY2VzJyl9O1xuICAgIHZhciB2YWx1ZXM6IGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke291dHB1dE51bWJlcn0+O1xuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgdW5pZm9ybXMuSzsgayA9IGsgKyAke2FDb21wb25lbnRzfSkge1xuICAgICAgJHtjYWxjUmVzdWx0KCl9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7b3V0cHV0TnVtYmVyfXU7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgJHtwcm9jZXNzQmlhc31cbiAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgbGV0IGN1cl9pbmRpY2VzID0gJHtvdXRwdXQudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93ICsgaSwgY29sKTtcbiAgICAgIGxldCBvZmZzZXQgPSAke291dHB1dC5pbmRpY2VzVG9PZmZzZXQoJ2N1cl9pbmRpY2VzJyl9O1xuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoYG9mZnNldCAvICR7Y29tcG9uZW50c31gLCAndmFsdWUnKX07XG4gICAgfVxuICB9XG4gIGA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ01hdE11bE5haXZlJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbn07JHtjb21wb25lbnRzfTske2FDb21wb25lbnRzfTske291dHB1dE51bWJlcn07JHtpc0NoYW5uZWxzTGFzdH1gLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IGhhc0JpYXMgPyBbJ3JhbmsnLCAncmFuaycsICdyYW5rJ10gOiBbJ3JhbmsnLCAncmFuayddLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvbWF0bXVsX3BhY2tlZF93ZWJncHUudHNcbi8vXG4vLyBtb2RpZmllZCB0byBmaXQgdGhlIG5lZWRzIG9mIHRoZSBwcm9qZWN0XG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFZhcmlhYmxlLFxuICBpbnRlcm5hbFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHtcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zLFxuICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhLFxuICBnZXRBY3RpdmF0aW9uU25pcHBldCxcbiAgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcbn0gZnJvbSAnLi4vZnVzZS11dGlscyc7XG5pbXBvcnQgeyBjb252ZXJ0T3V0cHV0QmF0Y2hJbmRpY2VzVG9JbnB1dEJhdGNoSW5kaWNlcyB9IGZyb20gJy4uL21hdG11bC1zaGFkZXJzJztcblxuaW1wb3J0IHsgdHlwZVNuaXBwZXQgfSBmcm9tICcuL2FjdGl2YXRpb25fdXRpbCc7XG5cbmNvbnN0IHdyaXRlRGF0YVRvU3ViQVZlYzRTbmlwcGV0ID0gKHRyYW5zcG9zZTogYm9vbGVhbiwgYmF0Y2hEaW1zPzogSW5kaWNlc0hlbHBlcikgPT4ge1xuICBpZiAodHJhbnNwb3NlKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgZ2xvYmFsUm93U3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgICBgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGdsb2JhbFJvdyArIGlubmVyUm93LFxuICAgICAgICAgIGtTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XG4gICAgICAgIGA7XG4gIH1cbn07XG5cbmNvbnN0IGNhbGN1bGF0ZVJlc3VsdFNuaXBwZXQgPSAodHJhbnNwb3NlQTogYm9vbGVhbiwgaW5uZXJFbGVtZW50U2l6ZTogbnVtYmVyKSA9PiB7XG4gIGlmICh0cmFuc3Bvc2VBKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgbGV0IEFDYWNoZWQwID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDEgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDIgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bbG9jYWxSb3ddO1xuICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdsZXQgQUNhY2hlZDMgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bbG9jYWxSb3ddOyd9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQwW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZDFbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkMltpXSArIGFjY1tpXTtcbiAgICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQzW2ldICsgYWNjW2ldOyd9XG4gICAgICAgIH1gO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGldW2tdO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZC54ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZC55ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZC56ICsgYWNjW2ldO1xuICAgICAgICAgICR7aW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/ICcnIDogJ2FjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZC53ICsgYWNjW2ldOyd9XG4gICAgICAgIH1gO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgbWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2UgPSAoXG4gIHdvcmtQZXJUaHJlYWQ6IG51bWJlcltdLFxuICB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIHR5cGUgPSAnZjMyJyxcbiAgYmF0Y2hEaW1zPzogSW5kaWNlc0hlbHBlcixcbiAgdHJhbnNwb3NlQSA9IGZhbHNlLFxuICB0aWxlSW5uZXIgPSAzMixcbiAgc3BsaXRLID0gZmFsc2UsXG4gIHNwbGl0ZWREaW1Jbm5lciA9IDMyLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgdGlsZUFPdXRlciA9IHdvcmtncm91cFNpemVbMV0gKiB3b3JrUGVyVGhyZWFkWzFdO1xuICBjb25zdCB0aWxlQk91dGVyID0gd29ya2dyb3VwU2l6ZVswXSAqIHdvcmtQZXJUaHJlYWRbMF07XG4gIGNvbnN0IHRpbGVBV2lkdGggPSB0cmFuc3Bvc2VBID8gdGlsZUFPdXRlciA6IHRpbGVJbm5lcjtcbiAgY29uc3QgdGlsZUFIaWdodCA9IHRyYW5zcG9zZUEgPyB0aWxlSW5uZXIgOiB0aWxlQU91dGVyO1xuICBjb25zdCBpbm5lckVsZW1lbnRTaXplID0gdGlsZUFXaWR0aCAvIHdvcmtncm91cFNpemVbMF07XG4gIGNvbnN0IHJvd1BlclRocmVhZEIgPSB0aWxlSW5uZXIgLyB3b3JrZ3JvdXBTaXplWzFdO1xuXG4gIGlmIChcbiAgICAhKFxuICAgICAgKCh0cmFuc3Bvc2VBICYmIGlubmVyRWxlbWVudFNpemUgPT09IDQgJiYgd29ya1BlclRocmVhZFsxXSA9PT0gNCkgfHxcbiAgICAgICAgKCF0cmFuc3Bvc2VBICYmIChpbm5lckVsZW1lbnRTaXplID09PSAzIHx8IGlubmVyRWxlbWVudFNpemUgPT09IDQpKSkgJiZcbiAgICAgIHRpbGVBV2lkdGggJSB3b3JrZ3JvdXBTaXplWzBdID09PSAwICYmXG4gICAgICB0aWxlSW5uZXIgJSB3b3JrZ3JvdXBTaXplWzFdID09PSAwICYmXG4gICAgICB3b3JrUGVyVGhyZWFkWzBdID09PSA0XG4gICAgKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYElmIHRyYW5zcG9zZUEgJHt0cmFuc3Bvc2VBfSBpcyB0cnVlLCBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gYW5kIHdvcmtQZXJUaHJlYWRbMV0gJHt3b3JrUGVyVGhyZWFkWzFdfSBtdXN0IGJlIDQuXG4gICAgICBPdGhlcndpc2UsIGlubmVyRWxlbWVudFNpemUgJHtpbm5lckVsZW1lbnRTaXplfSBtdXN0IGJlIDMgb3IgNC5cbiAgdGlsZUFXaWR0aCAke3RpbGVBV2lkdGh9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3dvcmtncm91cFNpemVbMF19LiB0aWxlSW5uZXIgJHt0aWxlSW5uZXJ9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0gJHt3b3JrZ3JvdXBTaXplWzFdfS4gY29sUGVyVGhyZWFkICR7d29ya1BlclRocmVhZFswXX0gbXVzdCBiZSA0LmApO1xuICB9XG4gIHJldHVybiBgXG52YXI8d29ya2dyb3VwPiBtbV9Bc3ViOiBhcnJheTxhcnJheTx2ZWMke2lubmVyRWxlbWVudFNpemV9PCR7dHlwZX0+LCAke3RpbGVBV2lkdGggLyBpbm5lckVsZW1lbnRTaXplfT4sICR7dGlsZUFIaWdodH0+O1xudmFyPHdvcmtncm91cD4gbW1fQnN1YjogYXJyYXk8YXJyYXk8dmVjNDwke3R5cGV9PiwgJHt0aWxlQk91dGVyIC8gd29ya1BlclRocmVhZFswXX0+LCAke3RpbGVJbm5lcn0+O1xuXG5jb25zdCByb3dQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMV19O1xuY29uc3QgY29sUGVyVGhyZWFkID0gJHt3b3JrUGVyVGhyZWFkWzBdfTtcbmNvbnN0IGlubmVyRWxlbWVudFNpemUgPSAke2lubmVyRWxlbWVudFNpemV9O1xuY29uc3QgdGlsZUlubmVyID0gJHt0aWxlSW5uZXJ9O1xuXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt3b3JrZ3JvdXBTaXplWzBdfSwgJHt3b3JrZ3JvdXBTaXplWzFdfSwgJHt3b3JrZ3JvdXBTaXplWzJdfSlcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XG4gIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICBsZXQgdGlsZVJvdyA9IGxvY2FsUm93ICogcm93UGVyVGhyZWFkO1xuICBsZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpO1xuXG4gIGxldCBnbG9iYWxSb3cgPWkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbiAgbGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KTtcbiAgbGV0IGJhdGNoID0gJHtzcGxpdEsgPyAnMCcgOiAnaTMyKGdsb2JhbElkLnopJ307XG4gICR7YmF0Y2hEaW1zID8gYGxldCBiYXRjaEluZGljZXMgPSAke2JhdGNoRGltcy5vZmZzZXRUb0luZGljZXMoJ3UzMihiYXRjaCknKX07YCA6ICcnfVxuICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3RpbGVBT3V0ZXJ9O1xuXG4gIGxldCBudW1fdGlsZXMgPSAke3NwbGl0SyA/IGAke01hdGguY2VpbChzcGxpdGVkRGltSW5uZXIgLyB0aWxlSW5uZXIpfWAgOiAnKHVuaWZvcm1zLmRpbV9pbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMSd9O1xuICB2YXIga1N0YXJ0ID0gJHtzcGxpdEsgPyBgaTMyKGdsb2JhbElkLnopICogJHtzcGxpdGVkRGltSW5uZXJ9YCA6ICcwJ307XG5cbiAgdmFyIGFjYzogYXJyYXk8dmVjNDwke3R5cGV9Piwgcm93UGVyVGhyZWFkPjtcblxuICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgbGV0IHRpbGVSb3dCID0gbG9jYWxSb3cgKiAke3Jvd1BlclRocmVhZEJ9O1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3cgKyBpbm5lclJvdztcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xuICAgICAgICAgICR7d3JpdGVEYXRhVG9TdWJBVmVjNFNuaXBwZXQodHJhbnNwb3NlQSwgYmF0Y2hEaW1zKX1cbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7cm93UGVyVGhyZWFkQn07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLCBrU3RhcnQgKyBpbnB1dFJvdywgZ2xvYmFsQ29sJHtcbiAgICAgICAgICAgIGJhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyIC8gaW5uZXJFbGVtZW50U2l6ZTsgayA9IGsgKyAxKSB7XG4gICAgICAgICAgbGV0IEJDYWNoZWQwID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQxID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMiA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVt0aWxlQ29sXTtcbiAgICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdsZXQgQkNhY2hlZDMgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bdGlsZUNvbF07J31cblxuICAgICAgICAgICR7Y2FsY3VsYXRlUmVzdWx0U25pcHBldCh0cmFuc3Bvc2VBLCBpbm5lckVsZW1lbnRTaXplKX1cbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICB9XG5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sLCBhY2NbaW5uZXJSb3ddKTtcbiAgfVxufWA7XG59O1xuXG5jb25zdCB3cml0ZURhdGFUb1N1YkFTbmlwcGV0ID0gKHRyYW5zcG9zZTogYm9vbGVhbiwgYmF0Y2hEaW1zPzogSW5kaWNlc0hlbHBlcikgPT4ge1xuICBpZiAodHJhbnNwb3NlKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XG4gICAgICAgICAgICBgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgICAgICAgYDtcbiAgfVxufTtcblxuY29uc3QgcmVhZERhdGFGcm9tU3ViQVNuaXBwZXQgPSAodHJhbnNwb3NlQTogYm9vbGVhbikgPT5cbiAgdHJhbnNwb3NlQSA/ICdsZXQgQUNhY2hlZCA9IG1tX0FzdWJba11bdGlsZVJvdyArIGlubmVyUm93XTsnIDogJ2xldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaW5uZXJSb3ddW2tdOyc7XG5cbi8vIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMgbWVhbnMgc2VxdWVudGlhbCBkYXRhIGluIG1lbW9yeSBpcyBhY2Nlc3NlZCBieVxuLy8gdGhyZWFkcywgaW5zdGVhZCBvZiBhIHNpbmdsZSB0aHJlYWQgKGRlZmF1bHQgYmVoYXZpb3IpLlxuZXhwb3J0IGNvbnN0IG1ha2VNYXRNdWxQYWNrZWRTb3VyY2UgPSAoXG4gIHdvcmtQZXJUaHJlYWQ6IG51bWJlcltdLFxuICB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIHR5cGUgPSAnZjMyJyxcbiAgYmF0Y2hEaW1zPzogSW5kaWNlc0hlbHBlcixcbiAgdHJhbnNwb3NlQSA9IGZhbHNlLFxuICB0aWxlSW5uZXIgPSAzMixcbiAgc3BsaXRLID0gZmFsc2UsXG4gIHNwbGl0ZWREaW1Jbm5lciA9IDMyLFxuICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzID0gZmFsc2UsXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCB0aWxlQU91dGVyID0gd29ya1BlclRocmVhZFsxXSAqIHdvcmtncm91cFNpemVbMV07XG4gIGNvbnN0IHRpbGVCT3V0ZXIgPSB3b3JrUGVyVGhyZWFkWzBdICogd29ya2dyb3VwU2l6ZVswXTtcbiAgY29uc3QgdGlsZUFXaWR0aCA9IHRyYW5zcG9zZUEgPyB0aWxlQU91dGVyIDogdGlsZUlubmVyO1xuICBjb25zdCB0aWxlQUhpZ2h0ID0gdHJhbnNwb3NlQSA/IHRpbGVJbm5lciA6IHRpbGVBT3V0ZXI7XG5cbiAgaWYgKFxuICAgICEodGlsZUFIaWdodCAlIHdvcmtncm91cFNpemVbMV0gPT09IDAgJiYgdGlsZUFXaWR0aCAlIHdvcmtncm91cFNpemVbMF0gPT09IDAgJiYgdGlsZUlubmVyICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMClcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHRpbGVBSGlnaHQgJHt0aWxlQUhpZ2h0fSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt3b3JrZ3JvdXBTaXplWzFdfSwgdGlsZUFXaWR0aCAke3RpbGVBV2lkdGh9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3dvcmtncm91cFNpemVbMF19LCB0aWxlSW5uZXIgJHt0aWxlSW5uZXJ9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3dvcmtncm91cFNpemVbMV19YCxcbiAgICApO1xuICB9XG4gIGNvbnN0IHJvd1BlclRocmVhZEEgPSB0aWxlQUhpZ2h0IC8gd29ya2dyb3VwU2l6ZVsxXTtcbiAgY29uc3QgY29sUGVyVGhyZWFkQSA9IHRpbGVBV2lkdGggLyB3b3JrZ3JvdXBTaXplWzBdO1xuICBjb25zdCByb3dQZXJUaHJlYWRCID0gdGlsZUlubmVyIC8gd29ya2dyb3VwU2l6ZVsxXTtcbiAgY29uc3QgbWF0bXVsU25pcHBldCA9IHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHNcbiAgICA/IGBcbiAgICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgICBsZXQgbG9jYWxDb2wgPSBpMzIobG9jYWxJZC54KTtcbiAgICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3RpbGVBT3V0ZXJ9O1xuICAgIGxldCBnbG9iYWxDb2xTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC54KSAqICR7dGlsZUJPdXRlcn07XG5cbiAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7dGlsZUFIaWdodH07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3dvcmtncm91cFNpemVbMV19KSB7XG4gICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHt0aWxlQVdpZHRofTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7d29ya2dyb3VwU2l6ZVswXX0pIHtcbiAgICAgICAgICAke3dyaXRlRGF0YVRvU3ViQVNuaXBwZXQodHJhbnNwb3NlQSwgYmF0Y2hEaW1zKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke3RpbGVJbm5lcn07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3dvcmtncm91cFNpemVbMV19KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7dGlsZUJPdXRlcn07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3dvcmtncm91cFNpemVbMF19KSB7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgIGdsb2JhbENvbFN0YXJ0ICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3R5cGV9LCBjb2xQZXJUaHJlYWQ+O1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgICAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVtsb2NhbENvbCArIGlubmVyICogJHt3b3JrZ3JvdXBTaXplWzBdfV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9ICR7XG4gICAgICAgICAgICB0cmFuc3Bvc2VBXG4gICAgICAgICAgICAgID8gYG1tX0FzdWJba11bbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7d29ya2dyb3VwU2l6ZVsxXX1dO2BcbiAgICAgICAgICAgICAgOiBgbW1fQXN1Yltsb2NhbFJvdyArIGlubmVyUm93ICogJHt3b3JrZ3JvdXBTaXplWzFdfV1ba107YFxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArXG4gICAgICAgICAgICAgICAgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbGV0IGdSb3cgPSBnbG9iYWxSb3dTdGFydCArIGxvY2FsUm93ICsgaW5uZXJSb3cgKiAke3dvcmtncm91cFNpemVbMV19O1xuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgbGV0IGdDb2wgPSBnbG9iYWxDb2xTdGFydCArIGxvY2FsQ29sICsgaW5uZXJDb2wgKiAke3dvcmtncm91cFNpemVbMF19O1xuICAgICAgICBtbV93cml0ZShiYXRjaCwgZ1JvdywgZ0NvbCwgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBgXG4gICAgOiBgXG5sZXQgdGlsZVJvdyA9IGkzMihsb2NhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KSAqIGNvbFBlclRocmVhZDtcblxubGV0IGdsb2JhbFJvdyA9IGkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbmxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XG5sZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3RpbGVBT3V0ZXJ9O1xuXG5sZXQgdGlsZVJvd0EgPSBpMzIobG9jYWxJZC55KSAqICR7cm93UGVyVGhyZWFkQX07XG5sZXQgdGlsZUNvbEEgPSBpMzIobG9jYWxJZC54KSAqICR7Y29sUGVyVGhyZWFkQX07XG5sZXQgdGlsZVJvd0IgPSBpMzIobG9jYWxJZC55KSAqICR7cm93UGVyVGhyZWFkQn07XG4vLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbmZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtyb3dQZXJUaHJlYWRBfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgJHtjb2xQZXJUaHJlYWRBfTsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dBICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sQSArIGlubmVyQ29sO1xuICAgICAgJHt3cml0ZURhdGFUb1N1YkFTbmlwcGV0KHRyYW5zcG9zZUEsIGJhdGNoRGltcyl9XG4gICAgfVxuICB9XG5cbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtyb3dQZXJUaHJlYWRCfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2wgKyBpbm5lckNvbDtcbiAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxuICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgZ2xvYmFsQ29sICsgaW5uZXJDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgIH1cbiAgfVxuICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3R5cGV9LCBjb2xQZXJUaHJlYWQ+O1xuICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVt0aWxlQ29sICsgaW5uZXJdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAke3JlYWREYXRhRnJvbVN1YkFTbmlwcGV0KHRyYW5zcG9zZUEpfVxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG59XG5cbmZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wgKyBpbm5lckNvbCxcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICB9XG59XG5gO1xuXG4gIHJldHVybiBgXG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0FzdWIgOiBhcnJheTxhcnJheTwke3R5cGV9LCAke3RpbGVBV2lkdGh9PiwgJHt0aWxlQUhpZ2h0fT47XG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0JzdWIgOiBhcnJheTxhcnJheTwke3R5cGV9LCAke3RpbGVCT3V0ZXJ9PiwgJHt0aWxlSW5uZXJ9PjtcbiAgY29uc3Qgcm93UGVyVGhyZWFkID0gJHt3b3JrUGVyVGhyZWFkWzFdfTtcbiAgY29uc3QgY29sUGVyVGhyZWFkID0gJHt3b3JrUGVyVGhyZWFkWzBdfTtcbiAgY29uc3QgdGlsZUlubmVyID0gJHt0aWxlSW5uZXJ9O1xuXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt3b3JrZ3JvdXBTaXplWzBdfSwgJHt3b3JrZ3JvdXBTaXplWzFdfSwgJHt3b3JrZ3JvdXBTaXplWzJdfSlcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XG4gICAgbGV0IGJhdGNoID0gJHtzcGxpdEsgPyAnMCcgOiAnaTMyKGdsb2JhbElkLnopJ307XG4gICAgJHtiYXRjaERpbXMgPyBgbGV0IGJhdGNoSW5kaWNlcyA9ICR7YmF0Y2hEaW1zLm9mZnNldFRvSW5kaWNlcygndTMyKGJhdGNoKScpfTtgIDogJyd9XG4gICAgbGV0IG51bV90aWxlcyA9ICR7XG4gICAgICBzcGxpdEsgPyBgJHtNYXRoLmNlaWwoc3BsaXRlZERpbUlubmVyIC8gdGlsZUlubmVyKX1gIDogJyh1bmlmb3Jtcy5kaW1faW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDEnXG4gICAgfTtcbiAgICB2YXIga1N0YXJ0ID0gJHtzcGxpdEsgPyBgaTMyKGdsb2JhbElkLnopICogJHtzcGxpdGVkRGltSW5uZXJ9YCA6ICcwJ307XG5cbiAgICB2YXIgYWNjIDogYXJyYXk8YXJyYXk8JHt0eXBlfSwgY29sUGVyVGhyZWFkPiwgcm93UGVyVGhyZWFkPjtcbiAgICAke21hdG11bFNuaXBwZXR9XG4gIH1cbmA7XG59O1xuXG5jb25zdCBtYXRNdWxSZWFkV3JpdGVGblNvdXJjZSA9IChcbiAgY29tcG9uZW50OiBudW1iZXIsXG4gIGhhc0JpYXM6IGJvb2xlYW4sXG4gIGFwcGx5QWN0aXZhdGlvbjogc3RyaW5nLFxuICB2YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSxcbiAgaXNDaGFubmVsc0xhc3QgPSBmYWxzZSxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IFtiYXRjaFZhcmlhYmxlLCBhVmFyaWFibGUsIGJWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGVdID0gdmFyaWFibGVzO1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSh2YXJpYWJsZXNbMF0udHlwZS50ZW5zb3IpO1xuXG4gIGNvbnN0IHNvdXJjZSA9IGBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2JhdGNoVmFyaWFibGUudHlwZS5pbmRpY2VzfSkgLT4gJHt0eXBlU25pcHBldChcbiAgICAgIGNvbXBvbmVudCxcbiAgICAgIGRhdGFUeXBlLFxuICAgICl9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7dHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2NvbXBvbmVudH07XG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1faW5uZXIpXG4gICAgICB7XG4gICAgICAgIHZhciBhSW5kaWNlczogJHthVmFyaWFibGUudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHtjb252ZXJ0T3V0cHV0QmF0Y2hJbmRpY2VzVG9JbnB1dEJhdGNoSW5kaWNlcyhcbiAgICAgICAgICAnYUluZGljZXMnLFxuICAgICAgICAgIGFWYXJpYWJsZSxcbiAgICAgICAgICBhVmFyaWFibGUucmFuayAtIDIsXG4gICAgICAgICAgYmF0Y2hWYXJpYWJsZS5yYW5rLFxuICAgICAgICAgICdiYXRjaEluZGljZXMnLFxuICAgICAgICApfVxuICAgICAgICAke2FWYXJpYWJsZS5pbmRpY2VzU2V0KCdhSW5kaWNlcycsIGFWYXJpYWJsZS5yYW5rIC0gMiwgJ3UzMihyb3cpJyl9XG4gICAgICAgICR7YVZhcmlhYmxlLmluZGljZXNTZXQoJ2FJbmRpY2VzJywgYVZhcmlhYmxlLnJhbmsgLSAxLCAndTMyKGNvbEluKScpfVxuICAgICAgICB2YWx1ZSA9ICR7YVZhcmlhYmxlLmdldEJ5SW5kaWNlcygnYUluZGljZXMnKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHtiYXRjaFZhcmlhYmxlLnR5cGUuaW5kaWNlc30pIC0+ICR7dHlwZVNuaXBwZXQoXG4gICAgICBjb21wb25lbnQsXG4gICAgICBkYXRhVHlwZSxcbiAgICApfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke3R5cGVTbmlwcGV0KGNvbXBvbmVudCwgZGF0YVR5cGUpfSgwLjApO1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtjb21wb25lbnR9O1xuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKVxuICAgICAge1xuICAgICAgICB2YXIgYkluZGljZXM6ICR7YlZhcmlhYmxlLnR5cGUuaW5kaWNlc307XG4gICAgICAgICR7Y29udmVydE91dHB1dEJhdGNoSW5kaWNlc1RvSW5wdXRCYXRjaEluZGljZXMoXG4gICAgICAgICAgJ2JJbmRpY2VzJyxcbiAgICAgICAgICBiVmFyaWFibGUsXG4gICAgICAgICAgYlZhcmlhYmxlLnJhbmsgLSAyLFxuICAgICAgICAgIGJhdGNoVmFyaWFibGUucmFuayxcbiAgICAgICAgICAnYmF0Y2hJbmRpY2VzJyxcbiAgICAgICAgKX1cbiAgICAgICAgJHtiVmFyaWFibGUuaW5kaWNlc1NldCgnYkluZGljZXMnLCBiVmFyaWFibGUucmFuayAtIDIsICd1MzIocm93KScpfVxuICAgICAgICAke2JWYXJpYWJsZS5pbmRpY2VzU2V0KCdiSW5kaWNlcycsIGJWYXJpYWJsZS5yYW5rIC0gMSwgJ3UzMihjb2xJbiknKX1cbiAgICAgICAgdmFsdWUgPSAke2JWYXJpYWJsZS5nZXRCeUluZGljZXMoJ2JJbmRpY2VzJyl9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCB2YWx1ZUluOiAke3R5cGVTbmlwcGV0KGNvbXBvbmVudCwgZGF0YVR5cGUpfSkge1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtjb21wb25lbnR9O1xuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICAgIGxldCBjb29yZHMgPSB2ZWMzPGkzMj4oYmF0Y2gsIHJvdywgY29sSW4pO1xuICAgICAgICAke1xuICAgICAgICAgIGhhc0JpYXNcbiAgICAgICAgICAgID8gYHZhbHVlID0gdmFsdWUgKyAke2lzQ2hhbm5lbHNMYXN0ID8gJ2JpYXNbY29sSW5dJyA6IGAke3R5cGVTbmlwcGV0KGNvbXBvbmVudCwgZGF0YVR5cGUpfShiaWFzW3Jvd10pYH07YFxuICAgICAgICAgICAgOiAnJ1xuICAgICAgICB9XG4gICAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgICAke291dHB1dFZhcmlhYmxlLnNldEJ5SW5kaWNlcygndmVjMzx1MzI+KGNvb3JkcyknLCAndmFsdWUnKX1cbiAgICAgIH1cbiAgICB9XG4gICAgYDtcbiAgcmV0dXJuIHNvdXJjZTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVNYXRtdWxQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGFjdGl2YXRpb25BdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHJlc2hhcGVkT3V0cHV0U2hhcGU/OiByZWFkb25seSBudW1iZXJbXSxcbiAgaXNDaGFubmVsc0xhc3QgPSBmYWxzZSAvKiBvbmx5IHVzZWQgZm9yIGNvbnYyZEJ5TWF0TXVsKi8sXG4gIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uPzogKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4gbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGFTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBiU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3Qgb3V0ZXJEaW1zQSA9IGFTaGFwZS5zbGljZSgwLCAtMik7XG4gIGNvbnN0IG91dGVyRGltc0IgPSBiU2hhcGUuc2xpY2UoMCwgLTIpO1xuICBjb25zdCBvdXRlckRpbXMgPSByZXNoYXBlZE91dHB1dFNoYXBlID8gcmVzaGFwZWRPdXRwdXRTaGFwZS5zbGljZSgwLCAtMikgOiBvdXRwdXRTaGFwZS5zbGljZSgwLCAtMik7XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dGVyRGltcyk7XG4gIGNvbnN0IGRpbUFPdXRlciA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMl07XG4gIGNvbnN0IGRpbUlubmVyID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAxXTtcbiAgY29uc3QgZGltQk91dGVyID0gYlNoYXBlW2JTaGFwZS5sZW5ndGggLSAxXTtcbiAgY29uc3QgaXNWZWM0ID0gZGltSW5uZXIgJSA0ID09PSAwICYmIGRpbUJPdXRlciAlIDQgPT09IDA7XG5cbiAgLy8gVE9ETzogZmluZSB0dW5lIHNpemVcbiAgY29uc3QgZWxlbWVudHNQZXJUaHJlYWQgPSBkaW1BT3V0ZXIgPD0gOCA/IFs0LCAxLCAxXSA6IFs0LCA0LCAxXTtcbiAgY29uc3Qgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzgsIDgsIDFdO1xuICBjb25zdCBkaXNwYXRjaCA9IFtcbiAgICBNYXRoLmNlaWwoZGltQk91dGVyIC8gd29ya2dyb3VwU2l6ZVswXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzBdKSxcbiAgICBNYXRoLmNlaWwoZGltQU91dGVyIC8gd29ya2dyb3VwU2l6ZVsxXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzFdKSxcbiAgICBNYXRoLmNlaWwoYmF0Y2hTaXplIC8gd29ya2dyb3VwU2l6ZVsyXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzJdKSxcbiAgXTtcblxuICBjb25zdCBjb21wb25lbnRzID0gaXNWZWM0ID8gNCA6IDE7XG4gIGNvbnN0IGFTaGFwZVRlbXAgPSBbLi4ub3V0ZXJEaW1zQSwgZGltQU91dGVyLCBkaW1Jbm5lciAvIGNvbXBvbmVudHNdO1xuICBjb25zdCBhUmFuayA9IGFTaGFwZVRlbXAubGVuZ3RoO1xuICBjb25zdCBiU2hhcGVUZW1wID0gWy4uLm91dGVyRGltc0IsIGRpbUlubmVyLCBkaW1CT3V0ZXIgLyBjb21wb25lbnRzXTtcbiAgY29uc3QgYlJhbmsgPSBiU2hhcGVUZW1wLmxlbmd0aDtcbiAgY29uc3Qgb3V0cHV0U2hhcGVUZW1wID0gW2JhdGNoU2l6ZSwgZGltQU91dGVyLCBkaW1CT3V0ZXIgLyBjb21wb25lbnRzXTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUFPdXRlciB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUJPdXRlciB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUlubmVyIH0sXG4gIF07XG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3Jtcyk7XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dGVyRGltcywgYVNoYXBlVGVtcCwgYlNoYXBlVGVtcCkpO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG5cbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICBpZiAoaGFzQmlhcykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlVGVtcCkpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGJhdGNoUmFuayA9IG91dGVyRGltcy5sZW5ndGg7XG4gICAgY29uc3QgYmF0Y2hEaW1zID0gaW50ZXJuYWxWYXJpYWJsZSgnYmF0Y2hEaW1zJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBiYXRjaFJhbmssIDEpO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG5cbiAgICBjb25zdCBBID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0c1swXS5kYXRhVHlwZSwgYVJhbmssIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IEIgPSBpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBiUmFuaywgY29tcG9uZW50cyk7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGVUZW1wLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbQSwgQl07XG4gICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgIGNvbnN0IGJpYXNDb21wb25lbnRzID0gaXNDaGFubmVsc0xhc3QgPyBjb21wb25lbnRzIDogMTtcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoLCBiaWFzQ29tcG9uZW50cykpO1xuICAgIH1cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdkaW1fYV9vdXRlcicsIHR5cGU6ICdpMzInIH0sXG4gICAgICB7IG5hbWU6ICdkaW1fYl9vdXRlcicsIHR5cGU6ICdpMzInIH0sXG4gICAgICB7IG5hbWU6ICdkaW1faW5uZXInLCB0eXBlOiAnaTMyJyB9LFxuICAgIF07XG4gICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGFjdGl2YXRpb25BdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG4gICAgY29uc3QgYmFzZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUob3V0cHV0LnR5cGUudGVuc29yKTtcbiAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhY3RpdmF0aW9uQXR0cmlidXRlcywgb3V0cHV0LnR5cGUudmFsdWUsIGJhc2VUeXBlKTtcbiAgICBjb25zdCBkZWNsYXJlRnVuY3Rpb25zID0gbWF0TXVsUmVhZFdyaXRlRm5Tb3VyY2UoXG4gICAgICBjb21wb25lbnRzLFxuICAgICAgaGFzQmlhcyxcbiAgICAgIGFwcGx5QWN0aXZhdGlvbixcbiAgICAgIFtiYXRjaERpbXMsIEEsIEIsIG91dHB1dF0sXG4gICAgICBpc0NoYW5uZWxzTGFzdCxcbiAgICApO1xuICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyXG4gICAgLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpXG4gICAgLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoYmF0Y2hEaW1zKVxuICAgIC5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAke2RlY2xhcmVGdW5jdGlvbnN9XG4gICR7XG4gICAgaXNWZWM0XG4gICAgICA/IG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlKGVsZW1lbnRzUGVyVGhyZWFkLCB3b3JrZ3JvdXBTaXplLCBkYXRhVHlwZSwgYmF0Y2hEaW1zKVxuICAgICAgOiBtYWtlTWF0TXVsUGFja2VkU291cmNlKGVsZW1lbnRzUGVyVGhyZWFkLCB3b3JrZ3JvdXBTaXplLCBkYXRhVHlwZSwgYmF0Y2hEaW1zKVxuICB9XG4gICAgICAgICAgICAgICAgICAgYDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnTWF0TXVsJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7ZWxlbWVudHNQZXJUaHJlYWR9OyR7YWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbn07JHtpc1ZlYzR9OyR7aXNDaGFubmVsc0xhc3R9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IGRpc3BhdGNoWzBdLCB5OiBkaXNwYXRjaFsxXSwgejogZGlzcGF0Y2hbMl0gfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLy8gc2FtcGxlZCBmcm9tIFtAdGVuc29yZmxvdy90ZmpzXSB0ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9jb252MmRfbW1fd2ViZ3B1LnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IExPR19ERUJVRyB9IGZyb20gJy4uLy4uLy4uL2xvZyc7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgQ29udkF0dHJpYnV0ZXMgfSBmcm9tICcuLi9jb252JztcbmltcG9ydCB7IGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcywgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSwgZ2V0QWN0aXZhdGlvblNuaXBwZXQgfSBmcm9tICcuLi9mdXNlLXV0aWxzJztcblxuaW1wb3J0IHsgYmlhc1NuaXBwZXQsIHR5cGVTbmlwcGV0IH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuaW1wb3J0IHsgdXRpbEZ1bmN0aW9ucyB9IGZyb20gJy4vY29udl91dGlsJztcbmltcG9ydCB7IG1ha2VNYXRNdWxQYWNrZWRTb3VyY2UsIG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlIH0gZnJvbSAnLi9tYXRtdWxfcGFja2VkX3dlYmdwdSc7XG5cbmNvbnN0IGNvbnYyZENvbW1vblNuaXBwZXQgPSAoXG4gIGlzQ2hhbm5lbHNMYXN0OiBib29sZWFuLFxuICBmaXRBT3V0ZXI6IGJvb2xlYW4sXG4gIGZpdEJPdXRlcjogYm9vbGVhbixcbiAgZml0SW5uZXI6IGJvb2xlYW4sXG4gIGFkZEJpYXMgPSBmYWxzZSxcbiAgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsXG4gIGlubmVyRWxlbWVudFNpemVYID0gNCxcbiAgaW5uZXJFbGVtZW50U2l6ZVcgPSA0LFxuICBpbm5lckVsZW1lbnRTaXplID0gNCxcbiAgZGF0YVR5cGUgPSAnZjMyJyxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGdldFhTbmlwcGV0ID0gKGlubmVyRWxlbWVudFNpemU6IG51bWJlcikgPT4ge1xuICAgIHN3aXRjaCAoaW5uZXJFbGVtZW50U2l6ZSkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gJ3Jlc0RhdGEgPSB4W3hJbmRleF07JztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIGByZXNEYXRhID0gdmVjMzwke2RhdGFUeXBlfT4oeFt4SW5kZXhdLCB4W3hJbmRleCArIDFdLCB4W3hJbmRleCArIDJdKTtgO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gJ3Jlc0RhdGEgPSB4W3hJbmRleCAvIDRdOyc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtpbm5lckVsZW1lbnRTaXplfSBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0V1NuaXBwZXQgPSAoaW5uZXJFbGVtZW50U2l6ZTogbnVtYmVyKSA9PiB7XG4gICAgc3dpdGNoIChpbm5lckVsZW1lbnRTaXplKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiAncmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pICsgY29sSW5dOyc7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiAncmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pIC8gNCArIGNvbEluXTsnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNvb3JkQVNuaXBwZXQgPSBpc0NoYW5uZWxzTGFzdFxuICAgID8gYFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeFJvdywgeENvbCwgeENoKTtcbiAgICBgXG4gICAgOiBgXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Q2gsIHhSb3csIHhDb2wpO1xuICAgIGA7XG5cbiAgY29uc3QgY29vcmRSZXNTbmlwcGV0ID0gaXNDaGFubmVsc0xhc3RcbiAgICA/IGBcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3cgLyBvdXRXaWR0aCxcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxuICAgICAgY29sKTtcbiAgICBgXG4gICAgOiBgXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93LFxuICAgICAgY29sIC8gb3V0V2lkdGgsXG4gICAgICBjb2wgJSBvdXRXaWR0aCk7XG4gICAgYDtcblxuICBjb25zdCB4SGVpZ2h0ID0gaXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMV0pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVsyXSknO1xuICBjb25zdCB4V2lkdGggPSBpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMueF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzNdKSc7XG4gIGNvbnN0IHJvdyA9IGlzQ2hhbm5lbHNMYXN0ID8gJ3JvdycgOiAnY29sJztcbiAgY29uc3QgY29sID0gaXNDaGFubmVsc0xhc3QgPyAnY29sJyA6ICdyb3cnO1xuICBjb25zdCByZWFkWFNuaXBwZXQgPSBgXG4gICAgbGV0IGluQ2hhbm5lbHMgPSBpMzIodW5pZm9ybXMud19zaGFwZVsyXSk7XG4gICAgbGV0IG91dFdpZHRoID0gJHtpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKScgOiAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSknfTtcbiAgICBsZXQgb3V0Um93ID0gJHtyb3d9IC8gb3V0V2lkdGg7XG4gICAgbGV0IG91dENvbCA9ICR7cm93fSAlIG91dFdpZHRoO1xuXG4gICAgbGV0IFdSb3cgPSAke2NvbH0gLyAoaTMyKHVuaWZvcm1zLndfc2hhcGVbMV0pICogaW5DaGFubmVscyk7XG4gICAgbGV0IFdDb2wgPSAke2NvbH0gLyBpbkNoYW5uZWxzICUgaTMyKHVuaWZvcm1zLndfc2hhcGVbMV0pO1xuICAgIGxldCB4Um93ID0gb3V0Um93ICogdW5pZm9ybXMuc3RyaWRlWzBdICsgdW5pZm9ybXMuZGlsYXRpb25bMF0gKiBXUm93IC0gdW5pZm9ybXMucGFkWzBdO1xuICAgIGxldCB4Q29sID0gb3V0Q29sICogdW5pZm9ybXMuc3RyaWRlWzFdICsgdW5pZm9ybXMuZGlsYXRpb25bMV0gKiBXQ29sIC0gdW5pZm9ybXMucGFkWzFdO1xuICAgIGxldCB4Q2ggPSAke2NvbH0gJSBpbkNoYW5uZWxzO1xuICAgIHZhciByZXNEYXRhID0gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpfSgwLjApO1xuICAgIC8vIFRoZSBib3VuZHMgY2hlY2tpbmcgaXMgYWx3YXlzIG5lZWRlZCBzaW5jZSB3ZSB1c2UgaXQgdG8gcGFkIHplcm8gZm9yXG4gICAgLy8gdGhlICdzYW1lJyBwYWRkaW5nIHR5cGUuXG4gICAgaWYgKHhSb3cgPj0gMCAmJiB4Um93IDwgJHt4SGVpZ2h0fSAmJiB4Q29sID49IDAgJiYgeENvbCA8ICR7eFdpZHRofSkge1xuICAgICAgJHtjb29yZEFTbmlwcGV0fVxuICAgICAgbGV0IHhJbmRleCA9IGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMueF9zaGFwZSkpO1xuICAgICAgJHtnZXRYU25pcHBldChpbm5lckVsZW1lbnRTaXplWCl9XG4gICAgfVxuICAgIHJldHVybiByZXNEYXRhO2A7XG5cbiAgY29uc3Qgc2FtcGxlWCA9IGlzQ2hhbm5lbHNMYXN0XG4gICAgPyBmaXRBT3V0ZXIgJiYgZml0SW5uZXJcbiAgICAgID8gYFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xuICAgICR7cmVhZFhTbmlwcGV0fWBcbiAgICAgIDogYFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1faW5uZXIpIHtcbiAgICAgICR7cmVhZFhTbmlwcGV0fVxuICAgIH1cbiAgICByZXR1cm4gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpfSgwLjApO2BcbiAgICA6IGZpdElubmVyICYmIGZpdEJPdXRlclxuICAgICAgPyBgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplWH07XG4gICAgJHtyZWFkWFNuaXBwZXR9YFxuICAgICAgOiBgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplWH07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgJHtyZWFkWFNuaXBwZXR9XG4gICAgfVxuICAgIHJldHVybiAke3R5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVYLCBkYXRhVHlwZSl9KDAuMCk7YDtcblxuICBjb25zdCBzYW1wbGVXID0gaXNDaGFubmVsc0xhc3RcbiAgICA/IGZpdElubmVyICYmIGZpdEJPdXRlclxuICAgICAgPyBnZXRXU25pcHBldChpbm5lckVsZW1lbnRTaXplVylcbiAgICAgIDogYFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVd9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7Z2V0V1NuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcpfVxuICAgIH1cbiAgICByZXR1cm4gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplVywgZGF0YVR5cGUpfSgwLjApO2BcbiAgICA6IGBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemVXfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9hX291dGVyKSB7XG4gICAgICAke2dldFdTbmlwcGV0KGlubmVyRWxlbWVudFNpemVXKX1cbiAgICB9XG4gICAgcmV0dXJuICR7dHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcsIGRhdGFUeXBlKX0oMC4wKTtgO1xuXG4gIGNvbnN0IHJlc1R5cGUgPSB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplLCBkYXRhVHlwZSk7XG4gIGNvbnN0IGFUeXBlID0gaXNDaGFubmVsc0xhc3QgPyB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpIDogdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcsIGRhdGFUeXBlKTtcbiAgY29uc3QgYlR5cGUgPSBpc0NoYW5uZWxzTGFzdCA/IHR5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVXLCBkYXRhVHlwZSkgOiB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpO1xuICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCByZXNUeXBlLCBkYXRhVHlwZSk7XG4gIGNvbnN0IHVzZXJDb2RlID0gYFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7YVR5cGV9IHtcbiAgICAgICR7aXNDaGFubmVsc0xhc3QgPyBzYW1wbGVYIDogc2FtcGxlV31cbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke2JUeXBlfSB7XG4gICAgICAke2lzQ2hhbm5lbHNMYXN0ID8gc2FtcGxlVyA6IHNhbXBsZVh9XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbiA6ICR7cmVzVHlwZX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZX07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXG4gICAgICB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKScgOiAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSknfTtcbiAgICAgICR7Y29vcmRSZXNTbmlwcGV0fVxuICAgICAgJHtiaWFzU25pcHBldChhZGRCaWFzKX1cbiAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgc2V0T3V0cHV0QXRDb29yZHMoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfWA7XG4gIHJldHVybiB1c2VyQ29kZTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGRpbUFPdXRlcjogbnVtYmVyLFxuICBkaW1CT3V0ZXI6IG51bWJlcixcbiAgZGltSW5uZXI6IG51bWJlcixcbiAgaGFzQmlhczogYm9vbGVhbixcbiAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkczogYm9vbGVhbixcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBpbkNoYW5uZWxzID0gaXNDaGFubmVsc0xhc3QgPyBpbnB1dHNbMF0uZGltc1szXSA6IGlucHV0c1swXS5kaW1zWzFdO1xuICBjb25zdCBiYXRjaFNpemUgPSBvdXRwdXRTaGFwZVswXTtcbiAgY29uc3Qgb3V0V2lkdGggPSBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlWzJdIDogb3V0cHV0U2hhcGVbM107XG4gIGNvbnN0IG91dEhlaWdodCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbMV0gOiBvdXRwdXRTaGFwZVsyXTtcbiAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlWzNdIDogb3V0cHV0U2hhcGVbMV07XG4gIC8vIFRPRE86IGVuYWJsZSB2ZWM0IGZvciBOQ0hXXG4gIGNvbnN0IGlzVmVjNCA9IGlzQ2hhbm5lbHNMYXN0ICYmIChpbkNoYW5uZWxzICUgNCA9PT0gMCB8fCBpbkNoYW5uZWxzICUgMyA9PT0gMCkgJiYgb3V0Q2hhbm5lbHMgJSA0ID09PSAwO1xuXG4gIC8vIFRPRE86IGZpbmUgdHVuZSBzaXplXG4gIGNvbnN0IGRpc3BhdGNoWCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRXaWR0aCAqIG91dEhlaWdodDtcbiAgY29uc3QgZGlzcGF0Y2hZID0gaXNDaGFubmVsc0xhc3QgPyBvdXRXaWR0aCAqIG91dEhlaWdodCA6IG91dENoYW5uZWxzO1xuICBjb25zdCB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbOCwgOCwgMV07XG4gIGNvbnN0IGVsZW1lbnRzUGVyVGhyZWFkID0gZGltQU91dGVyIDw9IDggPyBbNCwgMSwgMV0gOiBbNCwgNCwgMV07XG4gIGNvbnN0IGRpc3BhdGNoID0gW1xuICAgIE1hdGguY2VpbChkaXNwYXRjaFggLyB3b3JrR3JvdXBTaXplWzBdIC8gZWxlbWVudHNQZXJUaHJlYWRbMF0pLFxuICAgIE1hdGguY2VpbChkaXNwYXRjaFkgLyB3b3JrR3JvdXBTaXplWzFdIC8gZWxlbWVudHNQZXJUaHJlYWRbMV0pLFxuICAgIE1hdGguY2VpbChiYXRjaFNpemUgLyB3b3JrR3JvdXBTaXplWzJdIC8gZWxlbWVudHNQZXJUaHJlYWRbMl0pLFxuICBdO1xuXG4gIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbY29udjJkX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke2Rpc3BhdGNofWApO1xuXG4gIGNvbnN0IGlubmVyRWxlbWVudFNpemUgPSBpc1ZlYzQgPyAoaXNDaGFubmVsc0xhc3QgJiYgaW5DaGFubmVscyAlIDQgIT09IDAgPyAzIDogNCkgOiAxO1xuICBjb25zdCB0aWxlQU91dGVyID0gd29ya0dyb3VwU2l6ZVsxXSAqIGVsZW1lbnRzUGVyVGhyZWFkWzFdO1xuICBjb25zdCB0aWxlQk91dGVyID0gd29ya0dyb3VwU2l6ZVswXSAqIGVsZW1lbnRzUGVyVGhyZWFkWzBdO1xuICBjb25zdCB0aWxlSW5uZXIgPSBNYXRoLm1heCh3b3JrR3JvdXBTaXplWzBdICogaW5uZXJFbGVtZW50U2l6ZSwgd29ya0dyb3VwU2l6ZVsxXSk7XG4gIGNvbnN0IGZpdEFPdXRlciA9IGRpbUFPdXRlciAlIHRpbGVBT3V0ZXIgPT09IDA7XG4gIGNvbnN0IGZpdEJPdXRlciA9IGRpbUJPdXRlciAlIHRpbGVCT3V0ZXIgPT09IDA7XG4gIGNvbnN0IGZpdElubmVyID0gZGltSW5uZXIgJSB0aWxlSW5uZXIgPT09IDA7XG4gIGNvbnN0IGVsZW1lbnRzU2l6ZSA9IGlzVmVjNCA/IFtpbm5lckVsZW1lbnRTaXplLCA0LCA0XSA6IFsxLCAxLCAxXTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQU91dGVyIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQk91dGVyIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltSW5uZXIgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBbYXR0cmlidXRlcy5wYWRzWzBdLCBhdHRyaWJ1dGVzLnBhZHNbMV1dIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXR0cmlidXRlcy5zdHJpZGVzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXR0cmlidXRlcy5kaWxhdGlvbnMgfSxcbiAgXTtcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnLCAncmFuayddO1xuICBpZiAoaGFzQmlhcykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnZGltX2Ffb3V0ZXInLCB0eXBlOiAnaTMyJyB9LFxuICAgICAgeyBuYW1lOiAnZGltX2Jfb3V0ZXInLCB0eXBlOiAnaTMyJyB9LFxuICAgICAgeyBuYW1lOiAnZGltX2lubmVyJywgdHlwZTogJ2kzMicgfSxcbiAgICAgIHsgbmFtZTogJ3BhZCcsIHR5cGU6ICdpMzInLCBsZW5ndGg6IDIgfSxcbiAgICAgIHsgbmFtZTogJ3N0cmlkZScsIHR5cGU6ICdpMzInLCBsZW5ndGg6IDIgfSxcbiAgICAgIHsgbmFtZTogJ2RpbGF0aW9uJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMiB9LFxuICAgIF07XG4gICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcblxuICAgIC8vIFRPRE86IHN1cHBvcnQgY29tcG9uZW50IDIsIDMuXG4gICAgY29uc3QgY29tcG9uZW50cyA9IGlzVmVjNCA/IDQgOiAxO1xuICAgIGNvbnN0IHQgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICBsZXQgZGVjbGFyZUZ1bmN0aW9ucyA9IGBcbiAgICAgIGZuIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IDogaTMyLCB2YWx1ZSA6ICR7aXNWZWM0ID8gYHZlYzQ8JHt0fT5gIDogdH0pIHtcbiAgICAgICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZuIHNldE91dHB1dEF0Q29vcmRzKGQwIDogaTMyLCBkMSA6IGkzMiwgZDIgOiBpMzIsIGQzIDogaTMyLCB2YWx1ZSA6ICR7aXNWZWM0ID8gYHZlYzQ8JHt0fT5gIDogdH0pIHtcbiAgICAgICAgbGV0IGZsYXRJbmRleCA9IGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyh2ZWM0PGkzMj4oZDAsIGQxLCBkMiwgZDMpKTtcbiAgICAgICAgc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggJHtpc1ZlYzQgPyAnLyA0JyA6ICcnfSwgdmFsdWUpO1xuICAgICAgfWA7XG4gICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoXG4gICAgICAneCcsXG4gICAgICBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICBpbnB1dHNbMF0uZGltcy5sZW5ndGgsXG4gICAgICBpbm5lckVsZW1lbnRTaXplID09PSAzID8gMSA6IGlubmVyRWxlbWVudFNpemUsXG4gICAgKTtcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFt4LCB3XTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goYmlhcyk7XG4gICAgICBkZWNsYXJlRnVuY3Rpb25zICs9IGBcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7aXNDaGFubmVsc0xhc3QgPyAndycgOiAneSd9JHtpc1ZlYzQgPyAnLyA0JyA6ICcnfV07XG4gICAgICAgIH1gO1xuICAgIH1cblxuICAgIHJldHVybiBgXG4gICAgICAgICR7dXRpbEZ1bmN0aW9ucygndW5pZm9ybXMucmVzdWx0X3N0cmlkZXMnKX1cbiAgICAgICAgLy9zdHJ1Y3QgVW5pZm9ybXMgeyB4U2hhcGUgOiB2ZWM0PGkzMj4sIHdTaGFwZSA6IHZlYzQ8aTMyPiwgb3V0U2hhcGUgOiB2ZWM0PGkzMj4sXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICAgICAgICR7ZGVjbGFyZUZ1bmN0aW9uc31cbiAgICAgICAgJHtjb252MmRDb21tb25TbmlwcGV0KFxuICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0LFxuICAgICAgICAgIGZpdEFPdXRlcixcbiAgICAgICAgICBmaXRCT3V0ZXIsXG4gICAgICAgICAgZml0SW5uZXIsXG4gICAgICAgICAgaGFzQmlhcyxcbiAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgIGVsZW1lbnRzU2l6ZVswXSxcbiAgICAgICAgICBlbGVtZW50c1NpemVbMV0sXG4gICAgICAgICAgZWxlbWVudHNTaXplWzJdLFxuICAgICAgICAgIHQsXG4gICAgICAgICl9XG4gICAgICAgICR7XG4gICAgICAgICAgaXNWZWM0XG4gICAgICAgICAgICA/IG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlKGVsZW1lbnRzUGVyVGhyZWFkLCB3b3JrR3JvdXBTaXplLCB0LCB1bmRlZmluZWQsICFpc0NoYW5uZWxzTGFzdCwgdGlsZUlubmVyKVxuICAgICAgICAgICAgOiBtYWtlTWF0TXVsUGFja2VkU291cmNlKFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzUGVyVGhyZWFkLFxuICAgICAgICAgICAgICAgIHdvcmtHcm91cFNpemUsXG4gICAgICAgICAgICAgICAgdCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgIWlzQ2hhbm5lbHNMYXN0LFxuICAgICAgICAgICAgICAgIHRpbGVJbm5lcixcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyxcbiAgICAgICAgICAgICAgKVxuICAgICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQ29udjJETWF0TXVsJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtpbm5lckVsZW1lbnRTaXplfTske2lzVmVjNH07JHtmaXRBT3V0ZXJ9OyR7Zml0Qk91dGVyfTske2ZpdElubmVyfTske3RpbGVBT3V0ZXJ9OyR7dGlsZUJPdXRlcn07JHt0aWxlSW5uZXJ9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IGRpc3BhdGNoWzBdLCB5OiBkaXNwYXRjaFsxXSwgejogZGlzcGF0Y2hbMl0gfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLy8gc2FtcGxlZCBmcm9tIFtAdGVuc29yZmxvdy90ZmpzXSB0ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9jb252M2RfbmFpdmVfd2ViZ3B1LnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IExPR19ERUJVRyB9IGZyb20gJy4uLy4uLy4uL2xvZyc7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGdldEVsZW1lbnRBdCxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IENvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vY29udic7XG5pbXBvcnQgeyBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0IH0gZnJvbSAnLi4vZnVzZS11dGlscyc7XG5cbmltcG9ydCB7IHR5cGVTbmlwcGV0IH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuXG5jb25zdCBhcnJheVByb2R1Y3QgPSAoYXJyOiBudW1iZXJbXSkgPT4ge1xuICBsZXQgcHJvZHVjdCA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJvZHVjdCAqPSBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHByb2R1Y3Q7XG59O1xuXG5jb25zdCBwYXJzZTNUdXBsZVBhcmFtID0gKHBhcmFtOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPT5cbiAgdHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyA/IFtwYXJhbSwgcGFyYW0sIHBhcmFtXSA6IHBhcmFtO1xuXG5jb25zdCBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplID0gKGZpbHRlclNpemU6IG51bWJlciwgZGlsYXRpb246IG51bWJlcik6IG51bWJlciA9PiB7XG4gIGlmIChkaWxhdGlvbiA8PSAxKSB7XG4gICAgcmV0dXJuIGZpbHRlclNpemU7XG4gIH1cblxuICByZXR1cm4gZmlsdGVyU2l6ZSArIChmaWx0ZXJTaXplIC0gMSkgKiAoZGlsYXRpb24gLSAxKTtcbn07XG5cbmNvbnN0IGNvbXB1dGVEZWZhdWx0UGFkID0gKFxuICBpbnB1dFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGZpZWxkU2l6ZTogbnVtYmVyLFxuICBzdHJpZGU6IG51bWJlcixcbiAgZGlsYXRpb24gPSAxLFxuKTogbnVtYmVyID0+IHtcbiAgY29uc3QgZWZmZWN0aXZlRmllbGRTaXplID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWVsZFNpemUsIGRpbGF0aW9uKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGlucHV0U2hhcGVbMF0gKiAoc3RyaWRlIC0gMSkgLSBzdHJpZGUgKyBlZmZlY3RpdmVGaWVsZFNpemUpIC8gMik7XG59O1xuXG5jb25zdCBjb21wdXRlT3V0cHV0U2hhcGU0RCA9IChcbiAgaW5TaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGZpbHRlclNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIG91dENoYW5uZWxzOiBudW1iZXIsXG4gIHN0cmlkZXM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgemVyb1BhZD86IG51bWJlcixcbik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgaWYgKHplcm9QYWQgPT0gbnVsbCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHplcm9QYWQgPSBjb21wdXRlRGVmYXVsdFBhZChpblNoYXBlLCBmaWx0ZXJTaGFwZVswXSwgc3RyaWRlc1swXSk7XG4gIH1cbiAgY29uc3Qgb3V0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzAsIDAsIDAsIG91dENoYW5uZWxzXTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IDM7IGluZGV4KyspIHtcbiAgICBpZiAoaW5TaGFwZVtpbmRleF0gKyAyICogemVyb1BhZCA+PSBmaWx0ZXJTaGFwZVtpbmRleF0pIHtcbiAgICAgIG91dFNoYXBlW2luZGV4XSA9IE1hdGgudHJ1bmMoKGluU2hhcGVbaW5kZXhdIC0gZmlsdGVyU2hhcGVbaW5kZXhdICsgMiAqIHplcm9QYWQpIC8gc3RyaWRlc1tpbmRleF0gKyAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dFNoYXBlO1xufTtcblxuY29uc3QgZ2V0M0RQYWRBbmRPdXRJbmZvID0gKFxuICBwYWQ6IG51bWJlciB8IHN0cmluZyB8IG51bWJlcltdLFxuICBpbkRlcHRoOiBudW1iZXIsXG4gIGluSGVpZ2h0OiBudW1iZXIsXG4gIGluV2lkdGg6IG51bWJlcixcbiAgc3RyaWRlRGVwdGg6IG51bWJlcixcbiAgc3RyaWRlSGVpZ2h0OiBudW1iZXIsXG4gIHN0cmlkZVdpZHRoOiBudW1iZXIsXG4gIGZpbHRlckRlcHRoOiBudW1iZXIsXG4gIGZpbHRlckhlaWdodDogbnVtYmVyLFxuICBmaWx0ZXJXaWR0aDogbnVtYmVyLFxuKTogeyBwYWRJbmZvOiBQYWRJbmZvM0Q7IG91dERlcHRoOiBudW1iZXI7IG91dEhlaWdodDogbnVtYmVyOyBvdXRXaWR0aDogbnVtYmVyIH0gPT4ge1xuICBsZXQgcGFkSW5mbzogUGFkSW5mbzNEO1xuICBsZXQgb3V0RGVwdGg6IG51bWJlcjtcbiAgbGV0IG91dEhlaWdodDogbnVtYmVyO1xuICBsZXQgb3V0V2lkdGg6IG51bWJlcjtcblxuICBpZiAocGFkID09PSAnVkFMSUQnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcGFkID0gMDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFkID09PSAnbnVtYmVyJykge1xuICAgIHBhZEluZm8gPSB7IHRvcDogcGFkLCBib3R0b206IHBhZCwgbGVmdDogcGFkLCByaWdodDogcGFkLCBmcm9udDogcGFkLCBiYWNrOiBwYWQgfTtcbiAgICBjb25zdCBvdXRTaGFwZSA9IGNvbXB1dGVPdXRwdXRTaGFwZTREKFxuICAgICAgW2luRGVwdGgsIGluSGVpZ2h0LCBpbldpZHRoLCAxXSxcbiAgICAgIFtmaWx0ZXJEZXB0aCwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aF0sXG4gICAgICAxLFxuICAgICAgW3N0cmlkZURlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoXSxcbiAgICAgIHBhZCxcbiAgICApO1xuICAgIG91dERlcHRoID0gb3V0U2hhcGVbMF07XG4gICAgb3V0SGVpZ2h0ID0gb3V0U2hhcGVbMV07XG4gICAgb3V0V2lkdGggPSBvdXRTaGFwZVsyXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhZCkpIHtcbiAgICBpZiAoIXBhZC5ldmVyeSgodmFsLCBfLCBhcnIpID0+IHZhbCA9PT0gYXJyWzBdKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHBhZGRpbmcgcGFyYW1ldGVyOiAke3BhZH1gKTtcbiAgICB9XG4gICAgcGFkSW5mbyA9IHsgdG9wOiBwYWRbMF0sIGJvdHRvbTogcGFkWzFdLCBsZWZ0OiBwYWRbMl0sIHJpZ2h0OiBwYWRbM10sIGZyb250OiBwYWRbNF0sIGJhY2s6IHBhZFs1XSB9O1xuICAgIGNvbnN0IG91dFNoYXBlID0gY29tcHV0ZU91dHB1dFNoYXBlNEQoXG4gICAgICBbaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGgsIDFdLFxuICAgICAgW2ZpbHRlckRlcHRoLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoXSxcbiAgICAgIDEsXG4gICAgICBbc3RyaWRlRGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGhdLFxuICAgICAgcGFkWzBdLFxuICAgICk7XG4gICAgb3V0RGVwdGggPSBvdXRTaGFwZVswXTtcbiAgICBvdXRIZWlnaHQgPSBvdXRTaGFwZVsxXTtcbiAgICBvdXRXaWR0aCA9IG91dFNoYXBlWzJdO1xuICB9IGVsc2UgaWYgKHBhZCA9PT0gJ1NBTUVfVVBQRVInKSB7XG4gICAgLy8gVE9ETzogc3VwcG9ydCAnU0FNRV9MT1dFUicuXG4gICAgb3V0RGVwdGggPSBNYXRoLmNlaWwoaW5EZXB0aCAvIHN0cmlkZURlcHRoKTtcbiAgICBvdXRIZWlnaHQgPSBNYXRoLmNlaWwoaW5IZWlnaHQgLyBzdHJpZGVIZWlnaHQpO1xuICAgIG91dFdpZHRoID0gTWF0aC5jZWlsKGluV2lkdGggLyBzdHJpZGVXaWR0aCk7XG4gICAgY29uc3QgcGFkQWxvbmdEZXB0aCA9IChvdXREZXB0aCAtIDEpICogc3RyaWRlRGVwdGggKyBmaWx0ZXJEZXB0aCAtIGluRGVwdGg7XG4gICAgY29uc3QgcGFkQWxvbmdIZWlnaHQgPSAob3V0SGVpZ2h0IC0gMSkgKiBzdHJpZGVIZWlnaHQgKyBmaWx0ZXJIZWlnaHQgLSBpbkhlaWdodDtcbiAgICBjb25zdCBwYWRBbG9uZ1dpZHRoID0gKG91dFdpZHRoIC0gMSkgKiBzdHJpZGVXaWR0aCArIGZpbHRlcldpZHRoIC0gaW5XaWR0aDtcbiAgICBjb25zdCBmcm9udCA9IE1hdGguZmxvb3IocGFkQWxvbmdEZXB0aCAvIDIpO1xuICAgIGNvbnN0IGJhY2sgPSBwYWRBbG9uZ0RlcHRoIC0gZnJvbnQ7XG4gICAgY29uc3QgdG9wID0gTWF0aC5mbG9vcihwYWRBbG9uZ0hlaWdodCAvIDIpO1xuICAgIGNvbnN0IGJvdHRvbSA9IHBhZEFsb25nSGVpZ2h0IC0gdG9wO1xuICAgIGNvbnN0IGxlZnQgPSBNYXRoLmZsb29yKHBhZEFsb25nV2lkdGggLyAyKTtcbiAgICBjb25zdCByaWdodCA9IHBhZEFsb25nV2lkdGggLSBsZWZ0O1xuXG4gICAgcGFkSW5mbyA9IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0LCBmcm9udCwgYmFjayB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKGBVbmtub3duIHBhZGRpbmcgcGFyYW1ldGVyOiAke3BhZH1gKTtcbiAgfVxuICByZXR1cm4geyBwYWRJbmZvLCBvdXREZXB0aCwgb3V0SGVpZ2h0LCBvdXRXaWR0aCB9O1xufTtcblxudHlwZSBQYWRJbmZvM0QgPSB7XG4gIHRvcDogbnVtYmVyO1xuICBsZWZ0OiBudW1iZXI7XG4gIHJpZ2h0OiBudW1iZXI7XG4gIGJvdHRvbTogbnVtYmVyO1xuICBmcm9udDogbnVtYmVyO1xuICBiYWNrOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBDb252M0RJbmZvID0ge1xuICBiYXRjaFNpemU6IG51bWJlcjtcbiAgaW5EZXB0aDogbnVtYmVyO1xuICBpbkhlaWdodDogbnVtYmVyO1xuICBpbldpZHRoOiBudW1iZXI7XG4gIGluQ2hhbm5lbHM6IG51bWJlcjtcbiAgb3V0RGVwdGg6IG51bWJlcjtcbiAgb3V0SGVpZ2h0OiBudW1iZXI7XG4gIG91dFdpZHRoOiBudW1iZXI7XG4gIG91dENoYW5uZWxzOiBudW1iZXI7XG4gIGRhdGFGb3JtYXQ6ICdjaGFubmVsc0ZpcnN0JyB8ICdjaGFubmVsc0xhc3QnO1xuICBzdHJpZGVEZXB0aDogbnVtYmVyO1xuICBzdHJpZGVIZWlnaHQ6IG51bWJlcjtcbiAgc3RyaWRlV2lkdGg6IG51bWJlcjtcbiAgZGlsYXRpb25EZXB0aDogbnVtYmVyO1xuICBkaWxhdGlvbkhlaWdodDogbnVtYmVyO1xuICBkaWxhdGlvbldpZHRoOiBudW1iZXI7XG4gIGZpbHRlckRlcHRoOiBudW1iZXI7XG4gIGZpbHRlckhlaWdodDogbnVtYmVyO1xuICBmaWx0ZXJXaWR0aDogbnVtYmVyO1xuICBlZmZlY3RpdmVGaWx0ZXJEZXB0aDogbnVtYmVyO1xuICBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ6IG51bWJlcjtcbiAgZWZmZWN0aXZlRmlsdGVyV2lkdGg6IG51bWJlcjtcbiAgcGFkSW5mbzogUGFkSW5mbzNEO1xuICBpblNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBvdXRTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgZmlsdGVyU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG59O1xuXG5leHBvcnQgY29uc3QgY29tcHV0ZUNvbnYzREluZm8gPSAoXG4gIGluU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGZpbHRlclNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICBzdHJpZGVzOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGRpbGF0aW9uczogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICBwYWQ6IG51bWJlciB8IHN0cmluZyB8IG51bWJlcltdLFxuICBkZXB0aHdpc2UgPSBmYWxzZSxcbiAgZGF0YUZvcm1hdDogJ2NoYW5uZWxzRmlyc3QnIHwgJ2NoYW5uZWxzTGFzdCcgPSAnY2hhbm5lbHNMYXN0Jyxcbik6IENvbnYzREluZm8gPT4ge1xuICBsZXQgYmF0Y2hTaXplLCBpbkRlcHRoLCBpbkhlaWdodCwgaW5XaWR0aCwgaW5DaGFubmVscztcbiAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgW2JhdGNoU2l6ZSwgaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGgsIGluQ2hhbm5lbHNdID0gaW5TaGFwZTtcbiAgfSBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICBbYmF0Y2hTaXplLCBpbkNoYW5uZWxzLCBpbkRlcHRoLCBpbkhlaWdodCwgaW5XaWR0aF0gPSBpblNoYXBlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhRm9ybWF0ICR7ZGF0YUZvcm1hdH1gKTtcbiAgfVxuICBjb25zdCBbZmlsdGVyQ2hhbm5lbHMsICwgZmlsdGVyRGVwdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGhdID0gZmlsdGVyU2hhcGU7XG5cbiAgY29uc3QgW3N0cmlkZURlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoXSA9IHBhcnNlM1R1cGxlUGFyYW0oc3RyaWRlcyk7XG4gIGNvbnN0IFtkaWxhdGlvbkRlcHRoLCBkaWxhdGlvbkhlaWdodCwgZGlsYXRpb25XaWR0aF0gPSBwYXJzZTNUdXBsZVBhcmFtKGRpbGF0aW9ucyk7XG5cbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVyRGVwdGggPSBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplKGZpbHRlckRlcHRoLCBkaWxhdGlvbkRlcHRoKTtcbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWx0ZXJIZWlnaHQsIGRpbGF0aW9uSGVpZ2h0KTtcbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVyV2lkdGggPSBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplKGZpbHRlcldpZHRoLCBkaWxhdGlvbldpZHRoKTtcbiAgY29uc3QgeyBwYWRJbmZvLCBvdXREZXB0aCwgb3V0SGVpZ2h0LCBvdXRXaWR0aCB9ID0gZ2V0M0RQYWRBbmRPdXRJbmZvKFxuICAgIHBhZCxcbiAgICBpbkRlcHRoLFxuICAgIGluSGVpZ2h0LFxuICAgIGluV2lkdGgsXG4gICAgc3RyaWRlRGVwdGgsXG4gICAgc3RyaWRlSGVpZ2h0LFxuICAgIHN0cmlkZVdpZHRoLFxuICAgIGVmZmVjdGl2ZUZpbHRlckRlcHRoLFxuICAgIGVmZmVjdGl2ZUZpbHRlckhlaWdodCxcbiAgICBlZmZlY3RpdmVGaWx0ZXJXaWR0aCxcbiAgKTtcblxuICBjb25zdCBvdXRDaGFubmVscyA9IGRlcHRod2lzZSA/IGZpbHRlckNoYW5uZWxzICogaW5DaGFubmVscyA6IGZpbHRlckNoYW5uZWxzO1xuXG4gIGxldCBvdXRTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFswLCAwLCAwLCAwLCAwXTtcbiAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgIG91dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0Q2hhbm5lbHMsIG91dERlcHRoLCBvdXRIZWlnaHQsIG91dFdpZHRoXTtcbiAgfSBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgIG91dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0RGVwdGgsIG91dEhlaWdodCwgb3V0V2lkdGgsIG91dENoYW5uZWxzXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmF0Y2hTaXplLFxuICAgIGRhdGFGb3JtYXQsXG4gICAgaW5EZXB0aCxcbiAgICBpbkhlaWdodCxcbiAgICBpbldpZHRoLFxuICAgIGluQ2hhbm5lbHMsXG4gICAgb3V0RGVwdGgsXG4gICAgb3V0SGVpZ2h0LFxuICAgIG91dFdpZHRoLFxuICAgIG91dENoYW5uZWxzLFxuICAgIHBhZEluZm8sXG4gICAgc3RyaWRlRGVwdGgsXG4gICAgc3RyaWRlSGVpZ2h0LFxuICAgIHN0cmlkZVdpZHRoLFxuICAgIGZpbHRlckRlcHRoLFxuICAgIGZpbHRlckhlaWdodCxcbiAgICBmaWx0ZXJXaWR0aCxcbiAgICBlZmZlY3RpdmVGaWx0ZXJEZXB0aCxcbiAgICBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQsXG4gICAgZWZmZWN0aXZlRmlsdGVyV2lkdGgsXG4gICAgZGlsYXRpb25EZXB0aCxcbiAgICBkaWxhdGlvbkhlaWdodCxcbiAgICBkaWxhdGlvbldpZHRoLFxuICAgIGluU2hhcGUsXG4gICAgb3V0U2hhcGUsXG4gICAgZmlsdGVyU2hhcGUsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQ29udjNETmFpdmVQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGZpbHRlckRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBwYWRzOiByZWFkb25seSBudW1iZXJbXSxcbiAgZGF0YUZvcm1hdDogc3RyaW5nLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG4gIGNvbnN0IGluQ2hhbm5lbHMgPSBpc0NoYW5uZWxMYXN0ID8gaW5wdXRzWzBdLmRpbXNbM10gOiBpbnB1dHNbMF0uZGltc1sxXTtcbiAgLy8gVE9ETzogZW5hYmxlIHZlYzQuXG4gIGNvbnN0IGlzVmVjNCA9IGZhbHNlO1xuICBjb25zdCB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbNjQsIDEsIDFdO1xuICBjb25zdCBkaXNwYXRjaExheW91dCA9IHsgeDogb3V0cHV0U2hhcGUubWFwKChfLCBpKSA9PiBpKSB9O1xuICBjb25zdCBkaXNwYXRjaCA9IFtNYXRoLmNlaWwoYXJyYXlQcm9kdWN0KGRpc3BhdGNoTGF5b3V0LngubWFwKChkKSA9PiBvdXRwdXRTaGFwZVtkXSkpIC8gd29ya0dyb3VwU2l6ZVswXSksIDEsIDFdO1xuXG4gIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbY29udjNkX25haXZlX3dlYmdwdV0gZGlzcGF0Y2ggPSAke2Rpc3BhdGNofWApO1xuXG4gIGNvbnN0IGlubmVyRWxlbWVudFNpemUgPSBpc1ZlYzQgPyAoaXNDaGFubmVsTGFzdCAmJiBpbkNoYW5uZWxzICUgNCAhPT0gMCA/IDMgOiA0KSA6IDE7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBmaWx0ZXJEaW1zIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhZHMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5zdHJpZGVzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuZGlsYXRpb25zIH0sXG4gIF07XG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKSk7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPT09IDM7XG4gIGlmIChoYXNCaWFzKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gIH1cbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdmaWx0ZXJfZGltcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGZpbHRlckRpbXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogcGFkcy5sZW5ndGggfSxcbiAgICAgIHsgbmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBhdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdkaWxhdGlvbnMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggfSxcbiAgICBdO1xuICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG4gICAgLy8gVE9ETzogc3VwcG9ydCBjb21wb25lbnQgMiwgMy5cbiAgICBjb25zdCBjb21wb25lbnRzID0gaXNWZWM0ID8gNCA6IDE7XG4gICAgY29uc3QgdCA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuXG4gICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoXG4gICAgICAneCcsXG4gICAgICBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICBpbnB1dHNbMF0uZGltcy5sZW5ndGgsXG4gICAgICBpbm5lckVsZW1lbnRTaXplID09PSAzID8gMSA6IGlubmVyRWxlbWVudFNpemUsXG4gICAgKTtcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgnVycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFt4LCB3XTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGxldCBkZWNsYXJlRnVuY3Rpb25zID0gJyc7XG4gICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaChiaWFzKTtcbiAgICAgIGRlY2xhcmVGdW5jdGlvbnMgKz0gYFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogYXJyYXk8dTMyLCA1PikgLT4gJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbJHtpc0NoYW5uZWxMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCA0LCA1KSA6IGdldEVsZW1lbnRBdCgnY29vcmRzJywgMSwgNSl9JHtcbiAgICAgICAgICAgIGlzVmVjNCA/ICcvIDQnIDogJydcbiAgICAgICAgICB9XTtcbiAgICAgICAgfWA7XG4gICAgfVxuICAgIGNvbnN0IHJlc1R5cGUgPSB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplLCB0KTtcbiAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCByZXNUeXBlLCB0KTtcblxuICAgIHJldHVybiBgXG4gICAgICAgICAgICAke2RlY2xhcmVGdW5jdGlvbnN9XG4gICAgICAgICAgICBmbiBnZXRYKGQwIDogdTMyLCBkMSA6IHUzMiwgZDIgOiB1MzIsIGQzIDogdTMyLCBkNCA6IHUzMikgLT4gZjMyIHtcbiAgICAgICAgICAgICAgbGV0IGFJbmRpY2VzID0gYXJyYXk8dTMyLCA1PihkMCwgZDEsIGQyLCBkMywgZDQpO1xuICAgICAgICAgICAgICByZXR1cm4gJHt4LmdldEJ5SW5kaWNlcygnYUluZGljZXMnKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbiBnZXRXKGQwIDogdTMyLCBkMSA6IHUzMiwgZDIgOiB1MzIsIGQzIDogdTMyLCBkNCA6IHUzMikgLT4gZjMyIHtcbiAgICAgICAgICAgICAgbGV0IGFJbmRpY2VzID0gYXJyYXk8dTMyLCA1PihkMCwgZDEsIGQyLCBkMywgZDQpO1xuICAgICAgICAgICAgICByZXR1cm4gJHt3LmdldEJ5SW5kaWNlcygnYUluZGljZXMnKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgICAgICAgICBsZXQgY29vcmRzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICAgICAgICBsZXQgYmF0Y2ggPSAke2dldEVsZW1lbnRBdCgnY29vcmRzJywgMCwgeC5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCBkMiA9ICR7XG4gICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdCA/IGdldEVsZW1lbnRBdCgnY29vcmRzJywgeC5yYW5rIC0gMSwgeC5yYW5rKSA6IGdldEVsZW1lbnRBdCgnY29vcmRzJywgMSwgeC5yYW5rKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBsZXQgeEZSQ0Nvcm5lciA9IHZlYzM8dTMyPigke1xuICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3QgPyBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDEsIHgucmFuaykgOiBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDIsIHgucmFuaylcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJHtpc0NoYW5uZWxMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAyLCB4LnJhbmspIDogZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAzLCB4LnJhbmspfSxcbiAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAzLCB4LnJhbmspIDogZ2V0RWxlbWVudEF0KCdjb29yZHMnLCA0LCB4LnJhbmspXG4gICAgICAgICAgICAgIH0pICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICAgIGxldCB4RkNvcm5lciA9IHhGUkNDb3JuZXIueDtcbiAgICAgICAgICAgICAgbGV0IHhSQ29ybmVyID0geEZSQ0Nvcm5lci55O1xuICAgICAgICAgICAgICBsZXQgeENDb3JuZXIgPSB4RlJDQ29ybmVyLno7XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVZID0gJHtcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XG4gICAgICAgICAgICAgICAgICA/IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDEsIHgucmFuaylcbiAgICAgICAgICAgICAgICAgIDogZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMiwgeC5yYW5rKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlWiA9ICR7XG4gICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxuICAgICAgICAgICAgICAgICAgPyBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCAyLCB4LnJhbmspXG4gICAgICAgICAgICAgICAgICA6IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDMsIHgucmFuaylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVcgPSAke1xuICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcbiAgICAgICAgICAgICAgICAgID8gZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMywgeC5yYW5rKVxuICAgICAgICAgICAgICAgICAgOiBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCA0LCB4LnJhbmspXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVVID0gJHtcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XG4gICAgICAgICAgICAgICAgICA/IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDQsIHgucmFuaylcbiAgICAgICAgICAgICAgICAgIDogZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMSwgeC5yYW5rKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aE5lYXJlc3RWZWM0ID0gKHhTaGFwZVUgLyA0KSAqIDQ7XG4gICAgICAgICAgICAgIGxldCBpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9IHhTaGFwZVUgJSA0O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IDAuMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgd0YgPSAwdTsgd0YgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1swXTsgd0YrKykge1xuICAgICAgICAgICAgICAgIGxldCB4RiA9IHhGQ29ybmVyICsgd0YgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSB4U2hhcGVZKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDB1OyB3UiA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdOyB3UisrKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgeFIgPSB4UkNvcm5lciArIHdSICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSB4U2hhcGVaKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciB3QyA9IDB1OyB3QyA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzJdOyB3QysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB4QyA9IHhDQ29ybmVyICsgd0MgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0geFNoYXBlVykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwdTsgZDEgPCBpbnB1dERlcHRoTmVhcmVzdFZlYzQ7IGQxICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXQgeFZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgbGV0IHhWYWx1ZXMgPSB2ZWM0PGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMSwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAyLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDMsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMiwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDMsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGB2YWx1ZSArPSBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICogZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKTtgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgdmFsdWUgKz0gZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXQgeFZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXQgeFZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjMjxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgd0YsIHdSLCB3QykpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGV0IHhWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXQgeFZhbHVlcyA9IHZlYzM8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICR7aGFzQmlhcyA/ICd2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyknIDogJyd9O1xuICAgICAgICAgICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgICAgICAgICAgcmVzdWx0W2dsb2JhbF9pZHhdID0gZjMyKHZhbHVlKTtcbiAgICAgICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQ29udjNETmFpdmUnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7aXNDaGFubmVsTGFzdH07JHtpbm5lckVsZW1lbnRTaXplfTske2hhc0JpYXN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IGRpc3BhdGNoWzBdLCB5OiBkaXNwYXRjaFsxXSwgejogZGlzcGF0Y2hbMl0gfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRNYXhDb21wb25lbnRzLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBDb252QXR0cmlidXRlcyB9IGZyb20gJy4vY29udic7XG5pbXBvcnQgeyBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0IH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcblxuLyoqXG4gKiBuYWl2ZSBncm91cGVkIGNvbnYgaW1wbGVtZW50YXRpb24sIHN1cHBvcnRzIDFkLzJkIGNvbnZcbiAqIEBwYXJhbSBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiAtIGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIHNxdWVlemUgdGhlIG91dHB1dCBzaGFwZSwgb25seSB1c2VkIGluIGNvbnYxZFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlR3JvdXBlZENvbnZQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uPzogKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4gbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgY29uc3QgcHJvY2Vzc0JpYXMgPSBoYXNCaWFzID8gJ3ZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdOycgOiAnJztcbiAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IHdTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuXG4gIGNvbnN0IGlzQ2hhbm5lbExhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBvdXRwdXRDaGFubmVscyA9IGlzQ2hhbm5lbExhc3QgPyBvdXRwdXRTaGFwZVszXSA6IG91dHB1dFNoYXBlWzFdO1xuICBjb25zdCBvdXRwdXRDaGFubmVsc1Blckdyb3VwID0gb3V0cHV0Q2hhbm5lbHMgLyBhdHRyaWJ1dGVzLmdyb3VwO1xuICBjb25zdCBjb21wb25lbnRzID0gaXNDaGFubmVsTGFzdCAmJiBvdXRwdXRDaGFubmVsc1Blckdyb3VwID49IDQgPyBnZXRNYXhDb21wb25lbnRzKG91dHB1dENoYW5uZWxzKSA6IDE7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLmRpbGF0aW9ucyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBbYXR0cmlidXRlcy5zdHJpZGVzWzBdLCBhdHRyaWJ1dGVzLnN0cmlkZXNbMV1dIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnBhZHNbMF0sIGF0dHJpYnV0ZXMucGFkc1sxXV0gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCB9LFxuICBdO1xuICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3Jtcyk7XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKHhTaGFwZSwgW3dTaGFwZVswXSwgd1NoYXBlWzFdLCB3U2hhcGVbMl0sIHdTaGFwZVszXSAvIGNvbXBvbmVudHNdKSxcbiAgKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBoYXNCaWFzID8gWydyYW5rJywgJ3JhbmsnLCAncmFuayddIDogWydyYW5rJywgJ3JhbmsnXTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdIC8gY29tcG9uZW50c10pLFxuICApO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgYmFzZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUob3V0cHV0LnR5cGUudGVuc29yKTtcbiAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSwgYmFzZVR5cGUpO1xuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCB4U2hhcGUubGVuZ3RoKTtcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgd1NoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5wdXRWYXJzID0gW3gsIHddO1xuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY29tcG9uZW50cykpO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2RpbGF0aW9ucycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMuZGlsYXRpb25zLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IDIgfSxcbiAgICAgIHsgbmFtZTogJ3BhZHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiAyIH0sXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG5cbiAgICBjb25zdCBjYWxjdWxhdGVSZXN1bHQgPSBpc0NoYW5uZWxMYXN0XG4gICAgICA/IGBcbiAgICAgIGZvciAodmFyIHdIZWlnaHQ6IHUzMiA9IDB1OyB3SGVpZ2h0IDwgdW5pZm9ybXMud19zaGFwZVswXTsgd0hlaWdodCsrKSB7XG4gICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSB1bmlmb3Jtcy54X3NoYXBlWzFdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzFdOyB3V2lkdGgrKykge1xuICAgICAgICAgIGxldCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICBpZiAoeFdpZHRoIDwgMHUgfHwgeFdpZHRoID49IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgdW5pZm9ybXMud19zaGFwZVsyXTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGluX2NoYW5uZWxfb2Zmc2V0ICsgd0luQ2hhbm5lbDtcbiAgICAgICAgICAgIGxldCB4VmFsID0gJHt4LmdldCgnYmF0Y2gnLCAneEhlaWdodCcsICd4V2lkdGgnLCAnaW5wdXRfY2hhbm5lbCcpfTtcbiAgICAgICAgICAgIGxldCB3VmFsID0gJHt3LmdldCgnd0hlaWdodCcsICd3V2lkdGgnLCAnd0luQ2hhbm5lbCcsICdvdXRwdXRfY2hhbm5lbCcpfTtcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYFxuICAgICAgOiBgXG4gICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdJbkNoYW5uZWwrKykge1xuICAgICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGluX2NoYW5uZWxfb2Zmc2V0ICsgd0luQ2hhbm5lbDtcbiAgICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SGVpZ2h0KyspIHtcbiAgICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzNdOyB3V2lkdGgrKykge1xuICAgICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzNdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7eC5nZXQoJ2JhdGNoJywgJ2lucHV0X2NoYW5uZWwnLCAneEhlaWdodCcsICd4V2lkdGgnKX07XG4gICAgICAgICAgICBsZXQgd1ZhbCA9ICR7dy5nZXQoJ291dHB1dF9jaGFubmVsJywgJ3dJbkNoYW5uZWwnLCAnd0hlaWdodCcsICd3V2lkdGgnKX07XG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgIGxldCBiYXRjaDogdTMyID0gb3V0cHV0SW5kaWNlc1swXTtcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWw6IHUzMiA9IG91dHB1dEluZGljZXNbJHtpc0NoYW5uZWxMYXN0ID8gMyA6IDF9XTtcbiAgICBsZXQgeFJDQ29ybmVyOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4ob3V0cHV0SW5kaWNlc1ske2lzQ2hhbm5lbExhc3QgPyAxIDogMn1dLCBvdXRwdXRJbmRpY2VzWyR7XG4gICAgICBpc0NoYW5uZWxMYXN0ID8gMiA6IDNcbiAgICB9XSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICBsZXQgZ3JvdXBfaWQ6IHUzMiA9IG91dHB1dF9jaGFubmVsICogJHtjb21wb25lbnRzfSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgdmFyIGluX2NoYW5uZWxfb2Zmc2V0ID0gZ3JvdXBfaWQgKiB1bmlmb3Jtcy53X3NoYXBlWyR7aXNDaGFubmVsTGFzdCA/IDIgOiAxfV07XG5cbiAgICB2YXIgdmFsdWU6ICR7b3V0cHV0LnR5cGUudmFsdWV9ID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XG4gICAgJHtjYWxjdWxhdGVSZXN1bHR9XG4gICAgJHtwcm9jZXNzQmlhc31cbiAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfVxuICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnR3JvdXBlZENvbnYnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9XyR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxuICAgICAgICAgIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVHcm91cGVkQ29udlZlY3Rvcml6ZVByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhvdXRwdXRTaGFwZVszXSk7XG4gIGNvbnN0IG91dHB1dE51bWJlciA9IGdldE1heENvbXBvbmVudHMob3V0cHV0U2hhcGVbMl0pO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cyAvIG91dHB1dE51bWJlcjtcbiAgY29uc3QgeFNoYXBlID0gW2lucHV0c1swXS5kaW1zWzBdLCBpbnB1dHNbMF0uZGltc1sxXSwgaW5wdXRzWzBdLmRpbXNbMl0sIGlucHV0c1swXS5kaW1zWzNdIC8gY29tcG9uZW50c107XG4gIGNvbnN0IHdTaGFwZSA9IFtpbnB1dHNbMV0uZGltc1swXSwgaW5wdXRzWzFdLmRpbXNbMV0sIGlucHV0c1sxXS5kaW1zWzJdLCBpbnB1dHNbMV0uZGltc1szXSAvIGNvbXBvbmVudHNdO1xuICBjb25zdCBvdXRwdXRTaGFwZUluU2hhZGVyID0gW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdIC8gY29tcG9uZW50c107XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogW2F0dHJpYnV0ZXMuc3RyaWRlc1swXSwgYXR0cmlidXRlcy5zdHJpZGVzWzFdXSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnBhZHNbMF0sIGF0dHJpYnV0ZXMucGFkc1sxXV0gfSxcbiAgXTtcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyh4U2hhcGUsIHdTaGFwZSwgb3V0cHV0U2hhcGVJblNoYWRlcikpO1xuICBjb25zdCB4TnVtYmVyID0gKG91dHB1dE51bWJlciAtIDEpICogYXR0cmlidXRlcy5zdHJpZGVzWzFdICsgd1NoYXBlWzFdO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZUluU2hhZGVyLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgYmFzZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUob3V0cHV0LnR5cGUudGVuc29yKTtcbiAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSwgYmFzZVR5cGUpO1xuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCB4U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgd1NoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5wdXRWYXJzID0gW3gsIHddO1xuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY29tcG9uZW50cykpO1xuICAgIH1cbiAgICBjb25zdCBwcm9jZXNzQmlhcyA9IGhhc0JpYXMgPyAndmFsdWUgKz0gYltvdXRwdXRfY2hhbm5lbF07JyA6ICcnO1xuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiAyIH0sXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMiB9LFxuICAgIF07XG4gICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgb3V0cHV0KX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICBsZXQgd2lkdGgwID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzNdO1xuICAgIGxldCBvdXRwdXRfY2hhbm5lbCA9IGdsb2JhbF9pZHggJSB3aWR0aDA7XG4gICAgdmFyIGluZGV4MSA9IGdsb2JhbF9pZHggLyB3aWR0aDA7XG4gICAgbGV0IHdpZHRoMSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsyXSAvICR7b3V0cHV0TnVtYmVyfXU7XG4gICAgbGV0IGNvbCA9IChpbmRleDEgJSB3aWR0aDEpICogJHtvdXRwdXROdW1iZXJ9dTtcbiAgICBpbmRleDEgPSBpbmRleDEgLyB3aWR0aDE7XG4gICAgbGV0IHJvdyA9IGluZGV4MSAlIHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXTtcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG5cbiAgICBsZXQgeF9jb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHJvdyksIGkzMihjb2wpKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuXG4gICAgdmFyIHhfdmFsczogYXJyYXk8JHt4LnR5cGUudmFsdWV9LCAke3hOdW1iZXJ9PjtcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXROdW1iZXJ9PjtcbiAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IG91dHB1dF9jaGFubmVsO1xuICAgIC8vIFVzZSBjb25zdGFudCBpbnN0ZWFkIG9mIHVuaWZvcm0gY2FuIGdpdmUgYmV0dGVyIHBlcmZvcm1hbmNlIGZvciB3J3MgaGVpZ2h0L3dpZHRoLlxuICAgIGZvciAodmFyIHdfaGVpZ2h0OiB1MzIgPSAwdTsgd19oZWlnaHQgPCAke3dTaGFwZVswXX07IHdfaGVpZ2h0KyspIHtcbiAgICAgIGxldCB4X2hlaWdodCA9IHhfY29ybmVyLnggKyBpMzIod19oZWlnaHQpO1xuICAgICAgaWYgKHhfaGVpZ2h0ID49IDAgJiYgdTMyKHhfaGVpZ2h0KSA8IHVuaWZvcm1zLnhfc2hhcGVbMV0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3hOdW1iZXJ9OyBpKyspIHtcbiAgICAgICAgICBsZXQgeF93aWR0aCA9IHhfY29ybmVyLnkgKyBpO1xuICAgICAgICAgIGlmICh4X3dpZHRoID49IDAgJiYgdTMyKHhfd2lkdGgpIDwgdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt4LmdldCgnYmF0Y2gnLCAndTMyKHhfaGVpZ2h0KScsICd1MzIoeF93aWR0aCknLCAnaW5wdXRfY2hhbm5lbCcpfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt4LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3X3dpZHRoOiB1MzIgPSAwdTsgd193aWR0aCA8ICR7d1NoYXBlWzFdfTsgd193aWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHdfdmFsID0gJHt3LmdldCgnd19oZWlnaHQnLCAnd193aWR0aCcsICcwJywgJ291dHB1dF9jaGFubmVsJyl9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7b3V0cHV0TnVtYmVyfXU7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gZm1hKHhfdmFsc1tpICogdTMyKHVuaWZvcm1zLnN0cmlkZXNbMV0pICsgd193aWR0aF0sIHdfdmFsLCB2YWx1ZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7b3V0cHV0TnVtYmVyfXU7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgJHtwcm9jZXNzQmlhc31cbiAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgJHtvdXRwdXQuc2V0KCdiYXRjaCcsICdyb3cnLCAnY29sICsgaScsICdvdXRwdXRfY2hhbm5lbCcsICd2YWx1ZScpfTtcbiAgICB9XG4gIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0dyb3VwZWRDb252LVZlY3Rvcml6ZScsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7Y29tcG9uZW50c307JHtvdXRwdXROdW1iZXJ9OyR7eE51bWJlcn07JHt3U2hhcGVbMF19OyR7d1NoYXBlWzFdfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogaGFzQmlhcyA/IFsncmFuaycsICdyYW5rJywgJ3R5cGUnXSA6IFsncmFuaycsICdyYW5rJ10sXG4gICAgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW1xuICAgICAgICB7XG4gICAgICAgICAgZGltczogc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24gPyBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbihvdXRwdXRTaGFwZSkgOiBvdXRwdXRTaGFwZSxcbiAgICAgICAgICBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgUG9vbENvbnZVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZUNvbnYyRE1hdE11bFByb2dyYW1JbmZvIH0gZnJvbSAnLi8zcmQtcGFydHkvY29udjJkX21tX3dlYmdwdSc7XG5pbXBvcnQgeyBjb21wdXRlQ29udjNESW5mbywgY3JlYXRlQ29udjNETmFpdmVQcm9ncmFtSW5mbyB9IGZyb20gJy4vM3JkLXBhcnR5L2NvbnYzZF9uYWl2ZV93ZWJncHUnO1xuaW1wb3J0IHsgY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8gfSBmcm9tICcuLzNyZC1wYXJ0eS9tYXRtdWxfcGFja2VkX3dlYmdwdSc7XG5pbXBvcnQgeyBjcmVhdGVHcm91cGVkQ29udlByb2dyYW1JbmZvLCBjcmVhdGVHcm91cGVkQ29udlZlY3Rvcml6ZVByb2dyYW1JbmZvIH0gZnJvbSAnLi9jb252LWdyb3VwZWQnO1xuaW1wb3J0IHsgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzIH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZU5haXZlTWF0bXVsUHJvZ3JhbUluZm8gfSBmcm9tICcuL21hdG11bC1zaGFkZXJzJztcbmltcG9ydCB7IGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvIH0gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlT3V0cHV0U2hhcGUgPSAoXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGFkanVzdFBhZHM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgaXNDaGFubmVsTGFzdDogYm9vbGVhbixcbik6IG51bWJlcltdID0+IHtcbiAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXRTaGFwZVswXTtcbiAgY29uc3QgaW5wdXRTcGF0aWFsU2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKGlzQ2hhbm5lbExhc3QgPyAxIDogMiwgaXNDaGFubmVsTGFzdCA/IDMgOiA0KTtcbiAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dFNwYXRpYWxTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IG91dENoYW5uZWxzID0ga2VybmVsU2hhcGVbMF07XG4gIGNvbnN0IGtlcm5lbFNwYXRpYWxTaGFwZSA9IGtlcm5lbFNoYXBlLnNsaWNlKDIpO1xuICBjb25zdCBkaWxhdGVkS2VybmVsU2hhcGUgPSBrZXJuZWxTcGF0aWFsU2hhcGUubWFwKCh2LCBpKSA9PiB2ICsgKHYgLSAxKSAqIChkaWxhdGlvbnNbaV0gLSAxKSk7XG4gIGNvbnN0IGlucHV0U3BhdGlhbFNoYXBlV2l0aFBhZCA9IGlucHV0U3BhdGlhbFNoYXBlLm1hcCgodiwgaSkgPT4gdiArIGFkanVzdFBhZHNbaV0gKyBhZGp1c3RQYWRzW2kgKyBzcGF0aWFsUmFua10pO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U3BhdGlhbFNoYXBlV2l0aFBhZC5tYXAoKHYsIGkpID0+XG4gICAgTWF0aC5mbG9vcigodiAtIGRpbGF0ZWRLZXJuZWxTaGFwZVtpXSArIHN0cmlkZXNbaV0pIC8gc3RyaWRlc1tpXSksXG4gICk7XG4gIG91dHB1dFNoYXBlLnNwbGljZSgwLCAwLCBiYXRjaFNpemUpO1xuICBvdXRwdXRTaGFwZS5zcGxpY2UoaXNDaGFubmVsTGFzdCA/IDMgOiAxLCAwLCBvdXRDaGFubmVscyk7XG4gIHJldHVybiBvdXRwdXRTaGFwZTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udkF0dHJpYnV0ZXMgZXh0ZW5kcyBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBhdXRvUGFkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IGZvcm1hdDogJ05IV0MnIHwgJ05DSFcnO1xuICByZWFkb25seSBncm91cDogbnVtYmVyO1xuICByZWFkb25seSBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHBhZHM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgd0lzQ29uc3Q6IGJvb2xlYW47XG59XG5cbi8vIGZvciB0cmFuc3Bvc2luZyB3ZWlnaHQgdGVuc29yIGZyb20gW00sIEMvZ3JvdXAsIEtILCBLV10gdG8gW0tILCBLVywgQy9ncm91cCwgTV1cbmNvbnN0IHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZSA9IFsyLCAzLCAxLCAwXTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIFJlZmVyIHRvIHRoZSBiZWxvdyBsaW5rIGZvciBhbGwgaW5wdXQgY2hlY2tzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYXN0ZXIvZG9jcy9PcGVyYXRvcnMubWQjQ29udlxuICBpZiAoIWlucHV0cyB8fCAoaW5wdXRzLmxlbmd0aCAhPT0gMiAmJiBpbnB1dHMubGVuZ3RoICE9PSAzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoID4gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ3JlYXRlciB0aGFuIDVEIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXQnKTtcbiAgfVxuXG4gIC8vIEZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcbiAgY29uc3QgZGF0YUNoYW5uZWwgPSBpbnB1dHNbMF0uZGltc1thdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnID8gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMSA6IDFdO1xuICBjb25zdCBmaWx0ZXJJbkNoYW5uZWwgPSBpbnB1dHNbMV0uZGltc1sxXSAqIGF0dHJpYnV0ZXMuZ3JvdXA7XG4gIGlmIChkYXRhQ2hhbm5lbCAhPT0gZmlsdGVySW5DaGFubmVsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMJyk7XG4gIH1cblxuICAvLyBpZiBiaWFzIGlzIHByb3ZpZGVkIGl0IHNob3VsZCBiZSAxRCBhbmQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzaG91bGQgYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBmZWF0dXJlIG1hcHNcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgKGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMSB8fCBpbnB1dHNbMV0uZGltc1swXSAhPT0gaW5wdXRzWzJdLmRpbXNbMF0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJpYXMnKTtcbiAgfVxuXG4gIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMjtcbiAgLy8gd3JvbmcgZGlsYXRpb25zIGRpbWVuc2lvblxuICBpZiAoYXR0cmlidXRlcy5kaWxhdGlvbnMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIC8vIFdyb25nIHN0cmlkZXMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICAvLyBXcm9uZyBwYWRzIGRpbWVuc2lvblxuICBpZiAoYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmsgKiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rICogMn1EYCk7XG4gIH1cblxuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBzcGVjaWZpZWQsIGl0J3MgZGF0YSBsZW5ndGggbXVzdCBiZSAyIGxlc3MgdGhhbiBkaW1zIGxlbmd0aCBvZiB0aGUgd2VpZ2h0cyB0ZW5zb3JcbiAgLy8gKHRoZSBmaXJzdCAyIGRpbXMgYXJlIGJhdGNoX3NpemUgYW5kIGNoYW5uZWxzKVxuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggIT09IDAgJiYgYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQga2VybmVsIHNoYXBlJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEFkanVzdGVkQ29udkF0dHJpYnV0ZXMgPSA8VCBleHRlbmRzIENvbnZBdHRyaWJ1dGVzPihhdHRyaWJ1dGVzOiBULCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFQgPT4ge1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUuc2xpY2UoKTtcbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgbm90IHdlbGwgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzLCBpbmZlciBpdCBmcm9tIHRoZSB3ZWlnaHQgdGVuc29yIGRpbXNcbiAgaWYgKGtlcm5lbFNoYXBlLmxlbmd0aCA8IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDIpIHtcbiAgICBrZXJuZWxTaGFwZS5wdXNoKC4uLkFycmF5KGlucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDIgLSBrZXJuZWxTaGFwZS5sZW5ndGgpLmZpbGwoMCkpO1xuICB9XG4gIGZvciAobGV0IGkgPSAyOyBpIDwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoa2VybmVsU2hhcGVbaSAtIDJdID09PSAwKSB7XG4gICAgICBrZXJuZWxTaGFwZVtpIC0gMl0gPSBpbnB1dHNbMV0uZGltc1tpXTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xuICBQb29sQ29udlV0aWwuYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKFxuICAgIGlucHV0c1swXS5kaW1zLFxuICAgIGF0dHJpYnV0ZXMuc3RyaWRlcyxcbiAgICBhdHRyaWJ1dGVzLmRpbGF0aW9ucyxcbiAgICBrZXJuZWxTaGFwZSxcbiAgICBwYWRzLFxuICAgIGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycsXG4gICAgYXR0cmlidXRlcy5hdXRvUGFkLFxuICApO1xuXG4gIC8vIGFsd2F5cyByZXR1cm4gYSBuZXcgb2JqZWN0IHNvIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwgYXR0cmlidXRlc1xuICBjb25zdCBuZXdBdHRyaWJ1dGVzOiBUID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyk7XG4gIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywgeyBrZXJuZWxTaGFwZSwgcGFkcyB9KTtcbiAgcmV0dXJuIG5ld0F0dHJpYnV0ZXM7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDb252QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IENvbnZBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgYWN0aXZhdGlvbkF0dHJpYnV0ZXMgPSBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gIC8vIFRPRE8gOiBNYWtlIHRoaXMgZ2VuZXJpYyBlbm91Z2ggdG8gY29tcHV0ZSBkZWZhdWx0IGF0dHJpYnV0ZXMgZm9yIG11bHRpLWRpbWVuc2lvbmFsIGNvbnZcbiAgY29uc3QgZm9ybWF0ID0gYXR0cmlidXRlcy5mb3JtYXQgYXMgJ05IV0MnIHwgJ05DSFcnO1xuICBjb25zdCBhdXRvUGFkID0gWydOT1RTRVQnLCAnVkFMSUQnLCAnU0FNRV9VUFBFUicsICdTQU1FX0xPV0VSJ11bYXR0cmlidXRlcy5hdXRvX3BhZCBhcyBudW1iZXJdO1xuICBjb25zdCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucyBhcyBudW1iZXJbXTtcbiAgY29uc3QgZ3JvdXAgPSBhdHRyaWJ1dGVzLmdyb3VwIGFzIG51bWJlcjtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbF9zaGFwZSBhcyBudW1iZXJbXTtcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcyBhcyBudW1iZXJbXTtcbiAgY29uc3Qgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBudW1iZXJbXTtcbiAgY29uc3Qgd0lzQ29uc3QgPSAoYXR0cmlidXRlcy53X2lzX2NvbnN0IGFzICgpID0+IGJvb2xlYW4pKCk7XG5cbiAgcmV0dXJuIHtcbiAgICBhdXRvUGFkLFxuICAgIGZvcm1hdCxcbiAgICBkaWxhdGlvbnMsXG4gICAgZ3JvdXAsXG4gICAga2VybmVsU2hhcGUsXG4gICAgcGFkcyxcbiAgICBzdHJpZGVzLFxuICAgIHdJc0NvbnN0LFxuICAgIC4uLmFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuICAgIGNhY2hlS2V5OiBgJHthdHRyaWJ1dGVzLmZvcm1hdH07JHthY3RpdmF0aW9uQXR0cmlidXRlcy5hY3RpdmF0aW9ufTtgLFxuICB9O1xufTtcblxuY29uc3QgY29udjJkID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdLFxuKTogdm9pZCA9PiB7XG4gIC8vIGNoZWNrIGF0dHJpYnV0ZXNcblxuICAvLyBjb25zdCBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gZmFsc2U7IC8qIFRPRE86IGFkZCBzdXBwb3J0IGZvciBwcmVsdSBhY3RpdmF0aW9uIHdlaWdodHMgKi9cbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZU91dHB1dFNoYXBlKFxuICAgIGlucHV0c1swXS5kaW1zLFxuICAgIGlucHV0c1sxXS5kaW1zLFxuICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zLFxuICAgIGF0dHJpYnV0ZXMucGFkcyxcbiAgICBhdHRyaWJ1dGVzLnN0cmlkZXMsXG4gICAgaXNDaGFubmVsc0xhc3QsXG4gICk7XG4gIGlmIChhdHRyaWJ1dGVzLmdyb3VwICE9PSAxKSB7XG4gICAgY29uc3QgY29udklucHV0cyA9IFtpbnB1dHNbMF1dO1xuICAgIGlmIChpc0NoYW5uZWxzTGFzdCkge1xuICAgICAgY29uc3QgdHJhbnNwb3NlZFdlaWdodCA9XG4gICAgICAgIChjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgYXMgVGVuc29yVmlldyB8IHVuZGVmaW5lZCkgPz9cbiAgICAgICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGlucHV0c1sxXSwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlKSwge1xuICAgICAgICAgIGlucHV0czogWzFdLFxuICAgICAgICAgIG91dHB1dHM6IFthdHRyaWJ1dGVzLndJc0NvbnN0ID8gLTIgOiAtMV0sXG4gICAgICAgIH0pWzBdO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMud0lzQ29uc3QgJiYgIWNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCkge1xuICAgICAgICBjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgPSB0cmFuc3Bvc2VkV2VpZ2h0O1xuICAgICAgfVxuICAgICAgY29udklucHV0cy5wdXNoKHRyYW5zcG9zZWRXZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb252SW5wdXRzLnB1c2goaW5wdXRzWzFdKTtcbiAgICB9XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGNvbnZJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xuICAgIH1cbiAgICAvLyBOVklESUEgR1BVIHdpdGggYW1wZXJlIGFyY2hpdGVjdHVyZSBmYWlscyB3aXRoIGJlbG93IDIgY2FzZXMsIGJ1dCB3ZSBjb3VsZG4ndCByZXBybyB0aGVtIHdpdGggYW55IG90aGVyXG4gICAgLy8gR1BVcy4gU28ganVzdCBkaXNhYmxlIHZlY3Rvcml6ZSBvbiBOVklESUEgYW1wZXJlIHRvIGVuc3VyZSBhbHdheXMgY29ycmVjdCBvdXRwdXRzLlxuICAgIC8vIFt3ZWJncHVdQ29udiAtIGNvbnYgLSB2ZWN0b3JpemUgZ3JvdXAgLSBCXG4gICAgLy8gW3dlYmdwdV1Db252IC0gY29udiAtIHZlY3Rvcml6ZSBncm91cCAtIERcbiAgICBjb25zdCBlbmFibGVHcm91cGVkQ29udlZlY3Rvcml6ZSA9ICFjb250ZXh0LmFkYXB0ZXJJbmZvLmlzQXJjaGl0ZWN0dXJlKCdhbXBlcmUnKTtcbiAgICBpZiAoXG4gICAgICBlbmFibGVHcm91cGVkQ29udlZlY3Rvcml6ZSAmJlxuICAgICAgaXNDaGFubmVsc0xhc3QgJiZcbiAgICAgIGlucHV0c1sxXS5kaW1zWzBdID09PSBhdHRyaWJ1dGVzLmdyb3VwICYmXG4gICAgICBpbnB1dHNbMV0uZGltc1sxXSA9PT0gMSAmJlxuICAgICAgYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gPT09IDEgJiZcbiAgICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdID09PSAxXG4gICAgKSB7XG4gICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgIGNyZWF0ZUdyb3VwZWRDb252VmVjdG9yaXplUHJvZ3JhbUluZm8oY29udklucHV0cywgYXR0cmlidXRlcywgb3V0cHV0U2hhcGUsIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKSxcbiAgICAgICAgeyBpbnB1dHM6IGNvbnZJbnB1dHMgfSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVHcm91cGVkQ29udlByb2dyYW1JbmZvKGNvbnZJbnB1dHMsIGF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlLCBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiksIHtcbiAgICAgICAgaW5wdXRzOiBjb252SW5wdXRzLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID09PSAzO1xuICBjb25zdCBpbnB1dEhlaWdodCA9IGlucHV0c1swXS5kaW1zW2lzQ2hhbm5lbHNMYXN0ID8gMSA6IDJdO1xuICBjb25zdCBpbnB1dFdpZHRoID0gaW5wdXRzWzBdLmRpbXNbaXNDaGFubmVsc0xhc3QgPyAyIDogM107XG4gIGNvbnN0IGlucHV0Q2hhbm5lbHMgPSBpbnB1dHNbMF0uZGltc1tpc0NoYW5uZWxzTGFzdCA/IDMgOiAxXTtcbiAgY29uc3Qgd2VpZ2h0SGVpZ2h0ID0gaW5wdXRzWzFdLmRpbXNbMl07XG4gIGNvbnN0IHdlaWdodFdpZHRoID0gaW5wdXRzWzFdLmRpbXNbM107XG5cbiAgY29uc3Qgb3V0SGVpZ2h0ID0gb3V0cHV0U2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl07XG4gIGNvbnN0IG91dFdpZHRoID0gb3V0cHV0U2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM107XG4gIGNvbnN0IG91dENoYW5uZWxzID0gb3V0cHV0U2hhcGVbaXNDaGFubmVsc0xhc3QgPyAzIDogMV07XG5cbiAgY29uc3Qgc2FtZVNpemUgPVxuICAgIGlzQ2hhbm5lbHNMYXN0ICYmXG4gICAgd2VpZ2h0SGVpZ2h0ID09PSBpbnB1dEhlaWdodCAmJlxuICAgIHdlaWdodFdpZHRoID09PSBpbnB1dFdpZHRoICYmXG4gICAgYXR0cmlidXRlcy5wYWRzWzBdID09PSAwICYmXG4gICAgYXR0cmlidXRlcy5wYWRzWzFdID09PSAwO1xuICBpZiAoXG4gICAgc2FtZVNpemUgfHxcbiAgICAod2VpZ2h0SGVpZ2h0ID09PSAxICYmXG4gICAgICB3ZWlnaHRXaWR0aCA9PT0gMSAmJlxuICAgICAgYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gPT09IDEgJiZcbiAgICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdID09PSAxICYmXG4gICAgICBhdHRyaWJ1dGVzLnN0cmlkZXNbMF0gPT09IDEgJiZcbiAgICAgIGF0dHJpYnV0ZXMuc3RyaWRlc1sxXSA9PT0gMSAmJlxuICAgICAgYXR0cmlidXRlcy5wYWRzWzBdID09PSAwICYmXG4gICAgICBhdHRyaWJ1dGVzLnBhZHNbMV0gPT09IDApXG4gICkge1xuICAgIC8vIGNvbnYyZEJ5TWF0TXVsXG4gICAgY29uc3QgYmF0Y2ggPSBvdXRwdXRTaGFwZVswXTtcbiAgICBsZXQgeFJlc2hhcGVkLCB3UmVzaGFwZWQsIG1hdG11bE91dHB1dFNoYXBlO1xuICAgIGNvbnN0IG1hdG11bElucHV0cyA9IFtdO1xuICAgIGlmIChpc0NoYW5uZWxzTGFzdCkge1xuICAgICAgY29uc3QgdHJhbnNwb3NlZFdlaWdodCA9XG4gICAgICAgIChjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgYXMgVGVuc29yVmlldyB8IHVuZGVmaW5lZCkgPz9cbiAgICAgICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGlucHV0c1sxXSwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlKSwge1xuICAgICAgICAgIGlucHV0czogWzFdLFxuICAgICAgICAgIG91dHB1dHM6IFthdHRyaWJ1dGVzLndJc0NvbnN0ID8gLTIgOiAtMV0sXG4gICAgICAgIH0pWzBdO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMud0lzQ29uc3QgJiYgIWNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCkge1xuICAgICAgICBjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgPSB0cmFuc3Bvc2VkV2VpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKHNhbWVTaXplKSB7XG4gICAgICAgIGNvbnN0IHNoYXJlZERpbSA9IGlucHV0SGVpZ2h0ICogaW5wdXRXaWR0aCAqIGlucHV0Q2hhbm5lbHM7XG4gICAgICAgIHhSZXNoYXBlZCA9IGlucHV0c1swXS5yZXNoYXBlKFsxLCBiYXRjaCwgc2hhcmVkRGltXSk7XG4gICAgICAgIHdSZXNoYXBlZCA9IHRyYW5zcG9zZWRXZWlnaHQucmVzaGFwZShbMSwgc2hhcmVkRGltLCBvdXRDaGFubmVsc10pO1xuICAgICAgICBtYXRtdWxPdXRwdXRTaGFwZSA9IFsxLCBiYXRjaCwgb3V0Q2hhbm5lbHNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeFJlc2hhcGVkID0gaW5wdXRzWzBdLnJlc2hhcGUoW2JhdGNoLCBpbnB1dEhlaWdodCAqIGlucHV0V2lkdGgsIGlucHV0Q2hhbm5lbHNdKTtcbiAgICAgICAgd1Jlc2hhcGVkID0gdHJhbnNwb3NlZFdlaWdodC5yZXNoYXBlKFsxLCBpbnB1dENoYW5uZWxzLCBvdXRDaGFubmVsc10pO1xuICAgICAgICBtYXRtdWxPdXRwdXRTaGFwZSA9IFtiYXRjaCwgb3V0SGVpZ2h0ICogb3V0V2lkdGgsIG91dENoYW5uZWxzXTtcbiAgICAgIH1cbiAgICAgIG1hdG11bElucHV0cy5wdXNoKHhSZXNoYXBlZCk7XG4gICAgICBtYXRtdWxJbnB1dHMucHVzaCh3UmVzaGFwZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4UmVzaGFwZWQgPSBpbnB1dHNbMF0ucmVzaGFwZShbYmF0Y2gsIGlucHV0Q2hhbm5lbHMsIGlucHV0SGVpZ2h0ICogaW5wdXRXaWR0aF0pO1xuICAgICAgd1Jlc2hhcGVkID0gaW5wdXRzWzFdLnJlc2hhcGUoWzEsIG91dENoYW5uZWxzLCBpbnB1dENoYW5uZWxzXSk7XG4gICAgICBtYXRtdWxPdXRwdXRTaGFwZSA9IFtiYXRjaCwgb3V0Q2hhbm5lbHMsIG91dEhlaWdodCAqIG91dFdpZHRoXTtcbiAgICAgIG1hdG11bElucHV0cy5wdXNoKHdSZXNoYXBlZCk7XG4gICAgICBtYXRtdWxJbnB1dHMucHVzaCh4UmVzaGFwZWQpO1xuICAgIH1cbiAgICBpZiAoaGFzQmlhcykge1xuICAgICAgbWF0bXVsSW5wdXRzLnB1c2goaW5wdXRzWzJdKTtcbiAgICB9XG4gICAgY29uc3QgTiA9IG1hdG11bE91dHB1dFNoYXBlWzJdO1xuICAgIGNvbnN0IEsgPSBtYXRtdWxJbnB1dHNbMF0uZGltc1ttYXRtdWxJbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxXTtcbiAgICAvLyBUdW5lIHRoZSB0aHJlc2hvbGQuXG4gICAgaWYgKE4gPCA4ICYmIEsgPCA4KSB7XG4gICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgIGNyZWF0ZU5haXZlTWF0bXVsUHJvZ3JhbUluZm8oXG4gICAgICAgICAgbWF0bXVsSW5wdXRzLFxuICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgb3V0cHV0U2hhcGUsXG4gICAgICAgICAgbWF0bXVsT3V0cHV0U2hhcGUsXG4gICAgICAgICAgaXNDaGFubmVsc0xhc3QsXG4gICAgICAgICAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24sXG4gICAgICAgICksXG4gICAgICAgIHsgaW5wdXRzOiBtYXRtdWxJbnB1dHMgfSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8oXG4gICAgICAgICAgbWF0bXVsSW5wdXRzLFxuICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgb3V0cHV0U2hhcGUsXG4gICAgICAgICAgbWF0bXVsT3V0cHV0U2hhcGUsXG4gICAgICAgICAgaXNDaGFubmVsc0xhc3QsXG4gICAgICAgICAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24sXG4gICAgICAgICksXG4gICAgICAgIHsgaW5wdXRzOiBtYXRtdWxJbnB1dHMgfSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IGltcGxlbWVudCBjb252MmRXaXRoSW0yQ29sKClcblxuICBjb25zdCBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzID0gLyogYmFja2VuZC5hZGFwdGVySW5mby5pc0ludGVsKCkgKi8gdHJ1ZTtcblxuICAvLyBTVEVQLjE6IHRyYW5zcG9zZSB3ZWlnaHRcbiAgY29uc3QgdHJhbnNwb3NlZFdlaWdodCA9XG4gICAgKGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCBhcyBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkKSA/P1xuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbnB1dHNbMV0sIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZSksIHtcbiAgICAgIGlucHV0czogWzFdLFxuICAgICAgb3V0cHV0czogW2F0dHJpYnV0ZXMud0lzQ29uc3QgPyAtMiA6IC0xXSxcbiAgICB9KVswXTtcbiAgaWYgKGF0dHJpYnV0ZXMud0lzQ29uc3QgJiYgIWNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCkge1xuICAgIGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCA9IHRyYW5zcG9zZWRXZWlnaHQ7XG4gIH1cblxuICAvLyBTVEVQLjI6IHByZXBhcmUgcmVzaGFwZWQgaW5wdXRzXG4gIGNvbnN0IGNvbnZJbnB1dHMgPSBbaW5wdXRzWzBdLCB0cmFuc3Bvc2VkV2VpZ2h0XTtcbiAgaWYgKGhhc0JpYXMpIHtcbiAgICBjb252SW5wdXRzLnB1c2goaW5wdXRzWzJdKTtcbiAgfVxuXG4gIC8vIFNURVAuMzogY29tcHV0ZSBtYXRtdWxcbiAgY29uc3QgZGltQU91dGVyID0gaXNDaGFubmVsc0xhc3QgPyBvdXRIZWlnaHQgKiBvdXRXaWR0aCA6IG91dENoYW5uZWxzO1xuICBjb25zdCBkaW1CT3V0ZXIgPSBpc0NoYW5uZWxzTGFzdCA/IG91dENoYW5uZWxzIDogb3V0SGVpZ2h0ICogb3V0V2lkdGg7XG4gIGNvbnN0IGRpbUlubmVyID0gd2VpZ2h0SGVpZ2h0ICogd2VpZ2h0V2lkdGggKiBpbnB1dENoYW5uZWxzO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlQ29udjJETWF0TXVsUHJvZ3JhbUluZm8oXG4gICAgICBjb252SW5wdXRzLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIG91dHB1dFNoYXBlLFxuICAgICAgZGltQU91dGVyLFxuICAgICAgZGltQk91dGVyLFxuICAgICAgZGltSW5uZXIsXG4gICAgICBoYXNCaWFzLFxuICAgICAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyxcbiAgICAgIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uLFxuICAgICksXG4gICAgeyBpbnB1dHM6IGNvbnZJbnB1dHMgfSxcbiAgKTtcbn07XG5cbmNvbnN0IGNvbnYxZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gZXh0ZW5kIHRoZSBpbnB1dCB0byAyRCBieSBhZGRpbmcgSCBkaW1lbnNpb25cbiAgY29uc3QgaXNDaGFubmVsTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGlucHV0cyA9IFtcbiAgICBjb250ZXh0LmlucHV0c1swXS5yZXNoYXBlKFxuICAgICAgaXNDaGFubmVsTGFzdFxuICAgICAgICA/IC8vIFtOLCBXLCBDXSAtPiBbTiwgSD0xLCBXLCBDXVxuICAgICAgICAgIFtjb250ZXh0LmlucHV0c1swXS5kaW1zWzBdLCAxLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzFdLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzJdXVxuICAgICAgICA6IC8vIFtOLCBDLCBXXSAtPiBbTiwgQywgSD0xLCBXXVxuICAgICAgICAgIFtjb250ZXh0LmlucHV0c1swXS5kaW1zWzBdLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzFdLCAxLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzJdXSxcbiAgICApLFxuICAgIC8vW0ZJTFRFUl9PVVRfQ0hBTk5FTCwgRklMVEVSX0lOX0NIQU5ORUwsIGtXXSAtPiBbRklMVEVSX09VVF9DSEFOTkVMLCBGSUxURVJfSU5fQ0hBTk5FTCwga0g9MSwga1ddXG4gICAgY29udGV4dC5pbnB1dHNbMV0ucmVzaGFwZShbY29udGV4dC5pbnB1dHNbMV0uZGltc1swXSwgY29udGV4dC5pbnB1dHNbMV0uZGltc1sxXSwgMSwgY29udGV4dC5pbnB1dHNbMV0uZGltc1syXV0pLFxuICBdO1xuICBpZiAoY29udGV4dC5pbnB1dHMubGVuZ3RoID09PSAzKSB7XG4gICAgaW5wdXRzLnB1c2goY29udGV4dC5pbnB1dHNbMl0pO1xuICB9XG4gIGNvbnN0IHBhZHMgPSBbMCwgYXR0cmlidXRlcy5wYWRzWzBdLCAwLCBhdHRyaWJ1dGVzLnBhZHNbMV1dO1xuICBjb25zdCBzdHJpZGVzID0gWzFdLmNvbmNhdChhdHRyaWJ1dGVzLnN0cmlkZXMpO1xuICBjb25zdCBkaWxhdGlvbnMgPSBbMV0uY29uY2F0KGF0dHJpYnV0ZXMuZGlsYXRpb25zKTtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBbMV0uY29uY2F0KGF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xuICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZBdHRyaWJ1dGVzKFxuICAgIHsgLi4uYXR0cmlidXRlcywgcGFkcywgc3RyaWRlcywgZGlsYXRpb25zLCBrZXJuZWxTaGFwZSB9LFxuICAgIGlucHV0cyxcbiAgKTtcbiAgY29udjJkKGNvbnRleHQsIGlucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzLCAob3V0cHV0U2hhcGUpID0+XG4gICAgaXNDaGFubmVsTGFzdCA/IFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdXSA6IFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMV0sIG91dHB1dFNoYXBlWzNdXSxcbiAgKTtcbn07XG5cbmNvbnN0IGNvbnYzZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGZvcm1hdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycgPyAnY2hhbm5lbHNMYXN0JyA6ICdjaGFubmVsc0ZpcnN0JztcbiAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBpbnB1dHMpO1xuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5hdXRvUGFkID09PSAnTk9UU0VUJyA/IGF0dHJpYnV0ZXMucGFkcyA6IGF0dHJpYnV0ZXMuYXV0b1BhZDtcbiAgY29uc3QgY29udkluZm8gPSBjb21wdXRlQ29udjNESW5mbyhcbiAgICBpbnB1dHNbMF0uZGltcyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgIGlucHV0c1sxXS5kaW1zIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgYXR0cmlidXRlcy5zdHJpZGVzIGFzIG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICBhdHRyaWJ1dGVzLmRpbGF0aW9ucyBhcyBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgcGFkcyBhcyBzdHJpbmcgfCBudW1iZXJbXSxcbiAgICBmYWxzZSxcbiAgICBmb3JtYXQsXG4gICk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVDb252M0ROYWl2ZVByb2dyYW1JbmZvKFxuICAgICAgaW5wdXRzLFxuICAgICAgYWRqdXN0ZWRBdHRyaWJ1dGVzLFxuICAgICAgY29udkluZm8ub3V0U2hhcGUsXG4gICAgICBbY29udkluZm8uZmlsdGVyRGVwdGgsIGNvbnZJbmZvLmZpbHRlckhlaWdodCwgY29udkluZm8uZmlsdGVyV2lkdGhdLFxuICAgICAgW2NvbnZJbmZvLnBhZEluZm8uZnJvbnQsIGNvbnZJbmZvLnBhZEluZm8udG9wLCBjb252SW5mby5wYWRJbmZvLmxlZnRdLFxuICAgICAgZm9ybWF0LFxuICAgICksXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgY29udiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICBjb252MWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICBjb252M2QoY29udGV4dCwgY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udkF0dHJpYnV0ZXMoYXR0cmlidXRlcywgY29udGV4dC5pbnB1dHMpO1xuICAgIGNvbnYyZChjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzKTtcbiAgfVxufTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvY29udl9iYWNrcHJvcF93ZWJncHUudHNcblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi8uLi8uLi9sb2cnO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxuICBnZXRNYXhDb21wb25lbnRzLFxufSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgfSBmcm9tICcuLi9jb252LXRyYW5zcG9zZSc7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzLFxuICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYXR0cmlidXRlcy5vdXRwdXRTaGFwZTtcbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBncm91cCA9IGF0dHJpYnV0ZXMuZ3JvdXA7XG4gIGNvbnN0IHdTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCBpbnB1dENoYW5uZWxzUGVyR3JvdXAgPSB3U2hhcGVbMl0gLyBncm91cDtcbiAgY29uc3Qgb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCA9IHdTaGFwZVszXTtcbiAgY29uc3QgYUNvbXBvbmVudHMgPSBpc0NoYW5uZWxzTGFzdCA/IGdldE1heENvbXBvbmVudHMoaW5wdXRDaGFubmVsc1Blckdyb3VwKSA6IDE7XG4gIGNvbnN0IHBhY2tJbnB1dEFzNCA9IGlzQ2hhbm5lbHNMYXN0ICYmIG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPT09IDEgJiYgaW5wdXRDaGFubmVsc1Blckdyb3VwID49IDQ7XG4gIGNvbnN0IGlucHV0Q2hhbm5lbHNQZXJHcm91cEludCA9IHBhY2tJbnB1dEFzNFxuICAgID8gTWF0aC5mbG9vcihpbnB1dENoYW5uZWxzUGVyR3JvdXAgLyA0KSAqIDRcbiAgICA6IE1hdGguZmxvb3IoaW5wdXRDaGFubmVsc1Blckdyb3VwIC8gYUNvbXBvbmVudHMpICogYUNvbXBvbmVudHM7XG4gIGNvbnN0IGlucHV0Q2hhbm5lbHNSZW1haW5kZXIgPSBpbnB1dENoYW5uZWxzUGVyR3JvdXAgLSBpbnB1dENoYW5uZWxzUGVyR3JvdXBJbnQ7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBpc0NoYW5uZWxzTGFzdCA/IGdldE1heENvbXBvbmVudHMob3V0cHV0Q2hhbm5lbHNQZXJHcm91cCkgOiAxO1xuICBjb25zdCBiQ29tcG9uZW50cyA9IGlzQ2hhbm5lbHNMYXN0ID8gKG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPT09IDEgPyBhQ29tcG9uZW50cyA6IGNvbXBvbmVudHMpIDogMTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHM7XG4gIGNvbnN0IGRpc3BhdGNoID0gW01hdGguY2VpbChvdXRwdXRTaXplIC8gNjQpLCAxLCAxXTtcbiAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtjb252MmRfYmFja3Byb3Bfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7ZGlzcGF0Y2h9YCk7XG5cbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnLCAncmFuayddO1xuICBjb25zdCBzdHJpZGVzID0gW2F0dHJpYnV0ZXMuc3RyaWRlc1swXSwgYXR0cmlidXRlcy5zdHJpZGVzWzFdXTtcbiAgY29uc3QgZmlsdGVyRGltcyA9IFthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMSA6IDJdLCBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMiA6IDNdXTtcbiAgY29uc3QgZGlsYXRpb25zID0gW2F0dHJpYnV0ZXMuZGlsYXRpb25zWzBdLCBhdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXV07XG4gIGNvbnN0IGVmZmVjdGl2ZUZpbHRlckRpbXMgPSBbXG4gICAgZmlsdGVyRGltc1swXSArXG4gICAgICAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gPD0gMVxuICAgICAgICA/IDBcbiAgICAgICAgOiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDEgOiAyXSAtIDEpICogKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzBdIC0gMSkpLFxuICAgIGZpbHRlckRpbXNbMV0gK1xuICAgICAgKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdIDw9IDFcbiAgICAgICAgPyAwXG4gICAgICAgIDogKGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM10gLSAxKSAqIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXSAtIDEpKSxcbiAgXTtcbiAgY29uc3QgcGFkcyA9IFtcbiAgICBlZmZlY3RpdmVGaWx0ZXJEaW1zWzBdIC0gMSAtIE1hdGguZmxvb3IoKGF0dHJpYnV0ZXMucGFkc1swXSArIGF0dHJpYnV0ZXMucGFkc1syXSkgLyAyKSxcbiAgICBlZmZlY3RpdmVGaWx0ZXJEaW1zWzFdIC0gMSAtIE1hdGguZmxvb3IoKGF0dHJpYnV0ZXMucGFkc1sxXSArIGF0dHJpYnV0ZXMucGFkc1szXSkgLyAyKSxcbiAgXTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc3RyaWRlcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBmaWx0ZXJEaW1zIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGRpbGF0aW9ucyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBlZmZlY3RpdmVGaWx0ZXJEaW1zIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogcGFkcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBpbnB1dENoYW5uZWxzUGVyR3JvdXBJbnQgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaW5wdXRDaGFubmVsc1Blckdyb3VwIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpLFxuICBdO1xuICBpZiAoaGFzQmlhcykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IHN0cmlkZXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdmaWx0ZXJfZGltcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGZpbHRlckRpbXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdkaWxhdGlvbnMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBmaWx0ZXJEaW1zLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnZWZmZWN0aXZlX2ZpbHRlcl9kaW1zJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZWZmZWN0aXZlRmlsdGVyRGltcy5sZW5ndGggfSxcbiAgICAgIHsgbmFtZTogJ3BhZHMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiBwYWRzLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwX2ludCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdpbnB1dF9jaGFubmVsc19wZXJfZ3JvdXAnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnb3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cCcsIHR5cGU6ICd1MzInIH0sXG4gICAgXTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuICAgIGNvbnN0IHJvd0RpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMSA6IDI7XG4gICAgY29uc3QgY29sRGltID0gaXNDaGFubmVsc0xhc3QgPyAyIDogMztcbiAgICBjb25zdCBjaGFubmVsRGltID0gaXNDaGFubmVsc0xhc3QgPyAzIDogMTtcblxuICAgIGNvbnN0IHcgPSBpbnB1dFZhcmlhYmxlKCdXJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgsIGJDb21wb25lbnRzKTtcbiAgICBjb25zdCBkeSA9IGlucHV0VmFyaWFibGUoJ0R5JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgsIGFDb21wb25lbnRzKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFtkeSwgd107XG4gICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgW291dHB1dFNoYXBlW2NoYW5uZWxEaW1dXS5sZW5ndGgsIGNvbXBvbmVudHMpKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcblxuICAgIGNvbnN0IGNhbGN1bGF0ZVJlc3VsdCA9ICgpOiBzdHJpbmcgPT4ge1xuICAgICAgbGV0IGNhbGNTdHIgPSAnJztcbiAgICAgIGlmIChwYWNrSW5wdXRBczQpIHtcbiAgICAgICAgaWYgKGFDb21wb25lbnRzID09PSA0KSB7XG4gICAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgIGxldCB4VmFsdWUgPSAke2R5LmdldEJ5T2Zmc2V0KCd4X29mZnNldCcpfTtcbiAgICAgICAgbGV0IHdWYWx1ZSA9ICR7dy5nZXRCeU9mZnNldCgnd19vZmZzZXQnKX07XG4gICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgZG90KHhWYWx1ZSwgd1ZhbHVlKTtcbiAgICAgICAgeF9vZmZzZXQgKz0gMXU7XG4gICAgICAgIHdfb2Zmc2V0ICs9IDF1O2A7XG4gICAgICAgIH0gZWxzZSBpZiAoYUNvbXBvbmVudHMgPT09IDIpIHtcbiAgICAgICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIGRvdCh2ZWM0PCR7ZGF0YVR5cGV9Pigke2R5LmdldEJ5T2Zmc2V0KCd4X29mZnNldCcpfSwgJHtkeS5nZXRCeU9mZnNldCgneF9vZmZzZXQgKyAxdScpfSksIHZlYzQ8JHtkYXRhVHlwZX0+KCR7dy5nZXRCeU9mZnNldCgnd19vZmZzZXQnKX0sICR7dy5nZXRCeU9mZnNldCgnd19vZmZzZXQgKyAxdScpfSkpO1xuICAgICAgICAgIHhfb2Zmc2V0ICs9IDJ1O1xuICAgICAgICAgIHdfb2Zmc2V0ICs9IDJ1O2A7XG4gICAgICAgIH0gZWxzZSBpZiAoYUNvbXBvbmVudHMgPT09IDEpIHtcbiAgICAgICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIGRvdCh2ZWM0PCR7ZGF0YVR5cGV9Pigke2R5LmdldEJ5T2Zmc2V0KCd4X29mZnNldCcpfSwgJHtkeS5nZXRCeU9mZnNldCgneF9vZmZzZXQgKyAxdScpfSwgJHtkeS5nZXRCeU9mZnNldCgneF9vZmZzZXQgKyAydScpfSwgJHtkeS5nZXRCeU9mZnNldCgneF9vZmZzZXQgKyAzdScpfSksIHZlYzQ8JHtkYXRhVHlwZX0+KCR7dy5nZXRCeU9mZnNldCgnd19vZmZzZXQnKX0sICR7dy5nZXRCeU9mZnNldCgnd19vZmZzZXQgKyAxdScpfSwgJHt3LmdldEJ5T2Zmc2V0KCd3X29mZnNldCArIDJ1Jyl9LCAke3cuZ2V0QnlPZmZzZXQoJ3dfb2Zmc2V0ICsgM3UnKX0pKTtcbiAgICAgICAgICB4X29mZnNldCArPSA0dTtcbiAgICAgICAgICB3X29mZnNldCArPSA0dTtgO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICAgICAgICAgIGxldCB4VmFsdWUgPSAke1xuICAgICAgICAgICAgICAgICAgICBpc0NoYW5uZWxzTGFzdFxuICAgICAgICAgICAgICAgICAgICAgID8gZHkuZ2V0QnlPZmZzZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGAke2R5LmluZGljZXNUb09mZnNldChgJHtkeS50eXBlLmluZGljZXN9KGJhdGNoLCBpZHlSLCBpZHlDLCBpbnB1dENoYW5uZWwpYCl9IC8gJHthQ29tcG9uZW50c31gLFxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIDogZHkuZ2V0KCdiYXRjaCcsICdpbnB1dENoYW5uZWwnLCAnaWR5UicsICdpZHlDJylcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgIGA7XG4gICAgICAgIGlmIChhQ29tcG9uZW50cyA9PT0gMSkge1xuICAgICAgICAgIGNhbGNTdHIgKz0gYFxuICAgICAgICAgIGxldCB3X29mZnNldCA9ICR7dy5pbmRpY2VzVG9PZmZzZXQoYCR7dy50eXBlLmluZGljZXN9KHUzMih3UlBlcm0pLCB1MzIod0NQZXJtKSwgaW5wdXRDaGFubmVsLCB3T3V0Q2hhbm5lbClgKX07XG4gICAgICAgICAgbGV0IHdWYWx1ZSA9ICR7dy5nZXRCeU9mZnNldChgd19vZmZzZXQgLyAke2JDb21wb25lbnRzfWApfTtcbiAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZSAqIHdWYWx1ZTtgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgYUNvbXBvbmVudHM7IGMrKykge1xuICAgICAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICBsZXQgd1ZhbHVlJHtjfSA9ICR7dy5nZXRCeU9mZnNldChgJHt3LmluZGljZXNUb09mZnNldChgJHt3LnR5cGUuaW5kaWNlc30odTMyKHdSUGVybSksIHUzMih3Q1Blcm0pLCBpbnB1dENoYW5uZWwgKyAke2N9LCB3T3V0Q2hhbm5lbClgKX0gLyAke2JDb21wb25lbnRzfWApfTtcbiAgICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgeFZhbHVlWyR7Y31dICogd1ZhbHVlJHtjfTtgO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGNTdHI7XG4gICAgfTtcbiAgICBjb25zdCBjYWxjdWxhdGVSZW1haW5kZXIgPSAoKTogc3RyaW5nID0+IHtcbiAgICAgIGlmIChpbnB1dENoYW5uZWxzUmVtYWluZGVyID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGlmICghcGFja0lucHV0QXM0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFja0lucHV0QXM0ICR7cGFja0lucHV0QXM0fSBpcyBub3QgdHJ1ZS5gKTtcbiAgICAgIH1cbiAgICAgIGxldCBjYWxjU3RyID0gJyc7XG4gICAgICBpZiAoYUNvbXBvbmVudHMgPT09IDEpIHtcbiAgICAgICAgY2FsY1N0ciArPSAnZG90UHJvZCA9IGRvdFByb2QnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q2hhbm5lbHNSZW1haW5kZXI7IGkrKykge1xuICAgICAgICAgIGNhbGNTdHIgKz0gYFxuICAgICAgICAgICAgKyAke2R5LmdldEJ5T2Zmc2V0KGB4X29mZnNldCArICR7aX1gKX0gKiAke3cuZ2V0QnlPZmZzZXQoYHdfb2Zmc2V0ICsgJHtpfWApfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2FsY1N0ciArPSAnOyc7XG4gICAgICB9IGVsc2UgaWYgKGFDb21wb25lbnRzID09PSAyKSB7XG4gICAgICAgIGlmIChpbnB1dENoYW5uZWxzUmVtYWluZGVyICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGlucHV0Q2hhbm5lbHNSZW1haW5kZXIgJHtpbnB1dENoYW5uZWxzUmVtYWluZGVyfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICBsZXQgeFZhbHVlID0gJHtkeS5nZXRCeU9mZnNldCgneF9vZmZzZXQnKX07XG4gICAgICAgICAgbGV0IHdWYWx1ZSA9ICR7dy5nZXRCeU9mZnNldCgnd19vZmZzZXQnKX07XG4gICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyBkb3QoeFZhbHVlLCB3VmFsdWUpO2A7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsY1N0cjtcbiAgICB9O1xuICAgIGNvbnN0IGNvZGVTbmlwcGV0ID0gYFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke2NvbXBvbmVudHN9YCl9O1xuICAgICAgICAgICAgbGV0IGJhdGNoID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIDApfTtcbiAgICAgICAgICAgIGxldCBkMSA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dEluZGljZXMnLCBjaGFubmVsRGltKX07XG4gICAgICAgICAgICBsZXQgciA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dEluZGljZXMnLCByb3dEaW0pfTtcbiAgICAgICAgICAgIGxldCBjID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIGNvbERpbSl9O1xuICAgICAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICBsZXQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgICAgIGxldCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICAgICAgbGV0IGdyb3VwSWQgPSBkMSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICBsZXQgd091dENoYW5uZWwgPSBkMSAtIGdyb3VwSWQgKiB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXG4gICAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgICAgIHZhciBkb3RQcm9kID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMC4wKTtcbiAgICAgICAgICAgIHZhciB3UjogdTMyID0gMDtcbiAgICAgICAgICAgIGlmICh1bmlmb3Jtcy5kaWxhdGlvbnMueCA9PSAxKSB7XG4gICAgICAgICAgICAgIC8vIE1pbmltdW0gd1IgPj0gMCB0aGF0IHNhdGlzZmllcyAoZHlSQ29ybmVyICsgd1IpICUgKHVuaWZvcm1zLnN0cmlkZXMueCkgPT0gMFxuICAgICAgICAgICAgICB3UiA9IHUzMigoKGR5UkNvcm5lciArIGkzMih1bmlmb3Jtcy5zdHJpZGVzLngpIC0gMSkgLyBpMzIodW5pZm9ybXMuc3RyaWRlcy54KSkgKiBpMzIodW5pZm9ybXMuc3RyaWRlcy54KSAtIGR5UkNvcm5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgd1IgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueDsgd1IgPSB3UiArIDEpIHtcbiAgICAgICAgICAgICAgaWYgKHdSICUgdW5pZm9ybXMuZGlsYXRpb25zLnggIT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBkeVIgPSAoJHtkYXRhVHlwZX0oZHlSQ29ybmVyKSArICR7ZGF0YVR5cGV9KHdSKSkgLyAke2RhdGFUeXBlfSh1bmlmb3Jtcy5zdHJpZGVzWzBdKTtcbiAgICAgICAgICAgICAgbGV0IHdSUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnggLSAxIC0gd1IgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueDtcbiAgICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtkYXRhVHlwZX0odW5pZm9ybXMuRHlfc2hhcGVbJHtyb3dEaW19XSkgfHwgZnJhY3QoZHlSKSA+IDAuMCB8fFxuICAgICAgICAgICAgICAgICAgd1JQZXJtIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBpZHlSOiB1MzIgPSB1MzIoZHlSKTtcbiAgICAgICAgICAgICAgdmFyIHdDOiB1MzIgPSAwO1xuICAgICAgICAgICAgICBpZiAodW5pZm9ybXMuZGlsYXRpb25zLnkgPT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIE1pbmltdW0gd0MgPj0gMCB0aGF0IHNhdGlzZmllcyAoZHlDQ29ybmVyICsgd0MpICUgKHVuaWZvcm1zLnN0cmlkZXMueSkgPT0gMFxuICAgICAgICAgICAgICAgIHdDID0gdTMyKCgoZHlDQ29ybmVyICsgaTMyKHVuaWZvcm1zLnN0cmlkZXMueSkgLSAxKSAvIGkzMih1bmlmb3Jtcy5zdHJpZGVzLnkpKSAqIGkzMih1bmlmb3Jtcy5zdHJpZGVzLnkpIC0gZHlDQ29ybmVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKDsgd0MgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueTsgd0MgPSB3QyArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAod0MgJSB1bmlmb3Jtcy5kaWxhdGlvbnMueSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGR5QyA9ICgke2RhdGFUeXBlfShkeUNDb3JuZXIpICsgJHtkYXRhVHlwZX0od0MpKSAvICR7ZGF0YVR5cGV9KHVuaWZvcm1zLnN0cmlkZXMueSk7XG4gICAgICAgICAgICAgICAgbGV0IHdDUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnkgLSAxIC0gd0MgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueTtcbiAgICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2RhdGFUeXBlfSh1bmlmb3Jtcy5EeV9zaGFwZVske2NvbERpbX1dKSB8fFxuICAgICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wIHx8IHdDUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaWR5QzogdTMyID0gdTMyKGR5Qyk7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0Q2hhbm5lbCA9IGdyb3VwSWQgKiB1bmlmb3Jtcy5pbnB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICAgIHBhY2tJbnB1dEFzNFxuICAgICAgICAgICAgICAgICAgICA/IGBcbiAgICAgICAgICAgICAgICB2YXIgeF9vZmZzZXQgPSAke2R5LmluZGljZXNUb09mZnNldChgJHtkeS50eXBlLmluZGljZXN9KGJhdGNoLCBpZHlSLCBpZHlDLCBpbnB1dENoYW5uZWwpYCl9IC8gJHthQ29tcG9uZW50c307XG4gICAgICAgICAgICAgICAgdmFyIHdfb2Zmc2V0ID0gJHt3LmluZGljZXNUb09mZnNldChgJHt3LnR5cGUuaW5kaWNlc30od1JQZXJtLCB3Q1Blcm0sIGlucHV0Q2hhbm5lbCwgd091dENoYW5uZWwpYCl9IC8gJHtiQ29tcG9uZW50c307XG4gICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgIDogJydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwX2ludDsgZDIgPSBkMiArICR7cGFja0lucHV0QXM0ID8gNCA6IGFDb21wb25lbnRzfSkge1xuICAgICAgICAgICAgICAgICAgJHtjYWxjdWxhdGVSZXN1bHQoKX1cbiAgICAgICAgICAgICAgICAgIGlucHV0Q2hhbm5lbCA9IGlucHV0Q2hhbm5lbCArICR7cGFja0lucHV0QXM0ID8gNCA6IGFDb21wb25lbnRzfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHtjYWxjdWxhdGVSZW1haW5kZXIoKX1cbiAgICAgICAgICAgICAgICB3QyA9IHdDICsgdW5pZm9ybXMuc3RyaWRlcy55IC0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3UiA9IHdSICsgdW5pZm9ybXMuc3RyaWRlc1swXSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kJHtoYXNCaWFzID8gYCArIGJpYXNbZDEgLyAke2NvbXBvbmVudHN9XWAgOiAnJ307XG4gICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfTtcbiAgICAgICAgICBgO1xuXG4gICAgcmV0dXJuIGBcbiAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfTtcbiAgICAke2NvZGVTbmlwcGV0fX1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0NvbnZUcmFuc3Bvc2UyRCcsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7YUNvbXBvbmVudHN9JHtiQ29tcG9uZW50c30ke2NvbXBvbmVudHN9JHtwYWNrSW5wdXRBczR9JHtpbnB1dENoYW5uZWxzUmVtYWluZGVyfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llcyxcbiAgICB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IGRpc3BhdGNoWzBdLCB5OiBkaXNwYXRjaFsxXSwgejogZGlzcGF0Y2hbMl0gfSxcbiAgICAgIG91dHB1dHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyB9IGZyb20gJy4vM3JkLXBhcnR5L2NvbnZfYmFja3Byb3Bfd2ViZ3B1JztcbmltcG9ydCB7IENvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi9jb252JztcbmltcG9ydCB7IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyB9IGZyb20gJy4vZnVzZS11dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyB9IGZyb20gJy4vdHJhbnNwb3NlJztcblxuY29uc3QgY29tcHV0ZVRvdGFsUGFkID0gKFxuICBpbkRpbTogbnVtYmVyLFxuICBzdHJpZGU6IG51bWJlcixcbiAgYWRqOiBudW1iZXIsXG4gIGtlcm5lbDogbnVtYmVyLFxuICBkaWxhdGlvbjogbnVtYmVyLFxuICBvdXRTaXplOiBudW1iZXIsXG4pID0+IChpbkRpbSAtIDEpICogc3RyaWRlICsgYWRqICsgKGtlcm5lbCAtIDEpICogZGlsYXRpb24gKyAxIC0gb3V0U2l6ZTtcblxuY29uc3QgZGlzdHJpYnV0ZVBhZGRpbmcgPSAodG90YWxQYWQ6IG51bWJlciwgYXV0b1BhZDogc3RyaW5nLCBwYWRzOiBudW1iZXJbXSwgaGVhZDogbnVtYmVyLCB0YWlsOiBudW1iZXIpID0+IHtcbiAgY29uc3Qgc21hbGxQYWQgPSBNYXRoLmZsb29yKHRvdGFsUGFkIC8gMik7XG4gIGlmIChhdXRvUGFkID09PSAnU0FNRV9VUFBFUicpIHtcbiAgICBwYWRzW2hlYWRdID0gc21hbGxQYWQ7XG4gICAgcGFkc1t0YWlsXSA9IHRvdGFsUGFkIC0gc21hbGxQYWQ7XG4gIH0gZWxzZSBpZiAoYXV0b1BhZCA9PT0gJ1NBTUVfTE9XRVInKSB7XG4gICAgcGFkc1toZWFkXSA9IHRvdGFsUGFkIC0gc21hbGxQYWQ7XG4gICAgcGFkc1t0YWlsXSA9IHNtYWxsUGFkO1xuICB9XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZUFuZFBhZHMgPSAoXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGF1dG9QYWQ6IHN0cmluZyxcbiAgZ3JvdXA6IG51bWJlcixcbiAgcGFkczogbnVtYmVyW10sXG4gIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBpc0NoYW5uZWxMYXN0OiBib29sZWFuLFxuICBvdXRwdXRQYWRkaW5nOiBudW1iZXJbXSxcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdLFxuKSA9PiB7XG4gIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGggLSAyO1xuICBjb25zdCB1cGRhdGVPdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlLmxlbmd0aCA9PT0gMDtcbiAgaWYgKG91dHB1dFBhZGRpbmcubGVuZ3RoIDwgc3BhdGlhbFJhbmspIHtcbiAgICBvdXRwdXRQYWRkaW5nLnB1c2goLi4uQXJyYXkoc3BhdGlhbFJhbmsgLSBvdXRwdXRQYWRkaW5nLmxlbmd0aCkuZmlsbCgwKSk7XG4gIH1cbiAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXRTaGFwZVswXTtcbiAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBrZXJuZWxTaGFwZVtpc0NoYW5uZWxMYXN0ID8gMyA6IDFdICogZ3JvdXA7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gaW5wdXRTaGFwZS5sZW5ndGggLSBzcGF0aWFsUmFuayAtIChpc0NoYW5uZWxMYXN0ID8gMSA6IDApOyBpIDwgc3BhdGlhbFJhbms7ICsraSwgKytqKSB7XG4gICAgY29uc3QgaW5TaXplID0gaW5wdXRTaGFwZVtqXTtcbiAgICBjb25zdCBvdXRTaXplID0gdXBkYXRlT3V0cHV0U2hhcGUgPyBpblNpemUgKiBzdHJpZGVzW2ldIDogb3V0cHV0U2hhcGVbaV07XG4gICAgY29uc3QgdG90YWxQYWQgPSBjb21wdXRlVG90YWxQYWQoaW5TaXplLCBzdHJpZGVzW2ldLCBwYWRzW2ldLCBrZXJuZWxTaGFwZVtqXSwgZGlsYXRpb25zW2ldLCBvdXRTaXplKTtcbiAgICBkaXN0cmlidXRlUGFkZGluZyh0b3RhbFBhZCwgYXV0b1BhZCwgcGFkcywgaSwgaSArIHNwYXRpYWxSYW5rKTtcbiAgICBpZiAodXBkYXRlT3V0cHV0U2hhcGUpIHtcbiAgICAgIG91dHB1dFNoYXBlLnB1c2goXG4gICAgICAgIHN0cmlkZXNbaV0gKiAoaW5TaXplIC0gMSkgK1xuICAgICAgICAgIG91dHB1dFBhZGRpbmdbaV0gK1xuICAgICAgICAgIChrZXJuZWxTaGFwZVtqXSAtIDEpICogZGlsYXRpb25zW2ldICtcbiAgICAgICAgICAxIC1cbiAgICAgICAgICBwYWRzW2ldIC1cbiAgICAgICAgICBwYWRzW2kgKyBzcGF0aWFsUmFua10sXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBvdXRwdXRTaGFwZS5zcGxpY2UoMCwgMCwgYmF0Y2hTaXplKTtcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKGlzQ2hhbm5lbExhc3QgPyAzIDogMSwgMCwgb3V0Q2hhbm5lbHMpO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDb252VHJhbnNwb3NlQXR0cmlidXRlcyBleHRlbmRzIENvbnZBdHRyaWJ1dGVzIHtcbiAgcmVhZG9ubHkgb3V0cHV0UGFkZGluZzogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuY29uc3QgZ2V0QWRqdXN0ZWRDb252VHJhbnNwb3NlQXR0cmlidXRlcyA9IDxUIGV4dGVuZHMgQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXM+KFxuICBhdHRyaWJ1dGVzOiBULFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbik6IFQgPT4ge1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUuc2xpY2UoKTtcbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgYXR0cmlidXRlcyBvZiB0aGlzIG9wLCBpbmZlciBpdCBmcm9tIHRoZSB3ZWlnaHQgdGVuc29yIGRpbXNcbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAwIHx8IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSkgPT09IDApIHtcbiAgICBrZXJuZWxTaGFwZS5sZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGtlcm5lbFNoYXBlLnB1c2goaW5wdXRzWzFdLmRpbXNbaV0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGtlcm5lbFNoYXBlLnNwbGljZSgwLCAwLCBpbnB1dHNbMV0uZGltc1swXSk7XG4gIGtlcm5lbFNoYXBlLnNwbGljZShpc0NoYW5uZWxzTGFzdCA/IDMgOiAxLCAwLCBpbnB1dHNbMV0uZGltc1sxXSk7XG5cbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGF0dHJpYnV0ZXMub3V0cHV0U2hhcGUuc2xpY2UoKTtcbiAgY29uc3Qgb3V0cHV0UGFkZGluZyA9IGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZy5zbGljZSgpO1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGxldCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5zbGljZSgpO1xuICBpZiAoZGlsYXRpb25zLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID09PSAwKSB7XG4gICAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyO1xuICAgIGRpbGF0aW9ucyA9IG5ldyBBcnJheShzcGF0aWFsUmFuaykuZmlsbCgxKTtcbiAgfVxuICBsZXQgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcy5zbGljZSgpO1xuICBpZiAoc3RyaWRlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA9PT0gMCkge1xuICAgIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMjtcbiAgICBzdHJpZGVzID0gbmV3IEFycmF5KHNwYXRpYWxSYW5rKS5maWxsKDEpO1xuICB9XG4gIC8vIElmIG91dHB1dFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgcGFyYW1ldGVyc1xuICAvLyBTaW1pbGFybHksIGF1dG9tYXRpY2FsbHkgaW5mZXIgcGFkcyBpZiBub3Qgc3BlY2lmaWVkXG4gIGNhbGN1bGF0ZU91dHB1dFNoYXBlQW5kUGFkcyhcbiAgICBpbnB1dFNoYXBlLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIGRpbGF0aW9ucyxcbiAgICBhdHRyaWJ1dGVzLmF1dG9QYWQsXG4gICAgYXR0cmlidXRlcy5ncm91cCxcbiAgICBwYWRzLFxuICAgIHN0cmlkZXMsXG4gICAgaXNDaGFubmVsc0xhc3QsXG4gICAgb3V0cHV0UGFkZGluZyxcbiAgICBvdXRwdXRTaGFwZSxcbiAgKTtcblxuICAvLyBhbHdheXMgcmV0dXJuIGEgbmV3IG9iamVjdCBzbyBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGF0dHJpYnV0ZXNcbiAgY29uc3QgbmV3QXR0cmlidXRlczogVCA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpO1xuICBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIHsga2VybmVsU2hhcGUsIHBhZHMsIG91dHB1dFBhZGRpbmcsIG91dHB1dFNoYXBlLCBkaWxhdGlvbnMsIHN0cmlkZXMgfSk7XG4gIHJldHVybiBuZXdBdHRyaWJ1dGVzO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFjdGl2YXRpb25BdHRyaWJ1dGVzID0gcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAvLyBUT0RPIDogTWFrZSB0aGlzIGdlbmVyaWMgZW5vdWdoIHRvIGNvbXB1dGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gIGNvbnN0IGZvcm1hdCA9IGF0dHJpYnV0ZXMuZm9ybWF0IGFzICdOSFdDJyB8ICdOQ0hXJztcbiAgY29uc3QgYXV0b1BhZCA9IFsnTk9UU0VUJywgJ1ZBTElEJywgJ1NBTUVfVVBQRVInLCAnU0FNRV9MT1dFUiddW1xuICAgIHR5cGVvZiBhdHRyaWJ1dGVzLmF1dG9QYWQgPT0gJ3VuZGVmaW5lZCcgPyAwIDogKGF0dHJpYnV0ZXMuYXV0b1BhZCBhcyBudW1iZXIpXG4gIF07XG4gIGNvbnN0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zIGFzIFtudW1iZXIsIG51bWJlcl07XG4gIGNvbnN0IGdyb3VwID0gYXR0cmlidXRlcy5ncm91cCBhcyBudW1iZXI7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzIGFzIFtudW1iZXIsIG51bWJlcl07XG4gIGNvbnN0IHdJc0NvbnN0ID0gKGF0dHJpYnV0ZXMud0lzQ29uc3QgYXMgKCkgPT4gYm9vbGVhbikoKTtcbiAgY29uc3Qgb3V0cHV0UGFkZGluZyA9IGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhdHRyaWJ1dGVzLm91dHB1dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl07XG4gIHJldHVybiB7XG4gICAgYXV0b1BhZCxcbiAgICBmb3JtYXQsXG4gICAgZGlsYXRpb25zLFxuICAgIGdyb3VwLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIG91dHB1dFBhZGRpbmcsXG4gICAgb3V0cHV0U2hhcGUsXG4gICAgcGFkcyxcbiAgICBzdHJpZGVzLFxuICAgIHdJc0NvbnN0LFxuICAgIC4uLmFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuICAgIGNhY2hlS2V5OiBgJHthdHRyaWJ1dGVzLmZvcm1hdH07JHthY3RpdmF0aW9uQXR0cmlidXRlcy5hY3RpdmF0aW9ufTtgLFxuICB9O1xufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIFJlZmVyIHRvIHRoZSBiZWxvdyBsaW5rIGZvciBhbGwgaW5wdXQgY2hlY2tzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYWluL2RvY3MvT3BlcmF0b3JzLm1kI0NvbnZUcmFuc3Bvc2VcbiAgaWYgKCFpbnB1dHMgfHwgKGlucHV0cy5sZW5ndGggIT09IDIgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0cycpO1xuICB9XG5cbiAgLy8gVE9ETyA6IE5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG11bHRpLWRpbWVuc2lvbmFsIGNvbnZcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCAmJiBpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252Jyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0Jyk7XG4gIH1cblxuICAvLyBGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXG4gIGNvbnN0IGRhdGFDaGFubmVsID0gaW5wdXRzWzBdLmRpbXNbYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyA/IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDEgOiAxXTtcbiAgY29uc3QgZmlsdGVySW5DaGFubmVsID0gaW5wdXRzWzFdLmRpbXNbMF07XG4gIGlmIChkYXRhQ2hhbm5lbCAhPT0gZmlsdGVySW5DaGFubmVsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMJyk7XG4gIH1cblxuICBjb25zdCBmZWF0dXJlTWFwcyA9IGlucHV0c1sxXS5kaW1zWzFdICogYXR0cmlidXRlcy5ncm91cDtcblxuICAvLyBpZiBiaWFzIGlzIHByb3ZpZGVkIGl0IHNob3VsZCBiZSAxRCBhbmQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzaG91bGQgYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBmZWF0dXJlIG1hcHNcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgKGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMSB8fCBpbnB1dHNbMl0uZGltc1swXSAhPT0gZmVhdHVyZU1hcHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJpYXMnKTtcbiAgfVxuXG4gIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMjtcbiAgY29uc3QgZGlsYXRpb25zU2V0ID0gYXR0cmlidXRlcy5kaWxhdGlvbnMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPiAwO1xuICAvLyB3cm9uZyBkaWxhdGlvbnMgZGltZW5zaW9uXG4gIGlmIChkaWxhdGlvbnNTZXQgJiYgYXR0cmlidXRlcy5kaWxhdGlvbnMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIGNvbnN0IHN0cmlkZXNTZXQgPSBhdHRyaWJ1dGVzLnN0cmlkZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPiAwO1xuICAvLyBXcm9uZyBzdHJpZGVzIGRpbWVuc2lvblxuICBpZiAoc3RyaWRlc1NldCAmJiBhdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICAvLyBXcm9uZyBwYWRzIGRpbWVuc2lvblxuICBjb25zdCBwYWRzU2V0ID0gYXR0cmlidXRlcy5wYWRzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID4gMDtcbiAgaWYgKHBhZHNTZXQgJiYgYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmsgKiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rICogMn1EYCk7XG4gIH1cblxuICAvLyBXcm9uZyBvdXRwdXQgcGFkZGluZyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZy5sZW5ndGggIT09IHNwYXRpYWxSYW5rICYmIGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZy5sZW5ndGggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG91dHB1dF9wYWRkaW5nIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIHNwZWNpZmllZCwgaXQncyBkYXRhIGxlbmd0aCBtdXN0IGJlIDIgbGVzcyB0aGFuIGRpbXMgbGVuZ3RoIG9mIHRoZSB3ZWlnaHRzIHRlbnNvclxuICAvLyAodGhlIGZpcnN0IDIgZGltcyBhcmUgYmF0Y2hfc2l6ZSBhbmQgY2hhbm5lbHMpXG4gIGNvbnN0IGtlcm5lbFNoYXBlU2V0ID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA+IDA7XG4gIGlmIChcbiAgICBrZXJuZWxTaGFwZVNldCAmJlxuICAgIGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSAwICYmXG4gICAgYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDJcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGtlcm5lbCBzaGFwZScpO1xuICB9XG5cbiAgLy8gYXMgd2l0aCBrZXJuZWxTaGFwZSwgbXVzdCBoYXZlIHNhbWUgbnVtYmVyIG9mIHNwYXRpYWwgZGltcyBhcyBpbnB1dFxuICBpZiAoYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5sZW5ndGggIT09IDAgJiYgYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgb3V0cHV0IHNoYXBlJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNvbnZUcmFuc3Bvc2UyZCA9IChcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyxcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcbik6IHZvaWQgPT4ge1xuICAvLyBTVEVQLjE6IHRyYW5zcG9zZSB3ZWlnaHRcbiAgY29uc3QgdHJhbnNwb3NlZFdlaWdodCA9XG4gICAgKGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCBhcyBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkKSA/P1xuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbnB1dHNbMV0sIFsyLCAzLCAwLCAxXSksIHtcbiAgICAgIGlucHV0czogWzFdLFxuICAgICAgb3V0cHV0czogW2F0dHJpYnV0ZXMud0lzQ29uc3QgPyAtMiA6IC0xXSxcbiAgICB9KVswXTtcbiAgaWYgKGF0dHJpYnV0ZXMud0lzQ29uc3QgJiYgIWNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCkge1xuICAgIGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCA9IHRyYW5zcG9zZWRXZWlnaHQ7XG4gIH1cblxuICAvLyBTVEVQLjI6IHByZXBhcmUgcmVzaGFwZWQgaW5wdXRzXG4gIGNvbnN0IGNvbnZUcmFuc3Bvc2VJbnB1dHMgPSBbaW5wdXRzWzBdLCB0cmFuc3Bvc2VkV2VpZ2h0XTtcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICBjb252VHJhbnNwb3NlSW5wdXRzLnB1c2goaW5wdXRzWzJdKTtcbiAgfVxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQ29udlRyYW5zcG9zZTJEUHJvZ3JhbUluZm8oY29udlRyYW5zcG9zZUlucHV0cywgYXR0cmlidXRlcywgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24pLCB7XG4gICAgaW5wdXRzOiBjb252VHJhbnNwb3NlSW5wdXRzLFxuICB9KTtcbn07XG5cbmNvbnN0IGNvbnZUcmFuc3Bvc2UxZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gZXh0ZW5kIHRoZSBpbnB1dCB0byAyRCBieSBhZGRpbmcgSCBkaW1lbnNpb25cbiAgY29uc3QgaXNDaGFubmVsTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG5cbiAgY29uc3QgaW5wdXRzID0gW1xuICAgIGNvbnRleHQuaW5wdXRzWzBdLnJlc2hhcGUoXG4gICAgICBpc0NoYW5uZWxMYXN0XG4gICAgICAgID8gLy8gW04sIFcsIENdIC0+IFtOLCBIPTEsIFcsIENdXG4gICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dXG4gICAgICAgIDogLy8gW04sIEMsIFddIC0+IFtOLCBDLCBIPTEsIFddXG4gICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dLFxuICAgICksXG4gICAgLy9bRklMVEVSX09VVF9DSEFOTkVMLCBGSUxURVJfSU5fQ0hBTk5FTCwga1ddIC0+IFtGSUxURVJfT1VUX0NIQU5ORUwsIEZJTFRFUl9JTl9DSEFOTkVMLCBrSD0xLCBrV11cbiAgICBjb250ZXh0LmlucHV0c1sxXS5yZXNoYXBlKFtjb250ZXh0LmlucHV0c1sxXS5kaW1zWzBdLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzFdLCAxLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzJdXSksXG4gIF07XG4gIGlmIChjb250ZXh0LmlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICBpbnB1dHMucHVzaChjb250ZXh0LmlucHV0c1syXSk7XG4gIH1cbiAgbGV0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZTtcbiAgaWYgKGtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMCB8fCBrZXJuZWxTaGFwZVswXSA9PT0gMCkge1xuICAgIGtlcm5lbFNoYXBlID0gW2NvbnRleHQuaW5wdXRzWzFdLmRpbXNbMl1dO1xuICB9XG4gIGxldCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucztcbiAgaWYgKGRpbGF0aW9ucy5sZW5ndGggPT09IDAgfHwgZGlsYXRpb25zWzBdID09PSAwKSB7XG4gICAgZGlsYXRpb25zID0gWzFdO1xuICB9XG4gIGxldCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzO1xuICBpZiAoc3RyaWRlcy5sZW5ndGggPT09IDAgfHwgc3RyaWRlc1swXSA9PT0gMCkge1xuICAgIHN0cmlkZXMgPSBbMV07XG4gIH1cbiAgbGV0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHM7XG4gIGlmIChwYWRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHBhZHMgPSBbMCwgMF07XG4gIH1cbiAgcGFkcyA9IFswLCBwYWRzWzBdLCAwLCBwYWRzWzFdXTtcbiAgc3RyaWRlcyA9IFsxXS5jb25jYXQoc3RyaWRlcyk7XG4gIGRpbGF0aW9ucyA9IFsxXS5jb25jYXQoZGlsYXRpb25zKTtcbiAga2VybmVsU2hhcGUgPSBbMV0uY29uY2F0KGtlcm5lbFNoYXBlKTtcbiAgbGV0IG91dHB1dFBhZGRpbmcgPSBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmc7XG4gIG91dHB1dFBhZGRpbmcgPSBbMF0uY29uY2F0KG91dHB1dFBhZGRpbmcpO1xuICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKFxuICAgIHsgLi4uYXR0cmlidXRlcywgcGFkcywgc3RyaWRlcywgZGlsYXRpb25zLCBrZXJuZWxTaGFwZSwgb3V0cHV0UGFkZGluZyB9LFxuICAgIGlucHV0cyxcbiAgKTtcblxuICBjb252VHJhbnNwb3NlMmQoY29udGV4dCwgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMsIChvdXRwdXRTaGFwZSkgPT5cbiAgICBpc0NoYW5uZWxMYXN0ID8gW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsyXSwgb3V0cHV0U2hhcGVbM11dIDogW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbM11dLFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbnZUcmFuc3Bvc2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgY29udlRyYW5zcG9zZTFkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgY29udGV4dC5pbnB1dHMpO1xuICAgIGNvbnZUcmFuc3Bvc2UyZChjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRFbGVtZW50QXQsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3VtU3VtQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGV4Y2x1c2l2ZTogYm9vbGVhbjtcbiAgcmVhZG9ubHkgcmV2ZXJzZTogYm9vbGVhbjtcbn1cbmNvbnN0IGNyZWF0ZUN1bXN1bVByb2dyYW1JbmZvID0gKFxuICBpbnB1dFR5cGU6IG51bWJlcixcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGF4aXNJbnB1dDogVGVuc29yVmlldyxcbiAgYXR0cmlidXRlczogQ3VtU3VtQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKGlucHV0U2hhcGUpOyAvLyBvdXRwdXRTaGFwZSBpcyBzYW1lIGFzIGlucHV0U2hhcGUuXG4gIGNvbnN0IHJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDsgLy8gaW5wdXQvb3V0cHV0IHJhbmtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0VHlwZSwgcmFuayk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dFR5cGUsIHJhbmspO1xuICBjb25zdCBheGlzVmFsdWUgPVxuICAgIGF4aXNJbnB1dC5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50MzIgPyBheGlzSW5wdXQuZ2V0SW50MzJBcnJheSgpWzBdIDogTnVtYmVyKGF4aXNJbnB1dC5nZXRCaWdJbnQ2NEFycmF5KClbMF0pO1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXhpc1ZhbHVlLCByYW5rKTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBgIGkzMigke2lucHV0LmluZGljZXNHZXQoJ2lucHV0SW5kaWNlcycsICd1bmlmb3Jtcy5heGlzJyl9KSBgO1xuICAgIGNvbnN0IG1heCA9IGdldEVsZW1lbnRBdCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAndW5pZm9ybXMuYXhpcycsIHJhbmspO1xuICAgIGNvbnN0IGxvd2VyTGltaXQgPSBhdHRyaWJ1dGVzLnJldmVyc2UgPyBpbmRleCArIChhdHRyaWJ1dGVzLmV4Y2x1c2l2ZSA/ICcgKyAxJyA6ICcnKSA6ICcwJztcbiAgICBjb25zdCB1cHBlckxpbWl0ID0gYXR0cmlidXRlcy5yZXZlcnNlID8gbWF4IDogaW5kZXggKyAoYXR0cmlidXRlcy5leGNsdXNpdmUgPyAnJyA6ICcgKyAxJyk7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICAke3NoYWRlckhlbHBlclxuICAgICAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0U2l6ZScsICd1MzInKVxuICAgICAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpcycsICd1MzInKVxuICAgICAgICAgICAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0IDogaTMyID0gJHtsb3dlckxpbWl0fTtcbiAgICAgICAgICAgICAgICAgIGxldCBsYXN0IDogaTMyID0gJHt1cHBlckxpbWl0fTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgOiBpMzIgPSBmaXJzdDsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0SW5kaWNlcycsICd1bmlmb3Jtcy5heGlzJywgJ3UzMihpKScpfTtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtICsgJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0SW5kaWNlcycpfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3N1bScpfTtcbiAgICAgICAgICAgICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQ3VtU3VtJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogaW5wdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0VHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXhpcyB9LFxuICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBpbnB1dFNoYXBlKSxcbiAgICAgIF0sXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGN1bXN1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ3VtU3VtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gY29udGV4dC5pbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRUeXBlID0gY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGF4aXMgPSBjb250ZXh0LmlucHV0c1sxXTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUN1bXN1bVByb2dyYW1JbmZvKGlucHV0VHlwZSwgaW5wdXRTaGFwZSwgYXhpcywgYXR0cmlidXRlcyksIHsgaW5wdXRzOiBbMF0gfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDdW1TdW1BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ3VtU3VtQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGV4Y2x1c2l2ZSA9IChhdHRyaWJ1dGVzLmV4Y2x1c2l2ZSBhcyBudW1iZXIpID09PSAxO1xuICBjb25zdCByZXZlcnNlID0gKGF0dHJpYnV0ZXMucmV2ZXJzZSBhcyBudW1iZXIpID09PSAxO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgZXhjbHVzaXZlLCByZXZlcnNlIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdEF0dHJpYnV0ZXMge1xuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJyB8ICdOQ0hXJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzIGV4dGVuZHMgRm9ybWF0QXR0cmlidXRlcywgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYmxvY2tzaXplOiBudW1iZXI7XG4gIHJlYWRvbmx5IG1vZGU6IHN0cmluZztcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGVwdGhUb1NwYWNlIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGVwdGhUb1NwYWNlIHJlcXVpcmVzIDREIGlucHV0LicpO1xuICB9XG59O1xuXG5jb25zdCBwZXJtRnVuY3Rpb25Cb2R5ID0gKHBlcm06IG51bWJlcltdLCByYW5rOiBudW1iZXIsIGlucHV0OiBJbmRpY2VzSGVscGVyLCBvdXRwdXQ6IEluZGljZXNIZWxwZXIpOiBzdHJpbmcgPT4ge1xuICBjb25zdCByZXZlcnNlRnVuYyA9IFtdO1xuICByZXZlcnNlRnVuYy5wdXNoKGBmbiBwZXJtKGk6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7aW5wdXQudHlwZS5pbmRpY2VzfSB7XG4gICAgdmFyIGE6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtgKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICByZXZlcnNlRnVuYy5wdXNoKGlucHV0LmluZGljZXNTZXQoJ2EnLCBwZXJtW2ldLCBgaVske2l9XWApKTtcbiAgfVxuICByZXZlcnNlRnVuYy5wdXNoKCdyZXR1cm4gYTt9Jyk7XG4gIHJldHVybiByZXZlcnNlRnVuYy5qb2luKCdcXG4nKTtcbn07XG5cbmNvbnN0IGNyZWF0ZURlcHRoVG9TcGFjZVByb2dyYW1JbmZvID0gKGlucHV0VGVuc29yOiBUZW5zb3JWaWV3LCBhdHRyaWJ1dGVzOiBEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICBsZXQgbjogbnVtYmVyLCBoOiBudW1iZXIsIHc6IG51bWJlciwgYzogbnVtYmVyO1xuICBsZXQgc2hhcGU6IG51bWJlcltdO1xuICBsZXQgcGVybTogbnVtYmVyW107XG4gIGNvbnN0IGlzQ2hhbm5lbExhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBibG9ja3NpemUgPSBhdHRyaWJ1dGVzLmJsb2Nrc2l6ZTtcbiAgY29uc3QgaXNEQ1Jtb2RlID0gYXR0cmlidXRlcy5tb2RlID09PSAnRENSJztcbiAgaWYgKGlzQ2hhbm5lbExhc3QpIHtcbiAgICBbbiwgaCwgdywgY10gPSBpbnB1dFRlbnNvci5kaW1zO1xuICAgIHNoYXBlID0gaXNEQ1Jtb2RlXG4gICAgICA/IFtuLCBoLCB3LCBibG9ja3NpemUsIGJsb2Nrc2l6ZSwgYyAvIGJsb2Nrc2l6ZSAqKiAyXVxuICAgICAgOiBbbiwgaCwgdywgYyAvIGJsb2Nrc2l6ZSAqKiAyLCBibG9ja3NpemUsIGJsb2Nrc2l6ZV07XG4gICAgcGVybSA9IGlzRENSbW9kZSA/IFswLCAxLCAzLCAyLCA0LCA1XSA6IFswLCAxLCA0LCAyLCA1LCAzXTtcbiAgfSBlbHNlIHtcbiAgICBbbiwgaCwgdywgY10gPSBbaW5wdXRUZW5zb3IuZGltc1swXSwgaW5wdXRUZW5zb3IuZGltc1syXSwgaW5wdXRUZW5zb3IuZGltc1szXSwgaW5wdXRUZW5zb3IuZGltc1sxXV07XG4gICAgc2hhcGUgPSBpc0RDUm1vZGVcbiAgICAgID8gW24sIGJsb2Nrc2l6ZSwgYmxvY2tzaXplLCBjIC8gYmxvY2tzaXplICoqIDIsIGgsIHddXG4gICAgICA6IFtuLCBjIC8gYmxvY2tzaXplICoqIDIsIGJsb2Nrc2l6ZSwgYmxvY2tzaXplLCBoLCB3XTtcbiAgICBwZXJtID0gaXNEQ1Jtb2RlID8gWzAsIDMsIDQsIDEsIDUsIDJdIDogWzAsIDEsIDQsIDIsIDUsIDNdO1xuICB9XG4gIGNvbnN0IHJlc2hhcGVkSW5wdXRUZW5zb3IgPSBpbnB1dFRlbnNvci5yZXNoYXBlKHNoYXBlKTtcbiAgY29uc3QgcmVzaGFwZWRJbnB1dFJhbmsgPSByZXNoYXBlZElucHV0VGVuc29yLmRpbXMubGVuZ3RoO1xuICBjb25zdCBpbnB1dERhdGFUeXBlID0gaW5wdXRUZW5zb3IuZGF0YVR5cGU7XG5cbiAgY29uc3QgcmVzaGFwZWRJbnB1dCA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dERhdGFUeXBlLCByZXNoYXBlZElucHV0UmFuayk7XG4gIGNvbnN0IHBlcm1lZE91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dERhdGFUeXBlLCByZXNoYXBlZElucHV0UmFuayk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhyZXNoYXBlZElucHV0LCBwZXJtZWRPdXRwdXQpfVxuXG4gICR7cGVybUZ1bmN0aW9uQm9keShwZXJtLCByZXNoYXBlZElucHV0UmFuaywgcmVzaGFwZWRJbnB1dCwgcGVybWVkT3V0cHV0KX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuXG4gICAgbGV0IGluZGljZXMgPSAke3Blcm1lZE91dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7cGVybWVkT3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgcmVzaGFwZWRJbnB1dC5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJykpfVxuICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdEZXB0aFRvU3BhY2UnLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHtpbnB1dFRlbnNvci5kaW1zfTske2F0dHJpYnV0ZXMuYmxvY2tzaXplfTske2F0dHJpYnV0ZXMubW9kZX1gLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKGlucHV0cykgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpc0NoYW5uZWxMYXN0XG4gICAgICAgID8gW24sIGggKiBibG9ja3NpemUsIHcgKiBibG9ja3NpemUsIGMgLyBibG9ja3NpemUgKiogMl1cbiAgICAgICAgOiBbbiwgYyAvIGJsb2Nrc2l6ZSAqKiAyLCBoICogYmxvY2tzaXplLCB3ICogYmxvY2tzaXplXTtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICBjb25zdCBzaGFwZUJlZm9yZVBlcm0gPSByZXNoYXBlZElucHV0VGVuc29yLmRpbXM7XG4gICAgICBjb25zdCBzaGFwZUFmdGVyUGVybSA9IFNoYXBlVXRpbC5zb3J0QmFzZWRPblBlcm0oc2hhcGVCZWZvcmVQZXJtLCBwZXJtKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoc2hhcGVCZWZvcmVQZXJtLCBzaGFwZUFmdGVyUGVybSksXG4gICAgICAgIF0sXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGRlcHRoVG9TcGFjZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogRGVwdGhUb1NwYWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVEZXB0aFRvU3BhY2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcbiAgICBibG9ja3NpemU6IGF0dHJpYnV0ZXMuYmxvY2tzaXplIGFzIG51bWJlcixcbiAgICBtb2RlOiBhdHRyaWJ1dGVzLm1vZGUgYXMgc3RyaW5nLFxuICAgIGZvcm1hdDogYXR0cmlidXRlcy5mb3JtYXQgYXMgJ05IV0MnIHwgJ05DSFcnLFxuICB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBFaW5zdW1BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgZXF1YXRpb246IHN0cmluZztcbn1cbi8vIFRoZSBlcXVhdGlvbiBhdHRyaWJ1dGUgdmFsdWUgaXMgYSBzdHJpbmcgd2hpY2ggY29uc2lzdHMgb2YgbGVmdCBoYW5kIHNpZGUgKExIUykgYW5kIG9wdGlvbmFsbHkgcmlnaHQgaGFuZCBzaWRlIChSSFMpXG4vLyBzZXBhcmF0ZWQgYnkgJy0+Jy4gRXguIFwiaWosamsgLT4gaWtcIiBleHByZXNzZXMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4vLyAgICAgXCJpai0+amlcIiBleHByZXNzZXMgbWF0cml4IHRyYW5zcG9zZVxuLy8gICAgICBcImlpLT5pXCIgZGlhZ29uYWwgZWxlbWVudHMgb2YgYSBzcXVhcmUgbWF0cml4XG4vLyBMSFMgY29uc2lzdHMgb2YgYSBzZXF1ZW5jZSBvZiB0ZXJtcyBzZXBhcmF0ZWQgYnkgY29tbWFzLiBFYWNoIHRlcm0gY29ycmVzcG9uZHMgdG8gYW4gaW5wdXQgdmFyaWFibGUuXG4vLyBFYWNoIHN5bWJvbCBjb3JyZXNwb25kcyB0byBhIGRpbWVuc2lvbiBpbiB0aGUgaW5wdXQgdmFyaWFibGUuIFRoZSBzeW1ib2wgY2FuIGJlIGVpdGhlciBhIGxldHRlciwgJ2EnIHRvICd6JyBvciAnQScgdG9cbi8vICdaJyBvciAnLi4uJyB0byByZXByZXNlbnQgYXJiaXRyYXJ5IGRpbWVuc2lvbnMuXG5cbmNvbnN0IHN5bWJvbFBhdHRlcm4gPSAnW2EtekEtWl18XFxcXC5cXFxcLlxcXFwuJzsgLy8gVGhlIHBhdHRlcm4gZWFjaCBzeW1ib2wgaW4gZWFjaCB0ZXJtIGluIHRoZSBzeW1ib2xpYyBlcXVhdGlvbiBzaG91bGQgbWF0Y2hcbmNvbnN0IHRlcm1QYXR0ZXJuID0gJygnICsgc3ltYm9sUGF0dGVybiArICcpKyc7IC8vIFRoZSBwYXR0ZXJuIGVhY2ggdGVybSBpbiB0aGUgc3ltYm9saWMgZXF1YXRpb24gc2hvdWxkIG1hdGNoXG5jb25zdCB0ZXJtUGF0dGVybk9ubHkgPSAnXicgKyB0ZXJtUGF0dGVybiArICckJzsgLy8gVGhlIHBhdHRlcm5zIG9ubHkgbWF0Y2hlcyBhIHRlcm0gYmVnaW4gdG8gZW5kLlxuY29uc3QgbGhzUGF0dGVybiA9ICcoJyArIHRlcm1QYXR0ZXJuICsgJywpKicgKyB0ZXJtUGF0dGVybjsgLy8gVGhlIHBhdHRlcm4gdGhlIExIUyBzaG91bGQgbWF0Y2hcbmNvbnN0IGxoc1BhdHRlcm5Pbmx5ID0gJ14nICsgbGhzUGF0dGVybiArICckJzsgLy8gVGhlIHBhdHRlcm5zIG9ubHkgbWF0Y2hlcyBhIExIUyBiZWdpbiB0byBlbmQuXG5cbmludGVyZmFjZSBTeW1ib2xJbmZvIHtcbiAgY291bnQ6IG51bWJlcjsgLy8gU3ltYm9sIGNvcnJlc3BvbmRpbmcgdG8gYSBkaW1lbnNpb24gb2YgYW4gaW5wdXRcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXTsgLy8gTnVtYmVyIG9mIGlucHV0IHZhcmlhYmxlcyB0aGUgc3ltYm9sIGNvcnJlc3BvbmRzIHRvXG4gIGRpbVZhbHVlOiBudW1iZXI7IC8vIE51bWJlciBvZiBkaW1lbnNpb25zIHRoZSBzeW1ib2wgY29ycmVzcG9uZHMgdG9cbn1cblxuY2xhc3MgRWluc3VtVGVybSB7XG4gIGNvbnN0cnVjdG9yKGlucHV0SW5kZXggPSAtMSkge1xuICAgIHRoaXMuc3ltYm9sVG9JbmRpY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcltdPigpO1xuICAgIHRoaXMuaW5wdXRJbmRleCA9IGlucHV0SW5kZXg7XG4gIH1cblxuICAvLyBBZGQgYSBzeW1ib2wgdG8gdGhlIHRlcm1cbiAgYWRkU3ltYm9sKHN5bWJvbDogc3RyaW5nLCBpbmRleDogbnVtYmVyKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5zeW1ib2xUb0luZGljZXMuZ2V0KHN5bWJvbCk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gW2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUucHVzaChpbmRleCk7XG4gICAgfVxuICAgIHRoaXMuc3ltYm9sVG9JbmRpY2VzLnNldChzeW1ib2wsIHZhbHVlKTtcbiAgfVxuXG4gIHN5bWJvbFRvSW5kaWNlczogTWFwPHN0cmluZywgbnVtYmVyW10+OyAvLyBNYXAgZnJvbSBzeW1ib2wgdG8gZGltZW5zaW9ucyBvZiB0aGUgaW5wdXQgY29ycmVzcG9uZGluZyB0byB0aGUgdGVybVxuICBpbnB1dEluZGV4OiBudW1iZXI7IC8vIC0xIGZvciBvdXRwdXQgYW5kIDAsIDEsIDIsIC4uLiBmb3IgaW5wdXRzXG59XG5cbmNsYXNzIEVpbnN1bUVxdWF0aW9uIHtcbiAgY29uc3RydWN0b3IoXG4gICAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gICAgcHVibGljIHJlYWRvbmx5IGVxdWF0aW9uOiBzdHJpbmcsXG4gICkge1xuICAgIHRoaXMuaGFzRWxsaXBzaXMgPSBmYWxzZTtcbiAgICB0aGlzLnN5bWJvbFRvSW5mbyA9IG5ldyBNYXA8c3RyaW5nLCBTeW1ib2xJbmZvPigpO1xuICAgIHRoaXMubGhzID0gbmV3IEFycmF5PEVpbnN1bVRlcm0+KCk7XG4gICAgdGhpcy5vdXRwdXREaW1zID0gW107XG4gICAgLy8gQXMgcmhzIG5lZWRzIHRvIGJlIHVwZGF0ZWQgYWxsb3cgdXNpbmcgbGV0IGluc3RlYWQgb2YgY29uc3QgZm9yIGJvdGggbGhzIGFuZCByaHMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCBbbGhzLCByaHNdID0gZXF1YXRpb24uaW5jbHVkZXMoJy0+JykgPyBlcXVhdGlvbi5zcGxpdCgnLT4nLCAyKSA6IFtlcXVhdGlvbiwgJyddO1xuICAgIGlmICghbGhzLm1hdGNoKFJlZ0V4cChsaHNQYXR0ZXJuT25seSkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTEhTIHRlcm0nKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRUZXJtcyA9IGxocy5zcGxpdCgnLCcpO1xuICAgIGlucHV0VGVybXMuZm9yRWFjaCgoaW5wdXRUZXJtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZGltcyA9IGlucHV0c1tpbmRleF0uZGltcy5zbGljZSgpO1xuICAgICAgaWYgKCFpbnB1dFRlcm0ubWF0Y2goUmVnRXhwKHRlcm1QYXR0ZXJuT25seSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMSFMgdGVybScpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWluc3VtVGVybSA9IHRoaXMucHJvY2Vzc1Rlcm0oaW5wdXRUZXJtLCB0cnVlLCBkaW1zLCBpbmRleCk7XG4gICAgICB0aGlzLmxocy5wdXNoKGVpbnN1bVRlcm0pO1xuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgUkhTIGlmIG5vdCBzcGVjaWZpZWRcbiAgICBpZiAocmhzID09PSAnJykge1xuICAgICAgLy8gQ29uc3RydWN0IFJIUyBmcm9tIExIUyB0ZXJtcy9zeW1ib2xzXG4gICAgICByaHMgKz0gWy4uLnRoaXMuc3ltYm9sVG9JbmZvLmVudHJpZXMoKV1cbiAgICAgICAgLmZpbHRlcigoW3N5bSwgaW5mb10pID0+IGluZm8uY291bnQgPT09IDEgfHwgc3ltID09PSAnLi4uJylcbiAgICAgICAgLm1hcCgoW3N5bV0pID0+IHN5bSlcbiAgICAgICAgLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJocy5tYXRjaChSZWdFeHAodGVybVBhdHRlcm4pKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUkhTJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBvdXRwdXQgZGltc1xuICAgIGNvbnN0IHJoc1N5bWJvbHMgPSByaHMubWF0Y2goUmVnRXhwKHN5bWJvbFBhdHRlcm4sICdnJykpO1xuICAgIHJoc1N5bWJvbHM/LmZvckVhY2goKHN5bWJvbCkgPT4ge1xuICAgICAgaWYgKHN5bWJvbCA9PT0gJy4uLicpIHtcbiAgICAgICAgdGhpcy5vdXRwdXREaW1zID0gdGhpcy5vdXRwdXREaW1zLmNvbmNhdCh0aGlzLmVsbGlwc2lzRGltcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk7XG4gICAgICAgIGlmIChpbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUkhTIHN5bWJvbCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RGltcy5wdXNoKGluZm8uZGltVmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmhzID0gdGhpcy5wcm9jZXNzVGVybShyaHMsIGZhbHNlLCB0aGlzLm91dHB1dERpbXMpO1xuICB9IC8vIEVuZCBvZiBFaW5zdW1FcWF0aW9uIGNvbnN0cnVjdG9yXG5cbiAgLy8gQWRkIGEgc3ltYm9sIHRvIHRoZSBlcXVhdGlvblxuICBhZGRTeW1ib2woc3ltYm9sOiBzdHJpbmcsIGRpbVZhbHVlOiBudW1iZXIsIGlucHV0SW5kZXg6IG51bWJlcikge1xuICAgIGxldCBpbmZvID0gdGhpcy5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk7XG4gICAgaWYgKGluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZm8uZGltVmFsdWUgIT09IGRpbVZhbHVlICYmIGluZm8uY291bnQgIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2gnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8uY291bnQrKztcbiAgICAgICAgaW5mby5pbnB1dEluZGljZXMucHVzaChpbnB1dEluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyA9IHsgY291bnQ6IDEsIGRpbVZhbHVlLCBpbnB1dEluZGljZXM6IFtpbnB1dEluZGV4XSB9O1xuICAgIH1cbiAgICB0aGlzLnN5bWJvbFRvSW5mby5zZXQoc3ltYm9sLCBpbmZvKTtcbiAgfVxuXG4gIC8vIFByb2Nlc3Mgb25lIGlucHV0L291dHB1dCB0ZXJtXG4gIHByb2Nlc3NUZXJtKHRlcm06IHN0cmluZywgaXNJbnB1dDogYm9vbGVhbiwgZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGluZGV4ID0gLTEpOiBFaW5zdW1UZXJtIHtcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XG4gICAgbGV0IGVsbGlwc2lzID0gZmFsc2U7XG4gICAgbGV0IGVsbGlwc2lzRGltcyA9IFtdO1xuICAgIGxldCBuZXh0RGltID0gMDtcbiAgICAvLyBGb3Igb3V0cHV0IGVtcHR5IHN0cmluZyBpcyBhbGxvd2VkIGJlY2F1c2UgdGhlIG91dHB1dCBtYXkgYmUgcmVkdWNlZCB0byBhIHNjYWxhciB2YWx1ZVxuICAgIGlmICghdGVybS5tYXRjaChSZWdFeHAodGVybVBhdHRlcm5Pbmx5KSkgJiYgIWlzSW5wdXQgJiYgdGVybSAhPT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMSFMgdGVybScpO1xuICAgIH1cbiAgICBjb25zdCBpbmRleFN5bWJvbHMgPSB0ZXJtLm1hdGNoKFJlZ0V4cChzeW1ib2xQYXR0ZXJuLCAnZycpKTtcbiAgICBjb25zdCBlaW5zdW1UZXJtID0gbmV3IEVpbnN1bVRlcm0oaW5kZXgpO1xuICAgIC8vIHN5bWJvbCBjYW4gYmUgZWl0aGVyIGEgbGV0dHJlLCAnYScgdG8gJ3onIG9yICdBJyB0byAnWicsIG9yICcuLi4nXG4gICAgaW5kZXhTeW1ib2xzPy5mb3JFYWNoKChzeW1ib2w6IHN0cmluZywgaTogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAoc3ltYm9sID09PSAnLi4uJykge1xuICAgICAgICBpZiAoZWxsaXBzaXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIGVsbGlwc2lzIGlzIGFsbG93ZWQgcGVyIGlucHV0IHRlcm0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbGxpcHNpcyA9IHRydWU7XG4gICAgICAgIGNvbnN0IGVsbGlwc2lzRGltTGVuZ3RoID0gcmFuayAtIGluZGV4U3ltYm9scy5sZW5ndGggKyAxO1xuICAgICAgICBpZiAoZWxsaXBzaXNEaW1MZW5ndGggPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGxpcHNpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxsaXBzaXNEaW1zID0gZGltcy5zbGljZShuZXh0RGltLCBuZXh0RGltICsgZWxsaXBzaXNEaW1MZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5oYXNFbGxpcHNpcykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aCAhPT0gZWxsaXBzaXNEaW1zLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5lbGxpcHNpc0RpbXMudG9TdHJpbmcoKSAhPT0gZWxsaXBzaXNEaW1zLnRvU3RyaW5nKClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxsaXBzaXMgZGltZW5zaW9ucyBtaXNtYXRjaCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0lucHV0KSB7XG4gICAgICAgICAgdGhpcy5oYXNFbGxpcHNpcyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lbGxpcHNpc0RpbXMgPSBlbGxpcHNpc0RpbXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGxpcHNpcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgTEhTJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkICcwJywgJzEnLCAnMicsICczJywgJzQnLCBldGMgdG8gcmVwcmVzZW50IGVsbGlwc2lzIGRpbWVuc2lvbnMgdG8gYXZvaWQgc3BlY2lhbCBoYW5kbGluZ1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGVsbGlwc2lzRGltcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJzAnLmNoYXJDb2RlQXQoMCkgKyBqKTtcbiAgICAgICAgICBlaW5zdW1UZXJtLmFkZFN5bWJvbChzeW1ib2wsIGkgKyBqKTtcbiAgICAgICAgICB0aGlzLmFkZFN5bWJvbChzeW1ib2wsIGRpbXNbbmV4dERpbSsrXSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlaW5zdW1UZXJtLmFkZFN5bWJvbChzeW1ib2wsIGkgKyAodGhpcy5oYXNFbGxpcHNpcyA/IHRoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aCAtIDEgOiAwKSk7XG4gICAgICAgIHRoaXMuYWRkU3ltYm9sKHN5bWJvbCwgZGltc1tuZXh0RGltKytdLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGVpbnN1bVRlcm07XG4gIH1cblxuICBzeW1ib2xUb0luZm86IE1hcDxzdHJpbmcsIFN5bWJvbEluZm8+OyAvLyBBbGwgc3ltYm9scyBpbiB0aGUgZXF1YXRpb25cbiAgaGFzRWxsaXBzaXM6IGJvb2xlYW47IC8vIFRoZSBlcXVhdGlvbiBoYXMgZWxsaXBzaXMgb3Igbm90XG4gIGVsbGlwc2lzRGltczogbnVtYmVyW107IC8vIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBlcXVhdGlvbiBlbGxpcHNpcyBjb3JyZXNwb25kcyB0by5cbiAgbGhzOiBFaW5zdW1UZXJtW107IC8vIFRlcm1zIG9uIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgZXF1YXRpb25cbiAgcmhzOiBFaW5zdW1UZXJtOyAvLyBUZXJtIG9uIHRoZSByaWdodC1oYW5kIHNpZGUgb2YgdGhlIGVxdWF0aW9uXG4gIG91dHB1dERpbXM6IG51bWJlcltdOyAvLyBPdXRwdXQgZGltZW5zaW9ucyBvZiB0aGUgZXF1YXRpb25cbn0gLy8gRW5kIG9mIGNsYXNzIEVpbnN1bUVxdWF0aW9uXG5cbmNvbnN0IGFwcGVuZE1heCA9IChuYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT4gbmFtZSArICdfbWF4JztcblxuY29uc3QgY3JlYXRlRWluc3VtUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0U2hhcGVzOiBBcnJheTxyZWFkb25seSBudW1iZXJbXT4sXG4gIGRhdGFUeXBlOiBudW1iZXIsXG4gIGVpbnN1bUVxdWF0aW9uOiBFaW5zdW1FcXVhdGlvbixcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCByYW5rcyA9IGlucHV0U2hhcGVzLm1hcCgoZGltcykgPT4gZGltcy5sZW5ndGgpO1xuICBjb25zdCBpbnB1dFZhcnMgPSByYW5rcy5tYXAoKHJhbmssIGluZGV4KSA9PiBpbnB1dFZhcmlhYmxlKGBpbnB1dCR7aW5kZXh9YCwgZGF0YVR5cGUsIHJhbmspKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCB1bmlmb3Jtc1N5bWJvbHMgPSBbLi4uZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLmtleXMoKV0uZmlsdGVyKFxuICAgIChzeW1ib2wpID0+ICFlaW5zdW1FcXVhdGlvbi5yaHMuc3ltYm9sVG9JbmRpY2VzLmhhcyhzeW1ib2wpLFxuICApO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpZHhDb3B5OiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IGluaXRQcm9kID0gJ3ZhciBwcm9kID0gMS4wOyc7XG4gICAgY29uc3QgaW5pdFN1bSA9ICd2YXIgc3VtID0gMC4wOyc7XG4gICAgY29uc3QgdXBkYXRlU3VtID0gJ3N1bSArPSBwcm9kOyc7XG4gICAgY29uc3QgcmVkdWNlT3BzU2V0SW5kaWNlczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCByZWR1Y2VPcHNMb29wSGVhZGVyczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCByZWR1Y2VPcHNMb29wRm9vdGVyczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCByZWR1Y2VPcENvbXB1dGU6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgaXNSZWR1Y2VPcHNXaXRob3V0TG9vcCA9IGVpbnN1bUVxdWF0aW9uLnN5bWJvbFRvSW5mby5zaXplID09PSBlaW5zdW1FcXVhdGlvbi5yaHMuc3ltYm9sVG9JbmRpY2VzLnNpemU7XG4gICAgZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLmZvckVhY2goKGluZm8sIHN5bWJvbCkgPT4ge1xuICAgICAgaWYgKGVpbnN1bUVxdWF0aW9uLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKHN5bWJvbCkpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0SW5kZXggPSBlaW5zdW1FcXVhdGlvbi5yaHMuc3ltYm9sVG9JbmRpY2VzLmdldChzeW1ib2wpPy5bMF07XG4gICAgICAgIGlmIChvdXRwdXRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWluc3VtRXF1YXRpb24ubGhzLmZvckVhY2goKHRlcm0sIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmZvLmlucHV0SW5kaWNlcy5pbmNsdWRlcyhpKSkge1xuICAgICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gdGVybS5zeW1ib2xUb0luZGljZXMuZ2V0KHN5bWJvbCk7XG4gICAgICAgICAgICAgIGlmIChpbmRpY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3ltYm9sIGVycm9yJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW5kaWNlcy5mb3JFYWNoKChpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlkeENvcHkucHVzaChcbiAgICAgICAgICAgICAgICAgIGAke2lucHV0VmFyc1tpXS5pbmRpY2VzU2V0KFxuICAgICAgICAgICAgICAgICAgICBgaW5wdXQke2l9SW5kaWNlc2AsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dEluZGV4KSxcbiAgICAgICAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWluc3VtRXF1YXRpb24ubGhzLmZvckVhY2goKHRlcm0sIGkpID0+IHtcbiAgICAgICAgICBpZiAoaW5mby5pbnB1dEluZGljZXMuaW5jbHVkZXMoaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSB0ZXJtLnN5bWJvbFRvSW5kaWNlcy5nZXQoc3ltYm9sKTtcbiAgICAgICAgICAgIGlmIChpbmRpY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN5bWJvbCBlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kaWNlcy5mb3JFYWNoKChpbmRleCkgPT4ge1xuICAgICAgICAgICAgICByZWR1Y2VPcHNTZXRJbmRpY2VzLnB1c2goYCR7aW5wdXRWYXJzW2ldLmluZGljZXNTZXQoYGlucHV0JHtpfUluZGljZXNgLCBpbmRleCwgYCR7c3ltYm9sfWApfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZWR1Y2VPcENvbXB1dGUucHVzaChgcHJvZCAqPSAke2lucHV0VmFyc1tpXS5nZXRCeUluZGljZXMoYGlucHV0JHtpfUluZGljZXNgKX07YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVkdWNlT3BzTG9vcEhlYWRlcnMucHVzaChcbiAgICAgICAgICBgZm9yKHZhciAke3N5bWJvbH06IHUzMiA9IDA7ICR7c3ltYm9sfSA8IHVuaWZvcm1zLiR7YXBwZW5kTWF4KHN5bWJvbCl9OyAke3N5bWJvbH0rKykge2AsXG4gICAgICAgICk7XG4gICAgICAgIHJlZHVjZU9wc0xvb3BGb290ZXJzLnB1c2goJ30nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCByZWR1Y2VPcHMgPSBpc1JlZHVjZU9wc1dpdGhvdXRMb29wXG4gICAgICA/IFtcbiAgICAgICAgICAuLi5pZHhDb3B5LFxuICAgICAgICAgIGBsZXQgc3VtID0gJHtpbnB1dFZhcnMubWFwKChpbnB1dFZhciwgaSkgPT4gaW5wdXRWYXIuZ2V0QnlJbmRpY2VzKGBpbnB1dCR7aX1JbmRpY2VzYCkpLmpvaW4oJyAqICcpfTtgLFxuICAgICAgICBdXG4gICAgICA6IFtcbiAgICAgICAgICAuLi5pZHhDb3B5LFxuICAgICAgICAgIGluaXRTdW0sXG4gICAgICAgICAgLi4ucmVkdWNlT3BzTG9vcEhlYWRlcnMsXG4gICAgICAgICAgLi4ucmVkdWNlT3BzU2V0SW5kaWNlcyxcbiAgICAgICAgICBpbml0UHJvZCxcbiAgICAgICAgICAuLi5yZWR1Y2VPcENvbXB1dGUsXG4gICAgICAgICAgdXBkYXRlU3VtLFxuICAgICAgICAgIC4uLnJlZHVjZU9wc0xvb3BGb290ZXJzLFxuICAgICAgICBdO1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlclxuICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3Jtc1N5bWJvbHMubWFwKChzeW1ib2wpID0+ICh7IG5hbWU6IGAke2FwcGVuZE1heChzeW1ib2wpfWAsIHR5cGU6ICd1MzInIH0pKSlcbiAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0U2l6ZScsICd1MzInKVxuICAgICAgICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCl9XG5cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICAgICAgdmFyIG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgICAke2lucHV0VmFycy5tYXAoKF92YXIsIGkpID0+IGB2YXIgaW5wdXQke2l9SW5kaWNlczogJHtpbnB1dFZhcnNbaV0udHlwZS5pbmRpY2VzfTtgKS5qb2luKCdcXG4nKX1cbiAgICAgICAgICAgICR7cmVkdWNlT3BzLmpvaW4oJ1xcbicpfTtcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3N1bScpfTtcbiAgICAgICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnRWluc3VtJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBlaW5zdW1FcXVhdGlvbi5lcXVhdGlvbiwgaW5wdXREZXBlbmRlbmNpZXM6IGlucHV0U2hhcGVzLm1hcCgoKSA9PiAncmFuaycpIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4ge1xuICAgICAgLy8gVGhlIHN5bWJvbHMgZnJvbSB1bmlmb3JtU3ltYm9scyBhcnJheSBhcmUgZ3VhcmFudGVlZCB0byBleGlzdCBpbiBlaW5zdW1FcXVhdGlvbnMuc3ltYm9sVG9JbmZvIG1hcC4gVGhlXG4gICAgICAvLyBmaWx0ZXIgaXMgYWRkZWQgdG8gbWFrZSBzdXJlIHRoYXQgZGltVmFsdWUgaXMgbmV2ZXIgMC5cbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3Jtc0luaXQ6IFByb2dyYW1Vbmlmb3JtW10gPSB1bmlmb3Jtc1N5bWJvbHNcbiAgICAgICAgLmZpbHRlcigoc3ltYm9sKSA9PiBlaW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8uaGFzKHN5bWJvbCkpXG4gICAgICAgIC5tYXAoKHN5bWJvbCkgPT4gKHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBlaW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk/LmRpbVZhbHVlIHx8IDAgfSkpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zSW5pdC5wdXNoKHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0pO1xuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gaW5wdXRTaGFwZXNcbiAgICAgICAgLm1hcCgoZGltcywgXykgPT4gWy4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGRpbXMpXSlcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBpbnB1dFByb2dyYW1Vbmlmb3JtcykgPT4gYWNjLmNvbmNhdChpbnB1dFByb2dyYW1Vbmlmb3JtcyksIHByb2dyYW1Vbmlmb3Jtc0luaXQpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGVpbnN1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogRWluc3VtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBlaW5zdW1FcXVhdGlvbiA9IG5ldyBFaW5zdW1FcXVhdGlvbihjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcy5lcXVhdGlvbik7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gZWluc3VtRXF1YXRpb24ub3V0cHV0RGltcztcbiAgY29uc3QgaW5wdXRTaGFwZXMgPSBjb250ZXh0LmlucHV0cy5tYXAoKGlucHV0LCBfKSA9PiBpbnB1dC5kaW1zKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVpbnN1bVByb2dyYW1JbmZvKGlucHV0U2hhcGVzLCBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZWluc3VtRXF1YXRpb24sIG91dHB1dFNoYXBlKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VFaW5zdW1BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogRWluc3VtQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGVxdWF0aW9uID0gKGF0dHJpYnV0ZXMuZXF1YXRpb24gYXMgc3RyaW5nKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGVxdWF0aW9uIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwYW5kIHJlcXVpcmVzIDIgaW5wdXQuJyk7XG4gIH1cbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBzaGFwZSA9IEFycmF5LmZyb20oaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcblxuICBsZXQgc2hhcGVJbmRleCA9IHNoYXBlLmxlbmd0aCA8IGlucHV0U2hhcGUubGVuZ3RoID8gMCA6IHNoYXBlLmxlbmd0aCAtIGlucHV0U2hhcGUubGVuZ3RoO1xuICBsZXQgaW5wdXRTaGFwZUluZGV4ID0gaW5wdXRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGggPyAwIDogaW5wdXRTaGFwZS5sZW5ndGggLSBzaGFwZS5sZW5ndGg7XG4gIGZvciAoOyBzaGFwZUluZGV4IDwgc2hhcGUubGVuZ3RoICYmIGlucHV0U2hhcGVJbmRleCA8IGlucHV0U2hhcGUubGVuZ3RoOyArK3NoYXBlSW5kZXgsICsraW5wdXRTaGFwZUluZGV4KSB7XG4gICAgaWYgKFxuICAgICAgc2hhcGVbc2hhcGVJbmRleF0gIT09IGlucHV0U2hhcGVbaW5wdXRTaGFwZUluZGV4XSAmJlxuICAgICAgc2hhcGVbc2hhcGVJbmRleF0gIT09IDEgJiZcbiAgICAgIGlucHV0U2hhcGVbaW5wdXRTaGFwZUluZGV4XSAhPT0gMVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBhbmQgcmVxdWlyZXMgc2hhcGUgdG8gYmUgYnJvYWRjYXN0YWJsZSB0byBpbnB1dCcpO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRTaGFwZSA9IChzaGFwZTE6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZTI6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBkaWZmID0gc2hhcGUxLmxlbmd0aCAtIHNoYXBlMi5sZW5ndGg7XG4gIGNvbnN0IHNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmY7ICsraSkge1xuICAgIHNoYXBlLnB1c2goc2hhcGUxW2ldKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYXBlMi5sZW5ndGg7ICsraSkge1xuICAgIHNoYXBlLnB1c2goc2hhcGUyW2ldID09PSAxID8gc2hhcGUxW2kgKyBkaWZmXSA6IHNoYXBlMltpXSk7XG4gIH1cbiAgcmV0dXJuIHNoYXBlO1xufTtcblxuY29uc3QgY2FsY3VsYXRlT3V0cHV0U2hhcGUgPSAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdID0+XG4gIGlucHV0U2hhcGUubGVuZ3RoID4gc2hhcGUubGVuZ3RoID8gZ2V0QWRqdXN0ZWRTaGFwZShpbnB1dFNoYXBlLCBzaGFwZSkgOiBnZXRBZGp1c3RlZFNoYXBlKHNoYXBlLCBpbnB1dFNoYXBlKTtcblxuY29uc3QgY3JlYXRlRXhwYW5kUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgc2hhcGUgPSBBcnJheS5mcm9tKGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCksIE51bWJlcik7XG4gIGNvbnN0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IGNhbGN1bGF0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHNoYXBlKTtcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGlzQm9vbE9yU2NhbGFyID0gZGF0YVR5cGUgPT09IERhdGFUeXBlLmJvb2wgfHwgU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSkgPT09IDE7XG4gIGNvbnN0IGlDb21wb25lbnRzID1cbiAgICBkYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCA/IDQgOiBpbnB1dFNoYXBlLmxlbmd0aCA+IDAgJiYgaW5wdXRTaGFwZVtpbnB1dFNoYXBlLmxlbmd0aCAtIDFdICUgNCA9PT0gMCA/IDQgOiAxO1xuICBjb25zdCBjb21wb25lbnRzID0gaXNCb29sT3JTY2FsYXJcbiAgICA/IDRcbiAgICA6IG91dHB1dFNoYXBlLmxlbmd0aCA+IDAgJiYgb3V0cHV0U2hhcGVbb3V0cHV0U2hhcGUubGVuZ3RoIC0gMV0gJSA0ID09PSAwXG4gICAgICA/IDRcbiAgICAgIDogMTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoLCBpQ29tcG9uZW50cyk7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XG4gICAgaWYgKGRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sKSB7XG4gICAgICBjb25zdCBzaW5nbGVBc3NpZ25tZW50ID0gKHJlc1N0cjogc3RyaW5nLCB4OiBudW1iZXIsIHR5cGVDYXN0ID0gJycpID0+IGBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYG91dHB1dE9mZnNldCArICR7eH11YCl9O1xuICAgICAgICAgIGxldCBvZmZzZXQke3h9ID0gJHtpbnB1dC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcbiAgICAgICAgICBsZXQgaW5kZXgke3h9ID0gb2Zmc2V0JHt4fSAvIDR1O1xuICAgICAgICAgIGxldCBjb21wb25lbnQke3h9ID0gb2Zmc2V0JHt4fSAlIDR1O1xuICAgICAgICAgICR7cmVzU3RyfVske3h9XSA9ICR7dHlwZUNhc3R9KCR7aW5wdXQuZ2V0QnlPZmZzZXQoYGluZGV4JHt4fWApfVtjb21wb25lbnQke3h9XSk7XG4gICAgICAgIGA7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7Y29tcG9uZW50c307XG4gICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAwLCAndTMyJyl9XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDEsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMiwgJ3UzMicpfVxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAzLCAndTMyJyl9XG4gICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2RhdGEnKX1cbiAgICAgIH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqICR7Y29tcG9uZW50c31gKX07XG4gICAgICAgIGxldCBpbnB1dE9mZnNldCA9ICR7aW5wdXQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ291dHB1dEluZGljZXMnLCBvdXRwdXQpfTtcbiAgICAgICAgbGV0IGRhdGEgPSAke291dHB1dC50eXBlLnZhbHVlfSgke2lucHV0LmdldEJ5T2Zmc2V0KGBpbnB1dE9mZnNldCAvICR7aUNvbXBvbmVudHN9YCl9KTtcbiAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnZGF0YScpfVxuICAgICAgfWA7XG4gICAgfVxuICAgIHJldHVybiBgXG4gICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCd2ZWNfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLnZlY19zaXplJyl9XG4gICAgJHthc3NpZ25tZW50fWA7XG4gIH07XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUpLFxuICBdO1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdFeHBhbmQnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke291dHB1dFNoYXBlLmxlbmd0aH07JHtpQ29tcG9uZW50c30ke2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBleHBhbmQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRXhwYW5kUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpLCB7IGlucHV0czogWzBdIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxuICBXT1JLR1JPVVBfU0laRSxcbn0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0ICogYXMgdW5hcnkgZnJvbSAnLi91bmFyeS1vcCc7XG5cbi8vIEdFTFUgaXMgZGVmaW5lZCBhcyBZPTAuNSpYKigxK3RhbmgoMC43OTc4ODUqWCswLjAzNTY3NypYKlgqWCkpLCB3aGVyZSBYIG1heSBwcmUtYWRkIGEgYmlhcy5cblxuY29uc3QgY3JlYXRlRmFzdEdlbHVQcm9ncmFtSW5mbyA9IChpbnB1dFRlbnNvcnM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dFRlbnNvcnNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFRlbnNvcnNbMF0uZGltcyk7XG4gIGNvbnN0IGJpYXNMZW5ndGggPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFRlbnNvcnNbMV0uZGltcyk7XG4gIC8vIGNhbiBvbmx5IHVzZSB2ZWM0IHdoZW4gYmlhcyBsZW5ndGggaXMgbXVsdGlwbGUgb2YgNFxuICBjb25zdCB1c2VWZWM0ID0gYmlhc0xlbmd0aCAlIDQgPT09IDA7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcik6IHN0cmluZyA9PiB7XG4gICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBkYXRhVHlwZSwgWzFdLCA0KTtcbiAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGRhdGFUeXBlLCBbMV0sIDQpO1xuICAgIGNvbnN0IHkgPSBvdXRwdXRWYXJpYWJsZSgneScsIGRhdGFUeXBlLCBbMV0sIDQpO1xuXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3ZlY19zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2JpYXNfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgXTtcblxuICAgIGNvbnN0IHNpbmdsZUVsZW1lbnRCaWFzID0gKGk6IDAgfCAxIHwgMiB8IDMpID0+IGBcbiAgICAgIGxldCBiaWFzJHtpfV9vZmZzZXQ6IHUzMiA9IChnbG9iYWxfaWR4ICogNCArICR7aX0pICUgdW5pZm9ybXMuYmlhc19zaXplO1xuICAgICAgbGV0IGJpYXMke2l9ID0gJHtiaWFzLmdldEJ5T2Zmc2V0KGBiaWFzJHtpfV9vZmZzZXQgLyA0YCl9W2JpYXMke2l9X29mZnNldCAlIDRdO2A7XG4gICAgY29uc3QgYmlhc0dldEV4cHJlc3Npb24gPSB1c2VWZWM0XG4gICAgICA/IGBcbiAgICAgIGxldCBiaWFzID0gJHtiaWFzLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4ICUgKHVuaWZvcm1zLmJpYXNfc2l6ZSAvIDQpJyl9O2BcbiAgICAgIDogYCR7c2luZ2xlRWxlbWVudEJpYXMoMCl9JHtzaW5nbGVFbGVtZW50QmlhcygxKX0ke3NpbmdsZUVsZW1lbnRCaWFzKDIpfSR7c2luZ2xlRWxlbWVudEJpYXMoMyl9XG4gICAgICBsZXQgYmlhcyA9ICR7eC50eXBlLnZhbHVlfShiaWFzMCwgYmlhczEsIGJpYXMyLCBiaWFzMyk7YDtcblxuICAgIHJldHVybiBgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyh4LCBiaWFzLCB5KX1cblxuICAgICR7dW5hcnkuZmFzdEdlbHVJbXBsKHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoZGF0YVR5cGUpKX1cblxuICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChXT1JLR1JPVVBfU0laRSl9XG4gICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfdmVjX3NpemUnKX1cblxuICAgICAgbGV0IHggPSAke3guZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAke2JpYXNHZXRFeHByZXNzaW9ufVxuICAgICAgbGV0IHhfaW4gPSB4ICsgYmlhcztcbiAgICAgICR7eS5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIHVuYXJ5LmZhc3RHZWx1RXhwcmVzc2lvbigneF9pbicpKX1cbiAgICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdGYXN0R2VsdVdpdGhCaWFzJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHt1c2VWZWM0fWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnLCAndHlwZSddIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6IChpbnB1dHMpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBpbnB1dHNbMF0uZGltcywgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA0KSB9LFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYmlhc0xlbmd0aCB9LFxuICAgICAgXSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyBXT1JLR1JPVVBfU0laRSAvIDQpIH0sXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZmFzdEdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgaWYgKGNvbnRleHQuaW5wdXRzLmxlbmd0aCA8IDIgfHwgU2hhcGVVdGlsLnNpemUoY29udGV4dC5pbnB1dHNbMV0uZGltcykgPT09IDApIHtcbiAgICB1bmFyeS5mYXN0R2VsdShjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRmFzdEdlbHVQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cykpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdhdGhlckF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBheGlzOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhdGhlciByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlR2F0aGVyUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEdhdGhlckF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5kaWNlc1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG5cbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0UmFuayk7XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKDApO1xuICBvdXRwdXRTaGFwZS5zcGxpY2UoYXhpcywgMSwgLi4uaW5kaWNlc1NoYXBlKTtcblxuICBjb25zdCBheGlzRGltTGltaXQgPSBpbnB1dFNoYXBlW2F4aXNdO1xuICBjb25zdCBjb21wb25lbnRzID0gaW5wdXRzWzBdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sID8gNCA6IDE7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cyk7XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXhpc0RpbUxpbWl0IH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF4aXMgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMsIG91dHB1dFNoYXBlKSxcbiAgXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBkYXRhID0gaW5wdXRWYXJpYWJsZSgnZGF0YScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBpbmRpY2VzID0gaW5wdXRWYXJpYWJsZSgnaW5wdXRJbmRpY2VzJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG5cbiAgICBjb25zdCBjYWxjRGF0YUluZGljZXMgPSAoeDogbnVtYmVyIHwgc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IGluZGljZXNSYW5rID0gaW5kaWNlc1NoYXBlLmxlbmd0aDtcbiAgICAgIGxldCBjYWxjU3RyID0gYHZhciBpbmRpY2VzSW5kaWNlcyR7eH0gID0gJHtpbmRpY2VzLnR5cGUuaW5kaWNlc30oMCk7YDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlc1Jhbms7IGkrKykge1xuICAgICAgICBjYWxjU3RyICs9IGAke2luZGljZXNSYW5rID4gMSA/IGBpbmRpY2VzSW5kaWNlcyR7eH1bJHtpfV1gIDogYGluZGljZXNJbmRpY2VzJHt4fWB9ID0gJHtcbiAgICAgICAgICBvdXRwdXRTaGFwZS5sZW5ndGggPiAxID8gYG91dHB1dEluZGljZXMke3h9W3VuaWZvcm1zLmF4aXMgKyAke2l9XWAgOiBgb3V0cHV0SW5kaWNlcyR7eH1gXG4gICAgICAgIH07YDtcbiAgICAgIH1cbiAgICAgIGNhbGNTdHIgKz0gYFxuICAgICAgICAgIHZhciBpZHgke3h9ID0gJHtpbmRpY2VzLmdldEJ5SW5kaWNlcyhgaW5kaWNlc0luZGljZXMke3h9YCl9O1xuICAgICAgICAgIGlmIChpZHgke3h9IDwgMCkge1xuICAgICAgICAgICAgaWR4JHt4fSA9IGlkeCR7eH0gKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyR7eH0gOiAke2RhdGEudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgYDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGlucHV0UmFuazsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSBheGlzKSB7XG4gICAgICAgICAgY2FsY1N0ciArPSBgJHtpbnB1dFJhbmsgPiAxID8gYGRhdGFJbmRpY2VzJHt4fVske2l9XWAgOiBgZGF0YUluZGljZXMke3h9YH0gPSB1MzIoaWR4JHt4fSk7YDtcbiAgICAgICAgICBqICs9IGluZGljZXNSYW5rO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGNTdHIgKz0gYCR7aW5wdXRSYW5rID4gMSA/IGBkYXRhSW5kaWNlcyR7eH1bJHtpfV1gIDogYGRhdGFJbmRpY2VzJHt4fWB9ID0gJHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlLmxlbmd0aCA+IDEgPyBgb3V0cHV0SW5kaWNlcyR7eH1bJHtqfV1gIDogYG91dHB1dEluZGljZXMke3h9YFxuICAgICAgICAgIH07YDtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxjU3RyO1xuICAgIH07XG4gICAgbGV0IGFzc2lnbm1lbnQ6IHN0cmluZztcbiAgICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sKSB7XG4gICAgICBjb25zdCBzaW5nbGVBc3NpZ25tZW50ID0gKHJlc1N0cjogc3RyaW5nLCB4OiBudW1iZXIsIHR5cGVDYXN0ID0gJycpID0+IGBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYG91dHB1dE9mZnNldCArICR7eH11YCl9O1xuICAgICAgICAgICR7Y2FsY0RhdGFJbmRpY2VzKHgpfTtcbiAgICAgICAgICBsZXQgb2Zmc2V0JHt4fSA9ICR7ZGF0YS5pbmRpY2VzVG9PZmZzZXQoYGRhdGFJbmRpY2VzJHt4fWApfTtcbiAgICAgICAgICBsZXQgaW5kZXgke3h9ID0gb2Zmc2V0JHt4fSAvIDR1O1xuICAgICAgICAgIGxldCBjb21wb25lbnQke3h9ID0gb2Zmc2V0JHt4fSAlIDR1O1xuICAgICAgICAgICR7cmVzU3RyfVske3h9XSA9ICR7dHlwZUNhc3R9KCR7ZGF0YS5nZXRCeU9mZnNldChgaW5kZXgke3h9YCl9W2NvbXBvbmVudCR7eH1dKTtcbiAgICAgICAgYDtcbiAgICAgIGFzc2lnbm1lbnQgPSBgXG4gICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSBnbG9iYWxfaWR4ICogJHtjb21wb25lbnRzfTtcbiAgICAgICAgdmFyIHZhbHVlID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ3ZhbHVlJywgMCwgJ3UzMicpfVxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ3ZhbHVlJywgMSwgJ3UzMicpfVxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ3ZhbHVlJywgMiwgJ3UzMicpfVxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ3ZhbHVlJywgMywgJ3UzMicpfVxuICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfVxuICAgICAgYDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgJHtjYWxjRGF0YUluZGljZXMoJycpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7ZGF0YS5nZXRCeUluZGljZXMoJ2RhdGFJbmRpY2VzJyl9O1xuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX07XG4gICAgICBgO1xuICAgIH1cbiAgICByZXR1cm4gYFxuICAgICAgJHtzaGFkZXJIZWxwZXJcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0U2l6ZScsICd1MzInKVxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdheGlzRGltTGltaXQnLCAnaTMyJylcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpcycsICd1MzInKVxuICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyhkYXRhLCBpbmRpY2VzLCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICAgICAgJHthc3NpZ25tZW50fVxuICAgICAgfWA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0dhdGhlcicsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJ10gfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2F0aGVyQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdhdGhlckF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYXhpczogYXR0cmlidXRlcy5heGlzIGFzIG51bWJlciB9KTtcblxuZXhwb3J0IGNvbnN0IGdhdGhlciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2F0aGVyQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBpbnB1dHMgPSBjb250ZXh0LmlucHV0cztcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBVbmlmb3Jtc0FycmF5VHlwZSB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJOREF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBiYXRjaERpbXM6IG51bWJlcjtcbn1cblxuY29uc3QgY29tcHV0ZVNsaWNlT2Zmc2V0cyA9IChcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXG4gIGluZGljZXNEYXRhOiBUZW5zb3JWaWV3LFxuICBzaXplc0Zyb21TbGljZURpbXNEYXRhOiBudW1iZXJbXSxcbiAgYmF0Y2hEaW1zOiBudW1iZXIsXG4gIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIG51bVNsaWNlczogbnVtYmVyLFxuICBudW1TbGljZXNQZXJCYXRjaDogbnVtYmVyLFxuICBpbnB1dEJhdGNoU3RyaWRlOiBudW1iZXIsXG4gIG51bVNsaWNlRGltczogbnVtYmVyLFxuKSA9PiB7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogbnVtU2xpY2VzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGJhdGNoRGltcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBpbnB1dERpbXMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc2l6ZXNGcm9tU2xpY2VEaW1zRGF0YSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBudW1TbGljZXNQZXJCYXRjaCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBpbnB1dEJhdGNoU3RyaWRlIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG51bVNsaWNlRGltcyB9LFxuICBdO1xuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW251bVNsaWNlc107XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGluZGljZXNEYXRhLmRpbXMsIG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2luZGljZXNfZGF0YScsIGluZGljZXNEYXRhLmRhdGFUeXBlLCBpbmRpY2VzRGF0YS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ2lucHV0X3NsaWNlX29mZnNldHNfZGF0YScsIERhdGFUeXBlLnVpbnQzMiwgMSwgMSk7XG4gICAgY29uc3QgdmFyaWFibGVzID0gW2luZGljZXMsIG91dHB1dF07XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnYmF0Y2hfZGltcycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdpbnB1dF9kaW1zJywgdHlwZTogJ3UzMicsIGxlbmd0aDogaW5wdXREaW1zLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGEnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBzaXplc0Zyb21TbGljZURpbXNEYXRhLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnbnVtX3NsaWNlc19wZXJfYmF0Y2gnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnaW5wdXRfYmF0Y2hfc3RyaWRlJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ251bV9zbGljZV9kaW1zJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICBsZXQgYmF0Y2hfaWR4ID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLm51bV9zbGljZXNfcGVyX2JhdGNoO1xuICAgIGxldCBiYXNlX29mZnNldCA9IGJhdGNoX2lkeCAqIHVuaWZvcm1zLmlucHV0X2JhdGNoX3N0cmlkZTtcblxuICAgIGxldCBzbGljZV9pbmRpY2VzX2Jhc2Vfb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIHVuaWZvcm1zLm51bV9zbGljZV9kaW1zO1xuICAgIHZhciByZWxhdGl2ZV9zbGljZV9vZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGRpbV9pZHggPSAwdTsgZGltX2lkeCA8IHVuaWZvcm1zLm51bV9zbGljZV9kaW1zOyBkaW1faWR4ICsrKSB7XG4gICAgICB2YXIgaW5kZXggPSBpMzIoaW5kaWNlc19kYXRhW2RpbV9pZHggKyBzbGljZV9pbmRpY2VzX2Jhc2Vfb2Zmc2V0XS54KTtcbiAgICAgIGxldCBpbnB1dF9kaW1faWR4ID0gdW5pZm9ybXMuYmF0Y2hfZGltcyArIGRpbV9pZHg7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICR7XG4gICAgICAgICAgaW5wdXREaW1zLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgPyAnaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXMpOydcbiAgICAgICAgICAgIDogJ2luZGV4ICs9IGkzMih1bmlmb3Jtcy5pbnB1dF9kaW1zW2lucHV0X2RpbV9pZHhdKTsnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICR7XG4gICAgICAgIHNpemVzRnJvbVNsaWNlRGltc0RhdGEubGVuZ3RoID09PSAxXG4gICAgICAgICAgPyAncmVsYXRpdmVfc2xpY2Vfb2Zmc2V0ICs9IGluZGV4ICogaTMyKHVuaWZvcm1zLnNpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhKTsnXG4gICAgICAgICAgOiAncmVsYXRpdmVfc2xpY2Vfb2Zmc2V0ICs9IGluZGV4ICogaTMyKHVuaWZvcm1zLnNpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhW2RpbV9pZHhdKTsnXG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5wdXRfc2xpY2Vfb2Zmc2V0c19kYXRhW2dsb2JhbF9pZHhdID0gIGJhc2Vfb2Zmc2V0ICsgdTMyKHJlbGF0aXZlX3NsaWNlX29mZnNldCk7XG4gIH1gO1xuICB9O1xuXG4gIHJldHVybiBjb250ZXh0LmNvbXB1dGUoXG4gICAge1xuICAgICAgbmFtZTogJ2NvbXB1dGVTbGljZU9mZnNldHMnLFxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7aW5wdXREaW1zLmxlbmd0aH1fJHtzaXplc0Zyb21TbGljZURpbXNEYXRhLmxlbmd0aH1gLCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogY29udGV4dC5pbnB1dHNbMV0uZGF0YVR5cGUgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG51bVNsaWNlcyAvIDY0KSB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICB9KSxcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICB9LFxuICAgIHsgaW5wdXRzOiBbaW5kaWNlc0RhdGFdLCBvdXRwdXRzOiBbLTFdIH0sXG4gIClbMF07XG59O1xuXG5leHBvcnQgY29uc3QgZ2F0aGVyTkQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEdhdGhlck5EQXR0cmlidXRlcykgPT4ge1xuICBjb25zdCBpbnB1dHMgPSBjb250ZXh0LmlucHV0cztcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBpbnB1dFR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGluZGljZXNTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCBudW1TbGljZURpbXMgPSBpbmRpY2VzU2hhcGVbaW5kaWNlc1NoYXBlLmxlbmd0aCAtIDFdO1xuICBjb25zdCBudW1TbGljZXMgPSBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGluZGljZXNTaGFwZSwgaW5kaWNlc1NoYXBlLmxlbmd0aCAtIDEpO1xuICBjb25zdCBzbGljZVNpemUgPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXRTaGFwZSwgYXR0cmlidXRlcy5iYXRjaERpbXMgKyBudW1TbGljZURpbXMpO1xuICBjb25zdCBudW1CYXRjaGVzID0gU2hhcGVVdGlsLnNpemVUb0RpbWVuc2lvbihpbnB1dFNoYXBlLCBhdHRyaWJ1dGVzLmJhdGNoRGltcyk7XG4gIGNvbnN0IGlucHV0QmF0Y2hTdHJpZGUgPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXRTaGFwZSwgYXR0cmlidXRlcy5iYXRjaERpbXMpO1xuICBjb25zdCBudW1TbGljZXNQZXJCYXRjaCA9IG51bVNsaWNlcyAvIG51bUJhdGNoZXM7XG4gIGNvbnN0IHNpemVzRnJvbVNsaWNlRGltcyA9IG5ldyBBcnJheShudW1TbGljZURpbXMpO1xuICBsZXQgcnVubmluZ1Byb2R1Y3QgPSBzbGljZVNpemU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU2xpY2VEaW1zOyArK2kpIHtcbiAgICBzaXplc0Zyb21TbGljZURpbXNbbnVtU2xpY2VEaW1zIC0gMSAtIGldID0gcnVubmluZ1Byb2R1Y3Q7XG4gICAgcnVubmluZ1Byb2R1Y3QgKj0gaW5wdXRTaGFwZVthdHRyaWJ1dGVzLmJhdGNoRGltcyArIG51bVNsaWNlRGltcyAtIDEgLSBpXTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0U2xpY2VPZmZzZXRzID0gY29tcHV0ZVNsaWNlT2Zmc2V0cyhcbiAgICBjb250ZXh0LFxuICAgIGlucHV0c1sxXSxcbiAgICBzaXplc0Zyb21TbGljZURpbXMsXG4gICAgYXR0cmlidXRlcy5iYXRjaERpbXMsXG4gICAgaW5wdXRTaGFwZSxcbiAgICBudW1TbGljZXMsXG4gICAgbnVtU2xpY2VzUGVyQmF0Y2gsXG4gICAgaW5wdXRCYXRjaFN0cmlkZSxcbiAgICBudW1TbGljZURpbXMsXG4gICk7XG5cbiAgY29uc3QgbGFzdEluZGljZXNEaW1lbnNpb24gPSBhdHRyaWJ1dGVzLmJhdGNoRGltcyArIG51bVNsaWNlRGltcztcbiAgaWYgKGxhc3RJbmRpY2VzRGltZW5zaW9uID4gaW5wdXRTaGFwZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3QgZGltZW5zaW9uIG9mIGluZGljZXMgbXVzdCBub3QgYmUgbGFyZ2VyIHRoYW4gcmFuayBvZiBpbnB1dCB0ZW5zb3InKTtcbiAgfVxuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5kaWNlc1NoYXBlLnNsaWNlKDAsIC0xKS5jb25jYXQoaW5wdXRTaGFwZS5zbGljZShsYXN0SW5kaWNlc0RpbWVuc2lvbikpO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzbGljZVNpemUgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRTbGljZU9mZnNldHMuZGltcywgb3V0cHV0U2hhcGUpLFxuICBdO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnZGF0YScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBpbmRpY2VzID0gaW5wdXRWYXJpYWJsZSgnc2xpY2Vfb2Zmc2V0cycsIERhdGFUeXBlLnVpbnQzMiwgaW5wdXRTbGljZU9mZnNldHMuZGltcy5sZW5ndGgpO1xuXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgICByZXR1cm4gYFxuICAgICAgICAgICR7c2hhZGVySGVscGVyXG4gICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKVxuICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnc2xpY2Vfc2l6ZScsICd1MzInKVxuICAgICAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIGluZGljZXMsIG91dHB1dCl9XG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgICAgICAgbGV0IHNsaWNlX29mZnNldCA9IHNsaWNlX29mZnNldHNbZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLnNsaWNlX3NpemVdO1xuICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGRhdGFbdTMyKHNsaWNlX29mZnNldCkgKyBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuc2xpY2Vfc2l6ZV07XG4gICAgICAgIH1gO1xuICB9O1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAge1xuICAgICAgbmFtZTogJ0dhdGhlck5EJyxcbiAgICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuayddIH0sXG4gICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0VHlwZSB9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICB9KSxcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICB9LFxuICAgIHsgaW5wdXRzOiBbaW5wdXRzWzBdLCBpbnB1dFNsaWNlT2Zmc2V0c10gfSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdhdGhlck5EQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdhdGhlck5EQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGJhdGNoRGltcyA9IGF0dHJpYnV0ZXMuYmF0Y2hfZGltcyBhcyBudW1iZXI7XG4gIHJldHVybiB7XG4gICAgYmF0Y2hEaW1zLFxuICAgIGNhY2hlS2V5OiAnJyxcbiAgfTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgZ2F0aGVyQXhpczogbnVtYmVyO1xuICBxdWFudGl6ZUF4aXM6IG51bWJlcjtcbiAgYmxvY2tTaXplOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmIChpbnB1dHMubGVuZ3RoIDwgMyB8fCBpbnB1dHMubGVuZ3RoID4gNCkge1xuICAgIHRocm93IG5ldyBFcnJvcignR2F0aGVyQmxvY2tRdWFudGl6ZWQgcmVxdWlyZXMgMyBvciA0IGlucHV0cy4nKTtcbiAgfVxuICBjb25zdCBxdWFudGl6ZUF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLnF1YW50aXplQXhpcywgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcbiAgY29uc3QgYmxvY2tTaXplID0gYXR0cmlidXRlcy5ibG9ja1NpemU7XG4gIGNvbnN0IGRhdGEgPSBpbnB1dHNbMF07XG4gIGNvbnN0IHNjYWxlcyA9IGlucHV0c1syXTtcbiAgY29uc3QgemVyb1BvaW50ID0gaW5wdXRzLmxlbmd0aCA9PT0gNCA/IGlucHV0c1szXSA6IHVuZGVmaW5lZDtcbiAgaWYgKFxuICAgIHNjYWxlcy5kaW1zLmxlbmd0aCAhPT0gZGF0YS5kaW1zLmxlbmd0aCB8fFxuICAgICFkYXRhLmRpbXNcbiAgICAgIC5tYXAoKGQsIGkpID0+IChpID09PSBxdWFudGl6ZUF4aXMgPyBNYXRoLmNlaWwoZCAvIGJsb2NrU2l6ZSkgPT09IHNjYWxlcy5kaW1zW2ldIDogZCA9PT0gc2NhbGVzLmRpbXNbaV0pKVxuICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYSAmJiBiLCB0cnVlKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnU2NhbGVzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IgYW5kIHRoZSBkaW1zIHNob3VsZCBtYXRjaCBleGNlcHQgb24gZ2F0aGVyQXhpcy4nLFxuICAgICk7XG4gIH1cbiAgLy8gVE9ETyBVbmNvbW1lbnQgdGhlIGZvbGxvd2luZyBjaGVjayBvbmNlIHRoZSB0ZXN0IGNhc2UgY3JlYXRpb24gY29kZSBpcyBmaXhlZCB0byBjcmVhdGUgZGF0YSBjb3JyZWN0bHkgYWxpZ25lZC5cbiAgLy8gY29uc3QgaW5kaWNlcyA9IGlucHV0c1sxXTtcbiAgLy8gY29uc3QgdmFsaWRJbmRleCA9IChpbmRleDogbnVtYmVyKSA9PiBpbmRleCA+PSAwICYmIGluZGV4IDwgZGF0YS5kaW1zW2F0dHJpYnV0ZXMuZ2F0aGVyQXhpc107XG4gIC8vIGlmIChpbmRpY2VzLmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQzMiAmJiBpbmRpY2VzLmdldEludDMyQXJyYXkoKS5zb21lKCh2KSA9PiAhdmFsaWRJbmRleCh2KSkgfHxcbiAgLy8gICAgIGluZGljZXMuZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDY0ICYmIGluZGljZXMuZ2V0QmlnSW50NjRBcnJheSgpLnNvbWUoKHYpID0+ICF2YWxpZEluZGV4KE51bWJlcih2KSkpKSB7XG4gIC8vICAgdGhyb3cgbmV3IEVycm9yKCdJbmRpY2VzIG11c3QgYmUgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIGdhdGhlckF4aXMuJyk7XG4gIC8vIH1cbiAgaWYgKHplcm9Qb2ludCkge1xuICAgIGlmICh6ZXJvUG9pbnQuZGF0YVR5cGUgIT09IGRhdGEuZGF0YVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWmVybyBwb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlIGFzIHRoZSBpbnB1dCB0ZW5zb3IuJyk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHplcm9Qb2ludC5kaW1zLmxlbmd0aCAhPT0gc2NhbGVzLmRpbXMubGVuZ3RoIHx8XG4gICAgICAhemVyb1BvaW50LmRpbXMubWFwKChkLCBpKSA9PiBkID09PSBzY2FsZXMuZGltc1tpXSkucmVkdWNlKChhLCBiKSA9PiBhICYmIGIsIHRydWUpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdaZXJvIHBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IgYW5kIHRoZSBkaW1zIHNob3VsZCBtYXRjaCBleGNlcHQgb24gcXVhbnRpemVBeGlzLicsXG4gICAgICApO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgY3JlYXRlR2F0aGVyQmxvY2tRdWFudGl6ZWRQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IEdhdGhlckJsb2NrUXVhbnRpemVkQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBpbmRpY2VzU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGdhdGhlckF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmdhdGhlckF4aXMsIGlucHV0UmFuayk7XG4gIGNvbnN0IHF1YW50aXplQXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMucXVhbnRpemVBeGlzLCBpbnB1dFJhbmspO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCk7XG4gIG91dHB1dFNoYXBlLnNwbGljZShnYXRoZXJBeGlzLCAxLCAuLi5pbmRpY2VzU2hhcGUpO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICBjb25zdCBvdXRwdXRUeXBlID0gaW5wdXRzWzJdLmRhdGFUeXBlO1xuICBjb25zdCBpbnB1dFR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGlzU2lnbmVkID0gaW5wdXRUeXBlID09PSBEYXRhVHlwZS5pbnQ0OyAvLyBpbnB1dCBkYXRhIHR5cGUgaXMgZWl0aGVyIGludDQgb3IgdWludDQuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBxdWFudGl6ZUF4aXMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZ2F0aGVyQXhpcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLmJsb2NrU2l6ZSB9LFxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKC4uLmlucHV0cy5tYXAoKGlucHV0LCBfKSA9PiBpbnB1dC5kaW1zKSwgb3V0cHV0U2hhcGUpLFxuICBdO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBpbnB1dFZhcmlhYmxlKCdkYXRhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IGluZGljZXMgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dEluZGljZXMnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3Qgc2NhbGVzID0gaW5wdXRWYXJpYWJsZSgnc2NhbGVzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IHplcm9Qb2ludCA9XG4gICAgICBpbnB1dHMubGVuZ3RoID4gMyA/IGlucHV0VmFyaWFibGUoJ3plcm9Qb2ludCcsIGlucHV0c1szXS5kYXRhVHlwZSwgaW5wdXRzWzNdLmRpbXMubGVuZ3RoKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0Jywgb3V0cHV0VHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFtkYXRhLCBpbmRpY2VzLCBzY2FsZXNdO1xuICAgIGlmICh6ZXJvUG9pbnQpIHtcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goemVyb1BvaW50KTtcbiAgICB9XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAncXVhbnRpemVfYXhpcycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdnYXRoZXJfYXhpcycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdibG9ja19zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuICAgIHJldHVybiBgXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgIHZhciBpbmRpY2VzX2luZGljZXMgPSAke2luZGljZXMudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgIGlmIChpbmRpY2VzU2hhcGUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtpbmRpY2VzU2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICd1bmlmb3Jtcy5nYXRoZXJfYXhpcyArIGknKX07XG4gICAgICAgICAgICAke2luZGljZXMuaW5kaWNlc1NldCgnaW5kaWNlc19pbmRpY2VzJywgJ2knLCAnaW5kZXgnKX07XG4gICAgICAgICAgfWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgaW5kaWNlc19pbmRpY2VzID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAndW5pZm9ybXMuZ2F0aGVyX2F4aXMnKX07YDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCl9O1xuICAgICAgICB2YXIgZGF0YV9pbmRpY2VzID0gJHtkYXRhLnR5cGUuaW5kaWNlc30oMCk7XG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5nYXRoZXJfYXhpczsgaSsrKSB7XG4gICAgICAgICAgbGV0IGluZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAnaScpfTtcbiAgICAgICAgICAke2RhdGEuaW5kaWNlc1NldCgnZGF0YV9pbmRpY2VzJywgJ2knLCAnaW5kZXgnKX07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4X2Zyb21faW5kaWNlcyA9ICR7aW5kaWNlcy5nZXRCeUluZGljZXMoJ2luZGljZXNfaW5kaWNlcycpfTtcbiAgICAgICAgaWYgKGluZGV4X2Zyb21faW5kaWNlcyA8IDApIHtcbiAgICAgICAgICBpbmRleF9mcm9tX2luZGljZXMgKz0gJHtpbnB1dFNoYXBlW2dhdGhlckF4aXNdfTtcbiAgICAgICAgfVxuICAgICAgICAke2RhdGEuaW5kaWNlc1NldCgnZGF0YV9pbmRpY2VzJywgJ3VuaWZvcm1zLmdhdGhlcl9heGlzJywgJ3UzMihpbmRleF9mcm9tX2luZGljZXMpJyl9O1xuICAgICAgICBmb3IgKHZhciBpID0gdW5pZm9ybXMuZ2F0aGVyX2F4aXMgKyAxOyBpIDwgJHtvdXRwdXRTaGFwZS5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgICBsZXQgaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsIGBpICsgJHtpbmRpY2VzU2hhcGUubGVuZ3RofSAtIDFgKX07XG4gICAgICAgICAgJHtkYXRhLmluZGljZXNTZXQoJ2RhdGFfaW5kaWNlcycsICdpJywgJ2luZGV4Jyl9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhX29mZnNldCA9ICR7ZGF0YS5pbmRpY2VzVG9PZmZzZXQoJ2RhdGFfaW5kaWNlcycpfTtcbiAgICAgICAgbGV0IGRhdGFfaW5kZXggPSBkYXRhX29mZnNldCAlIDg7XG4gICAgICAgIC8vIENvbnZlcnQgNC1iaXQgcGFja2VkIGRhdGEgdG8gOC1iaXQgcGFja2VkIGRhdGEuXG4gICAgICAgIGxldCBwYWNrZWRfNGJpdF9xdWFudGl6ZWRfZGF0YSA9ICR7ZGF0YS5nZXRCeU9mZnNldCgnZGF0YV9vZmZzZXQgLyA4Jyl9O1xuICAgICAgICBsZXQgcGFja2VkXzhiaXRfcXVhbnRpemVkX2RhdGEgPSAocGFja2VkXzRiaXRfcXVhbnRpemVkX2RhdGEgPj4gKDQgKiAoZGF0YV9pbmRleCAlIDIpKSkgJiAweDBmMGYwZjBmO1xuICAgICAgICBsZXQgcXVhbnRpemVkX2RhdGFfdmVjID0gJHtpc1NpZ25lZCA/ICd1bnBhY2s0eEk4JyA6ICd1bnBhY2s0eFU4J30odTMyKHBhY2tlZF84Yml0X3F1YW50aXplZF9kYXRhKSk7XG4gICAgICAgIGxldCBxdWFudGl6ZWRfZGF0YSA9IHF1YW50aXplZF9kYXRhX3ZlY1tkYXRhX2luZGV4IC8gMl07XG4gICAgICAgIHZhciBzY2FsZV9pbmRpY2VzID0gZGF0YV9pbmRpY2VzO1xuICAgICAgICBsZXQgcXVhbnRpemVfYXhpc19pbmRleCA9ICR7c2NhbGVzLmluZGljZXNHZXQoJ2RhdGFfaW5kaWNlcycsICd1bmlmb3Jtcy5xdWFudGl6ZV9heGlzJyl9IC8gdW5pZm9ybXMuYmxvY2tfc2l6ZTtcbiAgICAgICAgJHtzY2FsZXMuaW5kaWNlc1NldCgnc2NhbGVfaW5kaWNlcycsICd1bmlmb3Jtcy5xdWFudGl6ZV9heGlzJywgJ3F1YW50aXplX2F4aXNfaW5kZXgnKX07XG4gICAgICAgIHZhciBzY2FsZSA9ICR7c2NhbGVzLmdldEJ5SW5kaWNlcygnc2NhbGVfaW5kaWNlcycpfTtcbiAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgIGlmICghemVyb1BvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ZhciB6ZXJvX3BvaW50ID0gMCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGljZXMgPSBzY2FsZV9pbmRpY2VzO1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9vZmZzZXQgPSAke3plcm9Qb2ludC5pbmRpY2VzVG9PZmZzZXQoJ3plcm9fcG9pbnRfaW5kaWNlcycpfTtcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kZXggPSB6ZXJvX3BvaW50X29mZnNldCAlIDg7XG4gICAgICAgICAgICAgIGxldCBwYWNrZWRfNGJpdF96ZXJvX3BvaW50cyA9ICR7emVyb1BvaW50LmdldEJ5T2Zmc2V0KCd6ZXJvX3BvaW50X29mZnNldCAvIDgnKX07XG4gICAgICAgICAgICAgIGxldCBwYWNrZWRfOGJpdF96ZXJvX3BvaW50cyA9IChwYWNrZWRfNGJpdF96ZXJvX3BvaW50cyA+PiAoNCAqICh6ZXJvX3BvaW50X2luZGV4ICUgMikpKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICR7aXNTaWduZWQgPyAndW5wYWNrNHhJOCcgOiAndW5wYWNrNHhVOCd9KHUzMihwYWNrZWRfOGJpdF96ZXJvX3BvaW50cykpO1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludCA9IHplcm9fcG9pbnRfdmVjW3plcm9fcG9pbnRfaW5kZXggLyAyXTtgO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKX07XG4gICAgICAgIGxldCBkZXF1YW50aXplZF9kYXRhID0gJHt0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKG91dHB1dFR5cGUpfShxdWFudGl6ZWRfZGF0YSAtIHplcm9fcG9pbnQpICogc2NhbGU7XG4gICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2RlcXVhbnRpemVkX2RhdGEnKX07XG4gICAgfWA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0dhdGhlckJsb2NrUXVhbnRpemVkJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtpbnB1dHNcbiAgICAgICAgLmZpbHRlcigoXywgaSkgPT4gaSAhPT0gMSlcbiAgICAgICAgLm1hcCgoaW5wdXQpID0+IGlucHV0LmRpbXMuam9pbignXycpKVxuICAgICAgICAuam9pbignOycpfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogQXJyYXkuZnJvbSh7IGxlbmd0aDogaW5wdXRzLmxlbmd0aCB9LCAoX3YsIF9pKSA9PiAncmFuaycpLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0VHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2F0aGVyQmxvY2tRdWFudGl6ZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEdhdGhlckJsb2NrUXVhbnRpemVkQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBpbnB1dHMgPSBjb250ZXh0LmlucHV0cztcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdhdGhlckJsb2NrUXVhbnRpemVkUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdhdGhlckJsb2NrUXVhbnRpemVkQXR0cmlidXRlcyA9IChcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4pOiBHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcbiAgICBibG9ja1NpemU6IGF0dHJpYnV0ZXMuYmxvY2tTaXplIGFzIG51bWJlcixcbiAgICBnYXRoZXJBeGlzOiBhdHRyaWJ1dGVzLmdhdGhlckF4aXMgYXMgbnVtYmVyLFxuICAgIHF1YW50aXplQXhpczogYXR0cmlidXRlcy5xdWFudGl6ZUF4aXMgYXMgbnVtYmVyLFxuICB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgYXhpczogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYXRoZXJFbGVtZW50cyByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGJlIHJhbmsgPj0gMS4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBhbmRcbiAgICAgICAgICAgICAgICAgICAgIGluZGljZXMgaW5wdXQgdGVuc29ycyBiZSBvZiBzYW1lIHJhbmsuYCk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUdhdGhlckVsZW1lbnRzUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBHYXRoZXJFbGVtZW50c0F0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRPdXRwdXREYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG5cbiAgY29uc3QgaW5kaWNlc1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gIGNvbnN0IGluZGljZXNEYXRhVHlwZSA9IGlucHV0c1sxXS5kYXRhVHlwZTtcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRSYW5rKTtcbiAgY29uc3QgYXhpc0RpbUxpbWl0ID0gaW5wdXRTaGFwZVtheGlzXTtcblxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGluZGljZXNTaGFwZS5zbGljZSgwKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcblxuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRPdXRwdXREYXRhVHlwZSwgaW5wdXRSYW5rKTtcbiAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2luZGljZXNJbnB1dCcsIGluZGljZXNEYXRhVHlwZSwgaW5kaWNlc1NoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dE91dHB1dERhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF4aXNEaW1MaW1pdCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBheGlzIH0sXG4gIF07XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIGluZGljZXNTaGFwZSwgb3V0cHV0U2hhcGUpKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnLCAncmFuayddO1xuXG4gIC8vIGludDY0IGluZGljZXMgd291bGQgYmUgdHJlYXRlZCBhcyBsaXR0bGUgZW5kaWFuIGkzMiB3aXRoIGFzc3VtcHRpb24gdGhleSBmYWxsIGluIGkzMiBsaW1pdHNcbiAgLy8gVGhhdCBhc3N1bXB0aW9uIGlzIHNhZmUgYXMgaXQncyBub3QgcG9zc2libGUgdG8gYWxsb2NhdGUgPjJnYiBidWZmZXIgZm9yIGlucHV0IHRlbnNvclxuICAvLyBJbnB1dCBkYXRhIHdpbGwgYmUgdHJlYXRlZCBhcyB1MzIgb3IgdHdvIHUzMiBmb3IgOC1ieXRlIHRlbnNvcnNcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICAke3NoYWRlckhlbHBlclxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXNEaW1MaW1pdCcsICdpMzInKVxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdheGlzJywgJ3UzMicpXG4gICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBpbmRpY2VzLCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG5cbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgICB2YXIgaWR4ID0gJHtpbmRpY2VzLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgaWR4ID0gaWR4ICsgdW5pZm9ybXMuYXhpc0RpbUxpbWl0O1xuICAgICAgfVxuICAgICAgdmFyIGlucHV0SW5kaWNlcyA9ICR7aW5wdXQudHlwZS5pbmRpY2VzfShvdXRwdXRJbmRpY2VzKTtcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRJbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnLCAndTMyKGlkeCknKX07XG4gICAgICBsZXQgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRJbmRpY2VzJyl9O1xuXG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfTtcbiAgfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnR2F0aGVyRWxlbWVudHMnLFxuICAgIHNoYWRlckNhY2hlOiB7IGlucHV0RGVwZW5kZW5jaWVzIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyIH0pO1xuXG5leHBvcnQgY29uc3QgZ2F0aGVyRWxlbWVudHMgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBpbnB1dHMgPSBjb250ZXh0LmlucHV0cztcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdhdGhlckVsZW1lbnRzUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IEdlbW1VdGlsLCBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBpcyBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPCAyIHx8IGlucHV0cy5sZW5ndGggPiAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhaWQgaW5wdXQgbnVtYmVyLicpO1xuICB9XG5cbiAgLy8gJ0MnIGNhbiBiZSBvZiBkaW1lbnNpb25hbGl0eSAwLCAxIG9yIDIgb25seVxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMl0uZGltcy5sZW5ndGggPiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHNoYXBlIG9mIEMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGF0YVR5cGUgIT09IGlucHV0c1sxXS5kYXRhVHlwZSB8fCAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IGlucHV0c1syXS5kYXRhVHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHR5cGVzIGFyZSBtaXNtYXRjaGVkJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2VtbUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICB0cmFuc0E6IGJvb2xlYW47XG4gIHRyYW5zQjogYm9vbGVhbjtcbiAgYWxwaGE6IG51bWJlcjtcbiAgYmV0YTogbnVtYmVyO1xufVxuXG5jb25zdCBjcmVhdGVHZW1tUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEdlbW1BdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBjb25zdCBiU2hhcGUgPSBpbnB1dHNbMV0uZGltcy5zbGljZSgpO1xuICBjb25zdCBbTSwgTiwgS10gPSBHZW1tVXRpbC5nZXRTaGFwZU9mR2VtbVJlc3VsdChcbiAgICBhU2hhcGUsXG4gICAgYXR0cmlidXRlcy50cmFuc0EsXG4gICAgYlNoYXBlLFxuICAgIGF0dHJpYnV0ZXMudHJhbnNCLFxuICAgIGlucHV0cy5sZW5ndGggPT09IDMgPyBpbnB1dHNbMl0uZGltcyA6IHVuZGVmaW5lZCxcbiAgKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbTSwgTl07XG4gIGlmICghb3V0cHV0U2hhcGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgZ2VtbSBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtcbiAgfVxuICBjb25zdCB0aWxlU2l6ZSA9IDE2O1xuICBjb25zdCBudW1UaWxlTiA9IE1hdGguY2VpbChOIC8gdGlsZVNpemUpO1xuICBjb25zdCBudW1UaWxlTSA9IE1hdGguY2VpbChNIC8gdGlsZVNpemUpO1xuICAvLyBUT0RPOiBGaW5kIHRoZSBjb25kaXRpb24gd2hlbiB0byB1c2UgdGhlIG5haXZlIG9uZS5cbiAgY29uc3QgdXNlU2hhcmVkID0gdHJ1ZTtcblxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHVzZVNoYXJlZCA/IG51bVRpbGVOIDogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE4gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogSyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYWxwaGEgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmJldGEgfSxcbiAgXTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgbGV0IGxpbmUgPSAnJztcbiAgICBpZiAoYXR0cmlidXRlcy50cmFuc0EgJiYgYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gYVtrICogdW5pZm9ybXMuTSArIG1dICogYltuICogdW5pZm9ybXMuSyArIGtdOyc7XG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLnRyYW5zQSAmJiAhYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gYVtrICogdW5pZm9ybXMuTSArIG1dICogYltrICogdW5pZm9ybXMuTiArIG5dOyc7XG4gICAgfSBlbHNlIGlmICghYXR0cmlidXRlcy50cmFuc0EgJiYgYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltuICogdW5pZm9ybXMuSyArIGtdOyc7XG4gICAgfSBlbHNlIGlmICghYXR0cmlidXRlcy50cmFuc0EgJiYgIWF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgICBsaW5lID0gJ3ZhbHVlICs9IGFbbSAqIHVuaWZvcm1zLksgKyBrXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTsnO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGN1bGF0ZUFscGhhID0gYXR0cmlidXRlcy5hbHBoYSA9PT0gMSA/ICcnIDogJ3ZhbHVlICo9IHVuaWZvcm1zLmFscGhhOyc7XG4gICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zKTtcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMpO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gYS50eXBlLnZhbHVlO1xuICAgIGxldCBjOiBJbmRpY2VzSGVscGVyIHwgbnVsbCA9IG51bGw7XG4gICAgY29uc3QgdmFyaWFibGVzID0gW2EsIGJdO1xuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBjID0gaW5wdXRWYXJpYWJsZSgnYycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcbiAgICAgIHZhcmlhYmxlcy5wdXNoKGMpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dCk7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnTScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdOJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZjMyJyB9LFxuICAgICAgeyBuYW1lOiAnYmV0YScsIHR5cGU6ICdmMzInIH0sXG4gICAgXTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgIGxldCBtID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLk47XG4gICAgbGV0IG4gPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuTjtcblxuICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KDApO1xuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAke2xpbmV9XG4gICAgfVxuXG4gICAgJHtjYWxjdWxhdGVBbHBoYX1cbiAgICAkeygoKSA9PiB7XG4gICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgbGV0IGNPZmZzZXQgPSAke2MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ3ZlYzIobSwgbiknLCBvdXRwdXQpfTsgdmFsdWUgKz0gJHtcbiAgICAgICAgICBkYXRhVHlwZVxuICAgICAgICB9KHVuaWZvcm1zLmJldGEpICogJHtjLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O2A7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSkoKX1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgfWA7XG4gIH07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlU2hhcmVkID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zKTtcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMpO1xuICAgIGxldCBjOiBJbmRpY2VzSGVscGVyIHwgbnVsbCA9IG51bGw7XG4gICAgY29uc3QgdmFyaWFibGVzID0gW2EsIGJdO1xuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBjID0gaW5wdXRWYXJpYWJsZSgnYycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcbiAgICAgIHZhcmlhYmxlcy5wdXNoKGMpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dCk7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnbnVtX3RpbGVfbicsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ04nLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnSycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInIH0sXG4gICAgICB7IG5hbWU6ICdiZXRhJywgdHlwZTogJ2YzMicgfSxcbiAgICBdO1xuXG4gICAgbGV0IGNhbGNSZXN1bHQgPSAnJztcbiAgICBsZXQgZmlsbFdvcmtncm91cE1lbW9yeSA9ICcnO1xuICAgIGlmIChhdHRyaWJ1dGVzLnRyYW5zQSAmJiBhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgZmlsbFdvcmtncm91cE1lbW9yeSA9IGBcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2EudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTikge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtiLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYDtcbiAgICAgIGNhbGNSZXN1bHQgPSBgdmFsdWUgKz0gdGlsZV9hW2tdW2xvY2FsX2lkLnldICogdGlsZV9iW2xvY2FsX2lkLnhdW2tdO2A7XG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLnRyYW5zQSAmJiAhYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgIGZpbGxXb3JrZ3JvdXBNZW1vcnkgPSBgXG4gICAgICB2YXIgY29sID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk0gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBhW3JvdyAqIHVuaWZvcm1zLk0gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHthLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuXG4gICAgICBjb2wgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5OICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5OICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7Yi50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cbiAgICAgIGA7XG4gICAgICBjYWxjUmVzdWx0ID0gYHZhbHVlICs9IHRpbGVfYVtrXVtsb2NhbF9pZC55XSAqIHRpbGVfYltrXVtsb2NhbF9pZC54XTtgO1xuICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXMudHJhbnNBICYmIGF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgICBmaWxsV29ya2dyb3VwTWVtb3J5ID0gYFxuICAgICAgdmFyIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk0pIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7YS50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5OKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2IudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgO1xuICAgICAgY2FsY1Jlc3VsdCA9IGB2YWx1ZSArPSB0aWxlX2FbbG9jYWxfaWQueV1ba10gKiB0aWxlX2JbbG9jYWxfaWQueF1ba107YDtcbiAgICB9IGVsc2UgaWYgKCFhdHRyaWJ1dGVzLnRyYW5zQSAmJiAhYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgIGZpbGxXb3JrZ3JvdXBNZW1vcnkgPSBgXG4gICAgICB2YXIgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTSkge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBhW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHthLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuXG4gICAgICBjb2wgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5OICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5OICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7Yi50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cbiAgICAgIGA7XG4gICAgICBjYWxjUmVzdWx0ID0gYHZhbHVlICs9IHRpbGVfYVtsb2NhbF9pZC55XVtrXSAqIHRpbGVfYltrXVtsb2NhbF9pZC54XTtgO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGN1bGF0ZUFscGhhID0gYXR0cmlidXRlcy5hbHBoYSA9PT0gMSA/ICcnIDogJ3ZhbHVlICo9IHVuaWZvcm1zLmFscGhhOyc7XG5cbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVfYTogYXJyYXk8YXJyYXk8JHthLnR5cGUuc3RvcmFnZX0sICR7dGlsZVNpemV9PiwgJHt0aWxlU2l6ZX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlX2I6IGFycmF5PGFycmF5PCR7Yi50eXBlLnN0b3JhZ2V9LCAke3RpbGVTaXplfT4sICR7dGlsZVNpemV9PjtcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFt0aWxlU2l6ZSwgdGlsZVNpemUsIDFdKX1cbiAgICBsZXQgdGlsZV9jb2xfc3RhcnQgPSAod29ya2dyb3VwX2luZGV4ICUgdW5pZm9ybXMubnVtX3RpbGVfbikgKiAke3RpbGVTaXplfTtcbiAgICBsZXQgdGlsZV9yb3dfc3RhcnQgPSAod29ya2dyb3VwX2luZGV4IC8gdW5pZm9ybXMubnVtX3RpbGVfbikgKiAke3RpbGVTaXplfTtcbiAgICBsZXQgbnVtX3RpbGVzID0gKHVuaWZvcm1zLksgLSAxKSAvICR7dGlsZVNpemV9ICsgMTtcbiAgICB2YXIga19zdGFydCA9IDB1O1xuICAgIHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO1xuICAgIGZvciAodmFyIHQ6IHUzMiA9IDB1OyB0IDwgbnVtX3RpbGVzOyB0KyspIHtcbiAgICAgICR7ZmlsbFdvcmtncm91cE1lbW9yeX1cbiAgICAgIGtfc3RhcnQgPSBrX3N0YXJ0ICsgJHt0aWxlU2l6ZX07XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgJHt0aWxlU2l6ZX07IGsrKykge1xuICAgICAgICAke2NhbGNSZXN1bHR9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgJHtjYWxjdWxhdGVBbHBoYX1cbiAgICBsZXQgbSA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICBsZXQgbiA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAkeygoKSA9PiB7XG4gICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgbGV0IGNPZmZzZXQgPSAke2MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ3ZlYzIobSwgbiknLCBvdXRwdXQpfTsgdmFsdWUgKz0gJHtcbiAgICAgICAgICBvdXRwdXQudHlwZS52YWx1ZVxuICAgICAgICB9KHVuaWZvcm1zLmJldGEpICogJHtjLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O2A7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSkoKX1cbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIG91dHB1dFttICogdW5pZm9ybXMuTiArIG5dID0gdmFsdWU7XG4gICAgfVxuICB9YDtcbiAgfTtcblxuICBpZiAodXNlU2hhcmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdHZW1tU2hhcmVkJyxcbiAgICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IG51bVRpbGVOICogbnVtVGlsZU0gfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgICAgfSksXG4gICAgICBnZXRTaGFkZXJTb3VyY2U6IGdldFNoYWRlclNvdXJjZVNoYXJlZCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnR2VtbScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHZW1tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdlbW1BdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgdHJhbnNBID0gYXR0cmlidXRlcy50cmFuc0EgYXMgYm9vbGVhbjtcbiAgY29uc3QgdHJhbnNCID0gYXR0cmlidXRlcy50cmFuc0IgYXMgYm9vbGVhbjtcbiAgY29uc3QgYWxwaGEgPSBhdHRyaWJ1dGVzLmFscGhhIGFzIG51bWJlcjtcbiAgY29uc3QgYmV0YSA9IGF0dHJpYnV0ZXMuYmV0YSBhcyBudW1iZXI7XG4gIHJldHVybiB7XG4gICAgdHJhbnNBLFxuICAgIHRyYW5zQixcbiAgICBhbHBoYSxcbiAgICBiZXRhLFxuICAgIGNhY2hlS2V5OiBgJHthdHRyaWJ1dGVzLnRyYW5zQX07JHthdHRyaWJ1dGVzLnRyYW5zQn07JHthdHRyaWJ1dGVzLmFscGhhID09PSAxfWAsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2VtbSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2VtbVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5sZXQgW2lkeE4sIGlkeEMsIGlkeEgsIGlkeFddID0gWzAsIDEsIDIsIDNdOyAvLyBOQ0hXXG50eXBlIE1vZGUgPSAnYmlsaW5lYXInIHwgJ25lYXJlc3QnIHwgJ2JpY3ViaWMnO1xudHlwZSBQYWRkaW5nTW9kZSA9ICd6ZXJvcycgfCAnYm9yZGVyJyB8ICdyZWZsZWN0aW9uJztcbnR5cGUgRm9ybWF0ID0gJ05IV0MnIHwgJ05DSFcnO1xuZXhwb3J0IGludGVyZmFjZSBHcmlkU2FtcGVBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgYWxpZ25Db3JuZXJzOiBudW1iZXI7XG4gIG1vZGU6IE1vZGU7XG4gIHBhZGRpbmdNb2RlOiBQYWRkaW5nTW9kZTtcbiAgZm9ybWF0OiBGb3JtYXQ7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgNC1EIHRlbnNvciBpcyBzdXBwb3J0ZWQuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwgdG8gZ3JpZCBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMiAhPT0gaW5wdXRzWzFdLmRpbXNbaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGxhc3QgZGltZW5zaW9uIG9mIGdyaWQgbXVzdCBiZSBlcXVhbCB0byAke2lucHV0c1swXS5kaW1zLmxlbmd0aCAtIDJ9YCk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLmRpbXNbMF0gIT09IGlucHV0c1sxXS5kaW1zWzBdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdncmlkIGJhdGNoIHNpemUgbXVzdCBtYXRjaCBpbnB1dCBiYXRjaCBzaXplJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdzR2V0Q3ViaWNDb2VmZnMgPSBgXG4gIGZuIGdzX2dldF9jdWJpY19jb2VmZnMoeDogZjMyKSAtPiB2ZWM0PGYzMj4ge1xuICAgIGxldCBjdWJpY19hbHBoYSA9IC0wLjc1ZjtcbiAgICBsZXQgeF9hYnMgPSBhYnMoeCk7XG4gICAgdmFyIGNvZWZmczogdmVjNDxmMzI+O1xuICAgIGNvZWZmc1swXSA9ICgoKGN1YmljX2FscGhhICogKHhfYWJzICsgMSkgLSA1ICogY3ViaWNfYWxwaGEpICogKHhfYWJzICsgMSkgKyA4ICogY3ViaWNfYWxwaGEpICogKHhfYWJzICsgMSkgLSA0ICogY3ViaWNfYWxwaGEpO1xuICAgIGNvZWZmc1sxXSA9ICgoKGN1YmljX2FscGhhICsgMikgKiB4X2FicyAtIChjdWJpY19hbHBoYSArIDMpKSAqIHhfYWJzICogeF9hYnMgKyAxKTtcbiAgICBjb2VmZnNbMl0gPSAoKChjdWJpY19hbHBoYSArIDIpICogKDEgLSB4X2FicykgLSAoY3ViaWNfYWxwaGEgKyAzKSkgKiAoMSAtIHhfYWJzKSAqICgxIC0geF9hYnMpICsgMSk7XG4gICAgY29lZmZzWzNdID0gKCgoY3ViaWNfYWxwaGEgKiAoMiAtIHhfYWJzKSAtIDUgKiBjdWJpY19hbHBoYSkgKiAoMiAtIHhfYWJzKSArIDggKiBjdWJpY19hbHBoYSkgKiAoMiAtIHhfYWJzKSAtIDQgKiBjdWJpY19hbHBoYSk7XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuYDtcblxuY29uc3QgZ3NCaWN1YmljSW50ZXJwb2xhdGUgPSAoZGF0YVR5cGU6IHN0cmluZyk6IHN0cmluZyA9PiBgXG4gIGZuIGdzX2JpY3ViaWNfaW50ZXJwb2xhdGUocDogbWF0NHg0PCR7ZGF0YVR5cGV9PiwgeDogZjMyLCB5OiBmMzIpIC0+ICR7ZGF0YVR5cGV9IHtcbiAgICB2YXIgdjogdmVjNDxmMzI+O1xuICAgIHZhciBjb2VmZnMgPSBnc19nZXRfY3ViaWNfY29lZmZzKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICB2W2ldID0gY29lZmZzWzBdICogcFtpXVswXSArIGNvZWZmc1sxXSAqIHBbaV1bMV0gKyBjb2VmZnNbMl0gKiBwW2ldWzJdICsgY29lZmZzWzNdICogcFtpXVszXTtcbiAgICB9XG4gICAgY29lZmZzID0gZ3NfZ2V0X2N1YmljX2NvZWZmcyh5KTtcbiAgICBsZXQgcGl4ZWwgPSAke2RhdGFUeXBlfShjb2VmZnNbMF0gKiB2WzBdICsgY29lZmZzWzFdICogdlsxXSArIGNvZWZmc1syXSAqIHZbMl0gKyBjb2VmZnNbM10gKiB2WzNdKTtcbiAgICByZXR1cm4gcGl4ZWw7XG4gIH1cbmA7XG5cbmNvbnN0IGdzRGVub3JtYWxpemUgPSAoYXR0cmlidXRlczogR3JpZFNhbXBlQXR0cmlidXRlcyk6IHN0cmluZyA9PiBgXG4gIGZuIGdzX2Rlbm9ybWFsaXplKG46IGYzMiwgbGVuZ3RoOiBpMzIpIC0+IGYzMiB7XG4gICAgJHtcbiAgICAgIGF0dHJpYnV0ZXMuYWxpZ25Db3JuZXJzID09PSAwXG4gICAgICAgID8gYFxuICAgIC8vIGFsaWduQ29ybmVyczogZmFsc2UgPT4gWy0xLCAxXSB0byBbLTAuNSwgbGVuZ3RoIC0gMC41XVxuICAgIHJldHVybiAoKG4gKyAxLjApICogZjMyKGxlbmd0aCkgLSAxLjApIC8gMi4wO1xuICAgIGBcbiAgICAgICAgOiBgXG4gICAgLy8gYWxpZ25Db3JuZXJzOiB0cnVlID0+IFstMSwgMV0gdG8gWzAsIGxlbmd0aCAtIDFdXG4gICAgcmV0dXJuIChuICsgMS4wKSAvIDIuMCAqIChmMzIobGVuZ3RoIC0gMSkpO1xuICAgIGBcbiAgICB9XG4gIH1cbmA7XG5cbmNvbnN0IGdzUmVmbGVjdCA9IChhdHRyaWJ1dGVzOiBHcmlkU2FtcGVBdHRyaWJ1dGVzKTogc3RyaW5nID0+IGBcbiAgJHtcbiAgICBhdHRyaWJ1dGVzLnBhZGRpbmdNb2RlID09PSAncmVmbGVjdGlvbidcbiAgICAgID8gYFxuICAgICAgZm4gZ3NfcmVmbGVjdCh4OiBpMzIsIHhfbWluOiBmMzIsIHhfbWF4OiBmMzIpIC0+IHUzMiB7XG4gICAgICAgIHZhciBkeCA9IDAuMDtcbiAgICAgICAgdmFyIGZ4ID0gZjMyKHgpO1xuICAgICAgICBsZXQgcmFuZ2UgPSB4X21heCAtIHhfbWluO1xuICAgICAgICBpZiAoZnggPCB4X21pbikge1xuICAgICAgICAgIGR4ID0geF9taW4gLSBmeDtcbiAgICAgICAgICBsZXQgbiA9IHUzMihkeCAvIHJhbmdlKTtcbiAgICAgICAgICBsZXQgciA9IGR4IC0gZjMyKG4pICogcmFuZ2U7XG4gICAgICAgICAgaWYgKG4gJSAyID09IDApIHtcbiAgICAgICAgICAgIGZ4ID0geF9taW4gKyByO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmeCA9IHhfbWF4IC0gcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZnggPiB4X21heCkge1xuICAgICAgICAgIGR4ID0gZnggLSB4X21heDtcbiAgICAgICAgICBsZXQgbiA9IHUzMihkeCAvIHJhbmdlKTtcbiAgICAgICAgICBsZXQgciA9IGR4IC0gZjMyKG4pICogcmFuZ2U7XG4gICAgICAgICAgaWYgKG4gJSAyID09IDApIHtcbiAgICAgICAgICAgIGZ4ID0geF9tYXggLSByO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmeCA9IHhfbWluICsgcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHUzMihmeCk7XG4gICAgICB9YFxuICAgICAgOiAnJ1xuICB9XG5gO1xuXG5jb25zdCBwaXhlbEF0R3JpZCA9IChpbnB1dDogSW5kaWNlc0hlbHBlciwgZGF0YVR5cGU6IHN0cmluZywgYXR0cmlidXRlczogR3JpZFNhbXBlQXR0cmlidXRlcyk6IHN0cmluZyA9PlxuICBgXG4gIGZuIHBpeGVsX2F0X2dyaWQocjogaTMyLCBjOiBpMzIsIEg6IGkzMiwgVzogaTMyLCBiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIGJvcmRlcjogdmVjNDxmMzI+KSAtPiAke2RhdGFUeXBlfSB7XG4gICAgIHZhciBwaXhlbCA9ICR7ZGF0YVR5cGV9KDApO1xuICAgICB2YXIgaW5kaWNlcyA9IHZlYzQ8dTMyPigwKTtcbiAgICAgaW5kaWNlc1ske2lkeE59XSA9IGJhdGNoO1xuICAgICBpbmRpY2VzWyR7aWR4Q31dID0gY2hhbm5lbDtgICtcbiAgKCgpID0+IHtcbiAgICBzd2l0Y2ggKGF0dHJpYnV0ZXMucGFkZGluZ01vZGUpIHtcbiAgICAgIGNhc2UgJ3plcm9zJzpcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBpZiAociA+PSAwICYmIHIgPCBIICYmIGMgPj0wICYmIGMgPCBXKSB7XG4gICAgICAgICAgICBpbmRpY2VzWyR7aWR4SH1dID0gdTMyKHIpO1xuICAgICAgICAgICAgaW5kaWNlc1ske2lkeFd9XSA9IHUzMihjKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICR7ZGF0YVR5cGV9KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIGNhc2UgJ2JvcmRlcic6XG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICAgaW5kaWNlc1ske2lkeEh9XSA9IHUzMihjbGFtcChyLCAwLCBIIC0gMSkpO1xuICAgICAgICAgIGluZGljZXNbJHtpZHhXfV0gPSB1MzIoY2xhbXAoYywgMCwgVyAtIDEpKTtcbiAgICAgICAgYDtcbiAgICAgIGNhc2UgJ3JlZmxlY3Rpb24nOlxuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgIGluZGljZXNbJHtpZHhIfV0gPSBnc19yZWZsZWN0KHIsIGJvcmRlclsxXSwgYm9yZGVyWzNdKTtcbiAgICAgICAgICBpbmRpY2VzWyR7aWR4V31dID0gZ3NfcmVmbGVjdChjLCBib3JkZXJbMF0sIGJvcmRlclsyXSk7XG4gICAgICAgIGA7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcgbW9kZSAke2F0dHJpYnV0ZXMucGFkZGluZ01vZGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gIH0pKCkgK1xuICBgXG4gICAgcmV0dXJuICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbmRpY2VzJyl9O1xuICB9XG5gO1xuXG5jb25zdCBjb21wdXRlUGl4ZWwgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBkYXRhVHlwZTogc3RyaW5nLCBhdHRyaWJ1dGVzOiBHcmlkU2FtcGVBdHRyaWJ1dGVzKTogc3RyaW5nID0+XG4gICgoKSA9PiB7XG4gICAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcbiAgICAgIGNhc2UgJ25lYXJlc3QnOlxuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgIGxldCByZXN1bHQgPSBwaXhlbF9hdF9ncmlkKGkzMihyb3VuZCh5KSksIGkzMihyb3VuZCh4KSksIEhfaW4sIFdfaW4sIGluZGljZXNbJHtpZHhOfV0sIGluZGljZXNbJHtpZHhDfV0sIGJvcmRlcik7XG4gICAgICAgIGA7XG4gICAgICBjYXNlICdiaWxpbmVhcic6XG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICAgbGV0IHgxID0gaTMyKGZsb29yKHgpKTtcbiAgICAgICAgICBsZXQgeTEgPSBpMzIoZmxvb3IoeSkpO1xuICAgICAgICAgIGxldCB4MiA9IHgxICsgMTtcbiAgICAgICAgICBsZXQgeTIgPSB5MSArIDE7XG5cbiAgICAgICAgICBsZXQgcDExID0gcGl4ZWxfYXRfZ3JpZCh5MSwgeDEsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtpZHhOfV0sIGluZGljZXNbJHtpZHhDfV0sIGJvcmRlcik7XG4gICAgICAgICAgbGV0IHAxMiA9IHBpeGVsX2F0X2dyaWQoeTEsIHgyLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7aWR4Tn1dLCBpbmRpY2VzWyR7aWR4Q31dLCBib3JkZXIpO1xuICAgICAgICAgIGxldCBwMjEgPSBwaXhlbF9hdF9ncmlkKHkyLCB4MSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2lkeE59XSwgaW5kaWNlc1ske2lkeEN9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDIyID0gcGl4ZWxfYXRfZ3JpZCh5MiwgeDIsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtpZHhOfV0sIGluZGljZXNbJHtpZHhDfV0sIGJvcmRlcik7XG5cbiAgICAgICAgICBsZXQgZHgyID0gJHtkYXRhVHlwZX0oZjMyKHgyKSAtIHgpO1xuICAgICAgICAgIGxldCBkeDEgPSAke2RhdGFUeXBlfSh4IC0gZjMyKHgxKSk7XG4gICAgICAgICAgbGV0IGR5MiA9ICR7ZGF0YVR5cGV9KGYzMih5MikgLSB5KTtcbiAgICAgICAgICBsZXQgZHkxID0gJHtkYXRhVHlwZX0oeSAtIGYzMih5MSkpO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBkeTIgKiAoZHgyICogcDExICsgZHgxICogcDEyKSArIGR5MSAqIChkeDIgKiBwMjEgKyBkeDEgKiBwMjIpO1xuICAgICAgICBgO1xuICAgICAgY2FzZSAnYmljdWJpYyc6XG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICAgbGV0IHgwID0gaTMyKGZsb29yKHgpKSAtIDE7XG4gICAgICAgICAgbGV0IHkwID0gaTMyKGZsb29yKHkpKSAtIDE7XG4gICAgICAgICAgdmFyIHA6IG1hdDR4NDwke2RhdGFUeXBlfT47XG4gICAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCA0OyBoKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgNDsgdysrKSB7XG4gICAgICAgICAgICAgIHBbaF1bd10gPSBwaXhlbF9hdF9ncmlkKGggKyB5MCwgdyArIHgwLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7aWR4Tn1dLCBpbmRpY2VzWyR7aWR4Q31dLCBib3JkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBkeCA9IHggLSBmMzIoeDAgKyAxKTtcbiAgICAgICAgICBsZXQgZHkgPSB5IC0gZjMyKHkwICsgMSk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGdzX2JpY3ViaWNfaW50ZXJwb2xhdGUocCwgZHgsIGR5KTtcbiAgICAgICAgYDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbW9kZSAke2F0dHJpYnV0ZXMubW9kZX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfSkoKSArIGAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdyZXN1bHQnKX1gO1xuXG5jb25zdCBjcmVhdGVHcmlkU2FtcGxlUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEdyaWRTYW1wZUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICAvLyBkaXNjYXJkIGxhc3QgZGltZW5zaW9uIGZvciB1c2luZyB2ZWMyIHRvIGFjY2VzcyBncmlkIGRhdGFcbiAgY29uc3QgZ3JpZFNoYXBlID0gW2lucHV0c1sxXS5kaW1zWzBdLCBpbnB1dHNbMV0uZGltc1sxXSwgaW5wdXRzWzFdLmRpbXNbMl1dO1xuICBjb25zdCBncmlkID0gaW5wdXRWYXJpYWJsZSgnZ3JpZCcsIGlucHV0c1sxXS5kYXRhVHlwZSwgZ3JpZFNoYXBlLmxlbmd0aCwgMik7XG4gIGxldCBvdXRwdXRTaGFwZSA9IFtpbnB1dHNbMF0uZGltc1swXSwgaW5wdXRzWzBdLmRpbXNbMV0sIGlucHV0c1sxXS5kaW1zWzFdLCBpbnB1dHNbMV0uZGltc1syXV07XG4gIGlmIChhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnKSB7XG4gICAgb3V0cHV0U2hhcGUgPSBbaW5wdXRzWzBdLmRpbXNbMF0sIGlucHV0c1sxXS5kaW1zWzFdLCBpbnB1dHNbMV0uZGltc1syXSwgaW5wdXRzWzBdLmRpbXNbM11dO1xuICAgIFtpZHhOLCBpZHhDLCBpZHhILCBpZHhXXSA9IFswLCAzLCAxLCAyXTtcbiAgfVxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBkYXRhVHlwZSA9IHgudHlwZS52YWx1ZTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgZ3JpZFNoYXBlLCBvdXRwdXRTaGFwZSksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyh4LCBncmlkLCBvdXRwdXQpfVxuICAke2dzR2V0Q3ViaWNDb2VmZnN9XG4gICR7Z3NCaWN1YmljSW50ZXJwb2xhdGUoZGF0YVR5cGUpfVxuICAke2dzRGVub3JtYWxpemUoYXR0cmlidXRlcyl9XG4gICR7Z3NSZWZsZWN0KGF0dHJpYnV0ZXMpfVxuICAke3BpeGVsQXRHcmlkKHgsIGRhdGFUeXBlLCBhdHRyaWJ1dGVzKX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgbGV0IEhfaW4gPSBpMzIodW5pZm9ybXMueF9zaGFwZVske2lkeEh9XSk7XG4gICAgICBsZXQgV19pbiA9IGkzMih1bmlmb3Jtcy54X3NoYXBlWyR7aWR4V31dKTtcblxuICAgICAgJHtcbiAgICAgICAgYXR0cmlidXRlcy5hbGlnbkNvcm5lcnMgPT09IDBcbiAgICAgICAgICA/IGBcbiAgICAgIGxldCB4X21pbiA9IC0wLjU7XG4gICAgICBsZXQgeF9tYXggPSBmMzIoV19pbikgLSAwLjU7XG4gICAgICBsZXQgeV9taW4gPSAtMC41O1xuICAgICAgbGV0IHlfbWF4ID0gZjMyKEhfaW4pIC0gMC41O1xuICAgICAgYFxuICAgICAgICAgIDogYFxuICAgICAgbGV0IHhfbWluID0gMC4wO1xuICAgICAgbGV0IHhfbWF4ID0gZjMyKFdfaW4pIC0gMS4wO1xuICAgICAgbGV0IHlfbWluID0gMC4wO1xuICAgICAgbGV0IHlfbWF4ID0gZjMyKEhfaW4pIC0gMS4wO1xuICAgICAgYFxuICAgICAgfTtcbiAgICAgIGxldCBib3JkZXIgPSB2ZWM0PGYzMj4oeF9taW4sIHlfbWluLCB4X21heCwgeV9tYXgpO1xuXG4gICAgICBsZXQgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgIHZhciBncmlkX2luZGljZXMgPSB2ZWMzPHUzMj4oaW5kaWNlc1ske2lkeE59XSwgaW5kaWNlc1ske2lkeEh9XSwgaW5kaWNlc1ske2lkeFd9XSk7XG4gICAgICBsZXQgbnh5ID0gJHtncmlkLmdldEJ5SW5kaWNlcygnZ3JpZF9pbmRpY2VzJyl9O1xuICAgICAgdmFyIHggPSBnc19kZW5vcm1hbGl6ZShmMzIobnh5WzBdKSwgV19pbik7XG4gICAgICB2YXIgeSA9IGdzX2Rlbm9ybWFsaXplKGYzMihueHlbMV0pLCBIX2luKTtcblxuICAgICAgJHtjb21wdXRlUGl4ZWwob3V0cHV0LCBkYXRhVHlwZSwgYXR0cmlidXRlcyl9XG4gIH1gO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0dyaWRTYW1wbGUnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZScsICd0eXBlJ10gfSxcbiAgICBnZXRSdW5EYXRhOiAoaW5wdXRzKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBncmlkU2FtcGxlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBHcmlkU2FtcGVBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdyaWRTYW1wbGVQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR3JpZFNhbXBsZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBHcmlkU2FtcGVBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgYWxpZ25Db3JuZXJzOiBhdHRyaWJ1dGVzLmFsaWduX2Nvcm5lcnMgYXMgbnVtYmVyLFxuICAgIG1vZGU6IGF0dHJpYnV0ZXMubW9kZSBhcyBNb2RlLFxuICAgIHBhZGRpbmdNb2RlOiBhdHRyaWJ1dGVzLnBhZGRpbmdfbW9kZSBhcyBQYWRkaW5nTW9kZSxcbiAgICBmb3JtYXQ6IGF0dHJpYnV0ZXMuZm9ybWF0IGFzIEZvcm1hdCxcbiAgfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBHcHVEYXRhVHlwZSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGFwcGx5QXR0ZW50aW9uLFxuICBBdHRlbnRpb25BdHRycyxcbiAgQXR0ZW50aW9uTWFza1R5cGUsXG4gIEF0dGVudGlvblBhcmFtZXRlcnMsXG4gIEF0dGVudGlvblFrdkZvcm1hdCxcbn0gZnJvbSAnLi9hdHRlbnRpb24nO1xuaW1wb3J0IHsgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgVW5pZm9ybXNBcnJheVR5cGUgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbywgVHJhbnNwb3NlQXR0cmlidXRlcyB9IGZyb20gJy4vdHJhbnNwb3NlJztcblxuY29uc3QgZ2V0SW5wdXQgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGk6IG51bWJlcikgPT5cbiAgaW5wdXRzLmxlbmd0aCA+IGkgJiYgaW5wdXRzW2ldLmRpbXMubGVuZ3RoID4gMCA/IGlucHV0c1tpXSA6IHVuZGVmaW5lZDtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogQXR0ZW50aW9uUGFyYW1ldGVycyA9PiB7XG4gIGNvbnN0IHF1ZXJ5ID0gaW5wdXRzWzBdO1xuICBjb25zdCBrZXkgPSBnZXRJbnB1dChpbnB1dHMsIDEpO1xuICBjb25zdCB2YWx1ZSA9IGdldElucHV0KGlucHV0cywgMik7XG4gIGNvbnN0IGJpYXMgPSBnZXRJbnB1dChpbnB1dHMsIDMpO1xuICBjb25zdCBrZXlQYWRkaW5nTWFzayA9IGdldElucHV0KGlucHV0cywgNCk7XG4gIGNvbnN0IGF0dGVudGlvbkJpYXMgPSBnZXRJbnB1dChpbnB1dHMsIDUpO1xuICBjb25zdCBwYXN0S2V5ID0gZ2V0SW5wdXQoaW5wdXRzLCA2KTtcbiAgY29uc3QgcGFzdFZhbHVlID0gZ2V0SW5wdXQoaW5wdXRzLCA3KTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gTm90YXRpb25zOlxuICAvLyAgICBCOiBiYXRjaF9zaXplXG4gIC8vICAgIE46IG51bV9oZWFkc1xuICAvLyAgICBIOiBoZWFkX3NpemUgb2YgUSBhbmQgS1xuICAvLyAgICBIX3Y6IGhlYWRfc2l6ZSBvZiBWXG4gIC8vICAgIEQ6IGhpZGRlbl9zaXplIGZvciBRIGFuZCBLLCB3aGVyZSBEID0gTiAqIEhcbiAgLy8gICAgRF92OiBoaWRkZW5fc2l6ZSBvZiBWLCB3aGVyZSBEX3YgPSBOICogSF92XG4gIC8vICAgIFM6IHFfc2VxdWVuY2VfbGVuZ3RoXG4gIC8vICAgIFA6IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIG9mIGt2IGNhY2hlXG4gIC8vICAgIEw6IGt2X3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgICBUOiB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSBQICsgTFxuICAvLyAgICBNOiBtYXhfc2VxdWVuY2VfbGVuZ3RoIG9mIGt2IGNhY2hlIHdoZW4gcGFzdCBhbmQgcHJlc2VudCBzaGFyZSBidWZmZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIE11bHRpSGVhZEF0dGVudGlvbiBpbnB1dHM6XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyAgUV9LX1ZfQlNOSCAtIG5vIHBhY2tpbmc6XG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBTLCBEKVxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSykgICAgICAgOiAoQiwgTCwgRClcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogKEIsIEwsIERfdilcbiAgLy8gIFFfS19WX0JTTkhfQk5TSF9CTlNIIC0gY3Jvc3MgYXR0ZW50aW9uIChrdiBjYWNoZSBpcyBub3QgdXNlZCwgTCA9PSBULCBEID09IERfdik6XG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBTLCBEKVxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSykgICAgICAgOiAoQiwgTiwgTCwgSClcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogKEIsIE4sIEwsIEhfdilcbiAgLy8gIFFfS1ZfQlNOSF9CU04ySCAtIHBhY2tlZCBrdiAoa3YgY2FjaGUgaXMgbm90IHVzZWQsIGJpYXMgaXMgbm90IGFsbG93ZWQgZm9yIHBhY2tlZCBrdik6XG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBTLCBEKVxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSy9WKSAgICAgOiAoQiwgTCwgTiwgMiwgSClcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgICAgICAgICAgIDogTm9uZVxuICAvLyAgUUtWX0JTTjNIIC0gcGFja2VkIHFrdiAoa3YgY2FjaGUgaXMgbm90IHVzZWQsIFMgPT0gTCwgRCA9PSBEX3YpOlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUS9LL1YpICAgOiAoQiwgUywgTiwgMywgSClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgICAgICAgICAgIDogTm9uZVxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAgICAgICAgICAgOiBOb25lXG4gIC8vXG4gIC8vICBPdGhlciBpbnB1dHM6XG4gIC8vICAgICBiaWFzICAgICAgICAgICAgIChRL0svVikgICA6IE5vbmUgb3IgKEQgKyBEICsgRF92KVxuICAvLyAgICAga2V5X3BhZGRpbmdfbWFzayAoSy9WKSAgICAgOiAoQikgb3IgKDMgKiBCICsgMikgb3IgKEIsIFQpIG9yIChCLCBTLCBUKVxuICAvLyAgICAgYXR0ZW50aW9uX2JpYXMgICAgICAgICAgICAgOiBOb25lIG9yIChCLCBOLCBTLCBUKSwgKDEsIE4sIFMsIFQpLCAoQiwgMSwgUywgVCkgb3IgKDEsIDEsIFMsIFQpXG4gIC8vICAgICBwYXN0X2tleSAgICAgICAgICAgICAgICAgICA6IChCLCBOLCBQLCBIKSBvciBOb25lLiBQYXN0IHN0YXRlIGlzIG9ubHkgYWxsb3dlZCBmb3IgUV9LX1ZfQlNOSC5cbiAgLy8gICAgIHBhc3RfdmFsdWUgICAgICAgICAgICAgICAgIDogKEIsIE4sIFAsIEgpIG9yIE5vbmUuIFBhc3Qgc3RhdGUgaXMgb25seSBhbGxvd2VkIGZvciBRX0tfVl9CU05ILlxuICAvL1xuICAvLyAgTm90IFN1cHBvcnRlZDpcbiAgLy8gICAgIGtleV9wYWRkaW5nX21hc2ssIHBhY2tlZCBrdiwgcGFja2VkIHFrdiwgYW5kIGJyb2FkY2FzdCBmb3IgYXR0ZW50aW9uX2JpYXMuXG5cbiAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzICYmIHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBjb25zdCBiYXRjaFNpemUgPSBxdWVyeS5kaW1zWzBdO1xuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IHF1ZXJ5LmRpbXNbMV07XG4gIGNvbnN0IGhpZGRlblNpemUgPSBxdWVyeS5kaW1zLmxlbmd0aCA9PT0gMyA/IHF1ZXJ5LmRpbXNbMl0gOiBhdHRyaWJ1dGVzLm51bUhlYWRzICogcXVlcnkuZGltc1s0XTtcbiAgbGV0IGt2U2VxdWVuY2VMZW5ndGggPSBzZXF1ZW5jZUxlbmd0aDtcblxuICBsZXQgcGFzdFNlcXVlbmNlTGVuZ3RoID0gMDtcbiAgbGV0IG1heFNlcXVlbmNlTGVuZ3RoID0gMDtcbiAgY29uc3QgaGVhZFNpemUgPSBNYXRoLmZsb29yKGhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKTtcbiAgaWYgKHBhc3RLZXkgJiYgcGFzdFZhbHVlICYmIFNoYXBlVXRpbC5zaXplKHBhc3RLZXkuZGltcykgJiYgU2hhcGVVdGlsLnNpemUocGFzdFZhbHVlLmRpbXMpKSB7XG4gICAgaWYgKHBhc3RLZXkuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIGlmIChwYXN0S2V5LmRpbXNbMF0gIT09IGJhdGNoU2l6ZSB8fCBwYXN0S2V5LmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwgcGFzdEtleS5kaW1zWzNdICE9PSBoZWFkU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgcGFzdF9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSknKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgcGFzdFZhbHVlLmRpbXNbMF0gIT09IGJhdGNoU2l6ZSB8fFxuICAgICAgcGFzdFZhbHVlLmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHxcbiAgICAgIHBhc3RWYWx1ZS5kaW1zWzNdICE9PSBoZWFkU2l6ZVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBwYXN0X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKScpO1xuICAgIH1cbiAgICBpZiAocGFzdEtleS5kaW1zWzJdICE9PSBwYXN0VmFsdWUuZGltc1syXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMiAocGFzdF9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgfVxuICAgIGlmIChwYXN0VmFsdWUuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgcGFzdFNlcXVlbmNlTGVuZ3RoID0gcGFzdEtleS5kaW1zWzJdO1xuICAgIG1heFNlcXVlbmNlTGVuZ3RoID0gcGFzdEtleS5kaW1zWzJdO1xuICB9IGVsc2UgaWYgKChwYXN0S2V5ICYmIFNoYXBlVXRpbC5zaXplKHBhc3RLZXkuZGltcykpIHx8IChwYXN0VmFsdWUgJiYgU2hhcGVVdGlsLnNpemUocGFzdFZhbHVlLmRpbXMpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBiZSBib3RoIHByZXNlbnQgb3IgYm90aCBhYnNlbnQnKTtcbiAgfVxuXG4gIGxldCBxa3ZGb3JtYXQ6IEF0dGVudGlvblFrdkZvcm1hdDtcbiAgaWYgKGtleSAmJiBTaGFwZVV0aWwuc2l6ZShrZXkuZGltcykgPiAwKSB7XG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBnaXZlbicpO1xuICAgIH1cbiAgICBpZiAoa2V5LmRpbXMubGVuZ3RoIDwgMyB8fCBrZXkuZGltcy5sZW5ndGggPiA1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmRpbXNbMF0gIT09IGtleS5kaW1zWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoIHNpemUpJyk7XG4gICAgfVxuXG4gICAgaWYgKGtleS5kaW1zLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKGtleS5kaW1zWzJdICE9PSBxdWVyeS5kaW1zWzJdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMiAoaGlkZGVuX3NpemUpJyk7XG4gICAgICB9XG4gICAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2QlNOSDtcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1sxXTtcbiAgICB9IGVsc2UgaWYgKGtleS5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgICAgaWYgKGtleS5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IGtleS5kaW1zWzNdICE9PSAyIHx8IGtleS5kaW1zWzRdICE9PSBoZWFkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpO1xuICAgICAgfVxuICAgICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFLdkJTTkh4QlNOMkg7XG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGtleV9kaW1zLnNpemUoKSA9PSA0IChjcm9zcy1hdHRlbnRpb24gd2l0aCBwYXN0X2tleSlcbiAgICAgIGlmIChrZXkuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBrZXkuZGltc1szXSAhPT0gaGVhZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSkgZm9yIHBhc3Rfa2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC51bmtub3duOyAvLyBRX0tfVl9CU05IX0JOU0hfQk5TSFxuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzJdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBwYWNrZWQgUUtWXG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSA1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBxdWVyeS5kaW1zWzNdICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInF1ZXJ5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAzLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtcbiAgICB9XG5cbiAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2QlNOM0g7XG4gIH1cblxuICBpZiAoYmlhcyAmJiBTaGFwZVV0aWwuc2l6ZShiaWFzLmRpbXMpID4gMCkge1xuICAgIGlmIChiaWFzLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAoa2V5LmRpbXMubGVuZ3RoID09PSA1ICYmIGtleS5kaW1zWzNdID09PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmlhcyBpcyBub3QgYWxsb3dlZCBmb3IgcGFja2VkIGt2LicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGggPSBwYXN0U2VxdWVuY2VMZW5ndGggKyBrdlNlcXVlbmNlTGVuZ3RoO1xuXG4gIGxldCBtYXNrVHlwZTogQXR0ZW50aW9uTWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5ub25lO1xuICBpZiAoa2V5UGFkZGluZ01hc2sgJiYgU2hhcGVVdGlsLnNpemUoa2V5UGFkZGluZ01hc2suZGltcykgPiAwKSB7XG4gICAgbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5tYXNrVW5rbm93bjtcbiAgICBjb25zdCBtYXNrRGltcyA9IGtleVBhZGRpbmdNYXNrLmRpbXM7XG4gICAgaWYgKG1hc2tEaW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKG1hc2tEaW1zWzBdID09PSBiYXRjaFNpemUpIHtcbiAgICAgICAgbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5tYXNrMWRLZXlTZXFMZW47XG4gICAgICB9IGVsc2UgaWYgKG1hc2tEaW1zWzBdID09PSAzICogYmF0Y2hTaXplICsgMikge1xuICAgICAgICBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm1hc2sxREtleVNlcUxlblN0YXJ0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWFza0RpbXMubGVuZ3RoID09PSAyICYmIG1hc2tEaW1zWzBdID09PSBiYXRjaFNpemUgJiYgbWFza0RpbXNbMV0gPT09IHRvdGFsU2VxdWVuY2VMZW5ndGgpIHtcbiAgICAgIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubWFzazJkS2V5UGFkZGluZztcbiAgICB9XG4gICAgaWYgKG1hc2tUeXBlID09PSBBdHRlbnRpb25NYXNrVHlwZS5tYXNrVW5rbm93bikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleV9wYWRkaW5nX21hc2tcIiBzaGFwZSBzaGFsbCBiZSAoYmF0Y2hfc2l6ZSkgb3IgKGJhdGNoX3NpemUsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXNrIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIGxldCBwYXNzUGFzdEluS3YgPSBmYWxzZTtcbiAgbGV0IHZIaWRkZW5TaXplID0gaGlkZGVuU2l6ZTtcbiAgaWYgKHZhbHVlICYmIFNoYXBlVXRpbC5zaXplKHZhbHVlLmRpbXMpID4gMCkge1xuICAgIGlmICh2YWx1ZS5kaW1zLmxlbmd0aCAhPT0gMyAmJiB2YWx1ZS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChxdWVyeS5kaW1zWzBdICE9PSB2YWx1ZS5kaW1zWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUuZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGlmIChrdlNlcXVlbmNlTGVuZ3RoICE9PSB2YWx1ZS5kaW1zWzFdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDEgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICAgIH1cbiAgICAgIHZIaWRkZW5TaXplID0gdmFsdWUuZGltc1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUV9LX1ZfQlNOSF9CTlNIX0JOU0hcbiAgICAgIGlmIChrdlNlcXVlbmNlTGVuZ3RoICE9PSB2YWx1ZS5kaW1zWzJdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDIgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICAgIH1cbiAgICAgIHZIaWRkZW5TaXplID0gdmFsdWUuZGltc1sxXSAqIHZhbHVlLmRpbXNbM107XG4gICAgICBwYXNzUGFzdEluS3YgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJyb2FkY2FzdFJlc1Bvc0JpYXMgPSBmYWxzZTtcblxuICBpZiAoa2V5UGFkZGluZ01hc2sgJiYgU2hhcGVVdGlsLnNpemUoa2V5UGFkZGluZ01hc2suZGltcykgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgcGFkZGluZyBtYXNrIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIGlmIChhdHRlbnRpb25CaWFzICYmIFNoYXBlVXRpbC5zaXplKGF0dGVudGlvbkJpYXMuZGltcykgPiAwKSB7XG4gICAgaWYgKGF0dGVudGlvbkJpYXMuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJhdHRlbnRpb25fYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogc3VwcG9ydCBicm9hZGNhc3RpbmcgdGhlIGZpcnN0IGFuZCBzZWNvbmQgZGltZW5zaW9ucyBvZiBhdHRlbnRpb25fYmlhcy5cbiAgICBpZiAoXG4gICAgICBhdHRlbnRpb25CaWFzLmRpbXNbMF0gIT09IGJhdGNoU2l6ZSB8fFxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8XG4gICAgICBhdHRlbnRpb25CaWFzLmRpbXNbMl0gIT09IHNlcXVlbmNlTGVuZ3RoIHx8XG4gICAgICBhdHRlbnRpb25CaWFzLmRpbXNbM10gIT09IHRvdGFsU2VxdWVuY2VMZW5ndGhcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwiYXR0ZW50aW9uX2JpYXNcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhdGNoU2l6ZSxcbiAgICBzZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXG4gICAga3ZTZXF1ZW5jZUxlbmd0aCxcbiAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoLFxuICAgIG1heFNlcXVlbmNlTGVuZ3RoLFxuICAgIGlucHV0SGlkZGVuU2l6ZTogMCxcbiAgICBoaWRkZW5TaXplLFxuICAgIHZIaWRkZW5TaXplLFxuICAgIGhlYWRTaXplLFxuICAgIHZIZWFkU2l6ZTogTWF0aC5mbG9vcih2SGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpLFxuICAgIG51bUhlYWRzOiBhdHRyaWJ1dGVzLm51bUhlYWRzLFxuICAgIGlzVW5pZGlyZWN0aW9uYWw6IGZhbHNlLFxuICAgIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGZhbHNlLFxuICAgIG1hc2tGaWx0ZXJWYWx1ZTogYXR0cmlidXRlcy5tYXNrRmlsdGVyVmFsdWUsXG4gICAgbWFza1R5cGUsXG4gICAgc2NhbGU6IGF0dHJpYnV0ZXMuc2NhbGUsXG4gICAgYnJvYWRjYXN0UmVzUG9zQmlhcyxcbiAgICBwYXNzUGFzdEluS3YsXG4gICAgcWt2Rm9ybWF0LFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlTXVsdGlIZWFkQXR0ZW50aW9uQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IEF0dGVudGlvbkF0dHJzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IC4uLmF0dHJpYnV0ZXMgfSk7XG5cbmNvbnN0IHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZTogVHJhbnNwb3NlQXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHBlcm06IFswLCAyLCAxLCAzXSB9KTtcblxuY29uc3QgYWRkQmlhc1RyYW5zcG9zZSA9IChcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXG4gIHFrdjogVGVuc29yVmlldyxcbiAgYmlhczogVGVuc29yVmlldyxcbiAgYmF0Y2hTaXplOiBudW1iZXIsXG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXG4gIGhpZGRlblNpemU6IG51bWJlcixcbiAgYmlhc09mZnNldDogbnVtYmVyLFxuKSA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgc2VxdWVuY2VMZW5ndGgsIGhpZGRlblNpemVdO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYmlhc09mZnNldCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBoaWRkZW5TaXplIH0sXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Frdl93aXRoX2JpYXMnLCBxa3YuZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBxa3ZJbnB1dCA9IGlucHV0VmFyaWFibGUoJ3FrdicsIHFrdi5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IGJpYXNJbnB1dCA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBiaWFzLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG5cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdiaWFzX29mZnNldCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdoaWRkZW5fc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgXTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKHFrdklucHV0LCBiaWFzSW5wdXQsIG91dHB1dCl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgbGV0IGJpYXNfb2Zmc2V0X2lkeCA9IChnbG9iYWxfaWR4ICUgdW5pZm9ybXMuaGlkZGVuX3NpemUpICsgdW5pZm9ybXMuYmlhc19vZmZzZXQ7XG5cbiAgICBxa3Zfd2l0aF9iaWFzW2dsb2JhbF9pZHhdID0gcWt2W2dsb2JhbF9pZHhdICsgYmlhc1tiaWFzX29mZnNldF9pZHhdO1xuICB9YDtcbiAgfTtcblxuICByZXR1cm4gY29udGV4dC5jb21wdXRlKFxuICAgIHtcbiAgICAgIG5hbWU6ICdNdWx0aUhlYWRBdHRlbnRpb25BZGRCaWFzJyxcbiAgICAgIHNoYWRlckNhY2hlOiB7IGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnLCAndHlwZSddIH0sXG4gICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IHFrdi5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgICAgfSksXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgfSxcbiAgICB7IGlucHV0czogW3FrdiwgYmlhc10sIG91dHB1dHM6IFstMV0gfSxcbiAgKVswXTtcbn07XG5cbmV4cG9ydCBjb25zdCBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMgPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBiYXRjaFNpemU6IG51bWJlcixcbiAgbnVtSGVhZHM6IG51bWJlcixcbiAgc2VxdWVuY2VMZW5ndGg6IG51bWJlcixcbiAgaGVhZFNpemU6IG51bWJlcixcbiAgaW5wdXQ6IFRlbnNvclZpZXcsXG4gIGJpYXM/OiBUZW5zb3JWaWV3LFxuICBiaWFzT2Zmc2V0PzogbnVtYmVyLFxuKSA9PiB7XG4gIC8vIGNvbnN0IG5ld0RpbXMgPSBbXTtcblxuICBsZXQgcmVzaGFwZWRJbnB1dCA9IGlucHV0O1xuICBpZiAoIShiaWFzICYmIFNoYXBlVXRpbC5zaXplKGJpYXMuZGltcykgPiAwKSkge1xuICAgIGlmIChpbnB1dC5kaW1zLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmVzaGFwZWRJbnB1dCA9IGlucHV0LnJlc2hhcGUoW2JhdGNoU2l6ZSwgc2VxdWVuY2VMZW5ndGgsIG51bUhlYWRzLCBoZWFkU2l6ZV0pO1xuICAgIH1cbiAgICBpZiAobnVtSGVhZHMgPT09IDEgfHwgc2VxdWVuY2VMZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiByZXNoYXBlZElucHV0O1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKHJlc2hhcGVkSW5wdXQsIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZS5wZXJtKSwge1xuICAgICAgaW5wdXRzOiBbcmVzaGFwZWRJbnB1dF0sXG4gICAgICBvdXRwdXRzOiBbLTFdLFxuICAgIH0pWzBdO1xuICB9IGVsc2Uge1xuICAgIGlmIChzZXF1ZW5jZUxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRCaWFzUmVzaGFwZSBpcyBub3QgaW1wbGVtZW50ZWQuIFBsZWFzZSBleHBvcnQgeW91ciBtb2RlbCB3aXRoIHBhY2tlZCBRS1Ygb3IgS1YnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzaGFwZWRJbnB1dCA9IGFkZEJpYXNUcmFuc3Bvc2UoXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBiaWFzLFxuICAgICAgICBiYXRjaFNpemUsXG4gICAgICAgIHNlcXVlbmNlTGVuZ3RoLFxuICAgICAgICBudW1IZWFkcyAqIGhlYWRTaXplLFxuICAgICAgICBiaWFzT2Zmc2V0ISxcbiAgICAgICk7XG4gICAgICByZXNoYXBlZElucHV0ID0gcmVzaGFwZWRJbnB1dC5yZXNoYXBlKFtiYXRjaFNpemUsIHNlcXVlbmNlTGVuZ3RoLCBudW1IZWFkcywgaGVhZFNpemVdKTtcbiAgICAgIGlmIChudW1IZWFkcyA9PT0gMSB8fCBzZXF1ZW5jZUxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcmVzaGFwZWRJbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8ocmVzaGFwZWRJbnB1dCwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlLnBlcm0pLCB7XG4gICAgICAgIGlucHV0czogW3Jlc2hhcGVkSW5wdXRdLFxuICAgICAgICBvdXRwdXRzOiBbLTFdLFxuICAgICAgfSlbMF07XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgbXVsdGlIZWFkQXR0ZW50aW9uID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IHZvaWQgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnN0IHF1ZXJ5ID0gY29udGV4dC5pbnB1dHNbMF07XG4gIGNvbnN0IGtleSA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCAxKTtcbiAgY29uc3QgdmFsdWUgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgMik7XG4gIGNvbnN0IGJpYXMgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgMyk7XG4gIGNvbnN0IGtleVBhZGRpbmdNYXNrID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDQpO1xuICBjb25zdCBhdHRlbnRpb25CaWFzID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDUpO1xuICBjb25zdCBwYXN0S2V5ID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDYpO1xuICBjb25zdCBwYXN0VmFsdWUgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgNyk7XG4gIGlmIChxdWVyeS5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFja2VkIFFLViBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIGlmIChrZXk/LmRpbXMubGVuZ3RoID09PSA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgS1YgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvLyBhcHBseUF0dGVudGlvbiBleHBlY3RzIEJOU0ggaW5wdXRzXG4gIGNvbnN0IGt2Qk5TSCA9IGtleSAmJiB2YWx1ZSAmJiBrZXkuZGltcy5sZW5ndGggPT09IDQgJiYgdmFsdWUuZGltcy5sZW5ndGggPT09IDQ7XG5cbiAgY29uc3QgUSA9IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyhcbiAgICBjb250ZXh0LFxuICAgIHBhcmFtcy5iYXRjaFNpemUsXG4gICAgcGFyYW1zLm51bUhlYWRzLFxuICAgIHBhcmFtcy5zZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXJhbXMuaGVhZFNpemUsXG4gICAgcXVlcnksXG4gICAgYmlhcyxcbiAgICAwLFxuICApO1xuXG4gIGlmIChrdkJOU0gpIHtcbiAgICByZXR1cm4gYXBwbHlBdHRlbnRpb24oY29udGV4dCwgUSwga2V5LCB2YWx1ZSwga2V5UGFkZGluZ01hc2ssIHVuZGVmaW5lZCwgcGFzdEtleSwgcGFzdFZhbHVlLCBhdHRlbnRpb25CaWFzLCBwYXJhbXMpO1xuICB9XG4gIGlmICgha2V5IHx8ICF2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigna2V5IGFuZCB2YWx1ZSBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gIH1cbiAgY29uc3QgSyA9IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyhcbiAgICBjb250ZXh0LFxuICAgIHBhcmFtcy5iYXRjaFNpemUsXG4gICAgcGFyYW1zLm51bUhlYWRzLFxuICAgIHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoLFxuICAgIHBhcmFtcy5oZWFkU2l6ZSxcbiAgICBrZXksXG4gICAgYmlhcyxcbiAgICBwYXJhbXMuaGlkZGVuU2l6ZSxcbiAgKTtcblxuICBjb25zdCBWID0gbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzKFxuICAgIGNvbnRleHQsXG4gICAgcGFyYW1zLmJhdGNoU2l6ZSxcbiAgICBwYXJhbXMubnVtSGVhZHMsXG4gICAgcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGgsXG4gICAgcGFyYW1zLnZIZWFkU2l6ZSxcbiAgICB2YWx1ZSxcbiAgICBiaWFzLFxuICAgIDIgKiBwYXJhbXMuaGlkZGVuU2l6ZSxcbiAgKTtcblxuICBhcHBseUF0dGVudGlvbihjb250ZXh0LCBRLCBLLCBWLCBrZXlQYWRkaW5nTWFzaywgdW5kZWZpbmVkLCBwYXN0S2V5LCBwYXN0VmFsdWUsIGF0dGVudGlvbkJpYXMsIHBhcmFtcyk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0sIFRlbnNvckluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRFbGVtZW50QXQsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG59IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBTcGxpdEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG4gIHJlYWRvbmx5IG51bU91dHB1dHM6IG51bWJlcjtcbiAgcmVhZG9ubHkgc3BsaXRTaXplczogbnVtYmVyW107XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b28gZmV3IGlucHV0cycpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVTcGxpdEF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogU3BsaXRBdHRyaWJ1dGVzLFxuKTogU3BsaXRBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qgc3BsaXRTaXplczogbnVtYmVyW10gPSBbXTtcbiAgbGV0IG51bU91dHB1dHM6IG51bWJlciA9IGF0dHJpYnV0ZXMubnVtT3V0cHV0cztcbiAgaWYgKGlucHV0c1sxXS5kaW1zWzBdID4gMCkge1xuICAgIGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCgodikgPT4gc3BsaXRTaXplcy5wdXNoKE51bWJlcih2KSkpO1xuICAgIG51bU91dHB1dHMgPSBzcGxpdFNpemVzLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgbnVtT3V0cHV0cywgYXhpczogYXR0cmlidXRlcy5heGlzLCBzcGxpdFNpemVzIH0pO1xufTtcblxuY29uc3QgY2FsY3VsYXRlT3V0cHV0SW5kZXhJbXBsID0gKG51bWJlck9mVGVuc29yczogbnVtYmVyKTogc3RyaW5nID0+IGBcbmZuIGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke251bWJlck9mVGVuc29yc311OyBpICs9IDF1ICkge1xuICAgIGlmIChpbmRleCA8ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXMnLCAnaScsIG51bWJlck9mVGVuc29ycyl9KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7bnVtYmVyT2ZUZW5zb3JzfXU7XG59YDtcbmNvbnN0IHdyaXRlQnVmZmVyRGF0YUltcGwgPSAob3V0cHV0czogcmVhZG9ubHkgSW5kaWNlc0hlbHBlcltdKSA9PiB7XG4gIGNvbnN0IG51bWJlck9mVGVuc29ycyA9IG91dHB1dHMubGVuZ3RoO1xuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUZW5zb3JzOyArK2kpIHtcbiAgICBjb25zdCByZXR1cm5TbmlwcGV0ID0gb3V0cHV0c1tpXS5zZXRCeUluZGljZXMoJ2luZGljZXMnLCAnaW5wdXRbZ2xvYmFsX2lkeF0nKTtcbiAgICBpZiAobnVtYmVyT2ZUZW5zb3JzID09PSAxKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChyZXR1cm5TbmlwcGV0KTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBpZiAob3V0cHV0X251bWJlciA9PSAke2l9dSkgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IG51bWJlck9mVGVuc29ycyAtIDEpIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBlbHNlIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBlbHNlIGlmIChvdXRwdXRfbnVtYmVyID09ICR7aX0pIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBgXG4gICAgICBmbiB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlcjogdTMyLCBpbmRpY2VzOiAke291dHB1dHNbMF0udHlwZS5pbmRpY2VzfSwgZ2xvYmFsX2lkeDogdTMyKSB7XG4gICAgICAgICR7Y29kZUxpbmVzLmpvaW4oJ1xcbicpfVxuICAgICAgfWA7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU3BsaXRQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogU3BsaXRBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGlucHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKGlucHV0U2hhcGUpO1xuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBvdXRwdXRzID0gbmV3IEFycmF5PEluZGljZXNIZWxwZXI+KGF0dHJpYnV0ZXMubnVtT3V0cHV0cyk7XG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBkYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBzaXplSW5TcGxpdEF4aXMgPSBuZXcgQXJyYXk8bnVtYmVyPihhdHRyaWJ1dGVzLm51bU91dHB1dHMpO1xuICBjb25zdCBvdXRwdXRzVGVuc29ySW5mbzogVGVuc29ySW5mb1tdID0gW107XG4gIGNvbnN0IG91dHB1dFNoYXBlczogbnVtYmVyW11bXSA9IFtdO1xuICBsZXQgcHJldmlvdXNTdW0gPSAwO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGlucHV0U2l6ZSB9XTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLm51bU91dHB1dHM7IGkrKykge1xuICAgIHByZXZpb3VzU3VtICs9IGF0dHJpYnV0ZXMuc3BsaXRTaXplc1tpXTtcbiAgICBzaXplSW5TcGxpdEF4aXNbaV0gPSBwcmV2aW91c1N1bTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoKTtcbiAgICBvdXRwdXRTaGFwZVtheGlzXSA9IGF0dHJpYnV0ZXMuc3BsaXRTaXplc1tpXTtcbiAgICBvdXRwdXRTaGFwZXMucHVzaChvdXRwdXRTaGFwZSk7XG4gICAgb3V0cHV0c1tpXSA9IG91dHB1dFZhcmlhYmxlKGBvdXRwdXQke2l9YCwgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgb3V0cHV0c1RlbnNvckluZm8ucHVzaCh7IGRpbXM6IG91dHB1dFNoYXBlc1tpXSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9KTtcbiAgfVxuICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc2l6ZUluU3BsaXRBeGlzIH0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgLi4ub3V0cHV0U2hhcGVzKSxcbiAgKTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICR7c2hhZGVySGVscGVyXG4gICAgLnJlZ2lzdGVyVW5pZm9ybSgnaW5wdXRfc2l6ZScsICd1MzInKVxuICAgIC5yZWdpc3RlclVuaWZvcm0oJ3NpemVfaW5fc3BsaXRfYXhpcycsICd1MzInLCBzaXplSW5TcGxpdEF4aXMubGVuZ3RoKVxuICAgIC5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCAuLi5vdXRwdXRzKX1cbiAgJHtjYWxjdWxhdGVPdXRwdXRJbmRleEltcGwoc2l6ZUluU3BsaXRBeGlzLmxlbmd0aCl9XG4gICR7d3JpdGVCdWZmZXJEYXRhSW1wbChvdXRwdXRzKX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5pbnB1dF9zaXplJyl9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7aW5wdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgIHZhciBpbmRleCA9ICR7aW5wdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGF4aXMpfTtcbiAgICBsZXQgb3V0cHV0X251bWJlciA9IGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4KTtcbiAgICBpZiAob3V0cHV0X251bWJlciAhPSAwKSB7XG4gICAgICBpbmRleCAtPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzJywgJ291dHB1dF9udW1iZXIgLSAxdScsIHNpemVJblNwbGl0QXhpcy5sZW5ndGgpfTtcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5kaWNlcycsIGF4aXMsICdpbmRleCcpfTtcbiAgICB9XG4gICAgd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXIsIGluZGljZXMsIGdsb2JhbF9pZHgpO1xuICB9YDtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnU3BsaXQnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogb3V0cHV0c1RlbnNvckluZm8sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChpbnB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBzcGxpdCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU3BsaXRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXMgPVxuICAgIGNvbnRleHQuaW5wdXRzLmxlbmd0aCA9PT0gMSA/IGF0dHJpYnV0ZXMgOiBjcmVhdGVTcGxpdEF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVNwbGl0UHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKSwgeyBpbnB1dHM6IFswXSB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVNwbGl0QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFNwbGl0QXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF4aXMgPSBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyO1xuICBjb25zdCBzcGxpdFNpemVzOiBudW1iZXJbXSA9IGF0dHJpYnV0ZXMuc3BsaXRTaXplcyBhcyBudW1iZXJbXTtcbiAgY29uc3QgbnVtT3V0cHV0cyA9IChhdHRyaWJ1dGVzLm51bU91dHB1dHMgYXMgbnVtYmVyKSA8IDAgPyBzcGxpdFNpemVzLmxlbmd0aCA6IChhdHRyaWJ1dGVzLm51bU91dHB1dHMgYXMgbnVtYmVyKTtcbiAgaWYgKG51bU91dHB1dHMgIT09IHNwbGl0U2l6ZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdudW1PdXRwdXRzIGFuZCBzcGxpdFNpemVzIGxlbmd0aCBtdXN0IGJlIGVxdWFsJyk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXMsIG51bU91dHB1dHMsIHNwbGl0U2l6ZXMgfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgV09SS0dST1VQX1NJWkUgfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IGludGVybGVhdmVkOiBib29sZWFuO1xuICByZWFkb25seSBudW1IZWFkczogbnVtYmVyO1xuICByZWFkb25seSByb3RhcnlFbWJlZGRpbmdEaW06IG51bWJlcjtcbiAgcmVhZG9ubHkgc2NhbGU6IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgW2lucHV0LCBwb3NpdGlvbklkcywgY29zQ2FjaGUsIHNpbkNhY2hlXSA9IGlucHV0cztcbiAgY29uc3QgeyBudW1IZWFkcywgcm90YXJ5RW1iZWRkaW5nRGltIH0gPSBhdHRyaWJ1dGVzO1xuXG4gIGlmIChpbnB1dC5kaW1zLmxlbmd0aCAhPT0gMyAmJiBpbnB1dC5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3gnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMsIGdvdCAke2lucHV0LmRpbXMubGVuZ3RofWApO1xuICB9XG4gIGlmIChcbiAgICAhU2hhcGVVdGlsLmFyZUVxdWFsKHBvc2l0aW9uSWRzLmRpbXMsIFtdKSAmJlxuICAgICFTaGFwZVV0aWwuYXJlRXF1YWwocG9zaXRpb25JZHMuZGltcywgWzFdKSAmJlxuICAgIHBvc2l0aW9uSWRzLmRpbXMubGVuZ3RoICE9PSAyXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAwLCAxLCBvciAyIGRpbWVuc2lvbnMsIGdvdCAke3Bvc2l0aW9uSWRzLmRpbXMubGVuZ3RofWApO1xuICB9XG4gIGlmIChjb3NDYWNoZS5kaW1zLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ2Nvc19jYWNoZScgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMsIGdvdCAke2Nvc0NhY2hlLmRpbXMubGVuZ3RofWApO1xuICB9XG4gIGlmIChzaW5DYWNoZS5kaW1zLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Npbl9jYWNoZScgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMsIGdvdCAke3NpbkNhY2hlLmRpbXMubGVuZ3RofWApO1xuICB9XG4gIGlmICghU2hhcGVVdGlsLmFyZUVxdWFsKGNvc0NhY2hlLmRpbXMsIHNpbkNhY2hlLmRpbXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXRzICdjb3NfY2FjaGUnIGFuZCAnc2luX2NhY2hlJyBhcmUgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKTtcbiAgfVxuXG4gIGlmIChyb3RhcnlFbWJlZGRpbmdEaW0gPiAwICYmIG51bUhlYWRzID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdudW1faGVhZHMgbXVzdCBiZSBwcm92aWRlZCBpZiByb3RhcnlfZW1iZWRkaW5nX2RpbSBpcyBzcGVjaWZpZWQnKTtcbiAgfVxuXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0LmRpbXNbMF07XG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gaW5wdXQuZGltc1tpbnB1dC5kaW1zLmxlbmd0aCAtIDJdO1xuICBjb25zdCBtYXhTZXF1ZW5jZUxlbmd0aCA9IGNvc0NhY2hlLmRpbXNbMF07XG4gIGNvbnN0IGhpZGRlblNpemUgPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXQuZGltcywgMSkgLyBzZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgaGVhZFNpemUgPSByb3RhcnlFbWJlZGRpbmdEaW0gPT09IDAgPyBjb3NDYWNoZS5kaW1zWzFdICogMiA6IGhpZGRlblNpemUgLyBudW1IZWFkcztcbiAgaWYgKHJvdGFyeUVtYmVkZGluZ0RpbSA+IGhlYWRTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyb3RhcnlfZW1iZWRkaW5nX2RpbSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBoZWFkX3NpemUnKTtcbiAgfVxuXG4gIGlmIChwb3NpdGlvbklkcy5kaW1zLmxlbmd0aCA9PT0gMikge1xuICAgIGlmIChiYXRjaFNpemUgIT09IHBvc2l0aW9uSWRzLmRpbXNbMF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgZGltZW5zaW9uIDAgc2hvdWxkIGJlIG9mIHNpemUgYmF0Y2hfc2l6ZSwgZ290ICR7cG9zaXRpb25JZHMuZGltc1swXX1gKTtcbiAgICB9XG4gICAgaWYgKHNlcXVlbmNlTGVuZ3RoICE9PSBwb3NpdGlvbklkcy5kaW1zWzFdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGRpbWVuc2lvbiAxIHNob3VsZCBiZSBvZiBzaXplIHNlcXVlbmNlX2xlbmd0aCwgZ290ICR7cG9zaXRpb25JZHMuZGltc1sxXX1gKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaGVhZFNpemUgLyAyICE9PSBjb3NDYWNoZS5kaW1zWzFdICYmIHJvdGFyeUVtYmVkZGluZ0RpbSAvIDIgIT09IGNvc0NhY2hlLmRpbXNbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW5wdXQgJ2Nvc19jYWNoZScgZGltZW5zaW9uIDEgc2hvdWxkIGJlIHNhbWUgYXMgaGVhZF9zaXplIC8gMiBvciByb3RhcnlfZW1iZWRkaW5nX2RpbSAvIDIsIGdvdCAke1xuICAgICAgICBjb3NDYWNoZS5kaW1zWzFdXG4gICAgICB9YCxcbiAgICApO1xuICB9XG5cbiAgaWYgKHNlcXVlbmNlTGVuZ3RoID4gbWF4U2VxdWVuY2VMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VwZGF0aW5nIGNvc19jYWNoZSBhbmQgc2luX2NhY2hlIGluIFJvdGFyeUVtYmVkZGluZyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCcpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUm90YXJ5RW1iZWRkaW5nUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCB7IGludGVybGVhdmVkLCBudW1IZWFkcywgcm90YXJ5RW1iZWRkaW5nRGltLCBzY2FsZSB9ID0gYXR0cmlidXRlcztcbiAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXRzWzBdLmRpbXNbMF07XG4gIGNvbnN0IGJhdGNoU3RyaWRlID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKGlucHV0c1swXS5kaW1zLCAxKTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBpbnB1dHNbMF0uZGltc1tpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyXTtcbiAgY29uc3QgaGlkZGVuU2l6ZSA9IGJhdGNoU3RyaWRlIC8gc2VxdWVuY2VMZW5ndGg7XG4gIGNvbnN0IGhhbGZSb3RhcnlFbWJlZGRpbmdEaW0gPSBpbnB1dHNbMl0uZGltc1sxXTtcbiAgY29uc3QgaGVhZFNpemUgPSByb3RhcnlFbWJlZGRpbmdEaW0gPT09IDAgPyBoYWxmUm90YXJ5RW1iZWRkaW5nRGltICogMiA6IGhpZGRlblNpemUgLyBudW1IZWFkcztcblxuICAvLyBSb3RhcnkgZW1iZWRkaW5ncyB3aWxsIGJlIGNhbGN1bGF0ZWQgaW4gYSBwYWlyLXdpc2UgZmFzaGlvbi4gSW4gYWNjb3JkYW5jZSwgdXNlIHRoZSBzaGFwZVxuICAvLyBbYmF0Y2ggc2l6ZSwgc2VxdWVuY2UgbGVuZ3RoLCBudW0gb2YgaGVhZHMsIG51bSBvZiBwYWlycyB0byByb3RhdGUgKyBudW0gb2YgZGltcyB0byBjb3B5XVxuICAvLyB0byB1bmZvbGQgdGhlIGdsb2JhbCBpbmRleCBpbiBzaGFkZXIuXG4gIGNvbnN0IGdsb2JhbFNoYXBlID0gbmV3IEFycmF5PG51bWJlcj4oXG4gICAgYmF0Y2hTaXplLFxuICAgIHNlcXVlbmNlTGVuZ3RoLFxuICAgIGhpZGRlblNpemUgLyBoZWFkU2l6ZSxcbiAgICBoZWFkU2l6ZSAtIGhhbGZSb3RhcnlFbWJlZGRpbmdEaW0sXG4gICk7XG4gIGNvbnN0IGdsb2JhbFN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZ2xvYmFsU2hhcGUpO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBzY2FsZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBnbG9iYWxTaGFwZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBnbG9iYWxTdHJpZGVzIH0sXG5cbiAgICAvLyBzdHJpZGVzIGZvciBhZGRyZXNzaW5nIHRoZSBpbnB1dC9vdXRwdXQgdGVuc29yLCBpbiBwZXJtdXRhdGVkIG9yZGVyIHRvIGFsaWduIHdpdGggdGhlIHVuZm9sZGVkIGdsb2JhbCBpbmRleCxcbiAgICAvLyBpLmUuIEJTTkhcbiAgICAuLi4oaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSAzXG4gICAgICA/IG5ldyBBcnJheTxQcm9ncmFtVW5pZm9ybT4oeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IFtiYXRjaFN0cmlkZSwgaGlkZGVuU2l6ZSwgaGVhZFNpemUsIDFdIH0pXG4gICAgICA6IFtdKSxcbiAgICAuLi4oaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSA0XG4gICAgICA/IG5ldyBBcnJheTxQcm9ncmFtVW5pZm9ybT4oe1xuICAgICAgICAgIHR5cGU6IERhdGFUeXBlLnVpbnQzMixcbiAgICAgICAgICBkYXRhOiBbYmF0Y2hTdHJpZGUsIGhlYWRTaXplLCBzZXF1ZW5jZUxlbmd0aCAqIGhlYWRTaXplLCAxXSxcbiAgICAgICAgfSlcbiAgICAgIDogW10pLFxuXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zLCBpbnB1dHNbMl0uZGltcywgaW5wdXRzWzNdLmRpbXMsIGlucHV0c1swXS5kaW1zKSxcbiAgXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IHBvc2l0aW9uSWRzID0gaW5wdXRWYXJpYWJsZSgncG9zaXRpb25faWRzJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IGNvc0NhY2hlID0gaW5wdXRWYXJpYWJsZSgnY29zX2NhY2hlJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IHNpbkNhY2hlID0gaW5wdXRWYXJpYWJsZSgnc2luX2NhY2hlJywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG5cbiAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtcyhbXG4gICAgICB7IG5hbWU6ICdzY2FsZScsIHR5cGU6ICdmMzInIH0sXG4gICAgICB7IG5hbWU6ICdnbG9iYWxfc2hhcGUnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBnbG9iYWxTaGFwZS5sZW5ndGggfSxcbiAgICAgIHsgbmFtZTogJ2dsb2JhbF9zdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZ2xvYmFsU3RyaWRlcy5sZW5ndGggfSxcbiAgICAgIHsgbmFtZTogJ2lucHV0X291dHB1dF9zdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZ2xvYmFsU3RyaWRlcy5sZW5ndGggfSxcbiAgICBdKTtcblxuICAgIHJldHVybiBgXG4gICAgICAgICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIHBvc2l0aW9uSWRzLCBjb3NDYWNoZSwgc2luQ2FjaGUsIG91dHB1dCl9XG5cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFdPUktHUk9VUF9TSVpFKX1cbiAgICAgICAgICBsZXQgaGFsZl9yb3RhcnlfZW1iX2RpbSA9IHVuaWZvcm1zLiR7Y29zQ2FjaGUubmFtZX1fc2hhcGVbMV07XG4gICAgICAgICAgbGV0IGJzbmggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuZ2xvYmFsX3N0cmlkZXMgJSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGU7XG4gICAgICAgICAgbGV0IHNpemUgPSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGVbMF0gKiB1bmlmb3Jtcy5nbG9iYWxfc3RyaWRlc1swXTtcbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCdzaXplJyl9XG5cbiAgICAgICAgICBpZiAoYnNuaFszXSA8IGhhbGZfcm90YXJ5X2VtYl9kaW0pIHtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZHNfaWR4ID1cbiAgICAgICAgICAgICAgICAke3Bvc2l0aW9uSWRzLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KCdic25oLnh5Jywgb3V0cHV0VmFyaWFibGUoJycsIHBvc2l0aW9uSWRzLnR5cGUudGVuc29yLCAyKSl9O1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uX2lkID1cbiAgICAgICAgICAgICAgICB1MzIoJHtwb3NpdGlvbklkcy5nZXRCeU9mZnNldCgncG9zaXRpb25faWRzX2lkeCcpfSkgKyBzZWxlY3QoMCwgYnNuaFsxXSwgcG9zaXRpb25faWRzX2lkeCA9PSAwKTtcbiAgICAgICAgICAgIGxldCBpID0gZG90KGJzbmgsIHVuaWZvcm1zLmlucHV0X291dHB1dF9zdHJpZGVzKSArIHNlbGVjdCgwLCBic25oWzNdLCAke2ludGVybGVhdmVkfSk7XG4gICAgICAgICAgICBsZXQgaiA9IGkgKyBzZWxlY3QoaGFsZl9yb3RhcnlfZW1iX2RpbSwgMSwgJHtpbnRlcmxlYXZlZH0pO1xuICAgICAgICAgICAgbGV0IHJlID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnaScpfSAqICR7Y29zQ2FjaGUuZ2V0KCdwb3NpdGlvbl9pZCcsICdic25oWzNdJyl9IC1cbiAgICAgICAgICAgICAgICAke2lucHV0LmdldEJ5T2Zmc2V0KCdqJyl9ICogJHtzaW5DYWNoZS5nZXQoJ3Bvc2l0aW9uX2lkJywgJ2JzbmhbM10nKX07XG4gICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnaScsICdyZScpfVxuICAgICAgICAgICAgbGV0IGltID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnaScpfSAqICR7c2luQ2FjaGUuZ2V0KCdwb3NpdGlvbl9pZCcsICdic25oWzNdJyl9ICtcbiAgICAgICAgICAgICAgICAke2lucHV0LmdldEJ5T2Zmc2V0KCdqJyl9ICogJHtjb3NDYWNoZS5nZXQoJ3Bvc2l0aW9uX2lkJywgJ2JzbmhbM10nKX07XG4gICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnaicsICdpbScpfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgayA9IGRvdChic25oLCB1bmlmb3Jtcy5pbnB1dF9vdXRwdXRfc3RyaWRlcykgKyBoYWxmX3JvdGFyeV9lbWJfZGltO1xuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2snLCBpbnB1dC5nZXRCeU9mZnNldCgnaycpKX1cbiAgICAgICAgICB9XG4gICAgICAgIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1JvdGFyeUVtYmVkZGluZycsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgICAgIGludGVybGVhdmVkLFxuICAgICAgfSkuY2FjaGVLZXksXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJywgJ3JhbmsnLCAncmFuaycsICdyYW5rJ10sXG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IGlucHV0c1swXS5kaW1zLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUoZ2xvYmFsU2hhcGUpIC8gV09SS0dST1VQX1NJWkUpIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgcm90YXJ5RW1iZWRkaW5nID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVJvdGFyeUVtYmVkZGluZ1Byb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcblxuaW1wb3J0IHsgYXBwbHlBdHRlbnRpb24sIEF0dGVudGlvbk1hc2tUeXBlLCBBdHRlbnRpb25QYXJhbWV0ZXJzLCBBdHRlbnRpb25Ra3ZGb3JtYXQgfSBmcm9tICcuL2F0dGVudGlvbic7XG5pbXBvcnQgeyBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMgfSBmcm9tICcuL211bHRpaGVhZC1hdHRlbnRpb24nO1xuaW1wb3J0IHsgY3JlYXRlU3BsaXRQcm9ncmFtSW5mbywgU3BsaXRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9zcGxpdCc7XG5pbXBvcnQgeyBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbywgVHJhbnNwb3NlQXR0cmlidXRlcyB9IGZyb20gJy4vdHJhbnNwb3NlJztcbmltcG9ydCB7IFJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMsIGNyZWF0ZVJvdGFyeUVtYmVkZGluZ1Byb2dyYW1JbmZvIH0gZnJvbSAnLi9yb3RhcnktZW1iZWRkaW5nJztcbmltcG9ydCB7IGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFVuaWZvcm1zQXJyYXlUeXBlIH0gZnJvbSAnLi9jb21tb24nO1xuZXhwb3J0IGludGVyZmFjZSBHcm91cFF1ZXJ5QXR0ZW50aW9uQXR0cmlidXRlcyB7XG4gIG51bUhlYWRzOiBudW1iZXI7XG4gIGt2TnVtSGVhZHM6IG51bWJlcjtcbiAgc2NhbGU6IG51bWJlcjtcbiAgc29mdGNhcDogbnVtYmVyO1xuICBkb1JvdGFyeTogbnVtYmVyO1xuICByb3RhcnlJbnRlcmxlYXZlZDogbnVtYmVyO1xuICBzbW9vdGhTb2Z0bWF4OiBib29sZWFuO1xuICBsb2NhbFdpbmRvd1NpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogR3JvdXBRdWVyeUF0dGVudGlvbkF0dHJpYnV0ZXMsXG4pOiBBdHRlbnRpb25QYXJhbWV0ZXJzID0+IHtcbiAgaWYgKGF0dHJpYnV0ZXMuZG9Sb3RhcnkgJiYgaW5wdXRzLmxlbmd0aCA8PSA3KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb3NfY2FjaGUgYW5kIHNpbl9jYWNoZSBpbnB1dHMgYXJlIHJlcXVpcmVkIGlmIGRvX3JvdGFyeSBpcyBzcGVjaWZpZWQnKTtcbiAgfVxuICBjb25zdCBxdWVyeSA9IGlucHV0c1swXTtcbiAgY29uc3Qga2V5ID0gaW5wdXRzWzFdO1xuICBjb25zdCB2YWx1ZSA9IGlucHV0c1syXTtcbiAgY29uc3QgcGFzdEtleSA9IGlucHV0c1szXTtcbiAgY29uc3QgcGFzdFZhbHVlID0gaW5wdXRzWzRdO1xuICBpZiAoYXR0cmlidXRlcy5kb1JvdGFyeSAhPT0gMCAmJiBpbnB1dHMubGVuZ3RoIDw9IDcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nvc19jYXN0IGFuZCBzaW5fY2FjaGUgYXJlIGV4cGVjdGVkIGlmIGRvX3JvdGFyeSBhdHRyaWJ1dGUgaXMgbm9uLXplcm8nKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy5sb2NhbFdpbmRvd1NpemUgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMb2NhbCBhdHRlbnRpb24gaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG4gIGlmIChhdHRyaWJ1dGVzLnNvZnRjYXAgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvZnRjYXAgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG4gIGlmIChhdHRyaWJ1dGVzLnJvdGFyeUludGVybGVhdmVkICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb3RhcnkgaW50ZXJsZWF2ZWQgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG4gIGlmIChhdHRyaWJ1dGVzLnNtb290aFNvZnRtYXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Ntb290aCBzb2Z0bWF4IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuICAvLyBBYmJyZXZpYXRpb24gYW5kIE1lYW5pbmdzOlxuICAvLyAgIEI6ICAgIGJhdGNoX3NpemVcbiAgLy8gICBTOiAgICBzZXF1ZW5jZV9sZW5ndGggKGlucHV0IHNlcXVlbmNlIGxlbmd0aCBvZiBxdWVyeSlcbiAgLy8gICBQOiAgICBwYXN0X3NlcXVlbmNlX2xlbmd0aCAocGFzdCBzZXF1ZW5jZSBsZW5ndGggb2Yga2V5IG9yIHZhbHVlKVxuICAvLyAgIEw6ICAgIGt2X3NlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIGtleSBvciB2YWx1ZSlcbiAgLy8gICBNOiAgICBtYXhfc2VxdWVuY2VfbGVuZ3RoXG4gIC8vICAgVDogICAgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggKyBrdl9zZXF1ZW5jZV9sZW5ndGhcbiAgLy8gICBOOiAgICBudW1faGVhZHNcbiAgLy8gICBIOiAgICBoZWFkIHNpemUgZm9yIFEgYW5kIEssIGFrYSBxX2hlYWRfc2l6ZSBvciBrX2hlYWRfc2l6ZSBvciBxa19oZWFkX3NpemVcbiAgLy8gICBIX3Y6ICB2X2hlYWRfc2l6ZVxuICAvLyAgIERfaTogIGlucHV0IGhpZGRlbiBzaXplXG4gIC8vICAgRDogICAgaGlkZGVuIHNpemUgZm9yIFEgYW5kIEsgKEQgPSBOICogSCksIGFrYSBxX2hpZGRlbl9zaXplIG9yIGtfaGlkZGVuX3NpemUgb3IgcWtfaGlkZGVuX3NpemVcbiAgLy8gICBEX3Y6ICB2X2hpZGRlbl9zaXplID0gbnVtX2hlYWRzICogdl9oZWFkX3NpemVcblxuICAvLyAgICAgcGFzdF9rZXkgICAgICAgICAgICAgICAgICAgOiAoQiwgTiwgUyosIEgpXG4gIC8vICAgICBwYXN0X3ZhbHVlICAgICAgICAgICAgICAgICA6IChCLCBOLCBTKiwgSClcbiAgLy8gV2hlbiBubyBwYWNraW5nIGZvciBxL2svdjpcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEpICAgICAgIDogKEIsIFMsIEQpXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLKSAgICAgICA6IChCLCBMLCBEKSBvciAoQiwgTiwgUyosIEgpXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IChCLCBMLCBEX3YpIG9yIChCLCBOLCBTKiwgSClcbiAgLy8gV2hlbiBwYWNrZWQga3YgaXMgdXNlZDpcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEpICAgICAgIDogKEIsIFMsIEQpXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLKSAgICAgICA6IChCLCBMLCBOLCAyLCBIKVxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAoVikgICAgICAgOiBOb25lXG4gIC8vIFdoZW4gcGFja2VkIHFrdiBpcyB1c2VkOlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgTCwgTiwgMywgSCkgb3IgKEIsIFMsIDMqRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogTm9uZVxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAoVikgICAgICAgOiBOb25lXG5cbiAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzICYmIHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBjb25zdCBkbW1oYVBhY2tpbmcgPSBmYWxzZTtcbiAgY29uc3QgYmF0Y2hTaXplID0gcXVlcnkuZGltc1swXTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBxdWVyeS5kaW1zWzFdO1xuICBsZXQgaGlkZGVuU2l6ZSA9XG4gICAgcXVlcnkuZGltcy5sZW5ndGggPT09IDMgPyAoZG1taGFQYWNraW5nID8gcXVlcnkuZGltc1syXSAvIDMgOiBxdWVyeS5kaW1zWzJdKSA6IGF0dHJpYnV0ZXMubnVtSGVhZHMgKiBxdWVyeS5kaW1zWzRdO1xuICBsZXQga3ZTZXF1ZW5jZUxlbmd0aCA9IHNlcXVlbmNlTGVuZ3RoO1xuXG4gIGxldCBwYXN0U2VxdWVuY2VMZW5ndGggPSAwO1xuICBjb25zdCBwYWNrZWRRS1YgPSAha2V5IHx8IGtleS5kaW1zLmxlbmd0aCA9PT0gMDtcbiAgY29uc3QgaGVhZFNpemUgPSAhcGFja2VkUUtWXG4gICAgPyBNYXRoLmZsb29yKGhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKVxuICAgIDogTWF0aC5mbG9vcihoaWRkZW5TaXplIC8gKGF0dHJpYnV0ZXMubnVtSGVhZHMgKyAyICogYXR0cmlidXRlcy5rdk51bUhlYWRzKSk7XG4gIGlmIChwYWNrZWRRS1YpIHtcbiAgICBoaWRkZW5TaXplID0gaGVhZFNpemUgKiBhdHRyaWJ1dGVzLm51bUhlYWRzO1xuICB9XG4gIGNvbnN0IGhhc1Bhc3RLZXkgPSBwYXN0S2V5ICYmIHBhc3RLZXkuZGltcy5sZW5ndGggIT09IDA7XG4gIGNvbnN0IGhhc1Bhc3RWYWx1ZSA9IHBhc3RWYWx1ZSAmJiBwYXN0VmFsdWUuZGltcy5sZW5ndGggIT09IDA7XG4gIC8vIEN1cnJlbnRseSB0aGUgb25ueHJ1bnRpbWUgR1FBIHNwZWNpZmljYXRpb24gb25seSBzdXBwb3J0IGtleS92YWx1ZSBCTlNIIGZvcm1hdC5cbiAgY29uc3QgaXNQYXN0a3ZCU05IID1cbiAgICBoYXNQYXN0S2V5ICYmXG4gICAgcGFzdEtleS5kaW1zLmxlbmd0aCA9PT0gNCAmJlxuICAgIHBhc3RLZXkuZGltc1swXSA9PT0gYmF0Y2hTaXplICYmXG4gICAgcGFzdEtleS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLmt2TnVtSGVhZHMgJiZcbiAgICBwYXN0S2V5LmRpbXNbMl0gPT09IGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyAmJlxuICAgIHBhc3RLZXkuZGltc1szXSA9PT0gaGVhZFNpemU7XG5cbiAgaWYgKGlzUGFzdGt2QlNOSCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQlNOSCBwYXN0S2V5L3Bhc3RWYWx1ZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgaWYgKGhhc1Bhc3RLZXkgJiYgaGFzUGFzdFZhbHVlKSB7XG4gICAgaWYgKHBhc3RLZXkuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIGlmIChwYXN0VmFsdWUuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgcGFzdFNlcXVlbmNlTGVuZ3RoID0gcGFzdEtleS5kaW1zWzJdO1xuICB9IGVsc2UgaWYgKGhhc1Bhc3RLZXkgfHwgaGFzUGFzdFZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGJlIGJvdGggcHJlc2VudCBvciBib3RoIGFic2VudCcpO1xuICB9XG5cbiAgbGV0IHFrdkZvcm1hdDogQXR0ZW50aW9uUWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFrdkJOU0g7XG4gIGlmIChrZXkgJiYga2V5LmRpbXMubGVuZ3RoID4gMCkge1xuICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZ2l2ZW4nKTtcbiAgICB9XG4gICAgaWYgKGtleS5kaW1zLmxlbmd0aCA8IDMgfHwga2V5LmRpbXMubGVuZ3RoID4gNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMywgNCwgb3IgNSBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5kaW1zWzBdICE9PSBrZXkuZGltc1swXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaCBzaXplKScpO1xuICAgIH1cblxuICAgIGlmIChrZXkuZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGlmIChxdWVyeS5kaW1zWzJdICUga2V5LmRpbXNbMl0gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gMiBvZiBcInF1ZXJ5XCIgc2hvdWxkIGJlIGEgbXVsdGlwbGUgb2YgXCJrZXlcIicpO1xuICAgICAgfVxuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzFdO1xuICAgIH0gZWxzZSBpZiAoa2V5LmRpbXMubGVuZ3RoID09PSA1KSB7XG4gICAgICBpZiAoa2V5LmRpbXNbMl0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwga2V5LmRpbXNbM10gIT09IDIgfHwga2V5LmRpbXNbNF0gIT09IGhlYWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAyLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInZhbHVlXCIgYmUgbm9uZSB3aGVuIFwia2V5XCIgaGFzIHBhY2tlZCBrdiBmb3JtYXQuJyk7XG4gICAgICB9XG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGtleV9kaW1zLnNpemUoKSA9PSA0IChjcm9zcy1hdHRlbnRpb24gd2l0aCBwYXN0X2tleSlcbiAgICAgIGlmIChrZXkuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBrZXkuZGltc1szXSAhPT0gaGVhZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSkgZm9yIHBhc3Rfa2V5Jyk7XG4gICAgICB9XG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMl07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHBhY2tlZCBRS1ZcbiAgICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDMgJiYgcXVlcnkuZGltcy5sZW5ndGggIT09IDUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHknKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoID09PSA1ICYmIChxdWVyeS5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IHF1ZXJ5LmRpbXNbM10gIT09IDMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInF1ZXJ5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAzLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtcbiAgICB9XG5cbiAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2QlNOM0g7XG4gIH1cblxuICBjb25zdCBtYXNrVHlwZTogQXR0ZW50aW9uTWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5ub25lO1xuICBsZXQgcGFzc1Bhc3RJbkt2ID0gZmFsc2U7XG4gIGxldCB2SGlkZGVuU2l6ZSA9IGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyA/IGhlYWRTaXplICogYXR0cmlidXRlcy5rdk51bUhlYWRzIDogaGlkZGVuU2l6ZTtcbiAgaWYgKHZhbHVlICYmIHZhbHVlLmRpbXMubGVuZ3RoID4gMCkge1xuICAgIGlmICh2YWx1ZS5kaW1zLmxlbmd0aCAhPT0gMyAmJiB2YWx1ZS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChxdWVyeS5kaW1zWzBdICE9PSB2YWx1ZS5kaW1zWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUuZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGlmIChrdlNlcXVlbmNlTGVuZ3RoICE9PSB2YWx1ZS5kaW1zWzFdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDEgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICAgIH1cbiAgICAgIHZIaWRkZW5TaXplID0gdmFsdWUuZGltc1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGt2U2VxdWVuY2VMZW5ndGggIT09IHZhbHVlLmRpbXNbMl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDIgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICAgIH1cbiAgICAgIHZIaWRkZW5TaXplID0gdmFsdWUuZGltc1sxXSAqIHZhbHVlLmRpbXNbM107XG4gICAgICBwYXNzUGFzdEluS3YgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZXFsTGVucyA9IGlucHV0cy5sZW5ndGggPiA0ID8gaW5wdXRzWzVdIDogdW5kZWZpbmVkO1xuICBpZiAoc2VxbExlbnMgJiYgc2VxbExlbnMuZGltcy5sZW5ndGggIT09IDEgJiYgc2VxbExlbnMuZGltc1swXSAhPT0gYmF0Y2hTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInNlcWxlbnNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uIGFuZCB0aGUgc2FtZSBkaW0gMCBhcyBiYXRjaF9zaXplJyk7XG4gIH1cbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IC0xO1xuICBjb25zdCBtYXhTZXF1ZW5jZUxlbmd0aCA9IC0xO1xuICBjb25zdCBicm9hZGNhc3RSZXNQb3NCaWFzID0gZmFsc2U7XG5cbiAgcmV0dXJuIHtcbiAgICBiYXRjaFNpemUsXG4gICAgc2VxdWVuY2VMZW5ndGgsXG4gICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxuICAgIGt2U2VxdWVuY2VMZW5ndGgsXG4gICAgdG90YWxTZXF1ZW5jZUxlbmd0aCxcbiAgICBtYXhTZXF1ZW5jZUxlbmd0aCxcbiAgICBpbnB1dEhpZGRlblNpemU6IDAsXG4gICAgaGlkZGVuU2l6ZSxcbiAgICB2SGlkZGVuU2l6ZSxcbiAgICBoZWFkU2l6ZSxcbiAgICB2SGVhZFNpemU6IE1hdGguZmxvb3IodkhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLmt2TnVtSGVhZHMpLFxuICAgIG51bUhlYWRzOiBhdHRyaWJ1dGVzLm51bUhlYWRzLFxuICAgIGt2TnVtSGVhZHM6IGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyxcbiAgICBuUmVwczogYXR0cmlidXRlcy5udW1IZWFkcyAvIGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyxcbiAgICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBmYWxzZSxcbiAgICBtYXNrVHlwZSxcbiAgICBzY2FsZTogYXR0cmlidXRlcy5zY2FsZSxcbiAgICBicm9hZGNhc3RSZXNQb3NCaWFzLFxuICAgIHBhc3NQYXN0SW5LdixcbiAgICBxa3ZGb3JtYXQsXG4gIH07XG59O1xuXG5jb25zdCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGU6IFRyYW5zcG9zZUF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBwZXJtOiBbMCwgMiwgMSwgM10gfSk7XG5cbmNvbnN0IG1heWJlVHJhbnNwb3NlVG9CTlNIID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBpbnB1dDogVGVuc29yVmlldywgcGFyYW1zOiBBdHRlbnRpb25QYXJhbWV0ZXJzKSA9PiB7XG4gIGxldCByZXNoYXBlZElucHV0ID0gaW5wdXQ7XG4gIGNvbnN0IG51bUhlYWRzID0gcGFyYW1zLmt2TnVtSGVhZHMhO1xuICBpZiAoaW5wdXQuZGltcy5sZW5ndGggPT09IDMgJiYgcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGggIT09IDApIHtcbiAgICByZXNoYXBlZElucHV0ID0gaW5wdXQucmVzaGFwZShbcGFyYW1zLmJhdGNoU2l6ZSwgcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGgsIG51bUhlYWRzLCBwYXJhbXMuaGVhZFNpemVdKTtcbiAgICByZXNoYXBlZElucHV0ID0gY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKHJlc2hhcGVkSW5wdXQsIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZS5wZXJtKSwge1xuICAgICAgaW5wdXRzOiBbcmVzaGFwZWRJbnB1dF0sXG4gICAgICBvdXRwdXRzOiBbLTFdLFxuICAgIH0pWzBdO1xuICB9XG5cbiAgcmV0dXJuIHJlc2hhcGVkSW5wdXQ7XG59O1xuXG5jb25zdCBnZW5lcmF0ZVBvc2l0aW9uSWRzUHJvZ3JhbUluZm8gPSAoXG4gIGJhdGNoU2l6ZTogbnVtYmVyLFxuICBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxuICBzZXFMZW5zOiBUZW5zb3JWaWV3LFxuICB0b3RhbFNlcUxlbjogVGVuc29yVmlldyxcbikgPT4ge1xuICBjb25zdCBvdXRwdXREYXRhVHlwZSA9IERhdGFUeXBlLmludDY0O1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZScsICd0eXBlJ107XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSAqIHNlcXVlbmNlTGVuZ3RoXTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IGJhdGNoU2l6ZSAqIHNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYmF0Y2hTaXplIH0sXG4gIF07XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IHNlcUxlbnNJbnB1dEhlbHBlciA9IGlucHV0VmFyaWFibGUoJ3NlcV9sZW5zJywgc2VxTGVucy5kYXRhVHlwZSwgc2VxTGVucy5kaW1zKTtcbiAgICBjb25zdCB0b3RhbFNlcUxlbklucHV0SGVscGVyID0gaW5wdXRWYXJpYWJsZSgndG90YWxfc2VxX2xlbnMnLCB0b3RhbFNlcUxlbi5kYXRhVHlwZSwgdG90YWxTZXFMZW4uZGltcyk7XG4gICAgY29uc3QgcG9zaXRpb25JZHNIZWxwZXIgPSBvdXRwdXRWYXJpYWJsZSgncG9zX2lkcycsIG91dHB1dERhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG5cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdzZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnYmF0Y2hfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgXTtcblxuICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoc2VxTGVuc0lucHV0SGVscGVyLCB0b3RhbFNlcUxlbklucHV0SGVscGVyLCBwb3NpdGlvbklkc0hlbHBlcil9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgbGV0IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHUzMigke3RvdGFsU2VxTGVuSW5wdXRIZWxwZXIuZ2V0QnlPZmZzZXQoJzAnKX0pO1xuICAgIGxldCBpc19zdWJzZXF1ZW50X3Byb21wdCA9IHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aCA+IDEgJiYgdW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoICE9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICBsZXQgaXNfZmlyc3RfcHJvbXB0ID0gIWlzX3N1YnNlcXVlbnRfcHJvbXB0ICYmIHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aCA9PSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGg7XG4gICAgbGV0IGJhdGNoX2lkeCA9IGdsb2JhbF9pZHggLyB1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGg7XG4gICAgbGV0IHNlcXVlbmNlX2lkeCA9IGkzMihnbG9iYWxfaWR4ICUgdW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoKTtcbiAgICB2YXIgcG9zX2lkOiBpMzIgPSAwO1xuICAgIGxldCBzZXFsZW4gPSAke3NlcUxlbnNJbnB1dEhlbHBlci5nZXRCeU9mZnNldCgnYmF0Y2hfaWR4Jyl9O1xuICAgIGxldCB0b3RhbF9zZXFsZW4gPSBzZXFsZW4gKyAxO1xuICAgIGlmIChpc19maXJzdF9wcm9tcHQpIHtcbiAgICAgIGlmIChzZXF1ZW5jZV9pZHggPCB0b3RhbF9zZXFsZW4pIHtcbiAgICAgICAgcG9zX2lkID0gc2VxdWVuY2VfaWR4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zX2lkID0gMTtcbiAgICAgIH1cbiAgICAgICR7cG9zaXRpb25JZHNIZWxwZXIuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAncG9zX2lkJyl9XG4gICAgfSBlbHNlIGlmIChpc19zdWJzZXF1ZW50X3Byb21wdCkge1xuICAgICAgbGV0IHBhc3Rfc2VxbGVuID0gdG90YWxfc2VxbGVuIC0gaTMyKHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aCk7XG4gICAgICBpZiAocGFzdF9zZXFsZW4gKyBzZXF1ZW5jZV9pZHggPCB0b3RhbF9zZXFsZW4pIHtcbiAgICAgICAgcG9zX2lkID0gcGFzdF9zZXFsZW4gKyBzZXF1ZW5jZV9pZHg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3NfaWQgPSAxO1xuICAgICAgfVxuICAgICAgJHtwb3NpdGlvbklkc0hlbHBlci5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdwb3NfaWQnKX1cbiAgICB9IGVsc2UgaWYgKGdsb2JhbF9pZHggPCB1bmlmb3Jtcy5iYXRjaF9zaXplKSB7XG4gICAgICAke3Bvc2l0aW9uSWRzSGVscGVyLnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3NlcWxlbicpfVxuICAgIH07XG4gIH1cbiAgYDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnR2VuZXJhdGVQb3NpdGlvbklkcycsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YmF0Y2hTaXplfTske3NlcXVlbmNlTGVuZ3RofWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdyb3VwUXVlcnlBdHRlbnRpb24gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEdyb3VwUXVlcnlBdHRlbnRpb25BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgaWYgKGNvbnRleHQuaW5wdXRzWzFdPy5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgY29uc3QgcSA9IGNvbnRleHQuaW5wdXRzWzBdO1xuICBjb25zdCBrID0gY29udGV4dC5pbnB1dHNbMV0gJiYgY29udGV4dC5pbnB1dHNbMV0uZGltcy5sZW5ndGggPiAwID8gY29udGV4dC5pbnB1dHNbMV0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHYgPSBjb250ZXh0LmlucHV0c1syXSAmJiBjb250ZXh0LmlucHV0c1syXS5kaW1zLmxlbmd0aCA+IDAgPyBjb250ZXh0LmlucHV0c1syXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgcGFzdEtleSA9IGNvbnRleHQuaW5wdXRzWzNdICYmIGNvbnRleHQuaW5wdXRzWzNdLmRpbXMubGVuZ3RoICE9PSAwID8gY29udGV4dC5pbnB1dHNbM10gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHBhc3RWYWx1ZSA9IGNvbnRleHQuaW5wdXRzWzRdICYmIGNvbnRleHQuaW5wdXRzWzRdLmRpbXMubGVuZ3RoICE9PSAwID8gY29udGV4dC5pbnB1dHNbNF0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHNlcUxlbnMgPSBjb250ZXh0LmlucHV0cy5sZW5ndGggPiA0ID8gY29udGV4dC5pbnB1dHNbNV0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCA9IGNvbnRleHQuaW5wdXRzLmxlbmd0aCA+IDUgPyBjb250ZXh0LmlucHV0c1s2XSA6IHVuZGVmaW5lZDtcbiAgY29uc3Qga3ZOdW1IZWFkcyA9IHBhcmFtcy5rdk51bUhlYWRzID8gcGFyYW1zLmt2TnVtSGVhZHMgOiBwYXJhbXMubnVtSGVhZHM7XG5cbiAgLy8gVE9ETyBSZW1vdmUgZXhwbGljaXQgc3BsaXQgb3BlcmF0aW9uIGFuZCB1c2UgaW5kZXhpbmcgaW4gQXR0ZW50aW9uIGltcGxlbWVudGF0aW9uIHRvIGF2b2lkIG92ZXJoZWFkLlxuXG4gIGNvbnN0IHNwbGl0QXR0cmlidXRlczogU3BsaXRBdHRyaWJ1dGVzID0gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcbiAgICBheGlzOiAyLFxuICAgIG51bU91dHB1dHM6IDMsXG4gICAgc3BsaXRTaXplczogW3BhcmFtcy5udW1IZWFkcyAqIHBhcmFtcy5oZWFkU2l6ZSwga3ZOdW1IZWFkcyAqIHBhcmFtcy5oZWFkU2l6ZSwga3ZOdW1IZWFkcyAqIHBhcmFtcy5oZWFkU2l6ZV0sXG4gIH0pO1xuICBjb25zdCBbcXVlcnksIGtleSwgdmFsdWVdID1cbiAgICAhayAmJiAhdlxuICAgICAgPyBjb250ZXh0LmNvbXB1dGUoY3JlYXRlU3BsaXRQcm9ncmFtSW5mbyhbcV0sIHNwbGl0QXR0cmlidXRlcyksIHsgaW5wdXRzOiBbcV0sIG91dHB1dHM6IFstMSwgLTEsIC0xXSB9KVxuICAgICAgOiBbcSwgayEsIHYhXTtcbiAgbGV0IHFSb3Rhcnk6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQ7XG4gIGxldCBrUm90YXJ5OiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkO1xuICBpZiAoYXR0cmlidXRlcy5kb1JvdGFyeSkge1xuICAgIGNvbnN0IHBvc0lkcyA9IGNvbnRleHQuY29tcHV0ZShcbiAgICAgIGdlbmVyYXRlUG9zaXRpb25JZHNQcm9ncmFtSW5mbyhwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMuc2VxdWVuY2VMZW5ndGgsIHNlcUxlbnMhLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQhKSxcbiAgICAgIHsgaW5wdXRzOiBbc2VxTGVucyEsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCFdLCBvdXRwdXRzOiBbLTFdIH0sXG4gICAgKVswXTtcbiAgICBjb25zdCBjb3NDYWNoZSA9IGNvbnRleHQuaW5wdXRzWzddO1xuICAgIGNvbnN0IHNpbkNhY2hlID0gY29udGV4dC5pbnB1dHNbOF07XG4gICAgY29uc3QgcVJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXM6IFJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgICAgaW50ZXJsZWF2ZWQ6IGF0dHJpYnV0ZXMucm90YXJ5SW50ZXJsZWF2ZWQgIT09IDAsXG4gICAgICBudW1IZWFkczogcGFyYW1zLm51bUhlYWRzLFxuICAgICAgcm90YXJ5RW1iZWRkaW5nRGltOiAwLFxuICAgICAgc2NhbGU6IGF0dHJpYnV0ZXMuc2NhbGUsXG4gICAgfSk7XG4gICAgY29uc3QgaW5wdXRzID0gW3F1ZXJ5LCBwb3NJZHMsIGNvc0NhY2hlLCBzaW5DYWNoZV07XG4gICAgY29uc3Qgb3V0cHV0cyA9IFstMV07XG4gICAgcVJvdGFyeSA9IGNvbnRleHQuY29tcHV0ZShjcmVhdGVSb3RhcnlFbWJlZGRpbmdQcm9ncmFtSW5mbyhpbnB1dHMsIHFSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzKSwge1xuICAgICAgaW5wdXRzLFxuICAgICAgb3V0cHV0cyxcbiAgICB9KVswXTtcbiAgICBpbnB1dHMuc3BsaWNlKDAsIDEsIGtleSk7XG4gICAgY29uc3Qga1JvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXM6IFJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgICAgaW50ZXJsZWF2ZWQ6IGF0dHJpYnV0ZXMucm90YXJ5SW50ZXJsZWF2ZWQgIT09IDAsXG4gICAgICBudW1IZWFkczogcGFyYW1zLmt2TnVtSGVhZHMhLFxuICAgICAgcm90YXJ5RW1iZWRkaW5nRGltOiAwLFxuICAgICAgc2NhbGU6IGF0dHJpYnV0ZXMuc2NhbGUsXG4gICAgfSk7XG4gICAga1JvdGFyeSA9IGNvbnRleHQuY29tcHV0ZShjcmVhdGVSb3RhcnlFbWJlZGRpbmdQcm9ncmFtSW5mbyhpbnB1dHMsIGtSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzKSwge1xuICAgICAgaW5wdXRzLFxuICAgICAgb3V0cHV0cyxcbiAgICB9KVswXTtcbiAgfVxuICBjb25zdCBRID0gbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzKFxuICAgIGNvbnRleHQsXG4gICAgcGFyYW1zLmJhdGNoU2l6ZSxcbiAgICBwYXJhbXMubnVtSGVhZHMsXG4gICAgcGFyYW1zLnNlcXVlbmNlTGVuZ3RoLFxuICAgIHBhcmFtcy5oZWFkU2l6ZSxcbiAgICBhdHRyaWJ1dGVzLmRvUm90YXJ5ID8gcVJvdGFyeSEgOiBxdWVyeSxcbiAgICB1bmRlZmluZWQsXG4gICAgMCxcbiAgKTtcbiAgY29uc3QgSyA9IG1heWJlVHJhbnNwb3NlVG9CTlNIKGNvbnRleHQsIGF0dHJpYnV0ZXMuZG9Sb3RhcnkgPyBrUm90YXJ5ISA6IGtleSwgcGFyYW1zKTtcbiAgY29uc3QgViA9IG1heWJlVHJhbnNwb3NlVG9CTlNIKGNvbnRleHQsIHZhbHVlLCBwYXJhbXMpO1xuXG4gIGFwcGx5QXR0ZW50aW9uKFxuICAgIGNvbnRleHQsXG4gICAgUSxcbiAgICBLLFxuICAgIFYsXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZCxcbiAgICBwYXN0S2V5LFxuICAgIHBhc3RWYWx1ZSxcbiAgICB1bmRlZmluZWQsXG4gICAgcGFyYW1zLFxuICAgIHNlcUxlbnMsXG4gICAgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LFxuICApO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRNYXhDb21wb25lbnRzLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICBzdW1WZWN0b3IsXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEluc3RhbmNlTm9ybUF0dHJpYnV0ZXMge1xuICBlcHNpbG9uOiBudW1iZXI7XG4gIGZvcm1hdDogJ05IV0MnIHwgJ05DSFcnO1xufVxuXG5jb25zdCBjb21wdXRlQ2hhbm5lbFNjYWxlU2hpZnQgPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBpbnB1dDogVGVuc29yVmlldyxcbiAgc2NhbGU6IFRlbnNvclZpZXcsXG4gIGJpYXM6IFRlbnNvclZpZXcsXG4gIG46IG51bWJlcixcbiAgaDogbnVtYmVyLFxuICBjOiBudW1iZXIsXG4gIGVwc2lsb246IG51bWJlcixcbikgPT4ge1xuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhoKTtcbiAgY29uc3QgZjMyVHlwZSA9IGNvbXBvbmVudHMgPT09IDEgPyAnZjMyJyA6IGB2ZWMke2NvbXBvbmVudHN9ZmA7XG4gIGNvbnN0IHdnVHlwZSA9IGNvbXBvbmVudHMgPT09IDEgPyAndmVjMmYnIDogYG1hdDJ4JHtjb21wb25lbnRzfWZgO1xuICBjb25zdCB1bml0c09mV29yayA9IG4gKiBjO1xuICBsZXQgd29ya2dyb3VwU2l6ZSA9IDY0O1xuICBpZiAodW5pdHNPZldvcmsgPT09IDEpIHtcbiAgICB3b3JrZ3JvdXBTaXplID0gMjU2O1xuICB9XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBbbiwgYywgaCAvIGNvbXBvbmVudHNdO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtuLCBjLCAyXTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnLCAndHlwZScsICd0eXBlJ107XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtdO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSkpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXQuZGF0YVR5cGUsIDMsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IHMgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZScsIHNjYWxlLmRhdGFUeXBlLCBzY2FsZS5kaW1zKTtcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGJpYXMuZGF0YVR5cGUsIGJpYXMuZGltcyk7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCAzLCAyKTtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbeCwgcywgYiwgb3V0cHV0XTtcbiAgICByZXR1cm4gYFxuICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBfc2hhcmVkIDogYXJyYXk8JHt3Z1R5cGV9LCAke3dvcmtncm91cFNpemV9PjtcbiAgY29uc3Qgd29ya2dyb3VwX3NpemUgPSAke3dvcmtncm91cFNpemV9dTtcbiAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQod29ya2dyb3VwU2l6ZSl9XG4gICAgbGV0IGJhdGNoID0gd29ya2dyb3VwX2luZGV4IC8gdW5pZm9ybXMueF9zaGFwZVsxXTtcbiAgICBsZXQgY2hhbm5lbCA9IHdvcmtncm91cF9pbmRleCAlIHVuaWZvcm1zLnhfc2hhcGVbMV07XG4gICAgbGV0IGhpZ2h0ID0gdW5pZm9ybXMueF9zaGFwZVsyXTtcbiAgICAvLyBpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnlcbiAgICB2YXIgc3VtID0gJHtmMzJUeXBlfSgwKTtcbiAgICB2YXIgc3F1YXJlZF9zdW0gPSAke2YzMlR5cGV9KDApO1xuICAgIGZvciAodmFyIGggPSBsb2NhbF9pZHg7IGggPCBoaWdodDsgaCArPSB3b3JrZ3JvdXBfc2l6ZSkge1xuICAgICAgbGV0IHZhbHVlID0gJHtmMzJUeXBlfSgke3guZ2V0KCdiYXRjaCcsICdjaGFubmVsJywgJ2gnKX0pO1xuICAgICAgc3VtICs9IHZhbHVlO1xuICAgICAgc3F1YXJlZF9zdW0gKz0gdmFsdWUgKiB2YWx1ZTtcbiAgICB9XG4gICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdID0gJHt3Z1R5cGV9KHN1bSwgc3F1YXJlZF9zdW0pO1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIGZvciAodmFyIGN1cnJTaXplID0gd29ya2dyb3VwX3NpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICBpZiAobG9jYWxfaWR4IDwgY3VyclNpemUpIHtcbiAgICAgICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdID0gd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdICsgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHggKyBjdXJyU2l6ZV07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGlmIChsb2NhbF9pZHggPT0gMCkge1xuICAgICAgbGV0IHN1bV9maW5hbCA9ICR7c3VtVmVjdG9yKCd3b3JrZ3JvdXBfc2hhcmVkWzBdWzBdJywgY29tcG9uZW50cyl9IC8gZjMyKGhpZ2h0ICogJHtjb21wb25lbnRzfSk7XG4gICAgICBsZXQgc3F1YXJlZF9zdW1fZmluYWwgPSAke3N1bVZlY3Rvcignd29ya2dyb3VwX3NoYXJlZFswXVsxXScsIGNvbXBvbmVudHMpfSAvIGYzMihoaWdodCAqICR7Y29tcG9uZW50c30pO1xuXG4gICAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydChzcXVhcmVkX3N1bV9maW5hbCAtIHN1bV9maW5hbCAqIHN1bV9maW5hbCArIGYzMigke2Vwc2lsb259KSk7XG4gICAgICBsZXQgY2hhbm5lbF9zY2FsZSA9IGludl9zdGRfZGV2ICogZjMyKHNjYWxlW2NoYW5uZWxdKTtcbiAgICAgIGxldCBjaGFubmVsX3NoaWZ0ID0gZjMyKGJpYXNbY2hhbm5lbF0pIC0gc3VtX2ZpbmFsICogY2hhbm5lbF9zY2FsZTtcbiAgICAgIG91dHB1dFt3b3JrZ3JvdXBfaW5kZXhdID0gdmVjMmYoY2hhbm5lbF9zY2FsZSwgY2hhbm5lbF9zaGlmdCk7XG4gICAgfVxuICB9YDtcbiAgfTtcblxuICByZXR1cm4gY29udGV4dC5jb21wdXRlKFxuICAgIHtcbiAgICAgIG5hbWU6ICdJbnN0YW5jZU5vcm1Db21wdXRlQ2hhbm5lbFNjYWxlU2hpZnQnLFxuICAgICAgLy8gVE9ETzogdXNlIGVwc2lsb24gYXMgdW5pZm9ybS4gQ3VycmVudGx5IGVwc2lsb24gYXMgdW5pZm9ybSBmYWlscyB0ZXN0X2luc3RhbmNlbm9ybV9lcHNpbG9uLlxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7Y29tcG9uZW50c307JHtlcHNpbG9ufTske3dvcmtncm91cFNpemV9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXQgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogdW5pdHNPZldvcmsgfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgICAgfSksXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgfSxcbiAgICB7IGlucHV0czogW2lucHV0LCBzY2FsZSwgYmlhc10sIG91dHB1dHM6IFstMV0gfSxcbiAgKVswXTtcbn07XG5cbmNvbnN0IGNyZWF0ZUluc3RhbmNlTm9ybVByb2dyYW1JbmZvID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IEluc3RhbmNlTm9ybUF0dHJpYnV0ZXMsXG4pID0+IHtcbiAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0geFNoYXBlO1xuICBjb25zdCBheGlzID0gMjtcbiAgY29uc3QgTiA9IHhTaGFwZVswXTtcbiAgY29uc3QgQyA9IHhTaGFwZVsxXTtcbiAgY29uc3QgSCA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbih4U2hhcGUsIGF4aXMpO1xuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhIKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHM7XG4gIC8vIGNvbXB1dGUgY2hhbm5lbCBzY2FsZSBhbmQgY2hhbm5lbCBzaGlmdC5cbiAgY29uc3QgY2hhbm5lbFNjYWxlU2hpZnQgPSBjb21wdXRlQ2hhbm5lbFNjYWxlU2hpZnQoXG4gICAgY29udGV4dCxcbiAgICBpbnB1dHNbMF0sXG4gICAgaW5wdXRzWzFdLFxuICAgIGlucHV0c1syXSxcbiAgICBOLFxuICAgIEgsXG4gICAgQyxcbiAgICBhdHRyaWJ1dGVzLmVwc2lsb24sXG4gICk7XG5cbiAgY29uc3QgaW5wdXRTaGFwZSA9IFtOLCBDLCBIIC8gY29tcG9uZW50c107XG4gIGNvbnN0IHNjYWxlU2hhcGUgPSBbTiwgQ107XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ25vbmUnXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IHNjYWxlID0gaW5wdXRWYXJpYWJsZSgnc2NhbGVfc2hpZnQnLCBEYXRhVHlwZS5mbG9hdCwgc2NhbGVTaGFwZS5sZW5ndGgsIDIpO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbeCwgc2NhbGUsIG91dHB1dF07XG4gICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRJbmRpY2VzWzBdO1xuICAgICAgbGV0IGNoYW5uZWwgPSBvdXRwdXRJbmRpY2VzWzFdO1xuICAgICAgbGV0IHNjYWxlX3NoaWZ0ID0gJHtzY2FsZS5nZXRCeUluZGljZXMoJ3ZlYzI8dTMyPihiYXRjaCwgY2hhbm5lbCknKX07XG4gICAgICBsZXQgdmFsdWUgPSAke3guZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX0gKiAke291dHB1dC50eXBlLnZhbHVlfShzY2FsZV9zaGlmdC54KSArICR7b3V0cHV0LnR5cGUudmFsdWV9KHNjYWxlX3NoaWZ0LnkpO1xuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX07XG4gIH1gO1xuICB9O1xuXG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICB7XG4gICAgICBuYW1lOiAnSW5zdGFuY2VOb3JtYWxpemF0aW9uJyxcbiAgICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgc2NhbGVTaGFwZSwgaW5wdXRTaGFwZSksXG4gICAgICAgIF0sXG4gICAgICB9KSxcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICB9LFxuICAgIHsgaW5wdXRzOiBbaW5wdXRzWzBdLCBjaGFubmVsU2NhbGVTaGlmdF0gfSxcbiAgKTtcbn07XG5cbmNvbnN0IGNyZWF0ZUluc3RhbmNlTm9ybU5IV0NQcm9ncmFtSW5mbyA9IChcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBJbnN0YW5jZU5vcm1BdHRyaWJ1dGVzLFxuKSA9PiB7XG4gIGNvbnN0IHhTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IHhTaGFwZTtcbiAgY29uc3QgTiA9IHhTaGFwZVswXTtcbiAgY29uc3QgQyA9IHhTaGFwZVt4U2hhcGUubGVuZ3RoIC0gMV07XG4gIGNvbnN0IEggPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oeFNoYXBlLCAxKSAvIEM7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKEMpO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cztcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBIIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguZmxvb3IoQyAvIGNvbXBvbmVudHMpIH0sXG4gIF07XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ3R5cGUnXTtcblxuICAvLyAxLiB0cmFuc3Bvc2UgeCBmcm9tIE5IV0MgdG8gTkNIV1xuICBsZXQgbmVlZFRyYW5zcG9zZSA9IGZhbHNlO1xuICBjb25zdCB0cmFuc3Bvc2VkWFBlcm0gPSBbMCwgeFNoYXBlLmxlbmd0aCAtIDFdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHhTaGFwZS5sZW5ndGggLSAyOyBpKyspIHtcbiAgICBuZWVkVHJhbnNwb3NlID0gbmVlZFRyYW5zcG9zZSB8fCB4U2hhcGVbaSArIDFdICE9PSAxO1xuICAgIHRyYW5zcG9zZWRYUGVybS5wdXNoKGkgKyAxKTtcbiAgfVxuXG4gIG5lZWRUcmFuc3Bvc2UgPSBuZWVkVHJhbnNwb3NlICYmIHhTaGFwZVt4U2hhcGUubGVuZ3RoIC0gMV0gIT09IDE7XG5cbiAgY29uc3QgdHJhbnNwb3NlZFggPSBuZWVkVHJhbnNwb3NlXG4gICAgPyBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sIHRyYW5zcG9zZWRYUGVybSksIHtcbiAgICAgICAgaW5wdXRzOiBbY29udGV4dC5pbnB1dHNbMF1dLFxuICAgICAgICBvdXRwdXRzOiBbLTFdLFxuICAgICAgfSlbMF1cbiAgICA6IGNvbnRleHQuaW5wdXRzWzBdLnJlc2hhcGUoQXJyYXkuZnJvbSh7IGxlbmd0aDogeFNoYXBlLmxlbmd0aCB9LCAoXywgaSkgPT4geFNoYXBlW3RyYW5zcG9zZWRYUGVybVtpXV0pKTtcbiAgLy8gMi4gY29tcHV0ZSBjaGFubmVsIHNjYWxlIGFuZCBjaGFubmVsIHNoaWZ0LlxuICBjb25zdCBjaGFubmVsU2NhbGVTaGlmdCA9IGNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdChcbiAgICBjb250ZXh0LFxuICAgIHRyYW5zcG9zZWRYLFxuICAgIGlucHV0c1sxXSxcbiAgICBpbnB1dHNbMl0sXG4gICAgTixcbiAgICBILFxuICAgIEMsXG4gICAgYXR0cmlidXRlcy5lcHNpbG9uLFxuICApO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuICAgIGNvbnN0IHNjYWxlVHlwZSA9IGNvbXBvbmVudHMgPT09IDEgPyAndmVjMmYnIDogYG1hdCR7Y29tcG9uZW50c314MmZgO1xuICAgIGNvbnN0IHNjYWxlRGF0YSA9IChudW06IG51bWJlcikgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBudW0gPT09IDAgPyAneCcgOiAneSc7XG4gICAgICBjb25zdCBmMzJUeXBlID0gY29tcG9uZW50cyA9PT0gMSA/ICdmMzInIDogYHZlYyR7Y29tcG9uZW50c31mYDtcbiAgICAgIHN3aXRjaCAoY29tcG9uZW50cykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGAke2RhdGFUeXBlfSgke2YzMlR5cGV9KHNjYWxlLiR7aW5kZXh9KSlgO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIGB2ZWMyPCR7ZGF0YVR5cGV9Pigke2YzMlR5cGV9KHNjYWxlWzBdLiR7aW5kZXh9LCBzY2FsZVsxXS4ke2luZGV4fSkpYDtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBgdmVjNDwke2RhdGFUeXBlfT4oJHtmMzJUeXBlfShzY2FsZVswXS4ke2luZGV4fSwgc2NhbGVbMV0uJHtpbmRleH0sIHNjYWxlWzJdLiR7aW5kZXh9LCBzY2FsZVszXS4ke2luZGV4fSkpYDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgY29tcG9lbnRzICR7Y29tcG9uZW50c31gKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlucHV0SGVscGVyID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBvdXRwdXRIZWxwZXIgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cyk7XG5cbiAgICByZXR1cm4gYFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGlucHV0IDogYXJyYXk8JHtpbnB1dEhlbHBlci50eXBlLnN0b3JhZ2V9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZV9pbnB1dCA6IGFycmF5PCR7c2NhbGVUeXBlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHtvdXRwdXRIZWxwZXIudHlwZS5zdG9yYWdlfT47XG4gIHN0cnVjdCBVbmlmb3JtcyB7SDogdTMyLCBDIDogdTMyfTtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgbGV0IGN1cnJlbnRfaW1hZ2VfbnVtYmVyID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5DICogdW5pZm9ybXMuSCk7XG4gICAgbGV0IGN1cnJlbnRfY2hhbm5lbF9udW1iZXIgPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuQztcblxuICAgIGxldCBzY2FsZV9vZmZzZXQgPSBjdXJyZW50X2ltYWdlX251bWJlciAqIHVuaWZvcm1zLkMgKyBjdXJyZW50X2NoYW5uZWxfbnVtYmVyO1xuICAgIGxldCBzY2FsZSA9IHNjYWxlX2lucHV0W3NjYWxlX29mZnNldF07XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZm1hKGlucHV0W2dsb2JhbF9pZHhdLCAke3NjYWxlRGF0YSgwKX0sICR7c2NhbGVEYXRhKDEpfSk7XG4gIH1gO1xuICB9O1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAge1xuICAgICAgbmFtZTogJ0luc3RhbmNlTm9ybWFsaXphdGlvbk5IV0MnLFxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgICAgfSksXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgfSxcbiAgICB7IGlucHV0czogW2lucHV0c1swXSwgY2hhbm5lbFNjYWxlU2hpZnRdIH0sXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgaW5zdGFuY2VOb3JtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBJbnN0YW5jZU5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmIChhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnKSB7XG4gICAgY3JlYXRlSW5zdGFuY2VOb3JtTkhXQ1Byb2dyYW1JbmZvKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICBjcmVhdGVJbnN0YW5jZU5vcm1Qcm9ncmFtSW5mbyhjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNhc3RUb0YzMixcbiAgZmlsbFZlY3RvcixcbiAgZ2V0TWF4Q29tcG9uZW50cyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgc3VtVmVjdG9yLFxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmludGVyZmFjZSBMYXllck5vcm1BdHRyaWJ1dGVzIHtcbiAgc2ltcGxpZmllZDogYm9vbGVhbjtcbiAgYXhpczogbnVtYmVyO1xuICBlcHNpbG9uOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMiBpbnB1dHMuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUxheWVyTm9ybVByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogTGF5ZXJOb3JtQXR0cmlidXRlcyxcbiAgb3V0cHV0Q291bnQ6IG51bWJlcixcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgc2ltcGxpZmllZCA9IGF0dHJpYnV0ZXMuc2ltcGxpZmllZDtcblxuICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgc2NhbGUgPSBpbnB1dHNbMV07XG4gIGNvbnN0IGJpYXMgPSAhc2ltcGxpZmllZCAmJiBpbnB1dHNbMl07XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIHhTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBub3JtQ291bnQgPSBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKHhTaGFwZSwgYXhpcyk7XG4gIGNvbnN0IG5vcm1TaXplID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKHhTaGFwZSwgYXhpcyk7XG5cbiAgY29uc3Qgc2NhbGVTaXplID0gU2hhcGVVdGlsLnNpemUoc2NhbGUuZGltcyk7XG4gIGNvbnN0IGJpYXNTaXplID0gYmlhcyA/IFNoYXBlVXRpbC5zaXplKGJpYXMuZGltcykgOiAwO1xuICBpZiAoc2NhbGVTaXplICE9PSBub3JtU2l6ZSB8fCAoYmlhcyAmJiBiaWFzU2l6ZSAhPT0gbm9ybVNpemUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTaXplIG9mIFguc2hhcGUoKVtheGlzOl0gPT0gJHtub3JtU2l6ZX0uXG4gICAgICAgU2l6ZSBvZiBzY2FsZSBhbmQgYmlhcyAoaWYgcHJvdmlkZWQpIG11c3QgbWF0Y2ggdGhpcy5cbiAgICAgICBHb3Qgc2NhbGUgc2l6ZSBvZiAke3NjYWxlU2l6ZX0gYW5kIGJpYXMgc2l6ZSBvZiAke2JpYXNTaXplfWApO1xuICB9XG5cbiAgY29uc3QgbWVhbkludlN0ZERldkRpbTogbnVtYmVyW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4U2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaSA8IGF4aXMpIHtcbiAgICAgIG1lYW5JbnZTdGREZXZEaW0ucHVzaCh4U2hhcGVbaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZWFuSW52U3RkRGV2RGltLnB1c2goMSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKG5vcm1TaXplKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG5vcm1Db3VudCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IG5vcm1TaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguZmxvb3Iobm9ybVNpemUgLyBjb21wb25lbnRzKSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuZXBzaWxvbiB9LFxuICBdO1xuICBpZiAoYmlhcykge1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcbiAgfVxuICBjb25zdCBoYXNNZWFuRGF0YU91dHB1dCA9IG91dHB1dENvdW50ID4gMTtcbiAgY29uc3QgaGFzSW52U3RkT3V0cHV0ID0gb3V0cHV0Q291bnQgPiAyO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG4gICAgY29uc3QgdmFyaWFibGVzID0gW1xuICAgICAgaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpLFxuICAgICAgaW5wdXRWYXJpYWJsZSgnc2NhbGUnLCBzY2FsZS5kYXRhVHlwZSwgc2NhbGUuZGltcywgY29tcG9uZW50cyksXG4gICAgXTtcbiAgICBpZiAoYmlhcykge1xuICAgICAgdmFyaWFibGVzLnB1c2goaW5wdXRWYXJpYWJsZSgnYmlhcycsIGJpYXMuZGF0YVR5cGUsIGJpYXMuZGltcywgY29tcG9uZW50cykpO1xuICAgIH1cbiAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cykpO1xuICAgIGlmIChoYXNNZWFuRGF0YU91dHB1dCkge1xuICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ21lYW5fZGF0YV9vdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgbWVhbkludlN0ZERldkRpbSkpO1xuICAgIH1cbiAgICBpZiAoaGFzSW52U3RkT3V0cHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnaW52X3N0ZF9vdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgbWVhbkludlN0ZERldkRpbSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ25vcm1fY291bnQnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnbm9ybV9zaXplJywgdHlwZTogJ2YzMicgfSxcbiAgICAgIHsgbmFtZTogJ25vcm1fc2l6ZV92ZWN0b3JpemVkJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2Vwc2lsb24nLCB0eXBlOiAnZjMyJyB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5ub3JtX2NvdW50Jyl9XG4gICAgbGV0IG9mZnNldCA9IGdsb2JhbF9pZHggKiB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDtcbiAgICB2YXIgbWVhbl92ZWN0b3IgPSAke2ZpbGxWZWN0b3IoJ2YzMicsIGNvbXBvbmVudHMpfTtcbiAgICB2YXIgbWVhbl9zcXVhcmVfdmVjdG9yID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzKX07XG5cbiAgICBmb3IgKHZhciBoOiB1MzIgPSAwdTsgaCA8IHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkOyBoKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAneFtoICsgb2Zmc2V0XScpfTtcbiAgICAgIG1lYW5fdmVjdG9yICs9IHZhbHVlO1xuICAgICAgbWVhbl9zcXVhcmVfdmVjdG9yICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIGxldCBtZWFuID0gJHtzdW1WZWN0b3IoJ21lYW5fdmVjdG9yJywgY29tcG9uZW50cyl9IC8gdW5pZm9ybXMubm9ybV9zaXplO1xuICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7c3VtVmVjdG9yKCdtZWFuX3NxdWFyZV92ZWN0b3InLCBjb21wb25lbnRzKX0gLyB1bmlmb3Jtcy5ub3JtX3NpemUgJHtcbiAgICAgIHNpbXBsaWZpZWQgPyAnJyA6ICctIG1lYW4gKiBtZWFuJ1xuICAgIH0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcblxuICAgIGZvciAodmFyIGo6IHUzMiA9IDA7IGogPCB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDsgaisrKSB7XG4gICAgICBsZXQgZjMyaW5wdXQgPSAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ3hbaiArIG9mZnNldF0nKX07XG4gICAgICBsZXQgZjMyc2NhbGUgPSAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ3NjYWxlW2pdJyl9O1xuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHt2YXJpYWJsZXNbMF0udHlwZS52YWx1ZX0oKGYzMmlucHV0ICR7c2ltcGxpZmllZCA/ICcnIDogJy0gbWVhbid9KSAqIGludl9zdGRfZGV2ICogZjMyc2NhbGVcbiAgICAgICAgJHtiaWFzID8gYCsgJHtjYXN0VG9GMzIoZGF0YVR5cGUsIGNvbXBvbmVudHMsICdiaWFzW2pdJyl9YCA6ICcnfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAke2hhc01lYW5EYXRhT3V0cHV0ID8gJ21lYW5fZGF0YV9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuJyA6ICcnfTtcbiAgICAke2hhc0ludlN0ZE91dHB1dCA/ICdpbnZfc3RkX291dHB1dFtnbG9iYWxfaWR4XSA9IGludl9zdGRfZGV2JyA6ICcnfTtcbiAgfWA7XG4gIH07XG4gIGNvbnN0IG91dHB1dHMgPSBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XTtcbiAgaWYgKGhhc01lYW5EYXRhT3V0cHV0KSB7XG4gICAgb3V0cHV0cy5wdXNoKHsgZGltczogbWVhbkludlN0ZERldkRpbSwgZGF0YVR5cGU6IERhdGFUeXBlLmZsb2F0IH0pO1xuICB9XG4gIGlmIChoYXNJbnZTdGRPdXRwdXQpIHtcbiAgICBvdXRwdXRzLnB1c2goeyBkaW1zOiBtZWFuSW52U3RkRGV2RGltLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXQgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdMYXllck5vcm1hbGl6YXRpb24nLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2NvbXBvbmVudHN9OyR7b3V0cHV0Q291bnR9OyR7c2ltcGxpZmllZH1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwobm9ybUNvdW50IC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGxheWVyTm9ybSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogTGF5ZXJOb3JtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVMYXllck5vcm1Qcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcywgY29udGV4dC5vdXRwdXRDb3VudCkpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IEJyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZU5haXZlTWF0bXVsUHJvZ3JhbUluZm8gfSBmcm9tICcuL21hdG11bC1zaGFkZXJzJztcbmltcG9ydCB7IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvIH0gZnJvbSAnLi8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXRNdWwgcmVxdWlyZXMgMiBpbnB1dHMuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLmRpbXNbaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMV0gIT09IGlucHV0c1sxXS5kaW1zW2lucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDJdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLicpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgbWF0TXVsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShjb250ZXh0LmlucHV0c1swXS5kaW1zLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zLCB0cnVlKTtcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBtYXRtdWwgb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7XG4gIH1cbiAgY29uc3QgTiA9IG91dHB1dFNoYXBlW291dHB1dFNoYXBlLmxlbmd0aCAtIDFdO1xuICBjb25zdCBLID0gY29udGV4dC5pbnB1dHNbMF0uZGltc1tjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDFdO1xuICBpZiAoTiA8IDggJiYgSyA8IDgpIHtcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTmFpdmVNYXRtdWxQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgeyBhY3RpdmF0aW9uOiAnJyB9LCBvdXRwdXRTaGFwZSkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IE0gPSBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAyXTtcbiAgICBjb25zdCBiYXRjaEEgPSBTaGFwZVV0aWwuc2l6ZShjb250ZXh0LmlucHV0c1swXS5kaW1zLnNsaWNlKDAsIC0yKSk7XG4gICAgY29uc3QgYmF0Y2hCID0gU2hhcGVVdGlsLnNpemUoY29udGV4dC5pbnB1dHNbMV0uZGltcy5zbGljZSgwLCAtMikpO1xuICAgIGlmIChiYXRjaEEgIT09IDEgJiYgTSA9PT0gMSAmJiBiYXRjaEIgPT09IDEpIHtcbiAgICAgIC8vIE9wdGltaXphdGlvbiBmb3IgYmF0Y2hlZCB2ZWMtbWF0LW11bFxuICAgICAgY29uc3QgcmVzaGFwZWRBID0gY29udGV4dC5pbnB1dHNbMF0ucmVzaGFwZShbMSwgYmF0Y2hBLCBLXSk7XG4gICAgICBjb25zdCByZXNoYXBlZEIgPSBjb250ZXh0LmlucHV0c1sxXS5yZXNoYXBlKFsxLCBLLCBOXSk7XG4gICAgICBjb25zdCBtYXRtdWxPdXRwdXRTaGFwZSA9IFsxLCBiYXRjaEEsIE5dO1xuICAgICAgY29uc3QgbWF0bXVsSW5wdXRzID0gW3Jlc2hhcGVkQSwgcmVzaGFwZWRCXTtcbiAgICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVNYXRtdWxQcm9ncmFtSW5mbyhtYXRtdWxJbnB1dHMsIHsgYWN0aXZhdGlvbjogJycgfSwgb3V0cHV0U2hhcGUsIG1hdG11bE91dHB1dFNoYXBlKSwge1xuICAgICAgICBpbnB1dHM6IG1hdG11bElucHV0cyxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHsgYWN0aXZhdGlvbjogJycgfSwgb3V0cHV0U2hhcGUpKTtcbiAgICB9XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGdldE1heENvbXBvbmVudHMsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG4vLyAgVE9ETyBzdXBwb3J0IHF1YW50aXphdGlvbiBiaXRzIG5vdCBlcXVhbCB0byA0XG5leHBvcnQgaW50ZXJmYWNlIE1hdE11bE5CaXRzQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIGs6IG51bWJlcjtcbiAgbjogbnVtYmVyO1xuICBhY2N1cmFjeUxldmVsOiBudW1iZXI7XG4gIGJpdHM6IG51bWJlcjtcbiAgYmxvY2tTaXplOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0cy5sZW5ndGggPCAzIHx8IGlucHV0cy5sZW5ndGggPiA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXRNdWxOQml0cyByZXF1aXJlcyAzIG9yIDQgaW5wdXRzJyk7XG4gIH1cbiAgY29uc3QgYSA9IGlucHV0c1swXTtcbiAgY29uc3QgYVJhbmsgPSBhLmRpbXMubGVuZ3RoO1xuICBpZiAoYS5kaW1zW2FSYW5rIC0gMV0gIT09IGF0dHJpYnV0ZXMuaykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGxhc3QgZGltIG9mIGlucHV0IHNoYXBlIGRvZXMgbm90IG1hdGNoIHRoZSBrIHZhbHVlJyk7XG4gIH1cbiAgY29uc3QgbkJsb2Nrc1BlckNvbCA9IE1hdGguZmxvb3IoKGF0dHJpYnV0ZXMuayArIGF0dHJpYnV0ZXMuYmxvY2tTaXplIC0gMSkgLyBhdHRyaWJ1dGVzLmJsb2NrU2l6ZSk7XG4gIGNvbnN0IGJsb2JTaXplID0gKGF0dHJpYnV0ZXMuYmxvY2tTaXplIC8gOCkgKiBhdHRyaWJ1dGVzLmJpdHM7XG4gIGNvbnN0IGIgPSBpbnB1dHNbMV07XG4gIGlmICghU2hhcGVVdGlsLmFyZUVxdWFsKGIuZGltcywgW2F0dHJpYnV0ZXMubiwgbkJsb2Nrc1BlckNvbCwgYmxvYlNpemVdKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlY29uZCBpbnB1dHMgbXVzdCBiZSAzRCB0ZW5zb3Igd2l0aCBzaGFwZSBOIFggbkJsb2Nrc1BlckNvbCBYIGJsb2JTaXplJyk7XG4gIH1cbiAgY29uc3Qgc2NhbGVzID0gaW5wdXRzWzJdO1xuICBjb25zdCBzY2FsZXNTaGFwZSA9IHNjYWxlcy5kaW1zO1xuICBpZiAoU2hhcGVVdGlsLnNpemUoc2NhbGVzU2hhcGUpICE9PSBhdHRyaWJ1dGVzLm4gKiBuQmxvY2tzUGVyQ29sKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzY2FsZXMgaW5wdXQgc2l6ZSBlcnJvci4nKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gNCkge1xuICAgIGNvbnN0IHplcm9Qb2ludHMgPSBpbnB1dHNbM107XG4gICAgY29uc3QgemVyb1BvaW50c1NoYXBlID0gemVyb1BvaW50cy5kaW1zO1xuXG4gICAgLy8gVGhpcyBhc3N1bWVzIHplcm8gcG9pbnRzIGFyZSBwYWNrZWQuXG4gICAgLy8gVW5wYWNrIGZvcm1hdCAoemVybyBwb2ludCBoYXMgc2FtZSBkYXRhIHR5cGUgYW5kIHNoYXBlIGFzIHNjYWxlKSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHdlYmdwdS5cbiAgICBjb25zdCBleHBlY3RlZFplcm9Qb2ludHNTaXplID1cbiAgICAgIGF0dHJpYnV0ZXMubiAqIChhdHRyaWJ1dGVzLmJpdHMgPT09IDggPyBuQmxvY2tzUGVyQ29sIDogTWF0aC5mbG9vcigobkJsb2Nrc1BlckNvbCAqIGF0dHJpYnV0ZXMuYml0cyArIDcpIC8gOCkpO1xuICAgIGlmIChTaGFwZVV0aWwuc2l6ZSh6ZXJvUG9pbnRzU2hhcGUpICE9PSBleHBlY3RlZFplcm9Qb2ludHNTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3plcm9Qb2ludHMgaW5wdXQgc2l6ZSBlcnJvci4nKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVNYXRNdWxOQml0c1Byb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogTWF0TXVsTkJpdHNBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGFSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGRpbUFPdXRlciA9IGlucHV0U2hhcGVbYVJhbmsgLSAyXTtcbiAgY29uc3QgZGltSW5uZXIgPSBhdHRyaWJ1dGVzLms7XG4gIGNvbnN0IGRpbUJPdXRlciA9IGF0dHJpYnV0ZXMubjtcbiAgY29uc3QgYmF0Y2hEaW1zID0gaW5wdXRTaGFwZS5zbGljZSgwLCBhUmFuayAtIDIpO1xuICBjb25zdCBiYXRjaFNpemUgPSBTaGFwZVV0aWwuc2l6ZShiYXRjaERpbXMpO1xuICBjb25zdCBibG9iU2l6ZSA9IGlucHV0c1sxXS5kaW1zWzJdO1xuICBjb25zdCBibG9iU2l6ZUluV29yZHMgPSBibG9iU2l6ZSAvIDQ7XG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBhQ29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoYXR0cmlidXRlcy5rKTtcbiAgY29uc3QgYkNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGJsb2JTaXplSW5Xb3Jkcyk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGRpbUJPdXRlcik7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYmF0Y2hEaW1zLmNvbmNhdChbZGltQU91dGVyLCBkaW1CT3V0ZXJdKTtcbiAgY29uc3Qgb3V0cHV0TnVtYmVyID0gZGltQU91dGVyID4gMSAmJiAoZGltQk91dGVyIC8gY29tcG9uZW50cykgJSAyID09PSAwID8gMiA6IDE7XG4gIGNvbnN0IGRpc3BhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMgLyBvdXRwdXROdW1iZXI7XG5cbiAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9IDY0O1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtdO1xuICBjb25zdCBpbnB1dFNoYXBlVGVtcCA9IFtiYXRjaFNpemUsIGRpbUFPdXRlciwgZGltSW5uZXIgLyBhQ29tcG9uZW50c107XG4gIGNvbnN0IGJTaGFwZSA9IFNoYXBlVXRpbC5jb252ZXJ0U2hhcGUoaW5wdXRzWzFdLmRpbXMpLnNsaWNlKCk7XG4gIGJTaGFwZS5zcGxpY2UoLTEsIDEsIGJsb2JTaXplSW5Xb3JkcyAvIGJDb21wb25lbnRzKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZVRlbXApKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoYlNoYXBlKSk7XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSA0KSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoU2hhcGVVdGlsLmNvbnZlcnRTaGFwZShpbnB1dHNbM10uZGltcykpKTtcbiAgfVxuICBjb25zdCBvdXRwdXRTaGFwZVRlbXAgPSBbYmF0Y2hTaXplLCBkaW1BT3V0ZXIsIGRpbUJPdXRlciAvIGNvbXBvbmVudHNdO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZVRlbXApKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlVGVtcC5sZW5ndGg7XG4gICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0UmFuaywgYUNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiJywgRGF0YVR5cGUudWludDMyLCBiU2hhcGUubGVuZ3RoLCBiQ29tcG9uZW50cyk7XG4gICAgY29uc3Qgc2NhbGVzID0gaW5wdXRWYXJpYWJsZSgnc2NhbGVzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2EsIGIsIHNjYWxlc107XG4gICAgY29uc3QgemVyb1BvaW50cyA9XG4gICAgICBpbnB1dHMubGVuZ3RoID09PSA0ID8gaW5wdXRWYXJpYWJsZSgnemVyb19wb2ludHMnLCBEYXRhVHlwZS51aW50MzIsIGlucHV0c1szXS5kaW1zLmxlbmd0aCkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHplcm9Qb2ludHMpIHtcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goemVyb1BvaW50cyk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dFJhbmsgPSBvdXRwdXRTaGFwZVRlbXAubGVuZ3RoO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFJhbmssIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG5cbiAgICBjb25zdCBxRHFEYXRhVHlwZSA9ICgoKSA9PiB7XG4gICAgICBzd2l0Y2ggKGFDb21wb25lbnRzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gYGFycmF5PCR7ZGF0YVR5cGV9LCA4PmA7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gYG1hdDR4Mjwke2RhdGFUeXBlfT5gO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIGBtYXQyeDQ8JHtkYXRhVHlwZX0+YDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7YUNvbXBvbmVudHN9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgfVxuICAgIH0pKCk7XG5cbiAgICBjb25zdCBwcm9jZXNzT25lV29yZCA9ICgpOiBzdHJpbmcgPT4ge1xuICAgICAgbGV0IGNhbGNTdHIgPSBgXG4gICAgICAgICAgLy8gcmV1c2UgYSBkYXRhXG4gICAgICAgICAgICB2YXIgaW5wdXRfb2Zmc2V0ID0gJHthLmluZGljZXNUb09mZnNldChgJHthLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgd29yZF9vZmZzZXQpYCl9O1xuICAgICAgICAgICAgdmFyIGFfZGF0YTogJHtxRHFEYXRhVHlwZX07XG4gICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgJHs4IC8gYUNvbXBvbmVudHN9OyBqKyspIHtcbiAgICAgICAgICAgICAgYV9kYXRhW2pdID0gJHthLmdldEJ5T2Zmc2V0KCdpbnB1dF9vZmZzZXQnKX07XG4gICAgICAgICAgICAgIGlucHV0X29mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGA7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvbXBvbmVudHMgKiBvdXRwdXROdW1iZXI7IGMrKykge1xuICAgICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICAgIGJfdmFsdWUgPSAke2JDb21wb25lbnRzID09PSAxID8gYGIke2N9X2RhdGFgIDogYGIke2N9X2RhdGFbaV1gfTtcbiAgICAgICAgICAgIGJfdmFsdWVfbG93ZXIgPSB1bnBhY2s0eFU4KGJfdmFsdWUgJiBiX21hc2spO1xuICAgICAgICAgICAgYl92YWx1ZV91cHBlciA9IHVucGFjazR4VTgoKGJfdmFsdWUgPj4gNCkgJiBiX21hc2spO1xuICAgICAgICAgICAgYl9xdWFudGl6ZWRfdmFsdWVzID0gJHtxRHFEYXRhVHlwZX0oJHtBcnJheS5mcm9tKFxuICAgICAgICAgICAgICB7IGxlbmd0aDogNCB9LFxuICAgICAgICAgICAgICAoXywgaSkgPT4gYCR7ZGF0YVR5cGV9KGJfdmFsdWVfbG93ZXJbJHtpfV0pLCAke2RhdGFUeXBlfShiX3ZhbHVlX3VwcGVyWyR7aX1dKWAsXG4gICAgICAgICAgICApLmpvaW4oJywgJyl9KTtcbiAgICAgICAgICAgIGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gJHsoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoYUNvbXBvbmVudHMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7cURxRGF0YVR5cGV9KCR7QXJyYXkuZnJvbShcbiAgICAgICAgICAgICAgICAgIHsgbGVuZ3RoOiA4IH0sXG4gICAgICAgICAgICAgICAgICAoXywgaSkgPT4gYChiX3F1YW50aXplZF92YWx1ZXNbJHtpfV0gLSAke3plcm9Qb2ludHMgPyBgemVyb19wb2ludCR7Y31gIDogJ3plcm9fcG9pbnQnfSkgKiBzY2FsZSR7Y31gLFxuICAgICAgICAgICAgICAgICkuam9pbignLCAnKX0pO2A7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gJHtxRHFEYXRhVHlwZX0oJHtBcnJheSg4KVxuICAgICAgICAgICAgICAgICAgLmZpbGwoYCR7emVyb1BvaW50cyA/IGB6ZXJvX3BvaW50JHtjfWAgOiAnemVyb19wb2ludCd9YClcbiAgICAgICAgICAgICAgICAgIC5qb2luKCcsJyl9KSkgKiBzY2FsZSR7Y307YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKX07XG4gICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkLnggKiAke291dHB1dE51bWJlcn0gKyAke01hdGguZmxvb3IoYyAvIGNvbXBvbmVudHMpfV0ke2NvbXBvbmVudHMgPiAxID8gYFske2MgJSBjb21wb25lbnRzfV1gIDogJyd9ICs9ICR7QXJyYXkuZnJvbShcbiAgICAgICAgICAgICAgeyBsZW5ndGg6IDggLyBhQ29tcG9uZW50cyB9LFxuICAgICAgICAgICAgICAoXywgaSkgPT5cbiAgICAgICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgICAgIGFDb21wb25lbnRzID09PSAxXG4gICAgICAgICAgICAgICAgICAgID8gYGFfZGF0YVske2l9XSAqIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7aX1dYFxuICAgICAgICAgICAgICAgICAgICA6IGBkb3QoYV9kYXRhWyR7aX1dLCBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske2l9XSlgXG4gICAgICAgICAgICAgICAgfWAsXG4gICAgICAgICAgICApLmpvaW4oJyArICcpfTtcbiAgICAgICAgICBgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGNTdHI7XG4gICAgfTtcbiAgICBjb25zdCBwcmVwYXJlU2NhbGVBbmRaZXJvUG9pbnQgPSAoKTogc3RyaW5nID0+IHtcbiAgICAgIGxldCBjYWxjU3RyID0gYFxuICAgICAgICAgICAgdmFyIGNvbF9pbmRleCA9IGNvbCAqICR7Y29tcG9uZW50c307XG4gICAgICAgICAgICAke1xuICAgICAgICAgICAgICB6ZXJvUG9pbnRzXG4gICAgICAgICAgICAgICAgPyBgXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlc19wZXJfY29sID0gKG5CbG9ja3NQZXJDb2wgKyAxKSAvIDI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX2NvdW50OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF93b3JkX2luZGV4OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX29mZnNldDogdTMyO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYml0c19vZmZzZXQ6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmQ6IHUzMjtgXG4gICAgICAgICAgICAgICAgOiBgXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtkYXRhVHlwZX0oJHs4LjB9KTtgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBgO1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb21wb25lbnRzICogb3V0cHV0TnVtYmVyOyBjKyspIHtcbiAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICBsZXQgc2NhbGUke2N9ID0gJHtzY2FsZXMuZ2V0QnlPZmZzZXQoYGNvbF9pbmRleCAqIG5CbG9ja3NQZXJDb2wgKyBibG9ja2ApfTtcbiAgICAgICAgICAgICR7XG4gICAgICAgICAgICAgIHplcm9Qb2ludHNcbiAgICAgICAgICAgICAgICA/IGBcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYnl0ZV9jb3VudCA9IGNvbF9pbmRleCAqIHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCArIChibG9jayA+PiAweDF1KTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfd29yZF9pbmRleCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA+PiAweDJ1O1xuICAgICAgICAgICAgemVyb19wb2ludF9ieXRlX29mZnNldCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCAmIDB4M3U7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0ID0gKHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPDwgMykgKyAoemVyb19wb2ludF9uaWJibGVfb2Zmc2V0IDw8IDIpO1xuICAgICAgICAgICAgemVyb19wb2ludF93b3JkID0gJHt6ZXJvUG9pbnRzLmdldEJ5T2Zmc2V0KCd6ZXJvX3BvaW50X3dvcmRfaW5kZXgnKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50JHtjfSA9ICR7ZGF0YVR5cGV9KCh6ZXJvX3BvaW50X3dvcmQpICYgMHhGdSk7YFxuICAgICAgICAgICAgICAgIDogJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsY1N0cjtcbiAgICB9O1xuICAgIGNvbnN0IHByZXBhcmVCRGF0YSA9ICgpOiBzdHJpbmcgPT4ge1xuICAgICAgbGV0IGNhbGNTdHIgPSBgY29sX2luZGV4ID0gY29sICogJHtjb21wb25lbnRzfTtgO1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb21wb25lbnRzICogb3V0cHV0TnVtYmVyOyBjKyspIHtcbiAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICBsZXQgYiR7Y31fZGF0YSA9ICR7Yi5nZXRCeUluZGljZXMoYCR7Yi50eXBlLmluZGljZXN9KGNvbF9pbmRleCwgYmxvY2ssIHdvcmQpYCl9O1xuICAgICAgICAgICAgY29sX2luZGV4ICs9IDE7YDtcbiAgICAgIH1cbiAgICAgIGNhbGNTdHIgKz0gYFxuICAgICAgICAgICAgdmFyIGJfdmFsdWU6IHUzMjtcbiAgICAgICAgICAgIGxldCBiX21hc2s6IHUzMiA9IDB4MEYwRjBGMEZ1O1xuICAgICAgICAgICAgdmFyIGJfdmFsdWVfbG93ZXI6IHZlYzQ8dTMyPjtcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlX3VwcGVyOiB2ZWM0PHUzMj47XG4gICAgICAgICAgICB2YXIgYl9xdWFudGl6ZWRfdmFsdWVzOiAke3FEcURhdGFUeXBlfTtcbiAgICAgICAgICAgIHZhciBiX2RlcXVhbnRpemVkX3ZhbHVlczogJHtxRHFEYXRhVHlwZX07YDtcbiAgICAgIHJldHVybiBjYWxjU3RyO1xuICAgIH07XG4gICAgcmV0dXJuIGBcbiAgICAgICAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwX3NoYXJlZDogYXJyYXk8JHtvdXRwdXQudHlwZS52YWx1ZX0sICR7b3V0cHV0TnVtYmVyICogd29ya2dyb3VwU2l6ZX0+O1xuICAgICAgICAke3NoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW3dvcmtncm91cFNpemUsIDEsIDFdKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYChnbG9iYWxfaWR4IC8gJHt3b3JrZ3JvdXBTaXplfSkgKiAke291dHB1dE51bWJlcn1gKX07XG4gICAgICAgICAgbGV0IGNvbCA9IG91dHB1dF9pbmRpY2VzWzJdO1xuICAgICAgICAgIGxldCByb3cgPSBvdXRwdXRfaW5kaWNlc1sxXTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRfaW5kaWNlc1swXTtcbiAgICAgICAgICBsZXQgbkJsb2Nrc1BlckNvbCA9IHVuaWZvcm1zLmJfc2hhcGVbMV07XG5cbiAgICAgICAgICBmb3IgKHZhciBibG9jayA9IGxvY2FsX2lkLng7IGJsb2NrIDwgbkJsb2Nrc1BlckNvbDsgYmxvY2sgKz0gJHt3b3JrZ3JvdXBTaXplfSkge1xuICAgICAgICAgICAgLy9wcm9jZXNzIG9uZSBibG9ja1xuICAgICAgICAgICAgdmFyIHdvcmRfb2Zmc2V0OiB1MzIgPSBibG9jayAqICR7YXR0cmlidXRlcy5ibG9ja1NpemUgLyBhQ29tcG9uZW50c307XG4gICAgICAgICAgICAke3ByZXBhcmVTY2FsZUFuZFplcm9Qb2ludCgpfVxuICAgICAgICAgICAgZm9yICh2YXIgd29yZDogdTMyID0gMDsgd29yZCA8ICR7YmxvYlNpemVJbldvcmRzfTsgd29yZCArPSAke2JDb21wb25lbnRzfSkge1xuICAgICAgICAgICAgICAke3ByZXBhcmVCRGF0YSgpfVxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtiQ29tcG9uZW50c307IGkrKykge1xuICAgICAgICAgICAgICAgICR7cHJvY2Vzc09uZVdvcmQoKX1cbiAgICAgICAgICAgICAgICB3b3JkX29mZnNldCArPSAkezggLyBhQ29tcG9uZW50c307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICAgaWYgKGxvY2FsX2lkLnggPCAke291dHB1dE51bWJlcn0pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfdmFsdWU6ICR7b3V0cHV0LnR5cGUudmFsdWV9ID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICB2YXIgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQ6IHUzMiA9IGxvY2FsX2lkLng7XG4gICAgICAgICAgICBmb3IgKHZhciBiOiB1MzIgPSAwdTsgYiA8ICR7d29ya2dyb3VwU2l6ZX11OyBiKyspIHtcbiAgICAgICAgICAgICAgb3V0cHV0X3ZhbHVlICs9IHdvcmtncm91cF9zaGFyZWRbd29ya2dyb3VwX3NoYXJlZF9vZmZzZXRdO1xuICAgICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkX29mZnNldCArPSAke291dHB1dE51bWJlcn07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke291dHB1dC5zZXRCeUluZGljZXMoYCR7b3V0cHV0LnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgY29sICsgbG9jYWxfaWQueClgLCAnb3V0cHV0X3ZhbHVlJyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgfWA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ01hdE11bE5CaXRzJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5ibG9ja1NpemV9OyR7YXR0cmlidXRlcy5iaXRzfTske2FDb21wb25lbnRzfTske2JDb21wb25lbnRzfTske2NvbXBvbmVudHN9OyR7b3V0cHV0TnVtYmVyfTske3dvcmtncm91cFNpemV9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBBcnJheShpbnB1dHMubGVuZ3RoKS5maWxsKCdyYW5rJyksXG4gICAgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBkaXNwYXRjaFNpemUgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG4vLyBDdXJyZW50bHksIG9ubHkgc3VwcG9ydCBibG9ja1NpemUgPSAzMi5cbmV4cG9ydCBjb25zdCBjcmVhdGVNYXRNdWxOQml0c0Jsb2NrU2l6ZTMyUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgYVJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgZGltQU91dGVyID0gaW5wdXRTaGFwZVthUmFuayAtIDJdO1xuICBjb25zdCBkaW1Jbm5lciA9IGF0dHJpYnV0ZXMuaztcbiAgY29uc3QgZGltQk91dGVyID0gYXR0cmlidXRlcy5uO1xuICBjb25zdCBiYXRjaERpbXMgPSBpbnB1dFNoYXBlLnNsaWNlKDAsIGFSYW5rIC0gMik7XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKGJhdGNoRGltcyk7XG4gIGNvbnN0IGJsb2JTaXplID0gaW5wdXRzWzFdLmRpbXNbMl07XG4gIGNvbnN0IGJsb2JTaXplSW5Xb3JkcyA9IGJsb2JTaXplIC8gNDtcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGFDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhhdHRyaWJ1dGVzLmspO1xuICBjb25zdCBiQ29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoYmxvYlNpemVJbldvcmRzKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBiYXRjaERpbXMuY29uY2F0KFtkaW1BT3V0ZXIsIGRpbUJPdXRlcl0pO1xuXG4gIGNvbnN0IHdvcmtncm91cFNpemUgPSAxMjg7XG4gIGNvbnN0IHdvcmtncm91cFkgPSBkaW1CT3V0ZXIgJSA4ID09PSAwID8gOCA6IGRpbUJPdXRlciAlIDQgPT09IDAgPyA0IDogMTtcbiAgY29uc3Qgd29ya2dyb3VwWCA9IHdvcmtncm91cFNpemUgLyB3b3JrZ3JvdXBZO1xuICBjb25zdCB0aWxlU2l6ZSA9IHdvcmtncm91cFggKiBiQ29tcG9uZW50cyAqIDg7IC8vIGVhY2ggdWludDMyIGhhcyA4IGRhdGEuXG4gIGNvbnN0IGFMZW5ndGhQZXJUaWxlID0gdGlsZVNpemUgLyBhQ29tcG9uZW50cztcbiAgY29uc3QgYmxvY2tzUGVyVGlsZSA9IHRpbGVTaXplIC8gYXR0cmlidXRlcy5ibG9ja1NpemU7XG4gIGNvbnN0IGRpc3BhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIHdvcmtncm91cFk7XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW107XG4gIGNvbnN0IGlucHV0U2hhcGVUZW1wID0gW2JhdGNoU2l6ZSwgZGltQU91dGVyLCBkaW1Jbm5lciAvIGFDb21wb25lbnRzXTtcbiAgY29uc3QgYlNoYXBlID0gU2hhcGVVdGlsLmNvbnZlcnRTaGFwZShpbnB1dHNbMV0uZGltcykuc2xpY2UoKTtcbiAgYlNoYXBlLnNwbGljZSgtMSwgMSwgYmxvYlNpemVJbldvcmRzIC8gYkNvbXBvbmVudHMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlVGVtcCkpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhiU2hhcGUpKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDQpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhTaGFwZVV0aWwuY29udmVydFNoYXBlKGlucHV0c1szXS5kaW1zKSkpO1xuICB9XG4gIGNvbnN0IG91dHB1dFNoYXBlVGVtcCA9IFtiYXRjaFNpemUsIGRpbUFPdXRlciwgZGltQk91dGVyXTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGVUZW1wKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZVRlbXAubGVuZ3RoO1xuICAgIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFJhbmssIGFDb21wb25lbnRzKTtcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIERhdGFUeXBlLnVpbnQzMiwgYlNoYXBlLmxlbmd0aCwgYkNvbXBvbmVudHMpO1xuICAgIGNvbnN0IHNjYWxlcyA9IGlucHV0VmFyaWFibGUoJ3NjYWxlcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFthLCBiLCBzY2FsZXNdO1xuICAgIGNvbnN0IHplcm9Qb2ludHMgPVxuICAgICAgaW5wdXRzLmxlbmd0aCA9PT0gNCA/IGlucHV0VmFyaWFibGUoJ3plcm9fcG9pbnRzJywgRGF0YVR5cGUudWludDMyLCBpbnB1dHNbM10uZGltcy5sZW5ndGgpIDogdW5kZWZpbmVkO1xuICAgIGlmICh6ZXJvUG9pbnRzKSB7XG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKHplcm9Qb2ludHMpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXRSYW5rID0gb3V0cHV0U2hhcGVUZW1wLmxlbmd0aDtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRSYW5rKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuICAgIGNvbnN0IHJlYWRBID0gKCkgPT4ge1xuICAgICAgc3dpdGNoIChhQ29tcG9uZW50cykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHZlYzQ8JHtkYXRhVHlwZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAxXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAyXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAzXSk7XG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSB2ZWM0PCR7ZGF0YVR5cGV9PihzdWJfYVt3b3JkX29mZnNldCArIDRdLCBzdWJfYVt3b3JkX29mZnNldCArIDVdLCBzdWJfYVt3b3JkX29mZnNldCArIDZdLCBzdWJfYVt3b3JkX29mZnNldCArIDddKTtgO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHZlYzQ8JHtkYXRhVHlwZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAxXSk7XG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSB2ZWM0PCR7ZGF0YVR5cGV9PihzdWJfYVt3b3JkX29mZnNldCArIDJdLCBzdWJfYVt3b3JkX29mZnNldCArIDNdKTtgO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHN1Yl9hW3dvcmRfb2Zmc2V0XTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV07YDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7YUNvbXBvbmVudHN9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gYFxuICAgICAgICB2YXI8d29ya2dyb3VwPiBzdWJfYTogYXJyYXk8JHthLnR5cGUudmFsdWV9LCAke2FMZW5ndGhQZXJUaWxlfT47XG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IGludGVyX3Jlc3VsdHM6IGFycmF5PGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke3dvcmtncm91cFh9PiwgJHt3b3JrZ3JvdXBZfT47XG4gICAgICAgICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbd29ya2dyb3VwWCwgd29ya2dyb3VwWSwgMV0pfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcyhgd29ya2dyb3VwX2luZGV4ICogJHt3b3JrZ3JvdXBZfWApfTtcbiAgICAgICAgICBsZXQgY29sID0gb3V0cHV0X2luZGljZXNbMl07XG4gICAgICAgICAgbGV0IHJvdyA9IG91dHB1dF9pbmRpY2VzWzFdO1xuICAgICAgICAgIGxldCBiYXRjaCA9IG91dHB1dF9pbmRpY2VzWzBdO1xuICAgICAgICAgIGxldCBuX2Jsb2Nrc19wZXJfY29sID0gdW5pZm9ybXMuYl9zaGFwZVsxXTtcbiAgICAgICAgICBsZXQgbnVtX3RpbGVzID0gIChuX2Jsb2Nrc19wZXJfY29sIC0gMSkgLyAke2Jsb2Nrc1BlclRpbGV9ICsgMTtcblxuICAgICAgICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICAgICAgICAgIGZvciAodmFyIHRpbGU6IHUzMiA9IDA7IHRpbGUgPCBudW1fdGlsZXM7IHRpbGUgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGFfY29sX3N0YXJ0ID0gdGlsZSAqICR7YUxlbmd0aFBlclRpbGV9O1xuICAgICAgICAgICAgLy8gbG9hZCBvbmUgdGlsZSBBIGRhdGEgaW50byBzaGFyZWQgbWVtb3J5LlxuICAgICAgICAgICAgZm9yICh2YXIgYV9vZmZzZXQgPSBsb2NhbF9pZHg7IGFfb2Zmc2V0IDwgJHthTGVuZ3RoUGVyVGlsZX07IGFfb2Zmc2V0ICs9ICR7d29ya2dyb3VwU2l6ZX0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxldCBhX2NvbCA9IGFfY29sX3N0YXJ0ICsgYV9vZmZzZXQ7XG4gICAgICAgICAgICAgIGlmIChhX2NvbCA8IHVuaWZvcm1zLmFfc2hhcGVbMl0pXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJfYVthX29mZnNldF0gPSAke2EuZ2V0QnlJbmRpY2VzKGAke2EudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCBhX2NvbClgKX07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ViX2FbYV9vZmZzZXRdID0gJHthLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgICAgIC8vIGVhY2ggdGhyZWFkIHByb2Nlc3Mgb25lIGJsb2NrXG4gICAgICAgICAgICBsZXQgYl9yb3cgPSBjb2wgKyBsb2NhbF9pZC55O1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gdGlsZSAqICR7YmxvY2tzUGVyVGlsZX0gKyBsb2NhbF9pZC54O1xuICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgemVyb1BvaW50c1xuICAgICAgICAgICAgICAgID8gYFxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCA9IChuX2Jsb2Nrc19wZXJfY29sICsgMSkgLyAyO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA9IGJfcm93ICogemVyb19wb2ludF9ieXRlc19wZXJfY29sICsgKGJsb2NrID4+IDB4MXUpO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfd29yZF9pbmRleCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA+PiAweDJ1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYml0c19vZmZzZXQgPSAoemVyb19wb2ludF9ieXRlX29mZnNldCA8PCAzKSArICh6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQgPDwgMik7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF93b3JkID0gJHt6ZXJvUG9pbnRzLmdldEJ5T2Zmc2V0KCd6ZXJvX3BvaW50X3dvcmRfaW5kZXgnKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtkYXRhVHlwZX0oKHplcm9fcG9pbnRfd29yZCkgJiAweEZ1KTtgXG4gICAgICAgICAgICAgICAgOiBgXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtkYXRhVHlwZX0oJHs4LjB9KTtgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2NhbGUgPSAke3NjYWxlcy5nZXRCeU9mZnNldChgYl9yb3cgKiBuX2Jsb2Nrc19wZXJfY29sICsgYmxvY2tgKX07XG4gICAgICAgICAgICBsZXQgYl9kYXRhID0gJHtiLmdldEJ5SW5kaWNlcyhgJHtiLnR5cGUuaW5kaWNlc30oYl9yb3csIGJsb2NrLCAwKWApfTtcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldCA9IGxvY2FsX2lkLnggKiAke2F0dHJpYnV0ZXMuYmxvY2tTaXplIC8gYUNvbXBvbmVudHN9O1xuICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7YkNvbXBvbmVudHN9OyBpKyspIHtcbiAgICAgICAgICAgICAgJHtyZWFkQSgpfVxuICAgICAgICAgICAgICBsZXQgYl92YWx1ZSA9ICR7YkNvbXBvbmVudHMgPT09IDEgPyBgYl9kYXRhYCA6IGBiX2RhdGFbaV1gfTtcbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWVfbG93ZXIgPSB1bnBhY2s0eFU4KGJfdmFsdWUgJiAweDBGMEYwRjBGdSk7XG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlX3VwcGVyID0gdW5wYWNrNHhVOCgoYl92YWx1ZSA+PiA0KSAmIDB4MEYwRjBGMEZ1KTtcbiAgICAgICAgICAgICAgbGV0IGJfcXVhbnRpemVkX3ZhbHVlcyA9IG1hdDJ4NDwke2RhdGFUeXBlfT4oJHtBcnJheS5mcm9tKFxuICAgICAgICAgICAgICAgIHsgbGVuZ3RoOiA0IH0sXG4gICAgICAgICAgICAgICAgKF8sIGkpID0+IGAke2RhdGFUeXBlfShiX3ZhbHVlX2xvd2VyWyR7aX1dKSwgJHtkYXRhVHlwZX0oYl92YWx1ZV91cHBlclske2l9XSlgLFxuICAgICAgICAgICAgICApLmpvaW4oJywgJyl9KTtcbiAgICAgICAgICAgICAgbGV0IGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gKGJfcXVhbnRpemVkX3ZhbHVlcyAtIG1hdDJ4NDwke2RhdGFUeXBlfT4oJHtBcnJheSg4KS5maWxsKCd6ZXJvX3BvaW50Jykuam9pbignLCcpfSkpICogc2NhbGU7XG4gICAgICAgICAgICAgIGludGVyX3Jlc3VsdHNbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gKz0gJHtBcnJheS5mcm9tKFxuICAgICAgICAgICAgICAgIHsgbGVuZ3RoOiAyIH0sXG4gICAgICAgICAgICAgICAgKF8sIGkpID0+IGAke2Bkb3QoYV9kYXRhJHtpfSwgYl9kZXF1YW50aXplZF92YWx1ZXNbJHtpfV0pYH1gLFxuICAgICAgICAgICAgICApLmpvaW4oJyArICcpfTtcbiAgICAgICAgICAgICAgd29yZF9vZmZzZXQgKz0gJHs4IC8gYUNvbXBvbmVudHN9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsb2NhbF9pZHggPCAke3dvcmtncm91cFl9KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0X3ZhbHVlOiAke291dHB1dC50eXBlLnZhbHVlfSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDB1OyBiIDwgJHt3b3JrZ3JvdXBYfTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkeF1bYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sICsgbG9jYWxfaWR4IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAke291dHB1dC5zZXRCeUluZGljZXMoYCR7b3V0cHV0LnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgY29sICsgbG9jYWxfaWR4KWAsICdvdXRwdXRfdmFsdWUnKX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1gO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdCbG9ja3dpc2VNYXRNdWxOQml0czMyJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5ibG9ja1NpemV9OyR7YUNvbXBvbmVudHN9OyR7YkNvbXBvbmVudHN9OyR7d29ya2dyb3VwWH07JHt3b3JrZ3JvdXBZfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogQXJyYXkoaW5wdXRzLmxlbmd0aCkuZmlsbCgncmFuaycpLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogZGlzcGF0Y2hTaXplIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IG1hdE11bE5CaXRzID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBpZiAoXG4gICAgYXR0cmlidXRlcy5ibG9ja1NpemUgPT09IDMyICYmXG4gICAgY29udGV4dC5hZGFwdGVySW5mby5pc1ZlbmRvcignaW50ZWwnKSAmJlxuICAgIGNvbnRleHQuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoJ2dlbi0xMmxwJylcbiAgKSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1hdE11bE5CaXRzQmxvY2tTaXplMzJQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVNYXRNdWxOQml0c1Byb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZU1hdE11bE5CaXRzQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IE1hdE11bE5CaXRzQXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoYXR0cmlidXRlcyBhcyBPbWl0PE1hdE11bE5CaXRzQXR0cmlidXRlcywga2V5b2YgQXR0cmlidXRlV2l0aENhY2hlS2V5Pik7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRFbGVtZW50QXQsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmludGVyZmFjZSBQYWRBdHRyaWJ1dGVzIHtcbiAgLy8gMC1jb25zdGFudCwgMS1yZWZsZWN0LCAyLWVkZ2UsIDMtd3JhcFxuICByZWFkb25seSBtb2RlOiBudW1iZXI7XG4gIHJlYWRvbmx5IHZhbHVlOiBudW1iZXI7XG4gIHJlYWRvbmx5IHBhZHM6IG51bWJlcltdO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVG9vIGZldyBpbnB1dHMnKTtcbiAgfVxuICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdCAmJiBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0MTYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHR5cGUgbXVzdCBiZSBmbG9hdCBvciBmbG9hdDE2LicpO1xuICB9XG5cbiAgaWYgKGlucHV0cy5sZW5ndGggPj0gMikge1xuICAgIGxldCB2YWxpZFBhZHMgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggKiAyID09PSBpbnB1dHNbMV0uZGltc1swXTtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFsaWRQYWRzID0gaW5wdXRzWzNdLmRpbXNbMF0gKiAyID09PSBpbnB1dHNbMV0uZGltc1swXTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZFBhZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBhZHMgc2hvdWxkIGJlIGEgMUQgdGVuc29yIG9mIHNoYXBlIFsyICogaW5wdXRfcmFua10gb3IgWzIgKiBudW1fYXhlc10uJyk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBnZXRQYWRDb25zdGFudCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBwYWRzTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IGlucHV0UmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICAgICAgayA9IGkzMigke291dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgaSl9KSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgaSwgcGFkc0xlbmd0aCl9O1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc3RyaWRlcycsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgYDtcbiAgfVxuXG4gIHJldHVybiBgXG4gICAgICAgICAgdmFsdWUgPSAke291dHB1dC50eXBlLnZhbHVlfSh1bmlmb3Jtcy5jb25zdGFudF92YWx1ZSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgJHtibG9ja31cbiAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIH1cbiAgICAgIGA7XG59O1xuXG5jb25zdCBnZXRQYWRSZWZsZWN0ID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIHBhZHNMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gaW5wdXRSYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBibG9jayArPSBgXG4gICAgICAgICAgICAgICAgayA9IGkzMigke291dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgaSl9KSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgaSwgcGFkc0xlbmd0aCl9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgayA9IC1rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBsZXQgXzJuXzEgPSAyICogKGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSAtIDEpO1xuICAgICAgICAgICAgICAgICAgayA9IGsgJSBfMm5fMTtcbiAgICAgICAgICAgICAgICAgIGlmKGsgPj0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBfMm5fMSAtIGs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3N0cmlkZXMnLCBpLCBpbnB1dFJhbmspfSk7XG4gICAgICAgICAgICBgO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtibG9ja31cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYDtcbn07XG5cbmNvbnN0IGdldFBhZEVkZ2UgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFJhbms6IG51bWJlciwgcGFkc0xlbmd0aDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgbGV0IGJsb2NrID0gJyc7XG4gIGZvciAobGV0IGkgPSBpbnB1dFJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7b3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBpKX0pIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCBpLCBwYWRzTGVuZ3RoKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pKSB7XG4gICAgICAgICAgICAgICAgICBrID0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc3RyaWRlcycsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgICAgIGA7XG4gIH1cblxuICByZXR1cm4gYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgO1xufTtcblxuY29uc3QgZ2V0UGFkV3JhcCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBwYWRzTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IGlucHV0UmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtvdXRwdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGkpfSkgLSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucGFkcycsIGksIHBhZHNMZW5ndGgpfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApICB7XG4gICAgICAgICAgICAgICAgICBrICs9IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrID49IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSkge1xuICAgICAgICAgICAgICAgICAgayAtPSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3N0cmlkZXMnLCBpLCBpbnB1dFJhbmspfSk7XG4gICAgICAgICAgICBgO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtibG9ja31cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYDtcbn07XG5cbmNvbnN0IGdldFBhZFNuaXBwZXQgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFJhbms6IG51bWJlciwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IHN0cmluZyA9PiB7XG4gIHN3aXRjaCAoYXR0cmlidXRlcy5tb2RlKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIGdldFBhZENvbnN0YW50KG91dHB1dCwgaW5wdXRSYW5rLCBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoKTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZ2V0UGFkUmVmbGVjdChvdXRwdXQsIGlucHV0UmFuaywgYXR0cmlidXRlcy5wYWRzLmxlbmd0aCk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGdldFBhZEVkZ2Uob3V0cHV0LCBpbnB1dFJhbmssIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGgpO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBnZXRQYWRXcmFwKG91dHB1dCwgaW5wdXRSYW5rLCBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vZGUnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlUGFkUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFBhZEF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gU2hhcGVVdGlsLnBhZFNoYXBlKGlucHV0c1swXS5kaW1zLnNsaWNlKCksIGF0dHJpYnV0ZXMucGFkcyk7XG4gIGNvbnN0IGlucHV0RGltcyA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLnBhZHMgfSxcbiAgXTtcblxuICBjb25zdCBpc1ZhbHVlRnJvbUlucHV0ID0gaW5wdXRzLmxlbmd0aCA+PSAzICYmIGlucHV0c1syXS5kYXRhO1xuICBpZiAoYXR0cmlidXRlcy5tb2RlID09PSAwKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goeyB0eXBlOiBpc1ZhbHVlRnJvbUlucHV0ID8gaW5wdXRzWzJdLmRhdGFUeXBlIDogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMudmFsdWUgfSk7XG4gIH1cblxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgb3V0cHV0U2hhcGUpKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXREaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICAgIGNvbnN0IHBhZFNuaXBwZXQgPSBnZXRQYWRTbmlwcGV0KG91dHB1dCwgaW5wdXREaW1zLmxlbmd0aCwgYXR0cmlidXRlcyk7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAncGFkcycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggfSxcbiAgICBdO1xuICAgIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09IDApIHtcbiAgICAgIHVuaWZvcm1zLnB1c2goeyBuYW1lOiAnY29uc3RhbnRfdmFsdWUnLCB0eXBlOiAoaXNWYWx1ZUZyb21JbnB1dCA/IGRhdGFUeXBlIDogJ2YzMicpIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG5cbiAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAke2RhdGFUeXBlfSgwKTtcbiAgICAgICAgICAgICR7cGFkU25pcHBldH1cbiAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdQYWQnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMubW9kZX0ke2lzVmFsdWVGcm9tSW5wdXR9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVQYWRBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IFBhZEF0dHJpYnV0ZXMgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBiaWdJbnQ2NFBhZHMgPSBpbnB1dHNbMV0uZ2V0QmlnSW50NjRBcnJheSgpO1xuICAgIGNvbnN0IHZhbHVlID1cbiAgICAgIGlucHV0cy5sZW5ndGggPj0gMyAmJiBpbnB1dHNbMl0uZGF0YVxuICAgICAgICA/IGlucHV0c1syXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNlxuICAgICAgICAgID8gaW5wdXRzWzJdLmdldFVpbnQxNkFycmF5KClbMF1cbiAgICAgICAgICA6IGlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXVxuICAgICAgICA6IDAuMDtcblxuICAgIGNvbnN0IGlucHV0UmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aDtcbiAgICBjb25zdCB1cGRhdGVQYWRzID0gbmV3IEludDMyQXJyYXkoMiAqIGlucHV0UmFuaykuZmlsbCgwKTtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA+PSA0KSB7XG4gICAgICBjb25zdCBheGVzID0gaW5wdXRzWzNdLmdldEJpZ0ludDY0QXJyYXkoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGVQYWRzW051bWJlcihheGVzW2ldKV0gPSBOdW1iZXIoYmlnSW50NjRQYWRzW2ldKTtcbiAgICAgICAgdXBkYXRlUGFkc1tOdW1iZXIoYXhlc1tpXSkgKyBpbnB1dFJhbmtdID0gTnVtYmVyKGJpZ0ludDY0UGFkc1tpICsgYXhlcy5sZW5ndGhdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYmlnSW50NjRQYWRzLmZvckVhY2goKHYsIGkpID0+ICh1cGRhdGVQYWRzW051bWJlcihpKV0gPSBOdW1iZXIodikpKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWRzOiBudW1iZXJbXSA9IFtdO1xuICAgIHVwZGF0ZVBhZHMuZm9yRWFjaCgodikgPT4gcGFkcy5wdXNoKHYpKTtcblxuICAgIHJldHVybiB7IG1vZGU6IGF0dHJpYnV0ZXMubW9kZSwgdmFsdWUsIHBhZHMgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHBhZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID0gY3JlYXRlUGFkQXR0cmlidXRlc0Zyb21JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlUGFkUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKSwgeyBpbnB1dHM6IFswXSB9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFBvb2xDb252VXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRFbGVtZW50QXQsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbi8vIFRPRE86IHN1cHBvcnQ6XG4vLyAtIGNlaWxfbW9kZSAgICAgICAgICAgICAgICAgXCJ0ZXN0X21heHBvb2xfMmRfY2VpbFwiXG4vLyAtIHN0b3JhZ2Vfb3JkZXIgICAgICAgICAgICAgXCJ0ZXN0X21heHBvb2xfd2l0aF9hcmdtYXhfMmRfcHJlY29tcHV0ZWRfc3RyaWRlc1wiXG4vLyAtIFtNYXhQb29sXSBkaWxhdGlvbnMgICAgICAgXCJ0ZXN0X21heHBvb2xfMmRfZGlsYXRpb25zXCJcbi8vIC0gW01heFBvb2xdIG91dHB1dFsxXSAgICAgICBcInRlc3RfbWF4cG9vbF93aXRoX2FyZ21heF8yZF9wcmVjb21wdXRlZF9wYWRzXCJcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKGVudi53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQgJiYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZSA9IDxBdHRyaWJ1dGVUeXBlIGV4dGVuZHMgQXZlcmFnZVBvb2xBdHRyaWJ1dGVzIHwgTWF4UG9vbEF0dHJpYnV0ZXM+KFxuICBpbnB1dDogVGVuc29yVmlldyxcbiAgYXR0cmlidXRlczogQXR0cmlidXRlVHlwZSxcbiAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcbik6IFtBdHRyaWJ1dGVUeXBlLCBudW1iZXJbXV0gPT4ge1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGlucHV0U2hhcGVBc0NoYW5uZWxGaXJzdCA9IGlucHV0LmRpbXMuc2xpY2UoKTtcbiAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LnNwbGljZSgxLCAwLCBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3QucG9wKCkhKTsgLy8gTW92ZSBjaGFubmVsIHRvIHRoZSBzZWNvbmQgcG9zaXRpb24uXG4gIH1cbiAgY29uc3QgaGFzRGlsYXRpb25zID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgJ2RpbGF0aW9ucycpO1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUuc2xpY2UoKTtcbiAgY29uc3Qgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcy5zbGljZSgpO1xuICBjb25zdCBkaWxhdGlvbnM6IG51bWJlcltdID0gaGFzRGlsYXRpb25zID8gKGF0dHJpYnV0ZXMgYXMgTWF4UG9vbEF0dHJpYnV0ZXMpLmRpbGF0aW9ucy5zbGljZSgpIDogW107XG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMuc2xpY2UoKTtcbiAgUG9vbENvbnZVdGlsLmFkanVzdFBvb2xBdHRyaWJ1dGVzKGlzR2xvYmFsT3BlcmF0b3IsIGlucHV0U2hhcGVBc0NoYW5uZWxGaXJzdCwga2VybmVsU2hhcGUsIHN0cmlkZXMsIGRpbGF0aW9ucywgcGFkcyk7XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGVBc0NoYW5uZWxGaXJzdCA9IFBvb2xDb252VXRpbC5jb21wdXRlUG9vbE91dHB1dFNoYXBlKFxuICAgIGlzR2xvYmFsT3BlcmF0b3IsXG4gICAgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LFxuICAgIHN0cmlkZXMsXG4gICAgZGlsYXRpb25zLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIHBhZHMsXG4gICAgYXR0cmlidXRlcy5hdXRvUGFkLFxuICApO1xuXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGhhc0RpbGF0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywgeyBrZXJuZWxTaGFwZSwgc3RyaWRlcywgcGFkcywgZGlsYXRpb25zLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleSB9KTtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIHsga2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHMsIGNhY2hlS2V5OiBhdHRyaWJ1dGVzLmNhY2hlS2V5IH0pO1xuICB9XG4gIGNvbnN0IG91dHB1dFNoYXBlQXNDaGFubmVsTGFzdCA9IG91dHB1dFNoYXBlQXNDaGFubmVsRmlyc3Quc2xpY2UoKTtcbiAgb3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0LnB1c2gob3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0LnNwbGljZSgxLCAxKVswXSk7XG4gIHJldHVybiBbbmV3QXR0cmlidXRlcywgaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZUFzQ2hhbm5lbExhc3QgOiBvdXRwdXRTaGFwZUFzQ2hhbm5lbEZpcnN0XTtcbn07XG5cbmNvbnN0IGdldFVuaWZvcm1BbmRQYWRJbmZvID0gPEF0dHJpYnV0ZVR5cGUgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgfCBNYXhQb29sQXR0cmlidXRlcz4oXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgYXR0cmlidXRlczogQXR0cmlidXRlVHlwZSxcbik6IFtQcm9ncmFtVW5pZm9ybVtdLCBVbmlmb3Jtc0FycmF5VHlwZSwgYm9vbGVhbiwgYm9vbGVhbiwgYm9vbGVhbl0gPT4ge1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IGtlcm5lbFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGtlcm5lbFNpemUgfSxcbiAgXTtcbiAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgIHsgbmFtZTogJ291dHB1dFNpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgIHsgbmFtZTogJ2tlcm5lbFNpemUnLCB0eXBlOiAndTMyJyB9LFxuICBdO1xuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPD0gMikge1xuICAgIGNvbnN0IGt3ID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZVthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHN3ID0gYXR0cmlidXRlcy5zdHJpZGVzW2F0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBwd1N0YXJ0ID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLyAyIC0gMV07XG4gICAgY29uc3QgcHdFbmQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHB3U3RhcnRFbmROb3RaZXJvID0gISEocHdTdGFydCArIHB3RW5kKTtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBrdyB9LFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN3IH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcHdTdGFydCB9LFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHB3RW5kIH0sXG4gICAgKTtcbiAgICB1bmlmb3Jtcy5wdXNoKFxuICAgICAgeyBuYW1lOiAna3cnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnc3cnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAncHdTdGFydCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdwd0VuZCcsIHR5cGU6ICd1MzInIH0sXG4gICAgKTtcblxuICAgIGxldCBwaFN0YXJ0RW5kTm90WmVybyA9IGZhbHNlO1xuICAgIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3Qga2ggPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2F0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIC0gMl07XG4gICAgICBjb25zdCBzaCA9IGF0dHJpYnV0ZXMuc3RyaWRlc1thdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoIC0gMl07XG4gICAgICBjb25zdCBwaFN0YXJ0ID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLyAyIC0gMl07XG4gICAgICBjb25zdCBwaEVuZCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC0gMl07XG4gICAgICBwaFN0YXJ0RW5kTm90WmVybyA9ICEhKHBoU3RhcnQgKyBwaEVuZCk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGtoIH0sXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzaCB9LFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGhTdGFydCB9LFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGhFbmQgfSxcbiAgICAgICk7XG5cbiAgICAgIHVuaWZvcm1zLnB1c2goXG4gICAgICAgIHsgbmFtZTogJ2toJywgdHlwZTogJ3UzMicgfSxcbiAgICAgICAgeyBuYW1lOiAnc2gnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgICB7IG5hbWU6ICdwaFN0YXJ0JywgdHlwZTogJ3UzMicgfSxcbiAgICAgICAgeyBuYW1lOiAncGhFbmQnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm9ncmFtVW5pZm9ybXMsIHVuaWZvcm1zLCB0cnVlLCBwd1N0YXJ0RW5kTm90WmVybywgcGhTdGFydEVuZE5vdFplcm9dO1xuICB9IGVsc2Uge1xuICAgIGlmIChpc0NoYW5uZWxzTGFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC4nKTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsU3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBrZXJuZWxTdHJpZGVzIH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5wYWRzIH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5zdHJpZGVzIH0sXG4gICAgKTtcbiAgICB1bmlmb3Jtcy5wdXNoKFxuICAgICAgeyBuYW1lOiAna2VybmVsU3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGtlcm5lbFN0cmlkZXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogYXR0cmlidXRlcy5wYWRzLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggfSxcbiAgICApO1xuXG4gICAgY29uc3QgaGFzUGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5yZWR1Y2UoKHN1bSwgY3VyKSA9PiBzdW0gKyBjdXIpO1xuICAgIHJldHVybiBbcHJvZ3JhbVVuaWZvcm1zLCB1bmlmb3JtcywgISFoYXNQYWRzLCBmYWxzZSwgZmFsc2VdO1xuICB9XG59O1xuXG5jb25zdCBnZW5lcmF0ZVBvb2xpbmdDb2RlID0gPEF0dHJpYnV0ZVR5cGUgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgfCBNYXhQb29sQXR0cmlidXRlcz4oXG4gIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLFxuICB4OiBJbmRpY2VzSGVscGVyLFxuICByYW5rOiBudW1iZXIsXG4gIG91dHB1dFNoYXBlUmFuazogbnVtYmVyLFxuICBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGVUeXBlLFxuICBvcDE6IHN0cmluZyxcbiAgb3AyOiBzdHJpbmcsXG4gIHN0YXJ0OiBudW1iZXIsXG4gIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSxcbiAgaGFzUGFkczogYm9vbGVhbixcbiAgcHdTdGFydEVuZE5vdFplcm86IGJvb2xlYW4sXG4gIHBoU3RhcnRFbmROb3RaZXJvOiBib29sZWFuLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBkYXRhVHlwZSA9IHgudHlwZS52YWx1ZTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIHgudHlwZS50ZW5zb3IsIG91dHB1dFNoYXBlUmFuayk7XG5cbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIDw9IDIpIHtcbiAgICBsZXQgY29kZVcgPSAnJztcbiAgICBsZXQgY29kZUggPSAnJztcbiAgICBsZXQgY29kZUhFbmQgPSAnJztcbiAgICBjb25zdCBkaW1JZHhXID0gcmFuayAtIChpc0NoYW5uZWxzTGFzdCA/IDIgOiAxKTtcbiAgICBpZiAocHdTdGFydEVuZE5vdFplcm8pIHtcbiAgICAgIGNvZGVXID0gYFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtkaW1JZHhXfV0gPSBpbmRpY2VzWyR7ZGltSWR4V31dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske2RpbUlkeFd9XSA8IDAgfHwgeEluZGljZXNbJHtkaW1JZHhXfV1cbiAgICAgICAgICAgICAgICAgICAgICA+PSB1bmlmb3Jtcy54X3NoYXBlWyR7ZGltSWR4V31dKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt4LmluZGljZXNUb09mZnNldCgneEluZGljZXMnKX1dO1xuICAgICAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICAgICAgfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVXID0gYFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtkaW1JZHhXfV0gPSBpbmRpY2VzWyR7ZGltSWR4V31dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt4LmluZGljZXNUb09mZnNldCgneEluZGljZXMnKX1dO1xuICAgICAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICAgICAgfWA7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBkaW1JZHhIID0gcmFuayAtIChpc0NoYW5uZWxzTGFzdCA/IDMgOiAyKTtcbiAgICAgIGlmIChwaFN0YXJ0RW5kTm90WmVybykge1xuICAgICAgICBjb2RlSCA9IGBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7ZGltSWR4SH1dID0gaW5kaWNlc1ske2RpbUlkeEh9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtkaW1JZHhIfV0gPCAwIHx8IHhJbmRpY2VzWyR7ZGltSWR4SH1dID49IHVuaWZvcm1zLnhfc2hhcGVbJHtkaW1JZHhIfV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkICs9IGkzMih1bmlmb3Jtcy5rdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZUggPSBgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCB1bmlmb3Jtcy5raDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2RpbUlkeEh9XSA9IGluZGljZXNbJHtkaW1JZHhIfV0gKiB1bmlmb3Jtcy5zaCAtIHVuaWZvcm1zLnBoU3RhcnQgKyBqO1xuICAgICAgICAgICAgICAgIGA7XG4gICAgICB9XG4gICAgICBjb2RlSEVuZCA9IGBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICB9XG5cbiAgICBjb25zdCBwb29saW5nQ29kZSA9IGBcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoeCwgb3V0cHV0KX1cblxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cblxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KCR7c3RhcnR9KTtcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XG4gICAgICAgICAgICAgICR7Y29kZUh9XG4gICAgICAgICAgICAgICR7Y29kZVd9XG4gICAgICAgICAgICAgICR7Y29kZUhFbmR9XG4gICAgICAgICAgICAgICR7b3AyfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWA7XG4gICAgcmV0dXJuIHBvb2xpbmdDb2RlO1xuICB9IGVsc2Uge1xuICAgIGlmIChpc0NoYW5uZWxzTGFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC4nKTtcbiAgICB9XG4gICAgY29uc3Qgc3RyaWRlc1JhbmsgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBwYWRzUmFuayA9IGF0dHJpYnV0ZXMucGFkcy5sZW5ndGg7XG4gICAgbGV0IHBhZENvZGUgPSAnJztcbiAgICBpZiAoaGFzUGFkcykge1xuICAgICAgcGFkQ29kZSA9IGBcbiAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbal0gPj0gdW5pZm9ybXMueF9zaGFwZVtqXSkge1xuICAgICAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgICAgICBpc1BhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc1BhZCkge1xuICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt4LmluZGljZXNUb09mZnNldCgneEluZGljZXMnKX1dO1xuICAgICAgICAgICAgICAgICR7b3AxfVxuICAgICAgICAgICAgICB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFkQ29kZSA9IGBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7eC5pbmRpY2VzVG9PZmZzZXQoJ3hJbmRpY2VzJyl9XTtcbiAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICBgO1xuICAgIH1cbiAgICBjb25zdCBwb29saW5nQ29kZSA9IGBcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoeCwgb3V0cHV0KX1cblxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcblxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0czogYXJyYXk8dTMyLCAke3N0cmlkZXNSYW5rfT47XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtkYXRhVHlwZX0oJHtzdGFydH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgdmFyIGlzUGFkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rZXJuZWxTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMHU7IGogPCAke3N0cmlkZXNSYW5rIC0gMX11OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldHNbal0gPSBvZmZzZXQgLyAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMua2VybmVsU3RyaWRlcycsICdqJywgc3RyaWRlc1JhbmspfTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBvZmZzZXRzW2pdICogJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmtlcm5lbFN0cmlkZXMnLCAnaicsIHN0cmlkZXNSYW5rKX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldHNbJHtzdHJpZGVzUmFuayAtIDF9XSA9IG9mZnNldDtcblxuICAgICAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9ICR7cmFuayAtIHN0cmlkZXNSYW5rfXU7IGogPCAke3Jhbmt9dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1tqXSA9IGluZGljZXNbal0gKiAke2dldEVsZW1lbnRBdChcbiAgICAgICAgICAgICAgICAgICAgJ3VuaWZvcm1zLnN0cmlkZXMnLFxuICAgICAgICAgICAgICAgICAgICBgaiAtICR7cmFuayAtIHN0cmlkZXNSYW5rfXVgLFxuICAgICAgICAgICAgICAgICAgICBzdHJpZGVzUmFuayxcbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICsgb2Zmc2V0c1tqIC0gJHtyYW5rIC0gc3RyaWRlc1Jhbmt9dV0gLSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucGFkcycsICdqIC0gMnUnLCBwYWRzUmFuayl9O1xuICAgICAgICAgICAgICAgICAgJHtwYWRDb2RlfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICR7b3AyfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWA7XG4gICAgcmV0dXJuIHBvb2xpbmdDb2RlO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdEF0dHJpYnV0ZXMge1xuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJyB8ICdOQ0hXJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb29sQ29tbW9uQXR0cmlidXRlcyBleHRlbmRzIEZvcm1hdEF0dHJpYnV0ZXMge1xuICByZWFkb25seSBhdXRvUGFkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNlaWxNb2RlOiBudW1iZXI7XG4gIHJlYWRvbmx5IGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHBhZHM6IHJlYWRvbmx5IG51bWJlcltdO1xufVxuXG5jb25zdCBjcmVhdGVTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBQb29sQ29tbW9uQXR0cmlidXRlcyk6IHN0cmluZyA9PlxuICBgJHthdHRyaWJ1dGVzLmZvcm1hdH07JHthdHRyaWJ1dGVzLmNlaWxNb2RlfTske2F0dHJpYnV0ZXMuYXV0b1BhZH07JHthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aH1gO1xuXG5jb25zdCBjcmVhdGVBdmVyYWdlUG9vbFNoYWRlcktleUZyb21BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyk6IHN0cmluZyA9PlxuICBgJHtjcmVhdGVTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKX07JHthdHRyaWJ1dGVzLmNvdW50SW5jbHVkZVBhZH1gO1xuXG5jb25zdCBjcmVhdGVNYXhQb29sU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMpOiBzdHJpbmcgPT5cbiAgYCR7Y3JlYXRlU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMoYXR0cmlidXRlcyl9OyR7YXR0cmlidXRlcy5zdG9yYWdlT3JkZXJ9OyR7YXR0cmlidXRlcy5kaWxhdGlvbnN9YDtcblxuY29uc3QgcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFBvb2xDb21tb25BdHRyaWJ1dGVzID0+ICh7XG4gIGZvcm1hdDogYXR0cmlidXRlcy5mb3JtYXQgYXMgRm9ybWF0QXR0cmlidXRlc1snZm9ybWF0J10sXG4gIGF1dG9QYWQ6IFsnTk9UU0VUJywgJ1ZBTElEJywgJ1NBTUVfVVBQRVInLCAnU0FNRV9MT1dFUiddW2F0dHJpYnV0ZXMuYXV0b19wYWQgYXMgbnVtYmVyXSxcbiAgY2VpbE1vZGU6IGF0dHJpYnV0ZXMuY2VpbF9tb2RlIGFzIG51bWJlcixcbiAga2VybmVsU2hhcGU6IGF0dHJpYnV0ZXMua2VybmVsX3NoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sXG4gIHN0cmlkZXM6IGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICBwYWRzOiBhdHRyaWJ1dGVzLnBhZHMgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG59KTtcblxuZXhwb3J0IGludGVyZmFjZSBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgZXh0ZW5kcyBQb29sQ29tbW9uQXR0cmlidXRlcywgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgY291bnRJbmNsdWRlUGFkOiBib29sZWFuO1xufVxuXG5jb25zdCBjcmVhdGVBdmVyYWdlUG9vbFByb2dyYW1JbmZvID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxuICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLFxuICBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IFthZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlXSA9IGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZShcbiAgICBpbnB1dCxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGlzR2xvYmFsT3BlcmF0b3IsXG4gICk7XG4gIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXQuZGF0YVR5cGUsIGlucHV0LmRpbXMubGVuZ3RoKTtcbiAgY29uc3QgZGF0YVR5cGUgPSB4LnR5cGUudmFsdWU7XG5cbiAgY29uc3Qgb3AxID0gJ3ZhbHVlICs9IHhfdmFsOyc7XG4gIGxldCBvcDIgPSAnJztcbiAgaWYgKGFkanVzdGVkQXR0cmlidXRlcy5jb3VudEluY2x1ZGVQYWQpIHtcbiAgICBvcDIgKz0gYHZhbHVlIC89ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLmtlcm5lbFNpemUpO2A7XG4gIH0gZWxzZSB7XG4gICAgb3AyICs9IGB2YWx1ZSAvPSAke2RhdGFUeXBlfShpMzIodW5pZm9ybXMua2VybmVsU2l6ZSkgLSBwYWQpO2A7XG4gIH1cbiAgY29uc3QgW3Byb2dyYW1Vbmlmb3JtcywgdW5pZm9ybXMsIGhhc1BhZHMsIHB3U3RhcnRFbmROb3RaZXJvLCBwaFN0YXJ0RW5kTm90WmVyb10gPSBnZXRVbmlmb3JtQW5kUGFkSW5mbyhcbiAgICBvdXRwdXRTaGFwZSxcbiAgICBhZGp1c3RlZEF0dHJpYnV0ZXMsXG4gICk7XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0LmRpbXMsIG91dHB1dFNoYXBlKSk7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJ107XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtoYXNQYWRzfTske3B3U3RhcnRFbmROb3RaZXJvfTske3BoU3RhcnRFbmROb3RaZXJvfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llcyxcbiAgICB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0LmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlOiAoc2hhZGVySGVscGVyKSA9PlxuICAgICAgZ2VuZXJhdGVQb29saW5nQ29kZShcbiAgICAgICAgc2hhZGVySGVscGVyLFxuICAgICAgICB4LFxuICAgICAgICBpbnB1dC5kaW1zLmxlbmd0aCxcbiAgICAgICAgb3V0cHV0U2hhcGUubGVuZ3RoLFxuICAgICAgICBhZGp1c3RlZEF0dHJpYnV0ZXMsXG4gICAgICAgIG9wMSxcbiAgICAgICAgb3AyLFxuICAgICAgICAwLjAsXG4gICAgICAgIHVuaWZvcm1zLFxuICAgICAgICBoYXNQYWRzLFxuICAgICAgICBwd1N0YXJ0RW5kTm90WmVybyxcbiAgICAgICAgcGhTdGFydEVuZE5vdFplcm8sXG4gICAgICApLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgY291bnRJbmNsdWRlUGFkID0gKGF0dHJpYnV0ZXMuY291bnRfaW5jbHVkZV9wYWQgYXMgbnVtYmVyKSA9PT0gMCA/IGZhbHNlIDogdHJ1ZTtcblxuICBjb25zdCBhdHRyID0gcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZSdcbiAgaWYgKGF0dHIuY2VpbE1vZGUgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2wnKTtcbiAgfVxuICBjb25zdCBhdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPSB7IGNvdW50SW5jbHVkZVBhZCwgLi4uYXR0ciwgY2FjaGVLZXk6ICcnIH07XG4gIHJldHVybiB7IC4uLmF2ZXJhZ2VQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGNyZWF0ZUF2ZXJhZ2VQb29sU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMoYXZlcmFnZVBvb2xBdHRyaWJ1dGVzKSB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGF2ZXJhZ2VQb29sID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbygnQXZlcmFnZVBvb2wnLCBjb250ZXh0LmlucHV0c1swXSwgZmFsc2UsIGF0dHJpYnV0ZXMpKTtcbn07XG5cbmNvbnN0IGdsb2JhbFBvb2xBdHRyaWJ1dGVzID0ge1xuICBhdXRvUGFkOiAnJyxcbiAgY2VpbE1vZGU6IDAsXG4gIGNvdW50SW5jbHVkZVBhZDogZmFsc2UsXG4gIGtlcm5lbFNoYXBlOiBbXSxcbiAgc3RyaWRlczogW10sXG4gIHBhZHM6IFtdLFxuICBzdG9yYWdlT3JkZXI6IDAsXG4gIGRpbGF0aW9uczogW10sXG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyBGb3JtYXRBdHRyaWJ1dGVzWydmb3JtYXQnXTtcbiAgcmV0dXJuIHsgZm9ybWF0LCAuLi5nbG9iYWxQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGZvcm1hdCB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbEF2ZXJhZ2VQb29sID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbygnR2xvYmFsQXZlcmFnZVBvb2wnLCBjb250ZXh0LmlucHV0c1swXSwgdHJ1ZSwgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBNYXhQb29sQXR0cmlidXRlcyBleHRlbmRzIFBvb2xDb21tb25BdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBzdG9yYWdlT3JkZXI6IG51bWJlcjtcbiAgcmVhZG9ubHkgZGlsYXRpb25zOiBudW1iZXJbXTtcbn1cblxuY29uc3QgY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxuICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLFxuICBhdHRyaWJ1dGVzOiBNYXhQb29sQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgW2FkanVzdGVkQXR0cmlidXRlcywgb3V0cHV0U2hhcGVdID0gZ2V0QWRqdXN0ZWRQb29sQXR0cmlidXRlc0FuZE91dHB1dFNoYXBlKFxuICAgIGlucHV0LFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgaXNHbG9iYWxPcGVyYXRvcixcbiAgKTtcbiAgY29uc3Qgb3AxID0gYFxuICAgICAgdmFsdWUgPSBtYXgoeF92YWwsIHZhbHVlKTtcbiAgICBgO1xuICBjb25zdCBvcDIgPSAnJztcbiAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dC5kYXRhVHlwZSwgaW5wdXQuZGltcy5sZW5ndGgpO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuayddO1xuICBjb25zdCBbcHJvZ3JhbVVuaWZvcm1zLCB1bmlmb3JtcywgaGFzUGFkcywgcHdTdGFydEVuZE5vdFplcm8sIHBoU3RhcnRFbmROb3RaZXJvXSA9IGdldFVuaWZvcm1BbmRQYWRJbmZvKFxuICAgIG91dHB1dFNoYXBlLFxuICAgIGFkanVzdGVkQXR0cmlidXRlcyxcbiAgKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXQuZGltcywgb3V0cHV0U2hhcGUpKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2hhc1BhZHN9OyR7cHdTdGFydEVuZE5vdFplcm99OyR7cGhTdGFydEVuZE5vdFplcm99YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXQuZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXIpID0+XG4gICAgICBnZW5lcmF0ZVBvb2xpbmdDb2RlKFxuICAgICAgICBzaGFkZXJIZWxwZXIsXG4gICAgICAgIHgsXG4gICAgICAgIGlucHV0LmRpbXMubGVuZ3RoLFxuICAgICAgICBvdXRwdXRTaGFwZS5sZW5ndGgsXG4gICAgICAgIGFkanVzdGVkQXR0cmlidXRlcyxcbiAgICAgICAgb3AxLFxuICAgICAgICBvcDIsXG4gICAgICAgIGlucHV0LmRhdGFUeXBlID09PSBEYXRhVHlwZS5mbG9hdDE2ID8gLTY1NTA0IDogLTFlNSxcbiAgICAgICAgdW5pZm9ybXMsXG4gICAgICAgIGhhc1BhZHMsXG4gICAgICAgIHB3U3RhcnRFbmROb3RaZXJvLFxuICAgICAgICBwaFN0YXJ0RW5kTm90WmVybyxcbiAgICAgICksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgbWF4UG9vbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvKCdNYXhQb29sJywgY29udGV4dC5pbnB1dHNbMF0sIGZhbHNlLCBhdHRyaWJ1dGVzKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VNYXhQb29sQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IE1heFBvb2xBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qgc3RvcmFnZU9yZGVyID0gYXR0cmlidXRlcy5zdG9yYWdlX29yZGVyIGFzIG51bWJlcjtcbiAgY29uc3QgZGlsYXRpb25zID0gYXR0cmlidXRlcy5kaWxhdGlvbnMgYXMgW251bWJlciwgbnVtYmVyXTtcblxuICBjb25zdCBhdHRyID0gcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZScgYW5kICdzdG9yYWdlX29yZGVyJ1xuICBpZiAoc3RvcmFnZU9yZGVyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbCcpO1xuICB9XG4gIGlmIChhdHRyLmNlaWxNb2RlICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2wnKTtcbiAgfVxuICBjb25zdCBtYXhQb29sQXR0cmlidXRlcyA9IHsgc3RvcmFnZU9yZGVyLCBkaWxhdGlvbnMsIC4uLmF0dHIsIGNhY2hlS2V5OiAnJyB9O1xuICByZXR1cm4geyAuLi5tYXhQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGNyZWF0ZU1heFBvb2xTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhtYXhQb29sQXR0cmlidXRlcykgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdsb2JhbE1heFBvb2xBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogTWF4UG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyBGb3JtYXRBdHRyaWJ1dGVzWydmb3JtYXQnXTtcbiAgcmV0dXJuIHsgZm9ybWF0LCAuLi5nbG9iYWxQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGZvcm1hdCB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbE1heFBvb2wgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbygnR2xvYmFsTWF4UG9vbCcsIGNvbnRleHQuaW5wdXRzWzBdLCB0cnVlLCBhdHRyaWJ1dGVzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRNYXhDb21wb25lbnRzLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIERlcXVhbnRpemVMaW5lckF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBheGlzOiBudW1iZXI7XG4gIGJsb2NrU2l6ZTogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogRGVxdWFudGl6ZUxpbmVyQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA8IDIgfHwgaW5wdXRzLmxlbmd0aCA+IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcXVhbnRpemVMaW5lYXIgcmVxdWlyZXMgMiBvciAzIGlucHV0cy4nKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMV0uZGltcyA9PT0gaW5wdXRzWzJdLmRpbXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3gtc2NhbGUgYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBpbnB1dHNbMl0uZGF0YVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDMyICYmIGlucHV0cy5sZW5ndGggPiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbiB0aGUgY2FzZSBvZiBkZXF1YW50aXppbmcgaW50MzIgdGhlcmUgaXMgbm8gemVybyBwb2ludC4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAwICYmIGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSAmJiBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGUgaW5wdXQgbXVzdCBiZSBhIHNjYWxhciwgYSAxRCB0ZW5zb3IsIG9yIGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yLicpO1xuICB9XG4gIC8vIHZhbGlkYXRlIHNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0IHNoYXBlc1xuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDIpIHtcbiAgICAvLyB6ZXJvLXBvaW50IGlucHV0IHR5cGUgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIGlucHV0IGRhdGEgdHlwZS5cbiAgICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBpbnB1dHNbMl0uZGF0YVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigneCBhbmQgeC16ZXJvLXBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuJyk7XG4gICAgfVxuICAgIC8vIFNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGVcbiAgICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSBpbnB1dHNbMl0uZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2NhbGUgYW5kIHplcm8tcG9pbnQgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rLicpO1xuICAgIH1cbiAgICBpZiAoIWlucHV0c1sxXS5kaW1zLm1hcCgoZCwgaSkgPT4gZCA9PT0gaW5wdXRzWzJdLmRpbXNbaV0pLnJlZHVjZSgoYSwgYikgPT4gYSAmJiBiLCB0cnVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLicpO1xuICAgIH1cbiAgfVxuICAvLyBWYWxpZGF0ZSBibG9ja1NpemVcbiAgaWYgKGF0dHJpYnV0ZXMuYmxvY2tTaXplID4gMCkge1xuICAgIC8vIEJsb2NrIHF1bmF0aXphdGlvblxuICAgIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggPT09IDAgfHwgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCA9PT0gMSAmJiBpbnB1dHNbMV0uZGltc1swXSA9PT0gMSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmxvY2tTaXplIG11c3QgYmUgc2V0IG9ubHkgZm9yIGJsb2NrIHF1YW50aXphdGlvbi4nKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIWlucHV0c1sxXS5kaW1zLm1hcCgoZCwgaSkgPT4gaSA9PT0gYXR0cmlidXRlcy5heGlzIHx8IGQgPT09IGlucHV0c1swXS5kaW1zW2ldKS5yZWR1Y2UoKGEsIGIpID0+IGEgJiYgYiwgdHJ1ZSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm9yIGJsb2NrIHF1bmF0aXphdGlvbiwgc2NhbGUgaW5wdXQgc2hhcGUgdG8gbWF0Y2ggdGhlIGlucHV0IHNoYXBlIGV4Y2VwdCBmb3IgdGhlIGF4aXMnKTtcbiAgICB9XG4gICAgLy8gU2NhbGUgaW5wdXQgcmFuayBzaG91bGQgYmUgc2FtZSBhcyB0aGUgaW5wdXQgcmFua1xuICAgIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3IgYmxvY2sgcXVuYXRpemF0aW9uIHRoZSBzY2FsZSBpbnB1dCByYW5rIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIHggcmFuay4nKTtcbiAgICB9XG4gICAgY29uc3QgZEkgPSBpbnB1dHNbMF0uZGltc1thdHRyaWJ1dGVzLmF4aXNdO1xuICAgIGNvbnN0IHNpID0gaW5wdXRzWzFdLmRpbXNbYXR0cmlidXRlcy5heGlzXTtcbiAgICBpZiAoYXR0cmlidXRlcy5ibG9ja1NpemUgPCBNYXRoLmNlaWwoZEkgLyBzaSkgfHwgYXR0cmlidXRlcy5ibG9ja1NpemUgPiBNYXRoLmNlaWwoZEkgLyAoc2kgLSAxKSAtIDEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NrU2l6ZSBtdXN0IGJlIHdpdGggaW4gdGhlIHJhbmdlIFtjZWlsKGRJIC8gU2kpLCBjZWlsKGRJIC8gKFNpIC0gMSkgLSAxKV0uJyk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBjcmVhdGVEZXF1YW50aXplTGluZWFyUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBEZXF1YW50aXplTGluZXJBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICBjb25zdCBpbnB1dFR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGlzU2lnbmVkID0gaW5wdXRUeXBlID09PSBEYXRhVHlwZS5pbnQ4O1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zOyAvLyBvdXRwdXQgc2hhcGUgaXMgc2FtZSBhcyB0aGUgaW5wdXQgc2hhcGVcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMV0uZGF0YVR5cGU7IC8vIG91dHB1dCB0eXBlIGlzIHNhbWUgYXMgdGhlIHRoZSBzY2FsZSBpbnB1dCB0eXBlXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IGlzUGFja2VkID0gaW5wdXRUeXBlID09PSBEYXRhVHlwZS5pbnQ4IHx8IGlucHV0VHlwZSA9PT0gRGF0YVR5cGUudWludDg7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpc1BhY2tlZCA/IFtNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUoaW5wdXRzWzBdLmRpbXMpIC8gNCldIDogaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IHNjYWxlU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgemVyb1BvaW50SW5wdXQgPSBpbnB1dHMubGVuZ3RoID4gMiA/IGlucHV0c1syXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgemVyb1BvaW50U2hhcGUgPSB6ZXJvUG9pbnRJbnB1dFxuICAgID8gaXNQYWNrZWRcbiAgICAgID8gW01hdGguY2VpbChTaGFwZVV0aWwuc2l6ZSh6ZXJvUG9pbnRJbnB1dC5kaW1zKSAvIDQpXVxuICAgICAgOiB6ZXJvUG9pbnRJbnB1dC5kaW1zXG4gICAgOiB1bmRlZmluZWQ7XG4gIC8vIFNjYWxlcyBpbnB1dCBpcyBhIHNjYWxlciBmb3IgcGVyLXRlbnNvci9wZXItbGF5ZXIgcXVhbnRpemF0aW9uLCAxLUQgdGVuc29yIGZvciBwZXItYXhpcyBxdWFudGl6YXRpb25cbiAgLy8gb3IgdGVuc29yIHdpdGggc2FtZSByYW5rIGFzIGlucHV0IGZvciBibG9ja2VkIHF1YW50aXphdGlvbi5cbiAgY29uc3QgcGVyTGF5ZXJRdWFudGl6YXRpb24gPSBzY2FsZVNoYXBlLmxlbmd0aCA9PT0gMCB8fCAoc2NhbGVTaGFwZS5sZW5ndGggPT09IDEgJiYgc2NhbGVTaGFwZVswXSA9PT0gMSk7XG4gIGNvbnN0IHBlckF4aXNRdWFudGl6YXRpb24gPSBwZXJMYXllclF1YW50aXphdGlvbiA9PT0gZmFsc2UgJiYgc2NhbGVTaGFwZS5sZW5ndGggPT09IDE7XG4gIC8vIExlZnQgdW5uZWNlc3NhcnkgY29tbWVudGVkLW91dCBhc3NpZ25tZW50IGZvciBkb2N1bWVudGF0aW9uXG4gIC8vIGNvbnN0IGJsb2NrUXVhbnRpemF0aW9uID0gcGVyTGF5ZXJRdWFudGl6YXRpb24gPT09IGZhbHNlICYmIHBlckF4aXNRdWFudGl6YXRpb24gPT09IGZhbHNlO1xuICBjb25zdCBtYXhDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhvdXRwdXRTaXplKTtcbiAgY29uc3QgdXNlQ29tcG9uZW50cyA9IHBlckxheWVyUXVhbnRpemF0aW9uICYmICghaXNQYWNrZWQgfHwgbWF4Q29tcG9uZW50cyA9PT0gNCk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB1c2VDb21wb25lbnRzID8gbWF4Q29tcG9uZW50cyA6IDE7XG4gIGNvbnN0IGlucHV0Q29tcG9uZW50ID0gdXNlQ29tcG9uZW50cyAmJiAhaXNQYWNrZWQgPyBtYXhDb21wb25lbnRzIDogMTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlzUGFja2VkID8gRGF0YVR5cGUudWludDMyIDogaW5wdXRUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCwgaW5wdXRDb21wb25lbnQpO1xuICBjb25zdCBzY2FsZSA9IGlucHV0VmFyaWFibGUoJ3NjYWxlJywgZGF0YVR5cGUsIHNjYWxlU2hhcGUubGVuZ3RoKTtcbiAgY29uc3QgemVyb1BvaW50ID0gemVyb1BvaW50SW5wdXRcbiAgICA/IGlucHV0VmFyaWFibGUoJ3plcm9fcG9pbnQnLCBpc1BhY2tlZCA/IERhdGFUeXBlLnVpbnQzMiA6IGlucHV0VHlwZSwgemVyb1BvaW50U2hhcGUhLmxlbmd0aClcbiAgICA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFtpbnB1dCwgc2NhbGVdO1xuICBpZiAoemVyb1BvaW50KSB7XG4gICAgaW5wdXRWYXJpYWJsZXMucHVzaCh6ZXJvUG9pbnQpO1xuICB9XG4gIGNvbnN0IGlucHV0U2hhcGVzID0gW2lucHV0U2hhcGUsIHNjYWxlU2hhcGVdO1xuICBpZiAoemVyb1BvaW50SW5wdXQpIHtcbiAgICBpbnB1dFNoYXBlcy5wdXNoKHplcm9Qb2ludFNoYXBlISk7XG4gIH1cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIC8gY29tcG9uZW50cyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBheGlzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuYmxvY2tTaXplIH0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoLi4uaW5wdXRTaGFwZXMsIG91dHB1dFNoYXBlKSxcbiAgXTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnYXhpcycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdibG9ja19zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuICAgIHJldHVybiBgXG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgICAgICAvLyBTZXQgaW5wdXQgeFxuICAgICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgbGV0IGlucHV0ID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCAvIDQnKX07XG4gICAgICAgICAgICBsZXQgeF92ZWMgPSAke2lzU2lnbmVkID8gJ3VucGFjazR4STgoaW5wdXQpJyA6ICd1bnBhY2s0eFU4KGlucHV0KSd9O1xuICAgICAgICAgICAgbGV0IHhfdmFsdWUgPSAke2NvbXBvbmVudHMgPT09IDEgPyAneF92ZWNbZ2xvYmFsX2lkeCAlIDRdJyA6ICd4X3ZlYyd9O2A7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gYGxldCB4X3ZhbHVlID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCl9O1xuXG4gICAgICAgICAgLy8gU2V0IHNjYWxlIGlucHV0XG4gICAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlckxheWVyUXVhbnRpemF0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIHNjYWxlIGlucHV0IGlzIGEgc2NhbGFyICgpXG4gICAgICAgICAgICAgIHJldHVybiBgbGV0IHNjYWxlX3ZhbHVlPSAke3NjYWxlLmdldEJ5T2Zmc2V0KCcwJyl9YDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGVyQXhpc1F1YW50aXphdGlvbikge1xuICAgICAgICAgICAgICAvLyBzY2FsZSBpbnB1dCBpcyBhIDFEIHRlbnNvclxuICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgbGV0IHNjYWxlX2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAndW5pZm9ybXMuYXhpcycpfTtcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHtzY2FsZS5nZXRCeU9mZnNldCgnc2NhbGVfaW5kZXgnKX07YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEJsb2NrIHF1YW50aXphdGlvbi4gU2NhbGUgaW5wdXQgcmFuayBpcyBzYW1lIGFzIGlucHV0L291dHB1dCByYW5rLlxuICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgdmFyIHNjYWxlX2luZGljZXM6ICR7c2NhbGUudHlwZS5pbmRpY2VzfSA9IG91dHB1dF9pbmRpY2VzO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtzY2FsZS5pbmRpY2VzR2V0KCdzY2FsZV9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnKX0gLyB1bmlmb3Jtcy5ibG9ja19zaXplO1xuICAgICAgICAgICAgJHtzY2FsZS5pbmRpY2VzU2V0KCdzY2FsZV9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnLCAnaW5kZXgnKX07XG4gICAgICAgICAgICBsZXQgc2NhbGVfdmFsdWU9ICR7c2NhbGUuZ2V0QnlJbmRpY2VzKCdzY2FsZV9pbmRpY2VzJyl9O2A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKX07XG5cbiAgICAgICAgICAvLyBTZXQgemVyby1wb2ludCBpbnB1dFxuICAgICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh6ZXJvUG9pbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHBlckxheWVyUXVhbnRpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gemVyby1wb2ludCBpbnB1dCBpcyBhIHNjYWxhclxuICAgICAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbnB1dCA9ICR7emVyb1BvaW50LmdldEJ5T2Zmc2V0KCcwJyl9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICAke2lzU2lnbmVkID8gJ3VucGFjazR4STgoemVyb19wb2ludF9pbnB1dCknIDogJ3VucGFjazR4VTgoemVyb19wb2ludF9pbnB1dCknfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZT0gemVyb19wb2ludF92ZWNbMF1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHt6ZXJvUG9pbnQuZ2V0QnlPZmZzZXQoJzAnKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwZXJBeGlzUXVhbnRpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gemVyby1wb2ludCBpbnB1dCBpcyBhIDFEIHRlbnNvclxuICAgICAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnemVyb19wb2ludF9pbmRleCAvIDQnKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7aXNTaWduZWQgPyAndW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KScgOiAndW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KSd9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAlIDRdYDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnemVyb19wb2ludF9pbmRleCcpfTtgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCbG9ja2VkUXVhbnRpemF0aW9uLiBUaGUgemVyby1wb2ludCBpbnB1dCBzaGFwZSBpcyBzYW1lIGFzIHRoZSBpbnB1dCBzaGFwZSBleGNlcHQgYWxvbmcgYXhpcy5cbiAgICAgICAgICAgICAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfb2Zmc2V0ID0gJHtzY2FsZS5pbmRpY2VzVG9PZmZzZXQoJ3NjYWxlX2luZGljZXMnKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnemVyb19wb2ludF9vZmZzZXQgLyA0Jyl9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICR7aXNTaWduZWQgPyAndW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KScgOiAndW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KSd9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9vZmZzZXQgJSA0XTtgO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHt6ZXJvUG9pbnQuZ2V0QnlJbmRpY2VzKCdzY2FsZV9pbmRpY2VzJyl9O2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gYGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHtpc1BhY2tlZCA/IChpc1NpZ25lZCA/ICdpMzInIDogJ3UzMicpIDogaW5wdXQudHlwZS52YWx1ZX0oMCk7YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpfTtcbiAgICAgIC8vIENvbXB1dGUgYW5kIHdyaXRlIG91dHB1dFxuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBgJHtvdXRwdXQudHlwZS52YWx1ZX0oeF92YWx1ZSAtIHplcm9fcG9pbnRfdmFsdWUpICogc2NhbGVfdmFsdWVgKX07XG4gICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnRGVxdWFudGl6ZUxpbmVhcicsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogemVyb1BvaW50ID8gWydyYW5rJywgJ3JhbmsnLCAncmFuayddIDogWydyYW5rJywgJ3JhbmsnXSxcbiAgICB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIGNvbXBvbmVudHMgLyA2NCksIHk6IDEsIHo6IDEgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZXF1YW50aXplTGluZWFyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBEZXF1YW50aXplTGluZXJBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZURlcXVhbnRpemVMaW5lYXJQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlRGVxdWFudGl6ZUxpbmVhckF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBEZXF1YW50aXplTGluZXJBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXIsIGJsb2NrU2l6ZTogYXR0cmlidXRlcy5ibG9ja1NpemUgYXMgbnVtYmVyIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBlbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0c0NvbnRlbnQgPSAoc3RhcnQ6IG51bWJlciwgbGltaXQ6IG51bWJlciwgZGVsdGE6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCBzYW1lU3RhcnRMaW1pdCA9IHN0YXJ0ID09PSBsaW1pdDtcbiAgY29uc3QgaW5jcmVhc2luZ1JhbmdlTmVnYXRpdmVTdGVwID0gc3RhcnQgPCBsaW1pdCAmJiBkZWx0YSA8IDA7XG4gIGNvbnN0IGRlY3JlYXNpbmdSYW5nZVBvc2l0aXZlU3RlcCA9IHN0YXJ0ID4gbGltaXQgJiYgZGVsdGEgPiAwO1xuXG4gIGlmIChzYW1lU3RhcnRMaW1pdCB8fCBpbmNyZWFzaW5nUmFuZ2VOZWdhdGl2ZVN0ZXAgfHwgZGVjcmVhc2luZ1JhbmdlUG9zaXRpdmVTdGVwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgdGhlc2UgaW5wdXRzJyBjb250ZW50cyBhcmUgaW52YWxpZC5cIik7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVJhbmdlUHJvZ3JhbUluZm8gPSAoc3RhcnQ6IG51bWJlciwgbGltaXQ6IG51bWJlciwgZGVsdGE6IG51bWJlciwgZGF0YVR5cGU6IERhdGFUeXBlKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBudW1FbGVtZW50cyA9IE1hdGguYWJzKE1hdGguY2VpbCgobGltaXQgLSBzdGFydCkgLyBkZWx0YSkpO1xuICBjb25zdCBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbbnVtRWxlbWVudHNdO1xuICBjb25zdCBvdXRwdXRTaXplID0gbnVtRWxlbWVudHM7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogZGF0YVR5cGUsIGRhdGE6IHN0YXJ0IH0sXG4gICAgeyB0eXBlOiBkYXRhVHlwZSwgZGF0YTogZGVsdGEgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IHdnc2xUeXBlID0gb3V0cHV0LnR5cGUudmFsdWU7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0U2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdzdGFydCcsIHR5cGU6IHdnc2xUeXBlIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgfSxcbiAgICAgIHsgbmFtZTogJ2RlbHRhJywgdHlwZTogd2dzbFR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhvdXRwdXQpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB1bmlmb3Jtcy5zdGFydCArICR7d2dzbFR5cGV9KGdsb2JhbF9pZHgpICogdW5pZm9ybXMuZGVsdGE7XG4gICAgICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdSYW5nZScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7ZGF0YVR5cGV9YCB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHJhbmdlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBsaW1pdCA9IDA7XG4gIGxldCBkZWx0YSA9IDA7XG4gIGlmIChjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50MzIpIHtcbiAgICBzdGFydCA9IGNvbnRleHQuaW5wdXRzWzBdLmdldEludDMyQXJyYXkoKVswXTtcbiAgICBsaW1pdCA9IGNvbnRleHQuaW5wdXRzWzFdLmdldEludDMyQXJyYXkoKVswXTtcbiAgICBkZWx0YSA9IGNvbnRleHQuaW5wdXRzWzJdLmdldEludDMyQXJyYXkoKVswXTtcbiAgfSBlbHNlIGlmIChjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQpIHtcbiAgICBzdGFydCA9IGNvbnRleHQuaW5wdXRzWzBdLmdldEZsb2F0MzJBcnJheSgpWzBdO1xuICAgIGxpbWl0ID0gY29udGV4dC5pbnB1dHNbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF07XG4gICAgZGVsdGEgPSBjb250ZXh0LmlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXTtcbiAgfVxuICBpZiAoZW52LndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCkge1xuICAgIHZhbGlkYXRlSW5wdXRzQ29udGVudChzdGFydCwgbGltaXQsIGRlbHRhKTtcbiAgfVxuXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVSYW5nZVByb2dyYW1JbmZvKHN0YXJ0LCBsaW1pdCwgZGVsdGEsIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKSwgeyBpbnB1dHM6IFtdIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBhdG9taWNPdXRwdXRWYXJpYWJsZSxcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG59IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBTY2F0dGVyTkRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVkdWN0aW9uOiBzdHJpbmc7XG59XG5cbnR5cGUgUmVkdWN0aW9uVHlwZSA9ICdpMzInIHwgJ3UzMicgfCAnZjMyJztcblxuY29uc3QgYXRvbWljUmVkdWN0aW9uU25pcHBldCA9IChyZWR1Y3Rpb246IHN0cmluZywgcHRyOiBzdHJpbmcsIHY6IHN0cmluZywgdHlwZTogUmVkdWN0aW9uVHlwZSkgPT4ge1xuICBpZiAocmVkdWN0aW9uICE9PSAnbm9uZScgJiYgdHlwZSAhPT0gJ2kzMicgJiYgdHlwZSAhPT0gJ3UzMicgJiYgdHlwZSAhPT0gJ2YzMicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7dHlwZX0gaXMgbm90IHN1cHBvcnRlZCB3aXRoIHJlZHVjdGlvbiAke3JlZHVjdGlvbn0uYCk7XG4gIH1cblxuICBjb25zdCBmbG9hdFN0YXJ0ID0gYHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIGxvb3Age1xuICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlRjMyID1gO1xuICBjb25zdCBmbG9hdEVuZCA9IGA7XG4gICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsdWUgPSBiaXRjYXN0PGkzMj4obmV3VmFsdWVGMzIpO1xuICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IGF0b21pY0NvbXBhcmVFeGNoYW5nZVdlYWsoJiR7cHRyfSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGlmIHJlcy5leGNoYW5nZWQge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gcmVzLm9sZF92YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1gO1xuXG4gIHN3aXRjaCAocmVkdWN0aW9uKSB7XG4gICAgY2FzZSAnbm9uZSc6XG4gICAgICByZXR1cm4gYCR7cHRyfT0ke3Z9O2A7XG4gICAgY2FzZSAnYWRkJzpcbiAgICAgIGlmICh0eXBlID09PSAnaTMyJyB8fCB0eXBlID09PSAndTMyJykge1xuICAgICAgICByZXR1cm4gYGF0b21pY0FkZCgmJHtwdHJ9LCBiaXRjYXN0PCR7dHlwZX0+KCR7dn0pKTtgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYXRvbWljQWRkIG9ubHkgc3VwcG9ydHMgdWludC9pbnQgdHlwZS4gRm9yIGZsb2F0LCB3ZSB1c2VcbiAgICAgICAgLy8gYXRvbWljQ29tcGFyZUV4Y2hhbmdlV2VhayB0byBzaW11bGF0ZS5cbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgJHtmbG9hdFN0YXJ0fWJpdGNhc3Q8JHt0eXBlfT4ob2xkVmFsdWUpICsgKCR7dn0pJHtmbG9hdEVuZH1gO1xuICAgICAgfVxuICAgIGNhc2UgJ21heCc6XG4gICAgICBpZiAodHlwZSA9PT0gJ2kzMicgfHwgdHlwZSA9PT0gJ3UzMicpIHtcbiAgICAgICAgcmV0dXJuIGBhdG9taWNNYXgoJiR7cHRyfSwgYml0Y2FzdDwke3R5cGV9Pigke3Z9KSk7YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGF0b21pY01heCBvbmx5IHN1cHBvcnRzIHVpbnQvaW50IHR5cGUuIEZvciBmbG9hdCwgd2UgdXNlXG4gICAgICAgIC8vIGF0b21pY0NvbXBhcmVFeGNoYW5nZVdlYWsgdG8gc2ltdWxhdGUuXG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgJHtmbG9hdFN0YXJ0fW1heChiaXRjYXN0PGYzMj4ob2xkVmFsdWUpLCAoJHt2fSkpJHtmbG9hdEVuZH1gO1xuICAgICAgfVxuICAgIGNhc2UgJ21pbic6XG4gICAgICBpZiAodHlwZSA9PT0gJ2kzMicgfHwgdHlwZSA9PT0gJ3UzMicpIHtcbiAgICAgICAgcmV0dXJuIGBhdG9taWNNaW4oJiR7cHRyfSwgYml0Y2FzdDwke3R5cGV9Pigke3Z9KSk7YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGF0b21pY01pbiBvbmx5IHN1cHBvcnRzIHVpbnQvaW50IHR5cGUuIEZvciBmbG9hdCwgd2UgdXNlXG4gICAgICAgIC8vIGF0b21pY0NvbXBhcmVFeGNoYW5nZVdlYWsgdG8gc2ltdWxhdGUuXG4gICAgICAgIHJldHVybiBgJHtmbG9hdFN0YXJ0fW1pbihiaXRjYXN0PCR7dHlwZX0+KG9sZFZhbHVlKSwgKCR7dn0pKSR7ZmxvYXRFbmR9YDtcbiAgICAgIH1cbiAgICBjYXNlICdtdWwnOlxuICAgICAgLy8gYXRvbWljTXVsIGlzIG5vdCBzdXBwb3J0ZWQsIHdlIHVzZSBhdG9taWNDb21wYXJlRXhjaGFuZ2VXZWFrIHRvIHNpbXVsYXRlLlxuICAgICAgcmV0dXJuIGAke2Zsb2F0U3RhcnR9KGJpdGNhc3Q8JHt0eXBlfT4ob2xkVmFsdWUpICogKCR7dn0pKSR7ZmxvYXRFbmR9YDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZHVjdGlvbiAke3JlZHVjdGlvbn0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlU2NhdHRlck5EUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNjYXR0ZXJOREF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5kaWNlc1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZTtcbiAgLy8gVE9ETzogc3VwcG9ydCBib29sIHdpdGggY29tcG9uZW50cyA0LlxuICBjb25zdCBjb21wb25lbnRzID0gMTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGluZGljZXNTaGFwZSwgaW5kaWNlc1NoYXBlLmxlbmd0aCAtIDEpIC8gY29tcG9uZW50cyk7XG4gIGNvbnN0IGxhc3RJbmRleERpbWVuc2lvbiA9IGluZGljZXNTaGFwZVtpbmRpY2VzU2hhcGUubGVuZ3RoIC0gMV07XG4gIGNvbnN0IG51bVVwZGF0ZXNFbGVtZW50cyA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihpbnB1dFNoYXBlLCBsYXN0SW5kZXhEaW1lbnNpb24pO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBsYXN0SW5kZXhEaW1lbnNpb24gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogbnVtVXBkYXRlc0VsZW1lbnRzIH0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzFdLmRpbXMsIGlucHV0c1syXS5kaW1zLCBvdXRwdXRTaGFwZSksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2luZGljZXMnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgdXBkYXRlcyA9IGlucHV0VmFyaWFibGUoJ3VwZGF0ZXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3Qgb3V0cHV0ID1cbiAgICAgIGF0dHJpYnV0ZXMucmVkdWN0aW9uICE9PSAnbm9uZScgJiYgYXR0cmlidXRlcy5yZWR1Y3Rpb24gIT09ICcnXG4gICAgICAgID8gYXRvbWljT3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKVxuICAgICAgICA6IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG5cbiAgICByZXR1cm4gYFxuICAgICAgJHtzaGFkZXJIZWxwZXJcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJylcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnbGFzdF9pbmRleF9kaW1lbnNpb24nLCAndTMyJylcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnbnVtX3VwZGF0ZXNfZWxlbWVudHMnLCAndTMyJylcbiAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5kaWNlcywgdXBkYXRlcywgb3V0cHV0KX1cbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICB2YXIgZGF0YV9vZmZzZXQgPSAwdTtcbiAgbGV0IGluZGljZXNfc3RhcnQgPSB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbiAqIGdsb2JhbF9pZHg7XG4gIGxldCBpbmRpY2VzX2VuZCA9IGluZGljZXNfc3RhcnQgKyB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbjtcbiAgZm9yICh2YXIgaSA9IGluZGljZXNfc3RhcnQ7IGkgPCBpbmRpY2VzX2VuZDsgaSsrKSB7XG4gICAgdmFyIGluZGV4ID0gaTMyKGluZGljZXNbaV0ueCk7XG4gICAgJHtcbiAgICAgIGlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IGBcbiAgICBsZXQgZWxlbWVudF9jb3VudF9kaW0gPSB1bmlmb3Jtcy5vdXRwdXRfc3RyaWRlcztcbiAgICBsZXQgZGltX3ZhbHVlID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlO2BcbiAgICAgICAgOiBgXG4gICAgbGV0IGVsZW1lbnRfY291bnRfZGltID0gdW5pZm9ybXMub3V0cHV0X3N0cmlkZXNbaSAtIGluZGljZXNfc3RhcnRdO1xuICAgIGxldCBkaW1fdmFsdWUgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbaSAtIGluZGljZXNfc3RhcnRdO2BcbiAgICB9XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGlmIChpbmRleCA+PSBpMzIoZGltX3ZhbHVlKSkge1xuICAgICAgICBpbmRleCA9IGkzMihkaW1fdmFsdWUgLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGluZGV4IDwgLWkzMihkaW1fdmFsdWUpKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ICs9IGkzMihkaW1fdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBkYXRhX29mZnNldCArPSB1MzIoKHUzMihpbmRleCkgKiBlbGVtZW50X2NvdW50X2RpbSkpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDB1OyBpIDwgdW5pZm9ybXMubnVtX3VwZGF0ZXNfZWxlbWVudHM7IGkrKykge1xuICAgIGxldCB2YWx1ZSA9IHVwZGF0ZXNbdW5pZm9ybXMubnVtX3VwZGF0ZXNfZWxlbWVudHMgKiBnbG9iYWxfaWR4ICsgaV07XG4gICAgJHthdG9taWNSZWR1Y3Rpb25TbmlwcGV0KFxuICAgICAgYXR0cmlidXRlcy5yZWR1Y3Rpb24sXG4gICAgICAnb3V0cHV0W2RhdGFfb2Zmc2V0ICsgaV0nLFxuICAgICAgJ3ZhbHVlJyxcbiAgICAgIG91dHB1dC50eXBlLnZhbHVlIGFzIFJlZHVjdGlvblR5cGUsXG4gICAgKX1cbiAgfVxuXG4gICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnU2NhdHRlck5EJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX1fJHthdHRyaWJ1dGVzLnJlZHVjdGlvbn1gLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJ10sXG4gICAgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU2NhdHRlck5EQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFNjYXR0ZXJOREF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgcmVkdWN0aW9uOiBhdHRyaWJ1dGVzLnJlZHVjdGlvbiBhcyBzdHJpbmcgfSk7XG5cbmV4cG9ydCBjb25zdCBzY2F0dGVyTkQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNjYXR0ZXJOREF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVNjYXR0ZXJORFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSwge1xuICAgIGlucHV0czogW2NvbnRleHQuaW5wdXRzWzFdLCBjb250ZXh0LmlucHV0c1syXV0sXG4gICAgb3V0cHV0czogW10sXG4gIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRFbGVtZW50QXQsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG59IGZyb20gJy4vY29tbW9uJztcblxudHlwZSBDb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9XG4gIHwgJ2hhbGZfcGl4ZWwnXG4gIHwgJ2FzeW1tZXRyaWMnXG4gIHwgJ3B5dG9yY2hfaGFsZl9waXhlbCdcbiAgfCAndGZfaGFsZl9waXhlbF9mb3Jfbm4nXG4gIHwgJ2FsaWduX2Nvcm5lcnMnXG4gIHwgJ3RmX2Nyb3BfYW5kX3Jlc2l6ZSdcbiAgfCAnaGFsZl9waXhlbF9zeW1tZXRyaWMnO1xuXG50eXBlIEtlZXBBc3BlY3RSYXRpb1BvbGljeSA9ICdzdHJldGNoJyB8ICdub3Rfc21hbGxlcicgfCAnbm90X2xhcmdlcic7XG5cbnR5cGUgTW9kZSA9ICduZWFyZXN0JyB8ICdsaW5lYXInIHwgJ2N1YmljJztcblxudHlwZSBOZWFyZXN0TW9kZSA9ICdyb3VuZF9wcmVmZXJfZmxvb3InIHwgJ3JvdW5kX3ByZWZlcl9jZWlsJyB8ICdmbG9vcicgfCAnY2VpbCcgfCAnc2ltcGxlJztcblxuZXhwb3J0IGludGVyZmFjZSBSZXNpemVBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgYW50aWFsaWFzOiBudW1iZXI7XG4gIGF4ZXM6IG51bWJlcltdO1xuICBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU7XG4gIGN1YmljQ29lZmZBOiBudW1iZXI7XG4gIGV4Y2x1ZGVPdXRzaWRlOiBib29sZWFuO1xuICBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlcjtcbiAga2VlcEFzcGVjdFJhdGlvUG9saWN5OiBLZWVwQXNwZWN0UmF0aW9Qb2xpY3k7XG4gIG1vZGU6IE1vZGU7XG4gIG5lYXJlc3RNb2RlOiBOZWFyZXN0TW9kZTtcbn1cblxuY29uc3QgdmFsaWRhdGVTY2FsZXMgPSAoc2NhbGVzOiBudW1iZXJbXSwgYXR0cmlidXRlczogUmVzaXplQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBzY2FsZXMuZXZlcnkoXG4gICAgKHZhbHVlKSA9PlxuICAgICAgdmFsdWUgPiAwIHx8XG4gICAgICAoKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlJyk7XG4gICAgICB9KSxcbiAgKTtcbiAgLy8gQ2hlY2sgc2NhbGVzIGRpbXMgYmFzZWQgb24gbW9kZTogTElORUFSLCBDVUJJQ1xuICBpZiAoc2NhbGVzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoYXR0cmlidXRlcy5tb2RlID09PSAnbGluZWFyJykge1xuICAgICAgaWYgKFxuICAgICAgICAhKFxuICAgICAgICAgIHNjYWxlcy5sZW5ndGggPT09IDIgfHxcbiAgICAgICAgICBzY2FsZXMubGVuZ3RoID09PSAzIHx8XG4gICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDQgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1sxXSA9PT0gMSkgfHxcbiAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzNdID09PSAxKSB8fFxuICAgICAgICAgIChzY2FsZXMubGVuZ3RoID09PSA1ICYmIHNjYWxlc1swXSA9PT0gMSAmJiBzY2FsZXNbMV0gPT09IDEpXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZvciBsaW5lYXIgbW9kZSwgUmVzaXplIHJlcXVpcmVzIHNjYWxlcyB0byBiZSAyRCwgM0QsIDREIHdpdGggZWl0aGVyIHR3byBvdXRlcm1vc3Qgb3Igb25lIGlubmVybW9zdCBhbmRcbiAgICAgICAgICAgIG9uZSBvdXRlcm1vc3Qgc2NhbGUgdmFsdWVzIGVxdWFsIHRvIDEsIG9yIDVEIHdpdGggdHdvIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09ICdjdWJpYycpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIShcbiAgICAgICAgICBzY2FsZXMubGVuZ3RoID09PSAyIHx8XG4gICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDQgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1sxXSA9PT0gMSkgfHxcbiAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzNdID09PSAxKVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHNpemUgdG8gYmUgMiBvciA0IGZvciBjdWJpYyBtb2RlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCB1cGRhdGVTY2FsZXMgPSAoc2NhbGVzOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgYXhlcy5ldmVyeShcbiAgICAodmFsdWUpID0+XG4gICAgICAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8IHJhbmspIHx8XG4gICAgICAoKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmsnKTtcbiAgICAgIH0pLFxuICApO1xuICBjb25zdCBuZXdTY2FsZXMgPSBuZXcgQXJyYXkocmFuaykuZmlsbCgxLjApO1xuICBheGVzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4gKG5ld1NjYWxlc1t2YWx1ZV0gPSBzY2FsZXNbaW5kZXhdKSk7XG4gIHJldHVybiBuZXdTY2FsZXM7XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMsXG4gIG9wc2V0VmVyc2lvbjogbnVtYmVyLFxuICBzY2FsZXM6IG51bWJlcltdLFxuICBzaXplczogbnVtYmVyW10sXG4gIHJvaTogbnVtYmVyW10sXG4pOiB2b2lkID0+IHtcbiAgY29uc3QgW3JvaUlucHV0SW5kZXgsIHNjYWxlc0lucHV0SW5kZXgsIHNpemVzSW5wdXRJbmRleF0gPVxuICAgIG9wc2V0VmVyc2lvbiA+IDEwID8gWzEsIDIsIDNdIDogWy0xLCBpbnB1dHMubGVuZ3RoID4gMSA/IDEgOiAtMSwgLTFdO1xuICBjb25zdCByYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICBpZiAocm9pSW5wdXRJbmRleCA+IDAgJiYgaW5wdXRzLmxlbmd0aCA+IHJvaUlucHV0SW5kZXggJiYgaW5wdXRzW3JvaUlucHV0SW5kZXhdLmRpbXMubGVuZ3RoID4gMCkge1xuICAgIGlucHV0c1tyb2lJbnB1dEluZGV4XS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4gcm9pLnB1c2godmFsdWUpKTtcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID09PSAndGZfY3JvcF9hbmRfcmVzaXplJykge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFJvSSBpbnB1dCB0byBiZSBzcGVjaWZpZWQgd2hlbiBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSBpcyB0ZkNyb3BBbmRSZXNpemUnKTtcbiAgfVxuXG4gIGlmIChcbiAgICBzY2FsZXNJbnB1dEluZGV4ID4gMCAmJlxuICAgIGlucHV0cy5sZW5ndGggPiBzY2FsZXNJbnB1dEluZGV4ICYmXG4gICAgaW5wdXRzW3NjYWxlc0lucHV0SW5kZXhdLmRpbXMubGVuZ3RoID09PSAxICYmXG4gICAgaW5wdXRzW3NjYWxlc0lucHV0SW5kZXhdLmRpbXNbMF0gPiAwXG4gICkge1xuICAgIGlucHV0c1tzY2FsZXNJbnB1dEluZGV4XS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4gc2NhbGVzLnB1c2godmFsdWUpKTtcbiAgICBpZiAoXG4gICAgICBzY2FsZXMubGVuZ3RoICE9PSAwICYmXG4gICAgICBzY2FsZXMubGVuZ3RoICE9PSByYW5rICYmXG4gICAgICBvcHNldFZlcnNpb24gPj0gMTggJiZcbiAgICAgIHNjYWxlcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGhcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cCcpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVNjYWxlcyhzY2FsZXMsIGF0dHJpYnV0ZXMpO1xuICAgIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdXBkYXRlU2NhbGVzKHNjYWxlcywgYXR0cmlidXRlcy5heGVzLCByYW5rKS5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IChzY2FsZXNbaW5kZXhdID0gdmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgaWYgKFxuICAgIHNpemVzSW5wdXRJbmRleCA+IDAgJiZcbiAgICBpbnB1dHMubGVuZ3RoID4gc2l6ZXNJbnB1dEluZGV4ICYmXG4gICAgaW5wdXRzW3NpemVzSW5wdXRJbmRleF0uZGltcy5sZW5ndGggPT09IDEgJiZcbiAgICBpbnB1dHNbc2l6ZXNJbnB1dEluZGV4XS5kaW1zWzBdID4gMFxuICApIHtcbiAgICBpbnB1dHNbc2l6ZXNJbnB1dEluZGV4XS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCgodmFsdWUpID0+IHNpemVzLnB1c2goTnVtYmVyKHZhbHVlKSkpO1xuICAgIGlmIChzaXplcy5sZW5ndGggIT09IDAgJiYgc2l6ZXMubGVuZ3RoICE9PSByYW5rICYmIG9wc2V0VmVyc2lvbiA+PSAxOCAmJiBzaXplcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIHNpemVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHNjYWxlcy5sZW5ndGggIT09IDAgJiYgc2NhbGVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5heGVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzY2FsZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtcbiAgICB9XG4gICAgaWYgKHNpemVzLmxlbmd0aCAhPT0gMCAmJiBzaXplcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFwic2l6ZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIHJhbmsgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNjYWxlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHNpemVzICE9PSAndW5kZWZpbmVkJyAmJiBzY2FsZXMubGVuZ3RoID4gMCAmJiBzaXplcy5sZW5ndGggPiByYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgb25seSBvZiBzY2FsZXMgb3Igc2l6ZXMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldFNhZmVJbnRlZ2VyRGl2aXNpb24gPSAoYTogc3RyaW5nLCBiOiBzdHJpbmcsIGM6IHN0cmluZywgZFR5cGU6IHN0cmluZyk6IHN0cmluZyA9PiBgXG4gIC8vIFRoZSB3aG9sZSBwYXJ0IGFuZCB0aGUgZnJhY3Rpb25hbCBwYXJ0IGFyZSBjYWxjdWxhdGVkIHNlcGFyYXRlbHkgZHVlIHRvIGluYWNjdXJhY3kgb2YgZmxvYXRpbmdcbiAgLy8gcG9pbnQgZGl2aXNpb24uIEFzIGFuIGV4YW1wbGUsIGYzMigyMSkgLyBmMzIoNykgbWF5IGV2YWx1YXRlIHRvIDIuOTkuLi4gaW5zdGVhZCBvZiAzLCBjYXVzaW5nIGFuXG4gIC8vIG9mZnNldC1ieS1vbmUgZXJyb3IgbGF0ZXIgaW4gZmxvb3IoKS5cbiAgbGV0IGJpZyA9ICgke2F9KSAqICgke2J9KTtcbiAgbGV0IHdob2xlID0gJHtkVHlwZX0oYmlnIC8gKCR7Y30pKTtcbiAgbGV0IGZyYWN0ID0gJHtkVHlwZX0oYmlnICUgKCR7Y30pKSAvICR7ZFR5cGV9KCR7Y30pO1xuICByZXR1cm4gd2hvbGUgKyBmcmFjdDtcbmA7XG5cbmNvbnN0IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSA9IChcbiAgY29vcmRpbmF0ZVRyYW5zZmVyTW9kZTogQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsXG4gIGRUeXBlOiBzdHJpbmcsXG4pOiBzdHJpbmcgPT5cbiAgYGZuIGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSh4UmVzaXplZDogdTMyLCB4U2NhbGU6IGYzMiwgbGVuZ3RoUmVzaXplZDogdTMyLFxuICAgICBsZW5ndGhPcmlnaW5hbDogdTMyLCByb2lTdGFydDogZjMyLCByb2lFbmQ6IGYzMikgLT4gJHtkVHlwZX0geyBgICtcbiAgKCgpID0+IHtcbiAgICBzd2l0Y2ggKGNvb3JkaW5hdGVUcmFuc2Zlck1vZGUpIHtcbiAgICAgIGNhc2UgJ2FzeW1tZXRyaWMnOlxuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgIGlmICh4U2NhbGUgPCAxLjAgfHwgZmxvb3IoeFNjYWxlKSAhPSB4U2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiAke2RUeXBlfSh4UmVzaXplZCkgLyAke2RUeXBlfSh4U2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAke2dldFNhZmVJbnRlZ2VyRGl2aXNpb24oJ3hSZXNpemVkJywgJ2xlbmd0aE9yaWdpbmFsJywgJ2xlbmd0aFJlc2l6ZWQnLCBkVHlwZSl9XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgY2FzZSAncHl0b3JjaF9oYWxmX3BpeGVsJzpcbiAgICAgICAgcmV0dXJuIGBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgke2RUeXBlfSh4UmVzaXplZCkgKyAwLjUpIC8gJHtkVHlwZX0oeFNjYWxlKSAtIDAuNTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICB9YDtcbiAgICAgIGNhc2UgJ3RmX2hhbGZfcGl4ZWxfZm9yX25uJzpcbiAgICAgICAgcmV0dXJuIGByZXR1cm4gKCR7ZFR5cGV9KHhSZXNpemVkKSArIDAuNSkgLyAke2RUeXBlfSh4U2NhbGUpO2A7XG4gICAgICBjYXNlICdhbGlnbl9jb3JuZXJzJzpcbiAgICAgICAgcmV0dXJuIGBpZiAobGVuZ3RoUmVzaXplZCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAke2dldFNhZmVJbnRlZ2VyRGl2aXNpb24oJ3hSZXNpemVkJywgJ2xlbmd0aE9yaWdpbmFsIC0gMScsICdsZW5ndGhSZXNpemVkIC0gMScsIGRUeXBlKX1cbiAgICAgICAgICAgICAgICAgIH1gO1xuICAgICAgY2FzZSAndGZfY3JvcF9hbmRfcmVzaXplJzpcbiAgICAgICAgcmV0dXJuIGBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR7ZFR5cGV9KHJvaVN0YXJ0KSAqICR7ZFR5cGV9KGxlbmd0aE9yaWdpbmFsIC0gMSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKCR7ZFR5cGV9KHhSZXNpemVkKSAqICR7ZFR5cGV9KHJvaUVuZCAtIHJvaVN0YXJ0KSAqICR7ZFR5cGV9KGxlbmd0aE9yaWdpbmFsIC0gMSkpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICR7ZFR5cGV9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAke2RUeXBlfShyb2lTdGFydCArIHJvaUVuZCkgKiAke2RUeXBlfShsZW5ndGhPcmlnaW5hbCAtIDEpO1xuICAgICAgICAgICAgICAgICAgfWA7XG4gICAgICBjYXNlICdoYWxmX3BpeGVsX3N5bW1ldHJpYyc6XG4gICAgICAgIHJldHVybiBgY29uc3Qgb3V0cHV0V2lkdGggPSAke2RUeXBlfXhTY2FsZSAqICR7ZFR5cGV9KGxlbmd0aFJlc2l6ZWQpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWRqdXN0bWVudCA9ICR7ZFR5cGV9KGxlbmd0aFJlc2l6ZWQpIC8gb3V0cHV0V2lkdGg7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXIgPSAke2RUeXBlfShsZW5ndGhPcmlnaW5hbCkgLyAyO1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gY2VudGVyICogKDEgLSBhZGp1c3RtZW50KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyAoKCR7ZFR5cGV9KHhSZXNpemVkKSArIDAuNSkgLyAke2RUeXBlfSh4U2NhbGUpKSAtIDAuNTtgO1xuICAgICAgY2FzZSAnaGFsZl9waXhlbCc6XG4gICAgICAgIHJldHVybiBgcmV0dXJuICgoJHtkVHlwZX0oeFJlc2l6ZWQpICsgMC41KSAvICR7ZFR5cGV9KHhTY2FsZSkpIC0gMC41O2A7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvb3JkaW5hdGUgdHJhbnNmb3JtIG1vZGUgJHtjb29yZGluYXRlVHJhbnNmZXJNb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9KSgpICtcbiAgJ30nO1xuXG5jb25zdCBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwgPSAobmVhcmVzdE1vZGU6IE5lYXJlc3RNb2RlLCBvcHNldFZlcnNpb246IG51bWJlciwgZFR5cGU6IHN0cmluZyk6IHN0cmluZyA9PlxuICBgZm4gZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKHhPcmlnaW5hbDogJHtkVHlwZX0sIGlzRG93blNhbXBsZTogYm9vbCkgLT4gJHtkVHlwZX0ge2AgK1xuICAoKCkgPT4ge1xuICAgIHN3aXRjaCAobmVhcmVzdE1vZGUpIHtcbiAgICAgIGNhc2UgJ3JvdW5kX3ByZWZlcl9jZWlsJzpcbiAgICAgICAgcmV0dXJuICdpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgXFxcbiAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7IFxcXG4gICAgICAgICAgfSBlbHNlIHsgXFxcbiAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyBcXFxuICAgICAgICAgIH0nO1xuICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICByZXR1cm4gJ3JldHVybiBmbG9vcih4T3JpZ2luYWwpOyc7XG4gICAgICBjYXNlICdjZWlsJzpcbiAgICAgICAgcmV0dXJuICdyZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyc7XG4gICAgICBjYXNlICdyb3VuZF9wcmVmZXJfZmxvb3InOlxuICAgICAgICByZXR1cm4gJ2lmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyBcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsgXFxcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyBcXFxuICAgICAgICAgICAgICAgICAgfSc7XG4gICAgICBjYXNlICdzaW1wbGUnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKG9wc2V0VmVyc2lvbiA8IDExKSB7XG4gICAgICAgICAgcmV0dXJuICdpZiAoaXNEb3duU2FtcGxlKSBcXFxuICAgICAgICAgICAgICAgICAgICB7IFxcXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgXFxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgXFxcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geE9yaWdpbmFsOyBcXFxuICAgICAgICAgICAgICAgICAgICB9JztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5lYXJlc3QgbW9kZSAke25lYXJlc3RNb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9KSgpICtcbiAgJ30nO1xuXG5jb25zdCB1cGRhdGVSb0kgPSAocm9pOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3Qgcm9pVG1wID0gbmV3IEFycmF5KHJhbmspLmZpbGwoMCkuY29uY2F0KG5ldyBBcnJheShyYW5rKS5maWxsKDEpKTtcbiAgY29uc3Qgcm9pTG9jYWwgPSByb2kubGVuZ3RoID09PSAwID8gcm9pVG1wIDogcm9pLnNsaWNlKCk7XG4gIGlmIChheGVzLmxlbmd0aCA+IDApIHtcbiAgICBheGVzLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgIHJvaVRtcFt2XSA9IHJvaUxvY2FsW2ldO1xuICAgICAgcm9pVG1wW2kgKyByYW5rXSA9IHJvaUxvY2FsW2F4ZXMubGVuZ3RoICsgaV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvaVRtcDtcbiAgfVxuICByZXR1cm4gcm9pTG9jYWw7XG59O1xuXG5jb25zdCBpbml0T3V0cHV0U2hhcGUgPSAoXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzY2FsZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzaXplczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuKTogbnVtYmVyW10gPT4ge1xuICBsZXQgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gIGlmIChzaXplcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgaW5wdXRTaGFwZS5mb3JFYWNoKCh2KSA9PiBvdXRwdXRTaGFwZS5wdXNoKHYpKTtcbiAgICAgIGlmIChNYXRoLm1heCguLi5heGVzKSA+IGlucHV0U2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXhlcyBpcyBvdXQgb2YgYm91bmQnKTtcbiAgICAgIH1cbiAgICAgIGF4ZXMuZm9yRWFjaCgodiwgaSkgPT4gKG91dHB1dFNoYXBlW3ZdID0gc2l6ZXNbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZXMuZm9yRWFjaCgodikgPT4gb3V0cHV0U2hhcGUucHVzaCh2KSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzY2FsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBlaXRoZXIgc2NhbGVzIG9yIHNpemVzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUubWFwKCh2YWx1ZSwgaW5kZXgpID0+IE1hdGgucm91bmQodmFsdWUgKiBzY2FsZXNbaW5kZXhdKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXRTaGFwZTtcbn07XG5cbmNvbnN0IGFkanVzdE91dHB1dFNoYXBlID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBzY2FsZXM6IG51bWJlcltdLCBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IHNjYWxlSW5Qb2xpY3kgPSAoKCkgPT4ge1xuICAgIHN3aXRjaCAoYXR0cmlidXRlcy5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kpIHtcbiAgICAgIGNhc2UgJ25vdF9sYXJnZXInOlxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IE1hdGgubWluKC4uLmF0dHJpYnV0ZXMuYXhlcy5tYXAoKGkpID0+IHNjYWxlc1tpXSksIE51bWJlci5NQVhfVkFMVUUpXG4gICAgICAgICAgOiBNYXRoLm1pbiguLi5zY2FsZXMsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgY2FzZSAnbm90X3NtYWxsZXInOlxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IE1hdGgubWF4KC4uLmF0dHJpYnV0ZXMuYXhlcy5tYXAoKGkpID0+IHNjYWxlc1tpXSksIE51bWJlci5NSU5fVkFMVUUpXG4gICAgICAgICAgOiBNYXRoLm1heCguLi5zY2FsZXMsIE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZWVwIGFzcGVjdCByYXRpbyBwb2xpY3kgJHthdHRyaWJ1dGVzLmtlZXBBc3BlY3RSYXRpb1BvbGljeX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfSkoKTtcbiAgc2NhbGVzLmZpbGwoMS4wLCAwLCBzY2FsZXMubGVuZ3RoKTtcbiAgY29uc3QgYWRqdXN0ZWRPdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoKTtcbiAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwKSB7XG4gICAgYXR0cmlidXRlcy5heGVzLmZvckVhY2goKHYpID0+IChzY2FsZXNbdl0gPSBzY2FsZUluUG9saWN5KSk7XG4gICAgYXR0cmlidXRlcy5heGVzLmZvckVhY2goKHYpID0+IChhZGp1c3RlZE91dHB1dFNoYXBlW3ZdID0gTWF0aC5yb3VuZChpbnB1dFNoYXBlW3ZdICogc2NhbGVzW3ZdKSkpO1xuICB9IGVsc2Uge1xuICAgIHNjYWxlcy5maWxsKHNjYWxlSW5Qb2xpY3ksIDAsIHNjYWxlcy5sZW5ndGgpO1xuICAgIGFkanVzdGVkT3V0cHV0U2hhcGUuZm9yRWFjaCgodiwgaSkgPT4gKGFkanVzdGVkT3V0cHV0U2hhcGVbaV0gPSBNYXRoLnJvdW5kKHYgKiBzY2FsZXNbaV0pKSk7XG4gIH1cbiAgcmV0dXJuIGFkanVzdGVkT3V0cHV0U2hhcGU7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyA9IChcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzY2FsZXNMZW5ndGg6IG51bWJlcixcbiAgcm9pTGVuZ3RoOiBudW1iZXIsXG4pOiBzdHJpbmcgPT4gYFxuICAgIGZuIGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiBhcnJheTwke1xuICAgICAgb3V0cHV0LnR5cGUudmFsdWVcbiAgICB9LCAke291dHB1dFNoYXBlLmxlbmd0aH0+IHtcbiAgICAgIHZhciBvcmlnaW5hbF9pbmRpY2VzOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXRTaGFwZS5sZW5ndGh9PjtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7b3V0cHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICB2YXIgc2NhbGUgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc2NhbGVzJywgJ2knLCBzY2FsZXNMZW5ndGgpfTtcbiAgICAgICAgdmFyIHJvaV9sb3cgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgJ2knLCByb2lMZW5ndGgpfTtcbiAgICAgICAgdmFyIHJvaV9oaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5yb2knLCBgaSArICR7aW5wdXRTaGFwZS5sZW5ndGh9YCwgcm9pTGVuZ3RoKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gJHtvdXRwdXQudHlwZS52YWx1ZX0ob3V0cHV0X2luZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMub3V0cHV0X3NoYXBlJywgJ2knLCBvdXRwdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgc2NhbGUsIG91dHB1dF9zaGFwZV9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfc2hhcGVfaSwgcm9pX2xvdywgcm9pX2hpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsX2luZGljZXM7XG4gICAgfWA7XG5cbmNvbnN0IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzID0gKFxuICBpbnB1dDogSW5kaWNlc0hlbHBlcixcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzY2FsZXNMZW5ndGg6IG51bWJlcixcbiAgcm9pTGVuZ3RoOiBudW1iZXIsXG4gIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4sXG4pOiBzdHJpbmcgPT4gYFxuICAgIGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2lucHV0LnR5cGUuaW5kaWNlc30ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7b3V0cHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXg6IHUzMjtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnNjYWxlcycsICdpJywgc2NhbGVzTGVuZ3RoKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm9pX2xvdyA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5yb2knLCAnaScsIHJvaUxlbmd0aCl9O1xuICAgICAgICAgIHZhciByb2lfaGkgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgYGkgKyAke2lucHV0U2hhcGUubGVuZ3RofWAsIHJvaUxlbmd0aCl9O1xuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5vdXRwdXRfc2hhcGUnLCAnaScsIG91dHB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvcmlnaW5hbF9pZHggPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICAgIGlmICghJHt1c2VFeHRyYXBvbGF0aW9ufSB8fCAob3JpZ2luYWxfaWR4ID49IDAgJiYgb3JpZ2luYWxfaWR4IDwgJHtvdXRwdXQudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSkpKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxfaWR4IDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsX2lkeCA+ICR7b3V0cHV0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kgLSAxKSkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSB1MzIoZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKG9yaWdpbmFsX2lkeCwgc2NhbGUgPCAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0X2luZGV4ID0gdTMyKG9yaWdpbmFsX2lkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsICdpJywgJ2lucHV0X2luZGV4Jyl9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXRfaW5kaWNlcztcbiAgICB9YDtcbmNvbnN0IGNoZWNrSW5wdXRJbmRpY2VzID0gKGlucHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IHN0cmluZyA9PiBgXG4gICAgZm4gY2hlY2tJbnB1dEluZGljZXMoaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9KSAtPiBib29sIHtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7aW5wdXRTaGFwZS5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0X2luZGV4ID0gJHtpbnB1dC5pbmRpY2VzR2V0KCdpbnB1dF9pbmRpY2VzJywgJ2knKX07XG4gICAgICAgIGlmIChpbnB1dF9pbmRleCA8IDAgfHwgaW5wdXRfaW5kZXggPj0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9YDtcblxuY29uc3Qgc2V0Q2hhbm5lbEFuZEJhdGNoSW5kaWNlcyA9IChcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXG4gIGNoYW5uZWxJZHg6IG51bWJlcixcbiAgYmF0Y2hJZHg6IG51bWJlcixcbiAgc3BhY2lhbERpbXM6IG51bWJlcixcbik6IHN0cmluZyA9PlxuICBpbnB1dC5yYW5rID4gc3BhY2lhbERpbXNcbiAgICA/IGBcbiAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBjaGFubmVsSWR4LCAnY2hhbm5lbCcpfTtcbiAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBiYXRjaElkeCwgJ2JhdGNoJyl9O1xuYFxuICAgIDogJyc7XG5cbmNvbnN0IGJpbGluZWFySW50ZXJwb2xhdGlvbiA9IChcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXG4gIG91dHB1dDogSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4sXG4gIGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgaXNOY2h3ID0gdHJ1ZTtcbiAgY29uc3QgW2JhdGNoSWR4LCBoZWlnaHRJZHgsIHdpZHRoSWR4LCBjaGFubmVsSWR4XSA9XG4gICAgaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgPyBbLTEsIDAsIDEsIC0xXSA6IGlzTmNodyA/IFswLCAyLCAzLCAxXSA6IFswLCAxLCAyLCAzXTtcbiAgY29uc3QgZFR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICByZXR1cm4gYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCByb3c6IHUzMiwgY29sOiB1MzIpIC0+ICR7ZFR5cGV9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBoZWlnaHRJZHgsIGBtYXgoMCwgbWluKHJvdywgJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkpYCl9O1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgd2lkdGhJZHgsIGBtYXgoMCwgbWluKGNvbCwgJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSlgKX07XG4gICAgICAke3NldENoYW5uZWxBbmRCYXRjaEluZGljZXMoaW5wdXQsIGNoYW5uZWxJZHgsIGJhdGNoSWR4LCAyKX1cbiAgICAgIHJldHVybiAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICB9XG5cbiAgICBmbiBiaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZFR5cGV9IHtcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICB2YXIgcm93OiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7aGVpZ2h0SWR4fV07XG4gICAgICB2YXIgY29sOiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7d2lkdGhJZHh9XTtcbiAgICAgICR7XG4gICAgICAgIHVzZUV4dHJhcG9sYXRpb25cbiAgICAgICAgICA/IGBpZiAocm93IDwgMCB8fCByb3cgPiAoJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkgfHwgY29sIDwgMCB8fCBjb2wgPiAoJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSkge1xuICAgICAgICByZXR1cm4gJHtleHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgfWBcbiAgICAgICAgICA6ICcnXG4gICAgICB9O1xuICAgICAgcm93ID0gbWF4KDAsIG1pbihyb3csICR7aW5wdXRTaGFwZVtoZWlnaHRJZHhdfSAtIDEpKTtcbiAgICAgIGNvbCA9IG1heCgwLCBtaW4oY29sLCAke2lucHV0U2hhcGVbd2lkdGhJZHhdfSAtIDEpKTtcbiAgICAgIHZhciByb3cxOiB1MzIgPSB1MzIocm93KTtcbiAgICAgIHZhciBjb2wxOiB1MzIgPSB1MzIoY29sKTtcbiAgICAgIHZhciByb3cyOiB1MzIgPSB1MzIocm93ICsgMSk7XG4gICAgICB2YXIgY29sMjogdTMyID0gdTMyKGNvbCArIDEpO1xuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9ICR7aW5wdXRTaGFwZS5sZW5ndGggPiAyID8gYHUzMihvcmlnaW5hbEluZGljZXNbJHtjaGFubmVsSWR4fV0pYCA6ICcwJ307XG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke2lucHV0U2hhcGUubGVuZ3RoID4gMiA/IGB1MzIob3JpZ2luYWxJbmRpY2VzWyR7YmF0Y2hJZHh9XSlgIDogJzAnfTtcbiAgICAgIHZhciB4MTE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMSk7XG4gICAgICB2YXIgeDEyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDIpO1xuICAgICAgdmFyIHgyMTogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wxKTtcbiAgICAgIHZhciB4MjI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMik7XG4gICAgICB2YXIgZHgxOiAke2RUeXBlfSA9IGFicyhyb3cgLSAke2RUeXBlfShyb3cxKSk7XG4gICAgICB2YXIgZHgyOiAke2RUeXBlfSA9IGFicygke2RUeXBlfShyb3cyKSAtIHJvdyk7XG4gICAgICB2YXIgZHkxOiAke2RUeXBlfSA9IGFicyhjb2wgLSAke2RUeXBlfShjb2wxKSk7XG4gICAgICB2YXIgZHkyOiAke2RUeXBlfSA9IGFicygke2RUeXBlfShjb2wyKSAtIGNvbCk7XG4gICAgICBpZiAocm93MSA9PSByb3cyKSB7XG4gICAgICAgIGR4MSA9IDAuNTtcbiAgICAgICAgZHgyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKGNvbDEgPT0gY29sMikge1xuICAgICAgICBkeTEgPSAwLjU7XG4gICAgICAgIGR5MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoeDExICogZHgyICogZHkyICsgeDEyICogZHgyICogZHkxICsgeDIxICogZHgxICogZHkyICsgeDIyICogZHgxICogZHkxKTtcbiAgICB9YDtcbn07XG5cbmNvbnN0IGJpY3ViaWNJbnRlcnBvbGF0aW9uID0gKFxuICBpbnB1dDogSW5kaWNlc0hlbHBlcixcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzY2FsZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICByb2k6IHJlYWRvbmx5IG51bWJlcltdLFxuICBjdWJpY0NvZWZmQTogbnVtYmVyLFxuICB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuLFxuICBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlcixcbiAgZXhjbHVkZU91dHNpZGU6IGJvb2xlYW4sXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBpczJEID0gaW5wdXRTaGFwZS5sZW5ndGggPT09IDI7XG4gIGNvbnN0IGlzTmNodyA9IHRydWU7XG4gIGNvbnN0IFtoZWlnaHRJZHgsIHdpZHRoSWR4XSA9IGlzMkQgPyBbMCwgMV0gOiBpc05jaHcgPyBbMiwgM10gOiBbMSwgMl07XG4gIGNvbnN0IGRUeXBlID0gaW5wdXQudHlwZS52YWx1ZTtcbiAgY29uc3QgY3JlYXRlQ3ViaWNJbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSAoaWR4OiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGlkeCA9PT0gaGVpZ2h0SWR4ID8gJ3JvdycgOiAnY29sJztcbiAgICByZXR1cm4gYFxuICAgICAgZm4gJHtkaXJlY3Rpb259Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfSwgb3V0cHV0X2luZGljZXM6ICR7XG4gICAgICAgIG91dHB1dC50eXBlLmluZGljZXNcbiAgICAgIH0pIC0+ICR7ZFR5cGV9IHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgaWR4KX07XG4gICAgICAgIHZhciBvcmlnaW5hbElkeDogJHtkVHlwZX0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCAke3NjYWxlc1tpZHhdfSxcbiAgICAgICAgJHtvdXRwdXRTaGFwZVtpZHhdfSwgJHtpbnB1dFNoYXBlW2lkeF19LCAke3JvaVtpZHhdfSwgJHtyb2lbaWR4XX0gKyAke2lucHV0U2hhcGUubGVuZ3RofSk7XG4gICAgICAgIHZhciBmcmFjdE9yaWdpbmFsSWR4OiAke2RUeXBlfSA9IG9yaWdpbmFsSWR4IC0gZmxvb3Iob3JpZ2luYWxJZHgpO1xuICAgICAgICB2YXIgY29lZnMgPSBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhmcmFjdE9yaWdpbmFsSWR4KTtcblxuICAgICAgICBpZiAoJHt1c2VFeHRyYXBvbGF0aW9ufSAmJiAob3JpZ2luYWxJZHggPCAwIHx8IG9yaWdpbmFsSWR4ID4gKCR7aW5wdXRTaGFwZVtpZHhdfSAtIDEpKSkge1xuICAgICAgICAgIHJldHVybiAke2V4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGE6IGFycmF5PCR7ZFR5cGV9LCA0PiA9IGFycmF5PCR7ZFR5cGV9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICBmb3IgKHZhciBpOiBpMzIgPSAtMTsgaSA8IDM7IGkrKykge1xuICAgICAgICAgIHZhciAke2RpcmVjdGlvbn06ICR7ZFR5cGV9ID0gb3JpZ2luYWxJZHggKyAke2RUeXBlfShpKTtcbiAgICAgICAgICBpZiAoJHtkaXJlY3Rpb259IDwgMCB8fCAke2RpcmVjdGlvbn0gPj0gJHtpbnB1dFNoYXBlW2lkeF19KSB7XG4gICAgICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChleGNsdWRlT3V0c2lkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgY29lZnNbaSArIDFdID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7YDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh1c2VFeHRyYXBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGByZXR1cm4gJHtleHRyYXBvbGF0aW9uVmFsdWV9O2A7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2RpcmVjdGlvbn0gPSBtYXgoMCwgbWluKCR7ZGlyZWN0aW9ufSwgJHtpbnB1dFNoYXBlW2lkeF19IC0gMSkpO2A7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCl9O1xuICAgICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0X2luZGljZXNfY29weTogJHtpbnB1dC50eXBlLmluZGljZXN9ID0gaW5wdXRfaW5kaWNlcztcbiAgICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXNfY29weScsIGlkeCwgYHUzMigke2RpcmVjdGlvbn0pYCl9O1xuICAgICAgICAgIGRhdGFbaSArIDFdID0gJHtcbiAgICAgICAgICAgIGlkeCA9PT0gaGVpZ2h0SWR4XG4gICAgICAgICAgICAgID8gaW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzX2NvcHknKVxuICAgICAgICAgICAgICA6ICdyb3dDdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlc19jb3B5LCBvdXRwdXRfaW5kaWNlcyknXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoZGF0YSwgY29lZnMpO1xuICAgICAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIGBcbiAgICAke2NyZWF0ZUN1YmljSW50ZXJwb2xhdGlvbkZ1bmN0aW9uKGhlaWdodElkeCl9O1xuICAgICR7Y3JlYXRlQ3ViaWNJbnRlcnBvbGF0aW9uRnVuY3Rpb24od2lkdGhJZHgpfTtcbiAgZm4gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoczogJHtkVHlwZX0pIC0+IGFycmF5PCR7ZFR5cGV9LCA0PiB7XG4gICAgdmFyIGFic1MgPSBhYnMocyk7XG4gICAgdmFyIGNvZWZmczogYXJyYXk8JHtkVHlwZX0sIDQ+ID0gYXJyYXk8JHtkVHlwZX0sIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgdmFyIG9uZU1pbnVzQWJzUzogJHtkVHlwZX0gPSAxLjAgLSBhYnNTO1xuICAgIHZhciB0d29NaW51c0Fic1M6ICR7ZFR5cGV9ID0gMi4wIC0gYWJzUztcbiAgICB2YXIgb25lUGx1c0Fic1M6ICR7ZFR5cGV9ID0gMS4wICsgYWJzUztcbiAgICBjb2VmZnNbMF0gPSAoKCR7Y3ViaWNDb2VmZkF9ICogb25lUGx1c0Fic1MgLSA1ICogJHtjdWJpY0NvZWZmQX0pICogb25lUGx1c0Fic1MgKyA4ICogJHtcbiAgICAgIGN1YmljQ29lZmZBXG4gICAgfSkgKiBvbmVQbHVzQWJzUyAtIDQgKiAke2N1YmljQ29lZmZBfTtcbiAgICBjb2VmZnNbMV0gPSAoKCR7Y3ViaWNDb2VmZkF9ICsgMikgKiBhYnNTIC0gKCR7Y3ViaWNDb2VmZkF9ICsgMykpICogYWJzUyAqIGFic1MgKyAxO1xuICAgIGNvZWZmc1syXSA9ICgoJHtjdWJpY0NvZWZmQX0gKyAyKSAqIG9uZU1pbnVzQWJzUyAtICgke2N1YmljQ29lZmZBfSArIDMpKSAqIG9uZU1pbnVzQWJzUyAqIG9uZU1pbnVzQWJzUyArIDE7XG4gICAgY29lZmZzWzNdID0gKCgke2N1YmljQ29lZmZBfSAqIHR3b01pbnVzQWJzUyAtIDUgKiAke2N1YmljQ29lZmZBfSkgKiB0d29NaW51c0Fic1MgKyA4ICogJHtcbiAgICAgIGN1YmljQ29lZmZBXG4gICAgfSkgKiB0d29NaW51c0Fic1MgLSA0ICogJHtjdWJpY0NvZWZmQX07XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuXG4gIGZuIGN1YmljSW50ZXJwb2xhdGlvbjFEKHg6IGFycmF5PCR7ZFR5cGV9LCA0PiwgY29lZnM6IGFycmF5PCR7ZFR5cGV9LCA0PikgLT4gJHtkVHlwZX0ge1xuICAgIHZhciBjb2Vmc1N1bTogJHtkVHlwZX0gPSBjb2Vmc1swXSArIGNvZWZzWzFdICsgY29lZnNbMl0gKyBjb2Vmc1szXTtcbiAgICByZXR1cm4gKHhbMF0gKiBjb2Vmc1swXSArIHhbMV0gKiBjb2Vmc1sxXSsgeFsyXSAqIGNvZWZzWzJdKyB4WzNdICogY29lZnNbM10pIC8gY29lZnNTdW07XG4gIH1cblxuICBmbiBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtkVHlwZX0ge1xuICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc30gPSBvdXRwdXRfaW5kaWNlcztcbiAgICByZXR1cm4gY29sQ3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXMsIG91dHB1dF9pbmRpY2VzKTtcbiAgfVxuICAgIGA7XG59O1xuXG5jb25zdCB0cmlsaW5lYXJJbnRlcnBvbGF0aW9uID0gKFxuICBpbnB1dDogSW5kaWNlc0hlbHBlcixcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgdXNlRXh0cmFwb2xhdGlvbjogYm9vbGVhbixcbiAgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXIsXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBpc05jaHcgPSB0cnVlO1xuICBjb25zdCBbYmF0Y2hJZHgsIGRlcHRoSWR4LCBoZWlnaHRJZHgsIHdpZHRoSWR4LCBjaGFubmVsSWR4XSA9XG4gICAgaW5wdXRTaGFwZS5sZW5ndGggPT09IDMgPyBbLTEsIDAsIDEsIDIsIC0xXSA6IGlzTmNodyA/IFswLCAyLCAzLCA0LCAxXSA6IFswLCAxLCAyLCAzLCA0XTtcbiAgY29uc3QgZFR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICByZXR1cm4gYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCBkZXB0aDp1MzIsIGhlaWdodDogdTMyLCB3aWR0aDogdTMyKSAtPiAke2RUeXBlfSB7XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgZGVwdGhJZHgsIGBtYXgoMCwgbWluKGRlcHRoLCAke2lucHV0U2hhcGVbZGVwdGhJZHhdfSAtIDEpKWApfTtcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGhlaWdodElkeCwgYG1heCgwLCBtaW4oaGVpZ2h0LCAke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSlgKX07XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCB3aWR0aElkeCwgYG1heCgwLCBtaW4od2lkdGgsICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpYCl9O1xuICAgICAgJHtzZXRDaGFubmVsQW5kQmF0Y2hJbmRpY2VzKGlucHV0LCBjaGFubmVsSWR4LCBiYXRjaElkeCwgMyl9XG4gICAgICByZXR1cm4gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07XG4gICAgfVxuXG4gICAgZm4gdHJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtkVHlwZX0ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciBkZXB0aDoke2RUeXBlfSA9IG9yaWdpbmFsSW5kaWNlc1ske2RlcHRoSWR4fV07XG4gICAgICB2YXIgaGVpZ2h0OiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7aGVpZ2h0SWR4fV07XG4gICAgICB2YXIgd2lkdGg6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHt3aWR0aElkeH1dO1xuICAgICAgJHtcbiAgICAgICAgdXNlRXh0cmFwb2xhdGlvblxuICAgICAgICAgID8gYGlmIChkZXB0aCA8IDAgfHwgZGVwdGggPiAoJHtpbnB1dFNoYXBlW2RlcHRoSWR4XX0gLSAxKSB8fCBoZWlnaHQgPCAwIHx8IGhlaWdodCA+ICgke1xuICAgICAgICAgICAgICBpbnB1dFNoYXBlW2hlaWdodElkeF1cbiAgICAgICAgICAgIH0gLSAxKSB8fCB3aWR0aCA8IDAgfHwgKHdpZHRoID4gJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSkge1xuICAgICAgcmV0dXJuICR7ZXh0cmFwb2xhdGlvblZhbHVlfTtcbiAgICAgICAgfWBcbiAgICAgICAgICA6ICcnXG4gICAgICB9O1xuXG4gICAgZGVwdGggPSBtYXgoMCwgbWluKGRlcHRoLCAke2lucHV0U2hhcGVbZGVwdGhJZHhdfSAtIDEpKTtcbiAgICAgIGhlaWdodCA9IG1heCgwLCBtaW4oaGVpZ2h0LCAke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSk7XG4gICAgICB3aWR0aCA9IG1heCgwLCBtaW4od2lkdGgsICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpO1xuICAgICAgdmFyIGRlcHRoMTogdTMyID0gdTMyKGRlcHRoKTtcbiAgICAgIHZhciBoZWlnaHQxOiB1MzIgPSB1MzIoaGVpZ2h0KTtcbiAgICAgIHZhciB3aWR0aDE6IHUzMiA9IHUzMih3aWR0aCk7XG4gICAgICB2YXIgZGVwdGgyOiB1MzIgPSB1MzIoZGVwdGggKyAxKTtcbiAgICAgIHZhciBoZWlnaHQyOiB1MzIgPSB1MzIoaGVpZ2h0ICsgMSk7XG4gICAgICB2YXIgd2lkdGgyOiB1MzIgPSB1MzIod2lkdGggKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke2lucHV0U2hhcGUubGVuZ3RoID4gMyA/IGB1MzIob3JpZ2luYWxJbmRpY2VzWyR7Y2hhbm5lbElkeH1dKWAgOiAnMCd9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtpbnB1dFNoYXBlLmxlbmd0aCA+IDMgPyBgdTMyKG9yaWdpbmFsSW5kaWNlc1ske2JhdGNoSWR4fV0pYCA6ICcwJ307XG5cbiAgICAgIHZhciB4MTExOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTEyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgyKTtcbiAgICAgIHZhciB4MTIxOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTIyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjExOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjEyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjIxOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjIyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciBkeDE6ICR7ZFR5cGV9ID0gYWJzKGRlcHRoIC0gJHtkVHlwZX0oZGVwdGgxKSk7XG4gICAgICB2YXIgZHgyOiAke2RUeXBlfSA9IGFicygke2RUeXBlfShkZXB0aDIpIC0gZGVwdGgpO1xuICAgICAgdmFyIGR5MTogJHtkVHlwZX0gPSBhYnMoaGVpZ2h0IC0gJHtkVHlwZX0oaGVpZ2h0MSkpO1xuICAgICAgdmFyIGR5MjogJHtkVHlwZX0gPSBhYnMoJHtkVHlwZX0oaGVpZ2h0MikgLSBoZWlnaHQpO1xuICAgICAgdmFyIGR6MTogJHtkVHlwZX0gPSBhYnMod2lkdGggLSAke2RUeXBlfSh3aWR0aDEpKTtcbiAgICAgIHZhciBkejI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KHdpZHRoMikgLSB3aWR0aCk7XG4gICAgICBpZiAoZGVwdGgxID09IGRlcHRoMikge1xuICAgICAgICBkeDEgPSAwLjU7XG4gICAgICAgIGR4MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHQxID09IGhlaWdodDIpIHtcbiAgICAgICAgZHkxID0gMC41O1xuICAgICAgICBkeTIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAod2lkdGgxID09IHdpZHRoMikge1xuICAgICAgICBkejEgPSAwLjU7XG4gICAgICAgIGR6MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoeDExMSAqIGR4MiAqIGR5MiAqIGR6MiArIHgxMTIgKiBkeDIgKiBkeTIgKiBkejEgKyB4MTIxICogZHgyICogZHkxICpkejIgKyB4MTIyICogZHgyICogZHkxICogZHoxICtcbiAgICAgICAgICAgICAgeDIxMSAqIGR4MSAqIGR5MiAqIGR6MiArIHgyMTIgKiBkeDEgKiBkeTIgKiBkejEgKyB4MjIxICogZHgxICogZHkxICpkejIgKyB4MjIyICogZHgxICogZHkxICogZHoxKTtcbiAgICB9YDtcbn07XG5cbmNvbnN0IGNyZWF0ZVJlc2l6ZVByb2dyYW1JbmZvID0gKFxuICBpbnB1dFRlbnNvcjogVGVuc29yVmlldyxcbiAgYXR0cmlidXRlczogUmVzaXplQXR0cmlidXRlcyxcbiAgb3BzZXRWZXJzaW9uOiBudW1iZXIsXG4gIHNjYWxlc0lucHV0OiByZWFkb25seSBudW1iZXJbXSxcbiAgc2l6ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICByb2lJbnB1dDogcmVhZG9ubHkgbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dFRlbnNvci5kaW1zO1xuICBjb25zdCByb2kgPSB1cGRhdGVSb0kocm9pSW5wdXQsIGF0dHJpYnV0ZXMuYXhlcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xuXG4gIGxldCBvdXRwdXRTaGFwZSA9IGluaXRPdXRwdXRTaGFwZShpbnB1dFNoYXBlLCBzY2FsZXNJbnB1dCwgc2l6ZXMsIGF0dHJpYnV0ZXMuYXhlcyk7XG4gIGxldCBzY2FsZXMgPSBzY2FsZXNJbnB1dC5zbGljZSgpO1xuICBpZiAoc2NhbGVzSW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgc2NhbGVzID0gaW5wdXRTaGFwZS5tYXAoKHZhbHVlLCBpbmRleCkgPT4gKHZhbHVlID09PSAwID8gMS4wIDogb3V0cHV0U2hhcGVbaW5kZXhdIC8gdmFsdWUpKTtcbiAgICBpZiAoYXR0cmlidXRlcy5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kgIT09ICdzdHJldGNoJykge1xuICAgICAgb3V0cHV0U2hhcGUgPSBhZGp1c3RPdXRwdXRTaGFwZShpbnB1dFNoYXBlLCBzY2FsZXMsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRUZW5zb3IuZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dFRlbnNvci5kYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICBjb25zdCBub1NjYWxlID0gaW5wdXRTaGFwZS5sZW5ndGggPT09IG91dHB1dFNoYXBlLmxlbmd0aCAmJiBpbnB1dFNoYXBlLmV2ZXJ5KChkLCBpKSA9PiBkID09PSBvdXRwdXRTaGFwZVtpXSk7XG4gIGNvbnN0IHVzZUV4dHJhcG9sYXRpb24gPSBhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID09PSAndGZfY3JvcF9hbmRfcmVzaXplJztcbiAgY29uc3QgZXh0cmFwb2xhdGlvblZhbHVlID0gYXR0cmlidXRlcy5leHRyYXBvbGF0aW9uVmFsdWU7XG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXQudHlwZS52YWx1ZTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICAke1xuICAgICAgICBub1NjYWxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogYFxuICAgICAgJHtnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoYXR0cmlidXRlcy5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSwgZGF0YVR5cGUpfTtcbiAgICAgICR7KCgpID0+IHtcbiAgICAgICAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcbiAgICAgICAgICBjYXNlICduZWFyZXN0JzpcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICR7Y2hlY2tJbnB1dEluZGljZXMoaW5wdXQsIGlucHV0U2hhcGUpfTtcbiAgICAgICAgICAgICAgJHtnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwoYXR0cmlidXRlcy5uZWFyZXN0TW9kZSwgb3BzZXRWZXJzaW9uLCBkYXRhVHlwZSl9O1xuICAgICAgICAgICAgICAke2NhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dFNoYXBlLFxuICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlLFxuICAgICAgICAgICAgICAgIHNjYWxlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcm9pLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB1c2VFeHRyYXBvbGF0aW9uLFxuICAgICAgICAgICAgICApfTtcbiAgICAgICAgICAgICAgYDtcbiAgICAgICAgICBjYXNlICdsaW5lYXInOlxuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgJHtjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXQsIGlucHV0U2hhcGUsIG91dHB1dFNoYXBlLCBzY2FsZXMubGVuZ3RoLCByb2kubGVuZ3RoKX07XG4gICAgICAgICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtiaWxpbmVhckludGVycG9sYXRpb24oaW5wdXQsIG91dHB1dCwgaW5wdXRTaGFwZSwgdXNlRXh0cmFwb2xhdGlvbiwgZXh0cmFwb2xhdGlvblZhbHVlKX1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPT09IDMgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHt0cmlsaW5lYXJJbnRlcnBvbGF0aW9uKGlucHV0LCBvdXRwdXQsIGlucHV0U2hhcGUsIHVzZUV4dHJhcG9sYXRpb24sIGV4dHJhcG9sYXRpb25WYWx1ZSl9YDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0xpbmVhciBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyLCAzLCA0IGFuZCA1IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSgpfTtcbiAgICAgICAgICAgIGA7XG4gICAgICAgICAgY2FzZSAnY3ViaWMnOlxuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0U2hhcGUubGVuZ3RoID09PSAyIHx8IGlucHV0U2hhcGUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2JpY3ViaWNJbnRlcnBvbGF0aW9uKFxuICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICAgICAgICBpbnB1dFNoYXBlLFxuICAgICAgICAgICAgICAgICAgb3V0cHV0U2hhcGUsXG4gICAgICAgICAgICAgICAgICBzY2FsZXMsXG4gICAgICAgICAgICAgICAgICByb2ksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmN1YmljQ29lZmZBLFxuICAgICAgICAgICAgICAgICAgdXNlRXh0cmFwb2xhdGlvbixcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuZXh0cmFwb2xhdGlvblZhbHVlLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5leGNsdWRlT3V0c2lkZSxcbiAgICAgICAgICAgICAgICApfWA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0N1YmljIG1vZGUgb25seSBzdXBwb3J0cyBpbnB1dCBkaW1zIDIgYW5kIDQgYXJlIHN1cHBvcnRlZCBpbiBsaW5lYXIgbW9kZS4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKX07XG4gICAgICAgICAgICBgO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCByZXNpemUgbW9kZScpO1xuICAgICAgICB9XG4gICAgICB9KSgpfTtcbiAgICAgIGBcbiAgICAgIH1cbiAgICAgICR7c2hhZGVySGVscGVyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ3NjYWxlcycsICdmMzInLCBzY2FsZXMubGVuZ3RoKVxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdyb2knLCAnZjMyJywgcm9pLmxlbmd0aClcbiAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICAgICAgJHtcbiAgICAgICAgICBub1NjYWxlXG4gICAgICAgICAgICA/ICdvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTsnXG4gICAgICAgICAgICA6IGBcbiAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ25lYXJlc3QnOlxuICAgICAgICAgICAgICByZXR1cm4gYGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHthdHRyaWJ1dGVzLmV4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICAgICAgICAgICAgfWA7XG4gICAgICAgICAgICBjYXNlICdsaW5lYXInOlxuICAgICAgICAgICAgICByZXR1cm4gYG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7XG4gICAgICAgICAgICAgICAgaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDQgPyAnYmlsaW5lYXJJbnRlcnBvbGF0aW9uJyA6ICd0cmlsaW5lYXJJbnRlcnBvbGF0aW9uJ1xuICAgICAgICAgICAgICB9KG91dHB1dF9pbmRpY2VzKTtgO1xuICAgICAgICAgICAgY2FzZSAnY3ViaWMnOlxuICAgICAgICAgICAgICByZXR1cm4gJ291dHB1dFtnbG9iYWxfaWR4XSA9IGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzKTsnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHJlc2l6ZSBtb2RlOiAke2F0dHJpYnV0ZXMubW9kZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCl9O1xuYFxuICAgICAgICB9XG4gICAgICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdSZXNpemUnLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fXwke29wc2V0VmVyc2lvbn18JHtcbiAgICAgICAgc2NhbGVzLmxlbmd0aCA+IDAgPyAoYXR0cmlidXRlcy5tb2RlID09PSAnY3ViaWMnID8gc2NhbGVzIDogc2NhbGVzLmxlbmd0aCkgOiAnJ1xuICAgICAgfXwke3NpemVzLmxlbmd0aCA+IDAgPyBzaXplcyA6ICcnfXwke3JvaS5sZW5ndGggPiAwID8gcm9pIDogJyd9fCR7bm9TY2FsZX18JHtcbiAgICAgICAgYXR0cmlidXRlcy5tb2RlID09PSAnbmVhcmVzdCcgPyBpbnB1dFNoYXBlLmxlbmd0aCA6IGlucHV0U2hhcGVcbiAgICAgIH1gLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddLFxuICAgIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0VGVuc29yLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IHNjYWxlcyB9LFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiByb2kgfSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUpLFxuICAgICAgXSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmNvbnN0IGdldE9wc2V0VmVyc2lvbkZyb21DdXN0b21EYXRhQnVmZmVyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogbnVtYmVyID0+IHtcbiAgY29uc3QgY3VzdG9tRGF0YUJ1ZmZlciA9IGNvbnRleHQuY3VzdG9tRGF0YUJ1ZmZlcjtcbiAgY29uc3QgY3VzdG9tRGF0YUJ1ZmZlcjMyID0gbmV3IFVpbnQzMkFycmF5KGN1c3RvbURhdGFCdWZmZXIsIGN1c3RvbURhdGFCdWZmZXIuYnl0ZU9mZnNldCwgMSk7XG4gIGNvbnN0IG9wc2V0VmVyc2lvbiA9IGN1c3RvbURhdGFCdWZmZXIzMlswXTtcbiAgcmV0dXJuIG9wc2V0VmVyc2lvbjtcbn07XG5cbmV4cG9ydCBjb25zdCByZXNpemUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3Qgc2NhbGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBzaXplczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgcm9pOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8vIE5vdGUgdGhhdCBzY2FsZXMgaW4gcmVzaXplIGFyZSBhbHdheXMgZjMyLiByb2kgY2FuIGJlIGYzMiBvciBmMTYuXG4gIC8vIFRPRE86IEN1cnJlbnRseSB0aGlzIGNvZGUgZG9lcyBub3Qgc3VwcG9ydCBmMTYgZm9yIHJvaSB3aGVuIHBhc3NlZCBhcyBvcHRpb25hbCBpbnB1dC5cblxuICBjb25zdCBvcHNldFZlcnNpb24gPSBnZXRPcHNldFZlcnNpb25Gcm9tQ3VzdG9tRGF0YUJ1ZmZlcihjb250ZXh0KTtcbiAgaWYgKGF0dHJpYnV0ZXMuYW50aWFsaWFzICE9PSAwKSB7XG4gICAgdGhyb3cgRXJyb3IoJ09ubHkgZGVmYXVsdCB2YWx1ZSAoMCkgZm9yIEFudGlhbGlhcyBhdHRyaWJ1dGUgaXMgc3VwcG9ydGVkJyk7XG4gIH1cbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMsIG9wc2V0VmVyc2lvbiwgc2NhbGVzLCBzaXplcywgcm9pKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVJlc2l6ZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCBhdHRyaWJ1dGVzLCBvcHNldFZlcnNpb24sIHNjYWxlcywgc2l6ZXMsIHJvaSksIHtcbiAgICBpbnB1dHM6IFswXSxcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VSZXNpemVBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogUmVzaXplQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFudGlhbGlhcyA9IGF0dHJpYnV0ZXMuYW50aWFsaWFzIGFzIG51bWJlcjtcbiAgY29uc3QgYXhlcyA9IGF0dHJpYnV0ZXMuYXhlcyBhcyBudW1iZXJbXTtcbiAgY29uc3QgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6IENvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID1cbiAgICBhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlIGFzIENvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlO1xuICBjb25zdCBjdWJpY0NvZWZmQSA9IGF0dHJpYnV0ZXMuY3ViaWNDb2VmZkEgYXMgbnVtYmVyO1xuICBjb25zdCBleGNsdWRlT3V0c2lkZSA9IChhdHRyaWJ1dGVzLmV4Y2x1ZGVPdXRzaWRlIGFzIG51bWJlcikgIT09IDA7XG4gIGNvbnN0IGV4dHJhcG9sYXRpb25WYWx1ZSA9IGF0dHJpYnV0ZXMuZXh0cmFwb2xhdGlvblZhbHVlIGFzIG51bWJlcjtcbiAgY29uc3Qga2VlcEFzcGVjdFJhdGlvUG9saWN5OiBLZWVwQXNwZWN0UmF0aW9Qb2xpY3kgPSBhdHRyaWJ1dGVzLmtlZXBBc3BlY3RSYXRpb1BvbGljeSBhcyBLZWVwQXNwZWN0UmF0aW9Qb2xpY3k7XG4gIGNvbnN0IG1vZGU6IE1vZGUgPSBhdHRyaWJ1dGVzLm1vZGUgYXMgTW9kZTtcbiAgLy8gSWYgbmVhcmVzdE1vZGUgaXMgbm90IHNwZWNpZmllZCwgdXNlIHNpbXBsZSBtb2RlLlxuICBjb25zdCBuZWFyZXN0TW9kZTogTmVhcmVzdE1vZGUgPSAoYXR0cmlidXRlcy5uZWFyZXN0TW9kZSA9PT0gJycgPyAnc2ltcGxlJyA6IGF0dHJpYnV0ZXMubmVhcmVzdE1vZGUpIGFzIE5lYXJlc3RNb2RlO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcbiAgICBhbnRpYWxpYXMsXG4gICAgYXhlcyxcbiAgICBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSxcbiAgICBjdWJpY0NvZWZmQSxcbiAgICBleGNsdWRlT3V0c2lkZSxcbiAgICBleHRyYXBvbGF0aW9uVmFsdWUsXG4gICAga2VlcEFzcGVjdFJhdGlvUG9saWN5LFxuICAgIG1vZGUsXG4gICAgbmVhcmVzdE1vZGUsXG4gIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjYXN0VG9GMzIsXG4gIGdldE1heENvbXBvbmVudHMsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHN1bVZlY3RvcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNraXBMYXllck5vcm1BdHRyaWJ1dGVzIHtcbiAgc2ltcGxpZmllZDogYm9vbGVhbjtcbiAgZXBzaWxvbjogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcignbGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDMgaW5wdXRzLicpO1xuICB9XG5cbiAgY29uc3QgaW5wdXQ6IFRlbnNvclZpZXcgPSBpbnB1dHNbMF07XG4gIGNvbnN0IHNraXA6IFRlbnNvclZpZXcgPSBpbnB1dHNbMV07XG4gIGNvbnN0IGdhbW1hOiBUZW5zb3JWaWV3ID0gaW5wdXRzWzJdO1xuXG4gIGlmIChpbnB1dC5kYXRhVHlwZSAhPT0gc2tpcC5kYXRhVHlwZSB8fCBpbnB1dC5kYXRhVHlwZSAhPT0gZ2FtbWEuZGF0YVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZScpO1xuICB9XG5cbiAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSAzICYmIGlucHV0LmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtdXN0IGJlIDJEIG9yIDNEJyk7XG4gIH1cblxuICBpZiAoc2tpcC5kaW1zLmxlbmd0aCAhPT0gMyAmJiBza2lwLmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTa2lwIG11c3QgYmUgMkQgb3IgM0QnKTtcbiAgfVxuXG4gIGNvbnN0IGhpZGRlblNpemUgPSBpbnB1dC5kaW1zW2lucHV0LmRpbXMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gaW5wdXQuZGltc1tpbnB1dC5kaW1zLmxlbmd0aCAtIDJdO1xuICBpZiAoc2tpcC5kaW1zW3NraXAuZGltcy5sZW5ndGggLSAxXSAhPT0gaGlkZGVuU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXQnKTtcbiAgfVxuICBpZiAoc2tpcC5kaW1zW3NraXAuZGltcy5sZW5ndGggLSAyXSAhPT0gc2VxdWVuY2VMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NraXAgbXVzdCBoYXZlIHRoZSBzYW1lIHNlcXVlbmNlIGxlbmd0aCBhcyBpbnB1dCcpO1xuICB9XG5cbiAgaWYgKGdhbW1hLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYW1tYSBtdXN0IGJlIDFEJyk7XG4gIH1cbiAgaWYgKGdhbW1hLmRpbXNbZ2FtbWEuZGltcy5sZW5ndGggLSAxXSAhPT0gaGlkZGVuU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignR2FtbWEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0Jyk7XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPiAzKSB7XG4gICAgY29uc3QgYmV0YTogVGVuc29yVmlldyA9IGlucHV0c1szXTtcbiAgICBpZiAoYmV0YS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCZXRhIG11c3QgYmUgMUQnKTtcbiAgICB9XG4gICAgaWYgKGJldGEuZGltc1tiZXRhLmRpbXMubGVuZ3RoIC0gMV0gIT09IGhpZGRlblNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmV0YSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXQnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPiA0KSB7XG4gICAgY29uc3QgYmlhczogVGVuc29yVmlldyA9IGlucHV0c1s0XTtcbiAgICBpZiAoYmlhcy5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaWFzIG11c3QgYmUgMUQnKTtcbiAgICB9XG4gICAgaWYgKGJpYXMuZGltc1tiaWFzLmRpbXMubGVuZ3RoIC0gMV0gIT09IGhpZGRlblNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmlhcyBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXQnKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVNraXBMYXllck5vcm1Qcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IFNraXBMYXllck5vcm1BdHRyaWJ1dGVzLFxuICBvdXRwdXRDb3VudDogbnVtYmVyLFxuICBpc1RyYWluaW5nOiBib29sZWFuLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBzaW1wbGlmaWVkID0gYXR0cmlidXRlcy5zaW1wbGlmaWVkO1xuXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IGlucHV0U2l6ZTtcbiAgY29uc3QgaGlkZGVuU2l6ZSA9IGlucHV0U2hhcGUuc2xpY2UoLTEpWzBdO1xuICBjb25zdCBtZWFuSW52U3RkRGV2RGltID0gaXNUcmFpbmluZyA/IGlucHV0U2hhcGUuc2xpY2UoMCwgLTEpLmNvbmNhdCgxKSA6IFtdO1xuICBjb25zdCBoYXNCZXRhSW5wdXQgPSAhc2ltcGxpZmllZCAmJiBpbnB1dHMubGVuZ3RoID4gMztcbiAgY29uc3QgaGFzQmlhc0lucHV0ID0gaW5wdXRzLmxlbmd0aCA+IDQ7XG4gIGNvbnN0IGhhc01lYW5PdXRwdXQgPSBpc1RyYWluaW5nICYmIG91dHB1dENvdW50ID4gMTtcbiAgY29uc3QgaGFzSW52U3RkRGV2T3V0cHV0ID0gaXNUcmFpbmluZyAmJiBvdXRwdXRDb3VudCA+IDI7XG4gIGNvbnN0IGhhc0lucHV0U2tpcEJpYXNTdW1PdXRwdXQgPSBvdXRwdXRDb3VudCA+IDM7XG4gIGNvbnN0IHdvcmtncm91cFNpemUgPSA2NDtcblxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhoaWRkZW5TaXplKTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogY29tcG9uZW50cyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBoaWRkZW5TaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5lcHNpbG9uIH0sXG4gIF07XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IHVuaWZvcm1zQXJyYXk6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnY29tcG9uZW50cycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdoaWRkZW5fc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdlcHNpbG9uJywgdHlwZTogJ2YzMicgfSxcbiAgICBdO1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IFtcbiAgICAgIGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCBjb21wb25lbnRzKSxcbiAgICAgIGlucHV0VmFyaWFibGUoJ3NraXAnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLCBjb21wb25lbnRzKSxcbiAgICAgIGlucHV0VmFyaWFibGUoJ2dhbW1hJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY29tcG9uZW50cyksXG4gICAgXTtcbiAgICBpZiAoaGFzQmV0YUlucHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiZXRhJywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcywgY29tcG9uZW50cykpO1xuICAgIH1cbiAgICBpZiAoaGFzQmlhc0lucHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzRdLmRhdGFUeXBlLCBpbnB1dHNbNF0uZGltcywgY29tcG9uZW50cykpO1xuICAgIH1cbiAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cykpO1xuICAgIGlmIChoYXNNZWFuT3V0cHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnbWVhbl9vdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgbWVhbkludlN0ZERldkRpbSkpO1xuICAgIH1cbiAgICBpZiAoaGFzSW52U3RkRGV2T3V0cHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnaW52X3N0ZF9vdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgbWVhbkludlN0ZERldkRpbSkpO1xuICAgIH1cbiAgICBpZiAoaGFzSW5wdXRTa2lwQmlhc1N1bU91dHB1dCkge1xuICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ2lucHV0X3NraXBfYmlhc19zdW0nLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLCBjb21wb25lbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG4gICAgY29uc3QgdmVjRGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoRGF0YVR5cGUuZmxvYXQsIGNvbXBvbmVudHMpO1xuICAgIHJldHVybiBgXG5cbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXNBcnJheSkuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxuICAgICAgdmFyPHdvcmtncm91cD4gc3VtX3NoYXJlZCA6IGFycmF5PCR7dmVjRGF0YVR5cGV9LCAke3dvcmtncm91cFNpemV9PjtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zcXVhcmVkX3NoYXJlZCA6IGFycmF5PCR7dmVjRGF0YVR5cGV9LCAke3dvcmtncm91cFNpemV9PjtcblxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFt3b3JrZ3JvdXBTaXplLCAxLCAxXSl9XG4gICAgICAgIGxldCBpeCA9IGxvY2FsX2lkLng7XG4gICAgICAgIGxldCBpeSA9IGdsb2JhbF9pZC54IC8gJHt3b3JrZ3JvdXBTaXplfTtcblxuICAgICAgICBsZXQgaGlkZGVuX3NpemVfdmVjdG9yaXplZDogdTMyID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgLyB1bmlmb3Jtcy5jb21wb25lbnRzO1xuICAgICAgICB2YXIgc3RyaWRlID0gaGlkZGVuX3NpemVfdmVjdG9yaXplZCAvICR7d29ya2dyb3VwU2l6ZX07XG4gICAgICAgIGxldCBvZmZzZXQgPSBpeCAqIHN0cmlkZSArIGl5ICogaGlkZGVuX3NpemVfdmVjdG9yaXplZDtcbiAgICAgICAgbGV0IG9mZnNldDFkID0gc3RyaWRlICogaXg7XG4gICAgICAgIGlmIChpeCA9PSAke3dvcmtncm91cFNpemUgLSAxfSkge1xuICAgICAgICAgIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLSBzdHJpZGUgKiBpeDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgc3RyaWRlOyBpKyspIHtcbiAgICAgICAgICBsZXQgc2tpcF92YWx1ZSA9IHNraXBbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgbGV0IGJpYXNfdmFsdWUgPSAke2hhc0JpYXNJbnB1dCA/ICdiaWFzW29mZnNldDFkICsgaV0nIDogZGF0YVR5cGUgKyAnKDAuMCknfTtcbiAgICAgICAgICBsZXQgaW5wdXRfdmFsdWUgPSB4W29mZnNldCArIGldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGlucHV0X3ZhbHVlICsgc2tpcF92YWx1ZSArIGJpYXNfdmFsdWU7XG4gICAgICAgICAgJHtoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0ID8gJ2lucHV0X3NraXBfYmlhc19zdW1bb2Zmc2V0ICsgaV0gPSB2YWx1ZTsnIDogJyd9XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gdmFsdWU7XG4gICAgICAgICAgbGV0IGYzMl92YWx1ZSA9ICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAndmFsdWUnKX07XG4gICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlO1xuICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlICogZjMyX3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlX3NpemUgOiB1MzIgPSAke3dvcmtncm91cFNpemV9O1xuICAgICAgICBmb3IgKHZhciBjdXJyX3NpemUgPSByZWR1Y2Vfc2l6ZSA+PiAxOyAgY3Vycl9zaXplID4gMDsgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZV9zaXplID0gY3Vycl9zaXplICsgKHJlZHVjZV9zaXplICYgMSk7XG4gICAgICAgICAgaWYgKGl4IDwgY3Vycl9zaXplKSB7XG4gICAgICAgICAgICBzdW1fc2hhcmVkW2l4XSArPSBzdW1fc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xuICAgICAgICAgICAgc3VtX3NxdWFyZWRfc2hhcmVkW2l4XSArPSBzdW1fc3F1YXJlZF9zaGFyZWRbaXggKyByZWR1Y2Vfc2l6ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdW0gPSBzdW1fc2hhcmVkWzBdO1xuICAgICAgICBsZXQgc3F1YXJlX3N1bSA9IHN1bV9zcXVhcmVkX3NoYXJlZFswXTtcbiAgICAgICAgbGV0IG1lYW4gPSAke3N1bVZlY3Rvcignc3VtJywgY29tcG9uZW50cyl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKTtcbiAgICAgICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoJHtzdW1WZWN0b3IoJ3NxdWFyZV9zdW0nLCBjb21wb25lbnRzKX0gLyBmMzIodW5pZm9ybXMuaGlkZGVuX3NpemUpICR7XG4gICAgICAgICAgc2ltcGxpZmllZCA/ICcnIDogJy0gbWVhbiAqIG1lYW4nXG4gICAgICAgIH0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcbiAgICAgICAgJHtoYXNNZWFuT3V0cHV0ID8gJ21lYW5fb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhbjsnIDogJyd9XG4gICAgICAgICR7aGFzSW52U3RkRGV2T3V0cHV0ID8gJ2ludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXY7JyA6ICcnfVxuXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IChvdXRwdXRbb2Zmc2V0ICsgaV0gJHtzaW1wbGlmaWVkID8gJycgOiBgLSAke2RhdGFUeXBlfShtZWFuKWB9KSAqXG4gICAgICAgICAgICAke2RhdGFUeXBlfShpbnZfc3RkX2RldikgKiBnYW1tYVtvZmZzZXQxZCArIGldXG4gICAgICAgICAgICAke2hhc0JldGFJbnB1dCA/ICcrIGJldGFbb2Zmc2V0MWQgKyBpXScgOiAnJ307XG4gICAgICAgIH1cbiAgICAgIH1gO1xuICB9O1xuICBjb25zdCBvdXRwdXRzID0gW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV07XG4gIGlmIChvdXRwdXRDb3VudCA+IDEpIHtcbiAgICBvdXRwdXRzLnB1c2goeyBkaW1zOiBtZWFuSW52U3RkRGV2RGltLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXQgfSk7XG4gIH1cbiAgaWYgKG91dHB1dENvdW50ID4gMikge1xuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdCB9KTtcbiAgfVxuICBpZiAob3V0cHV0Q291bnQgPiAzKSB7XG4gICAgb3V0cHV0cy5wdXNoKHsgZGltczogaW5wdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdTa2lwTGF5ZXJOb3JtYWxpemF0aW9uJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7Y29tcG9uZW50c307JHtoYXNNZWFuT3V0cHV0fTske2hhc0ludlN0ZERldk91dHB1dH07JHtoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0fWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogaW5wdXRzLm1hcCgoX2lucHV0LCBfaW5kZXgpID0+ICd0eXBlJyksXG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHMsXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7XG4gICAgICAgIHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gaGlkZGVuU2l6ZSksXG4gICAgICB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHNraXBMYXllck5vcm0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNraXBMYXllck5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIFRPRE86IGluaXRpYWxpemUgaXNUcmFpbmluZyBmcm9tIENvbXB1dGVDb250ZXh0XG4gIGNvbnN0IGlzVHJhaW5pbmcgPSBmYWxzZTtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICAvLyBNZWFuIGFuZCBJbnZTdGREZXYgYXJlIG9ubHkgdXNlZCBpbiB0cmFpbmluZyBtb2RlIGFuZCBhcmUgbm90IHJlcXVpcmVkIGZvciBpbmZlcmVuY2UuXG4gIC8vIFRoZXkgYXJlIGFkZGVkIGhlcmUgZm9yIGNvbXBsZXRlbmVzcyBvbmx5LlxuICBjb25zdCBvdXRwdXRzID0gWzBdO1xuICBpZiAoY29udGV4dC5vdXRwdXRDb3VudCA+IDEpIHtcbiAgICBvdXRwdXRzLnB1c2goaXNUcmFpbmluZyA/IDEgOiAtMyk7XG4gIH1cbiAgaWYgKGNvbnRleHQub3V0cHV0Q291bnQgPiAyKSB7XG4gICAgb3V0cHV0cy5wdXNoKGlzVHJhaW5pbmcgPyAyIDogLTMpO1xuICB9XG4gIGlmIChjb250ZXh0Lm91dHB1dENvdW50ID4gMykge1xuICAgIG91dHB1dHMucHVzaCgzKTtcbiAgfVxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlU2tpcExheWVyTm9ybVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLCBjb250ZXh0Lm91dHB1dENvdW50LCBpc1RyYWluaW5nKSwge1xuICAgIG91dHB1dHMsXG4gIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtLCBUZW5zb3JJbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgZ2V0RWxlbWVudEF0LFxuICBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWNlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IHN0YXJ0czogbnVtYmVyW107XG4gIHJlYWRvbmx5IGVuZHM6IG51bWJlcltdO1xuICByZWFkb25seSBheGVzOiBudW1iZXJbXTtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCAhPT0gMCkge1xuICAgIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLnN0YXJ0cy5sZW5ndGggfHwgYXR0cmlidXRlcy5heGVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5lbmRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdheGVzLCBzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLnN0YXJ0cy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuZW5kcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gIH1cbiAgaW5wdXRzLnNsaWNlKDEpLmZvckVhY2goKF8sIGlkeCkgPT4ge1xuICAgIGlmIChpbnB1dHNbaWR4ICsgMV0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDMyICYmIGlucHV0c1tpZHggKyAxXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50NjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtpZHh9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuY29uc3QgcmVhZElucHV0ID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBpZHg6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3QgaW5wdXQ6IG51bWJlcltdID0gW107XG4gIGlmIChpbnB1dHMubGVuZ3RoID4gaWR4KSB7XG4gICAgaWYgKGlucHV0c1tpZHhdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQ2NCkge1xuICAgICAgaW5wdXRzW2lkeF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2goKHYpID0+IGlucHV0LnB1c2goTnVtYmVyKHYpKSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dHNbaWR4XS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50MzIpIHtcbiAgICAgIGlucHV0c1tpZHhdLmdldEludDMyQXJyYXkoKS5mb3JFYWNoKCh2KSA9PiBpbnB1dC5wdXNoKE51bWJlcih2KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7aWR4fSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbmNvbnN0IGNyZWF0ZVNsaWNlQXR0cmlidXRlc0Zyb21JbnB1dHMgPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBTbGljZUF0dHJpYnV0ZXMsXG4pOiBTbGljZUF0dHJpYnV0ZXMgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBzdGFydHM6IG51bWJlcltdID0gcmVhZElucHV0KGlucHV0cywgMSk7XG4gICAgY29uc3QgZW5kczogbnVtYmVyW10gPSByZWFkSW5wdXQoaW5wdXRzLCAyKTtcbiAgICBsZXQgYXhlczogbnVtYmVyW10gPSByZWFkSW5wdXQoaW5wdXRzLCAzKTtcbiAgICBpZiAoYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGF4ZXMgPSBbLi4uQXJyYXkoaW5wdXRzWzBdLmRpbXMubGVuZ3RoKS5rZXlzKCldO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgc3RhcnRzLCBlbmRzLCBheGVzIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG59O1xuXG5jb25zdCBmaXhTdGFydEVuZFZhbHVlcyA9IChcbiAgdmFsdWU6IG51bWJlcixcbiAgaW5kZXg6IG51bWJlcixcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzdGVwczogcmVhZG9ubHkgbnVtYmVyW10sXG4pOiBudW1iZXIgPT4ge1xuICBsZXQgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgaWYgKHZhbHVlIDwgMCkge1xuICAgIG5ld1ZhbHVlICs9IGlucHV0U2hhcGVbYXhlc1tpbmRleF1dO1xuICB9XG4gIGlmIChzdGVwc1tpbmRleF0gPCAwKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKG5ld1ZhbHVlLCBpbnB1dFNoYXBlW2F4ZXNbaW5kZXhdXSAtIDEpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obmV3VmFsdWUsIGlucHV0U2hhcGVbYXhlc1tpbmRleF1dKSk7XG4gIH1cbn07XG5cbmNvbnN0IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0ltcGwgPSAoXG4gIGlucHV0OiBJbmRpY2VzSGVscGVyLFxuICBvdXRwdXQ6IEluZGljZXNIZWxwZXIsXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuKTogc3RyaW5nID0+XG4gIGBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7aW5wdXQudHlwZS5pbmRpY2VzfSB7XG4gICAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICB2YXIgY2FycnkgPSAwdTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gJHtpbnB1dFNoYXBlLmxlbmd0aCAtIDF9OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGlucHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc3RlcHNfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zdGVwcycsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzaWduc19pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnNpZ25zJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0YXJ0c19pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnN0YXJ0cycsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICAgICAgdmFyIGlucHV0X2luZGV4ID0gb3V0cHV0X2luZGV4ICogc3RlcHNfaSArIHN0YXJ0c19pICsgY2Fycnk7XG4gICAgICAgICAgICBjYXJyeSA9IGlucHV0X2luZGV4IC8gaW5wdXRfc2hhcGVfaTtcbiAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfaW5kZXggJSBpbnB1dF9zaGFwZV9pO1xuICAgICAgICAgICAgaWYgKHNpZ25zX2kgPCAwKSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfc2hhcGVfaSAtIGlucHV0X2luZGV4IC0gMXUgKyBzdGFydHNfaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsICdpJywgJ2lucHV0X2luZGV4Jyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5wdXRfaW5kaWNlcztcbiAgICAgIH1gO1xuXG5jb25zdCBjcmVhdGVTbGljZVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBTbGljZUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XG4gIGNvbnN0IGF4ZXMgPVxuICAgIGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwXG4gICAgICA/IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF0dHJpYnV0ZXMuYXhlcywgaW5wdXRTaGFwZS5sZW5ndGgpXG4gICAgICA6IFsuLi5BcnJheShpbnB1dFNoYXBlLmxlbmd0aCkua2V5cygpXTtcbiAgbGV0IHN0ZXBzID0gcmVhZElucHV0KGlucHV0cywgNCk7XG4gIHN0ZXBzLmZvckVhY2goXG4gICAgKHN0ZXApID0+XG4gICAgICBzdGVwICE9PSAwIHx8XG4gICAgICAoKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0ZXAgY2Fubm90IGJlIDAnKTtcbiAgICAgIH0pLFxuICApO1xuICBpZiAoc3RlcHMubGVuZ3RoID09PSAwKSB7XG4gICAgc3RlcHMgPSBBcnJheShheGVzLmxlbmd0aCkuZmlsbCgxKTtcbiAgfVxuICBjb25zdCBzdGFydHMgPSBhdHRyaWJ1dGVzLnN0YXJ0cy5tYXAoKHN0YXJ0LCBpKSA9PiBmaXhTdGFydEVuZFZhbHVlcyhzdGFydCwgaSwgaW5wdXRTaGFwZSwgYXhlcywgc3RlcHMpKTtcblxuICBjb25zdCBlbmRzID0gYXR0cmlidXRlcy5lbmRzLm1hcCgoZW5kLCBpKSA9PiBmaXhTdGFydEVuZFZhbHVlcyhlbmQsIGksIGlucHV0U2hhcGUsIGF4ZXMsIHN0ZXBzKSk7XG5cbiAgaWYgKGF4ZXMubGVuZ3RoICE9PSBzdGFydHMubGVuZ3RoIHx8IGF4ZXMubGVuZ3RoICE9PSBlbmRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQsIGVuZHMgYW5kIGF4ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzJyk7XG4gIH1cblxuICBpZiAoYXhlcy5sZW5ndGggIT09IGlucHV0U2hhcGUubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoIWF4ZXMuaW5jbHVkZXMoaSkpIHtcbiAgICAgICAgc3RhcnRzLnNwbGljZShpLCAwLCAwKTtcbiAgICAgICAgZW5kcy5zcGxpY2UoaSwgMCwgaW5wdXRTaGFwZVtpXSk7XG4gICAgICAgIHN0ZXBzLnNwbGljZShpLCAwLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3Qgc2lnbnMgPSBzdGVwcy5tYXAoKHN0ZXApID0+IE1hdGguc2lnbihzdGVwKSk7XG4gIC8vIENvbnZlcnQgbmVnYXRpdmUgc3RlcHMgdG8gcG9zaXRpdmUgc3RlcHMgYW5kIHJldmVyc2Ugc3RhcnRzIGFuZCBlbmRzXG4gIHN0ZXBzLmZvckVhY2goKHN0ZXAsIGksIGFycmF5KSA9PiB7XG4gICAgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICBjb25zdCBudW1TdGVwcyA9IChlbmRzW2ldIC0gc3RhcnRzW2ldKSAvIHN0ZXA7XG4gICAgICBjb25zdCBuZXdFbmQgPSBzdGFydHNbaV07XG4gICAgICBjb25zdCBuZXdTdGFydCA9IG5ld0VuZCArIG51bVN0ZXBzICogc3RlcHNbaV07XG4gICAgICBzdGFydHNbaV0gPSBuZXdTdGFydDtcbiAgICAgIGVuZHNbaV0gPSBuZXdFbmQ7XG4gICAgICBhcnJheVtpXSA9IC1zdGVwO1xuICAgIH1cbiAgfSk7XG4gIC8vIE91dHB1dCByYW5rIGlzIGV4cGVjdGVkIHRvIGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgaW5wdXQgcmFuay5cbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKDApO1xuICBheGVzLmZvckVhY2goKGF4aXMsIF8pID0+IHtcbiAgICBvdXRwdXRTaGFwZVtheGlzXSA9IE1hdGguY2VpbCgoZW5kc1theGlzXSAtIHN0YXJ0c1theGlzXSkgLyBzdGVwc1theGlzXSk7XG4gIH0pO1xuICBjb25zdCBvdXRwdXRUZW5zb3JJbmZvOiBUZW5zb3JJbmZvID0geyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9O1xuXG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICB7IG5hbWU6ICdvdXRwdXRTaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICB7IG5hbWU6ICdzdGFydHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBzdGFydHMubGVuZ3RoIH0sXG4gICAgeyBuYW1lOiAnc2lnbnMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiBzaWducy5sZW5ndGggfSxcbiAgICB7IG5hbWU6ICdzdGVwcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IHN0ZXBzLmxlbmd0aCB9LFxuICBdO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzdGFydHMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBzaWducyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzdGVwcyB9LFxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBvdXRwdXRTaGFwZSksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuICAgICAgICAke2NhbGN1bGF0ZUlucHV0SW5kaWNlc0ltcGwoaW5wdXQsIG91dHB1dCwgaW5wdXRTaGFwZSl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgbGV0IGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgaW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJykpfVxuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1NsaWNlJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtzaWducy5sZW5ndGh9XyR7c3RhcnRzLmxlbmd0aH1fJHtzdGVwcy5sZW5ndGh9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbb3V0cHV0VGVuc29ySW5mb10sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChpbnB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBzbGljZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU2xpY2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXMgPSBjcmVhdGVTbGljZUF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVNsaWNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKSwgeyBpbnB1dHM6IFswXSB9KTtcbiAgLy8gaWYgKFNoYXBlVXRpbC5zaXplKHByb2dyYW0ub3V0cHV0c1swXS5kaW1zKSA+IDApIHtcbiAgLy8gICBjb250ZXh0LmNvbXB1dGUocHJvZ3JhbUluZm9Mb2FkZXIsIHtpbnB1dHM6IFswXX0pO1xuICAvLyB9IGVsc2Uge1xuICAvLyAgIC8vIFRPRE86IHN1cHBvcnQgZW1wdHkgb3V0cHV0XG4gIC8vICAgdGhyb3cgbmV3IEVycm9yKCdzbGljZTogb3V0cHV0IHNpemUgaXMgMCcpO1xuICAvLyB9XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VTbGljZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBTbGljZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBzdGFydHMgPSBhdHRyaWJ1dGVzLnN0YXJ0cyBhcyBudW1iZXJbXTtcbiAgY29uc3QgZW5kcyA9IGF0dHJpYnV0ZXMuZW5kcyBhcyBudW1iZXJbXTtcbiAgY29uc3QgYXhlcyA9IGF0dHJpYnV0ZXMuYXhlcyBhcyBudW1iZXJbXTtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHN0YXJ0cywgZW5kcywgYXhlcyB9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFRPRE86IHRoaXMgaXMgdGhlIHNhbWUgbmFpdmUgaW1wbGVtZW50YXRpb24gd2UgdXNlIGZvciByZWR1Y2UgdGhhdCBoYXNcbi8vIHBlcmZvcm1hbmNlIGxpbWl0YXRpb25zIHdoZW4gdGhlIHJlZHVjZWQgYXhpcyBpcyBsb25nLiBOZWVkIHRvIGFkZFxuLy8gYSBvcHRpbWl6ZWQgY29kZXBhdGggZm9yIHRoaXMuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyB9IGZyb20gJy4vdHJhbnNwb3NlJztcblxuaW1wb3J0IHtcbiAgZ2V0TWF4Q29tcG9uZW50cyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgc3VtVmVjdG9yLFxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU29mdG1heCBvcCByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFNvZnRtYXhBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXhpczogbnVtYmVyO1xufVxuXG5jb25zdCBjcmVhdGVTb2Z0bWF4UHJvZ3JhbUluZm8gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNvZnRtYXhBdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IGlucHV0ID0gY29udGV4dC5pbnB1dHNbMF07XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dC5kaW1zO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFJhbmspO1xuICBjb25zdCBpc1RyYW5zcG9zZVJlcXVpcmVkID0gYXhpcyA8IGlucHV0U2hhcGUubGVuZ3RoIC0gMTtcbiAgbGV0IHRyYW5zcG9zZWRJbnB1dDogVGVuc29yVmlldztcbiAgbGV0IHBlcm06IG51bWJlcltdID0gW107XG5cbiAgaWYgKGlzVHJhbnNwb3NlUmVxdWlyZWQpIHtcbiAgICBwZXJtID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogaW5wdXRSYW5rIH0sIChfLCBpKSA9PiBpKTtcbiAgICBwZXJtW2F4aXNdID0gaW5wdXRSYW5rIC0gMTtcbiAgICBwZXJtW2lucHV0UmFuayAtIDFdID0gYXhpcztcblxuICAgIHRyYW5zcG9zZWRJbnB1dCA9IGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbnB1dCwgcGVybSksIHtcbiAgICAgIGlucHV0czogW2lucHV0XSxcbiAgICAgIG91dHB1dHM6IFstMV0sXG4gICAgfSlbMF07XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3NlZElucHV0ID0gaW5wdXQ7XG4gIH1cblxuICBjb25zdCB0cmFuc3Bvc2VkSW5wdXRTaGFwZSA9IHRyYW5zcG9zZWRJbnB1dC5kaW1zO1xuICBjb25zdCBjb2xzID0gdHJhbnNwb3NlZElucHV0U2hhcGVbaW5wdXRSYW5rIC0gMV07XG4gIGNvbnN0IHJvd3MgPSBvdXRwdXRTaXplIC8gY29scztcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoY29scyk7XG4gIGNvbnN0IHBhY2tlZENvbHMgPSBjb2xzIC8gY29tcG9uZW50cztcbiAgbGV0IFdHID0gNjQ7XG4gIC8vIElmIG9ubHkgb25lIHdvcmtncm91cCBpcyBkaXNwYXRjaGVkLCBpbmNyZWFzZSB3b3JrZ3JvdXBTaXplIHRvIGltcHJvdmUgcGFyYWxsZWxpc20uXG4gIGlmIChyb3dzID09PSAxKSB7XG4gICAgV0cgPSAyNTY7XG4gIH1cbiAgY29uc3QgbWF4VmVjdG9yID0gKG5hbWU6IHN0cmluZywgY29tcG9uZW50czogbnVtYmVyKSA9PiB7XG4gICAgaWYgKGNvbXBvbmVudHMgPT09IDQpIHtcbiAgICAgIHJldHVybiBgbWF4KG1heCgke25hbWV9LngsICR7bmFtZX0ueSksIG1heCgke25hbWV9LnosICR7bmFtZX0udykpYDtcbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMgPT09IDIpIHtcbiAgICAgIHJldHVybiBgbWF4KCR7bmFtZX0ueCwgJHtuYW1lfS55KWA7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnRzID09PSAzKSB7XG4gICAgICByZXR1cm4gYG1heChtYXgoJHtuYW1lfS54LCAke25hbWV9LnkpLCAke25hbWV9LnopYDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcbiAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCB0cmFuc3Bvc2VkSW5wdXQuZGF0YVR5cGUsIHRyYW5zcG9zZWRJbnB1dC5kaW1zLCBjb21wb25lbnRzKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIHRyYW5zcG9zZWRJbnB1dC5kYXRhVHlwZSwgdHJhbnNwb3NlZElucHV0LmRpbXMsIGNvbXBvbmVudHMpO1xuICBjb25zdCB2YWx1ZVR5cGUgPSB4LnR5cGUudmFsdWU7XG4gIC8vIDYuMi40IGluIHdnc2wgc3BlY1xuICBjb25zdCB0aHJlYWRNYXhEZWNsID1cbiAgICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUodHJhbnNwb3NlZElucHV0LmRhdGFUeXBlKSA9PT0gJ2YzMidcbiAgICAgID8gYHZhciB0aHJlYWRNYXggPSAke3ZhbHVlVHlwZX0oLTMuNDAyODIzZSszOGYpO2BcbiAgICAgIDogYHZhciB0aHJlYWRNYXggPSAke3ZhbHVlVHlwZX0oLTY1NTA0LjBoKTtgO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd01heFNoYXJlZCA6ICR7dmFsdWVUeXBlfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd1N1bVNoYXJlZCA6ICR7dmFsdWVUeXBlfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHRocmVhZFNoYXJlZCA6IGFycmF5PCR7dmFsdWVUeXBlfSwgJHtXR30+O1xuXG4gICAgICBmbiBnZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMikgLT4gJHt2YWx1ZVR5cGV9IHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmV0dXJuIHhbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBmbiBzZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMiwgdmFsdWU6ICR7dmFsdWVUeXBlfSkge1xuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3BhY2tlZENvbHMnLCAnaTMyJykuZGVjbGFyZVZhcmlhYmxlcyh4LCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFdHKX1cbiAgICAgICAgbGV0IGdpbmRleCA9IGkzMihnbG9iYWxfaWR4KTtcbiAgICAgICAgbGV0IGxpbmRleCA9IGkzMihsb2NhbF9pZHgpO1xuICAgICAgICBjb25zdCB3ZyA9ICR7V0d9O1xuICAgICAgICBsZXQgcm93ID0gZ2luZGV4IC8gd2c7XG4gICAgICAgIGxldCBjb2xzID0gdW5pZm9ybXMucGFja2VkQ29scztcbiAgICAgICAgbGV0IHJvd19zdHJpZGUgOiBpMzIgPSB1bmlmb3Jtcy5wYWNrZWRDb2xzO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3MgbWF4XG4gICAgICAgICR7dGhyZWFkTWF4RGVjbH1cbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSk7XG4gICAgICAgICAgdGhyZWFkTWF4ID0gbWF4KHRocmVhZE1heCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPCBjb2xzKSB7XG4gICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRNYXg7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKGNvbHMsIHdnKTtcbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxKSB7XG4gICAgICAgICAgcmVkdWNlU2l6ZSA9IGN1cnJTaXplICsgKHJlZHVjZVNpemUgJiAxKTtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gbWF4KHRocmVhZFNoYXJlZFtsaW5kZXhdLCB0aHJlYWRTaGFyZWRbbGluZGV4ICsgcmVkdWNlU2l6ZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93TWF4U2hhcmVkID0gJHt2YWx1ZVR5cGV9KCR7bWF4VmVjdG9yKCd0aHJlYWRTaGFyZWRbMF0nLCBjb21wb25lbnRzKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIHN1bVxuICAgICAgICB2YXIgdGhyZWFkU3VtID0gJHt2YWx1ZVR5cGV9KDAuMCk7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHN1YkV4cCA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpO1xuICAgICAgICAgIHRocmVhZFN1bSArPSBzdWJFeHA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTdW07XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdnID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgICAgIGlmIChsaW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTaGFyZWRbbGluZGV4XSArIHRocmVhZFNoYXJlZFtsaW5kZXggKyBjdXJyU2l6ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcbiAgICAgICAgICByb3dTdW1TaGFyZWQgPSAke3ZhbHVlVHlwZX0oJHtzdW1WZWN0b3IoJ3RocmVhZFNoYXJlZFswXScsIGNvbXBvbmVudHMpfSk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSByb3dcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKSAvIHJvd1N1bVNoYXJlZDtcbiAgICAgICAgICAvLyBtYXggb3BlcmF0aW9uIHByb3RlY3RzIGFnYWluc3QgTmFOIHNpbmNlIGFsbCB2YWx1ZXMgc2hvdWxkIGJlID49MFxuICAgICAgICAgIHZhbHVlID0gbWF4KHZhbHVlLCAke3ZhbHVlVHlwZX0oMC4wKSk7XG4gICAgICAgICAgc2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfWA7XG4gIGNvbnN0IHJlc3VsdCA9IGNvbnRleHQuY29tcHV0ZShcbiAgICB7XG4gICAgICBuYW1lOiAnU29mdG1heCcsXG4gICAgICAvLyBOb3RlIHRoYXQgaW4gSlNFUCwgV0cgc2l6ZSBpcyBub3QgaW5jbHVkZWQgaW4gY2FjaGUgYnkgZGVmYXVsdCwgYnV0IFdlYkdQVSBFUCBpdCBpcy5cbiAgICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2NvbXBvbmVudHN9OyR7V0d9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZSddIH0sXG4gICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiB0cmFuc3Bvc2VkSW5wdXRTaGFwZSwgZGF0YVR5cGU6IHRyYW5zcG9zZWRJbnB1dC5kYXRhVHlwZSB9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiByb3dzIH0sXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtczogW3sgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IHBhY2tlZENvbHMgfV0sXG4gICAgICB9KSxcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlucHV0czogW3RyYW5zcG9zZWRJbnB1dF0sXG4gICAgICBvdXRwdXRzOiBbaXNUcmFuc3Bvc2VSZXF1aXJlZCA/IC0xIDogMF0sXG4gICAgfSxcbiAgKVswXTtcblxuICBpZiAoaXNUcmFuc3Bvc2VSZXF1aXJlZCkge1xuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhyZXN1bHQsIHBlcm0pLCB7XG4gICAgICBpbnB1dHM6IFtyZXN1bHRdLFxuICAgIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgc29mdG1heCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU29mdG1heEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjcmVhdGVTb2Z0bWF4UHJvZ3JhbUluZm8oY29udGV4dCwgYXR0cmlidXRlcyk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VTb2Z0bWF4QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFNvZnRtYXhBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXIgfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgZ2V0UmVwZWF0cyA9IChyZXBlYXRzVGVuc29yVmlldzogVGVuc29yVmlldyk6IHJlYWRvbmx5IG51bWJlcltdID0+XG4gIEFycmF5LmZyb20ocmVwZWF0c1RlbnNvclZpZXcuZ2V0QmlnSW50NjRBcnJheSgpLCBOdW1iZXIpO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKFxuICAgIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQgJiZcbiAgICBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0MTYgJiZcbiAgICBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDMyICYmXG4gICAgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS51aW50MzJcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIG9ubHkgc3VwcG9ydCBmbG9hdCwgZmxvYXQxNiwgaW50MzIsIGFuZCB1aW50MzIgZGF0YSB0eXBlcycpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50NjQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSBvZiBpbnQ2NCBkYXRhIHR5cGUnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSAxLUQnKTtcbiAgfVxuXG4gIGNvbnN0IHJlcGVhdHM6IHJlYWRvbmx5IG51bWJlcltdID0gZ2V0UmVwZWF0cyhpbnB1dHNbMV0pO1xuXG4gIGlmIChyZXBlYXRzLmxlbmd0aCAhPT0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgaGF2ZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cyBhcyByYW5rIG9mIGlucHV0IGRhdGEgdGVuc29yJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldE91dHB1dFNoYXBlID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCByZXBlYXRzOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgb3V0cHV0U2hhcGUucHVzaChpbnB1dFNoYXBlW2ldICogcmVwZWF0c1tpXSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0U2hhcGU7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVGlsZVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBzaGFwZT86IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IHJlcGVhdHM6IHJlYWRvbmx5IG51bWJlcltdID0gc2hhcGUgPT0gbnVsbCA/IGdldFJlcGVhdHMoaW5wdXRzWzFdKSA6IHNoYXBlO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGdldE91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHJlcGVhdHMpO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9ICR7aW5wdXQuaW5kaWNlcyguLi5pbnB1dFNoYXBlKX07XG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke2lucHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIGxldCBpbnB1dF9kaW1faSA9ICR7aW5wdXQuaW5kaWNlc0dldCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAnaScpfTtcbiAgICAgICAgbGV0IGlucHV0X2RpbV92YWx1ZSA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ2knKX0gICUgaW5wdXRfZGltX2k7XG5cbiAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgJ2knLCAnaW5wdXRfZGltX3ZhbHVlJyl9XG4gICAgICB9XG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGlucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpKX1cbiAgICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdUaWxlJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtyZXBlYXRzfWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgb3V0cHV0U2hhcGUpLFxuICAgICAgXSxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdGlsZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUaWxlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpLCB7IGlucHV0czogWzBdIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgQnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCBjcmVhdGVXaGVyZU9wUHJvZ3JhbVNoYWRlciA9IChcbiAgc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIsXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBkaW1zT3V0cHV0OiByZWFkb25seSBudW1iZXJbXSxcbiAgaXNCcm9hZGNhc3Q6IGJvb2xlYW4sXG4gIHR5cGVPdXRwdXQ6IG51bWJlcixcbikgPT4ge1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0X2RhdGEnLCB0eXBlT3V0cHV0LCBkaW1zT3V0cHV0Lmxlbmd0aCwgNCk7XG4gIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhX2RhdGEnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCwgNCk7XG4gIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiX2RhdGEnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgNCk7XG4gIGNvbnN0IGMgPSBpbnB1dFZhcmlhYmxlKCdjX2RhdGEnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCwgNCk7XG5cbiAgbGV0IGFzc2lnbm1lbnQ6IHN0cmluZztcbiAgY29uc3QgZXhwcmVzc2lvbiA9IChhOiBzdHJpbmcsIGI6IHN0cmluZywgYzogc3RyaW5nKSA9PiBgc2VsZWN0KCR7Yn0sICR7YX0sICR7Y30pYDtcbiAgaWYgKCFpc0Jyb2FkY2FzdCkge1xuICAgIGFzc2lnbm1lbnQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoXG4gICAgICAnZ2xvYmFsX2lkeCcsXG4gICAgICBleHByZXNzaW9uKGEuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSwgYi5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpLCBjLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JykpLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiB7XG4gICAgICBjb25zdCBleHByZXNzaW9uQSA9IGBhX2RhdGFbaW5kZXhfYSR7eH1dW2NvbXBvbmVudF9hJHt4fV1gO1xuICAgICAgY29uc3QgZXhwcmVzc2lvbkIgPSBgYl9kYXRhW2luZGV4X2Ike3h9XVtjb21wb25lbnRfYiR7eH1dYDtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICBjb25zdCBleHByZXNzaW9uQyA9IGBib29sKGNfZGF0YVtpbmRleF9jJHt4fV0gJiAoMHhmZnUgPDwgKGNvbXBvbmVudF9jJHt4fSAqIDgpKSlgO1xuICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7eH11YCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9hJHt4fSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke3h9YCwgb3V0cHV0KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Ike3h9ID0gJHtiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYyR7eH0gPSAke2MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Eke3h9ID0gb2Zmc2V0X2Eke3h9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhfYiR7eH0gPSBvZmZzZXRfYiR7eH0gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleF9jJHt4fSA9IG9mZnNldF9jJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9hJHt4fSA9IG9mZnNldF9hJHt4fSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9iJHt4fSA9IG9mZnNldF9iJHt4fSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9jJHt4fSA9IG9mZnNldF9jJHt4fSAlIDR1O1xuICAgICAgICAgICAgJHtyZXNTdHJ9WyR7eH1dID0gJHt0eXBlQ2FzdH0oJHtleHByZXNzaW9uKGV4cHJlc3Npb25BLCBleHByZXNzaW9uQiwgZXhwcmVzc2lvbkMpfSk7XG4gICAgICAgICAgYDtcbiAgICB9O1xuICAgIGlmICh0eXBlT3V0cHV0ID09PSBEYXRhVHlwZS5ib29sKSB7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAwLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAxLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAyLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAzLCAndTMyJyl9XG4gICAgICAgICAgICBvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDApfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDEpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDIpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDMpfVxuICAgICAgICAgIGA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCd2ZWNfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGMsIGEsIGIsIG91dHB1dCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy52ZWNfc2l6ZScpfVxuICAgICAgICAke2Fzc2lnbm1lbnR9XG4gICAgICB9YDtcbn07XG5cbmNvbnN0IGNyZWF0ZVdoZXJlT3BQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgZGltc0EgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgZGltc0IgPSBpbnB1dHNbMl0uZGltcztcbiAgY29uc3QgZGltc0MgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgb3V0cHV0RGF0YVR5cGUgPSBpbnB1dHNbMV0uZGF0YVR5cGU7XG5cbiAgY29uc3QgaXNCcm9hZGNhc3QgPSAhKFNoYXBlVXRpbC5hcmVFcXVhbChkaW1zQSwgZGltc0IpICYmIFNoYXBlVXRpbC5hcmVFcXVhbChkaW1zQiwgZGltc0MpKTtcbiAgbGV0IG91dHB1dFNoYXBlID0gZGltc0E7XG4gIGxldCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoZGltc0EpO1xuICAvLyBUT0RPOiBkZWFsIHdpdGggemVyby1zaXplZCB0ZW5zb3JzIChlZy4gZGltcz1bMSwwXSlcblxuICBpZiAoaXNCcm9hZGNhc3QpIHtcbiAgICBjb25zdCBjYWxjdWxhdGVkU2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShkaW1zQSwgZGltc0IsIGZhbHNlKSEsIGRpbXNDLCBmYWxzZSk7XG4gICAgaWYgKCFjYWxjdWxhdGVkU2hhcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gd2hlcmUgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7XG4gICAgfVxuICAgIG91dHB1dFNoYXBlID0gY2FsY3VsYXRlZFNoYXBlO1xuICAgIG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIH1cblxuICBjb25zdCB2ZWNTaXplID0gTWF0aC5jZWlsKG91dHB1dFNpemUgLyA0KTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdXaGVyZScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJywgJ3JhbmsnXSB9LFxuICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcikgPT5cbiAgICAgIGNyZWF0ZVdoZXJlT3BQcm9ncmFtU2hhZGVyKHNoYWRlckhlbHBlciwgaW5wdXRzLCBvdXRwdXRTaGFwZSwgaXNCcm9hZGNhc3QsIG91dHB1dERhdGFUeXBlKSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyAvIDQgLyogdmVjIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHZlY1NpemUgfSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoZGltc0MsIGRpbXNBLCBkaW1zQiwgb3V0cHV0U2hhcGUpLFxuICAgICAgXSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB3aGVyZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlV2hlcmVPcFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBhcmdNYXgsIGFyZ01pbiwgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvYXJnbWlubWF4JztcbmltcG9ydCB7IGF0dGVudGlvbiB9IGZyb20gJy4vb3BzL2F0dGVudGlvbic7XG5pbXBvcnQgeyBiYXRjaE5vcm0gfSBmcm9tICcuL29wcy9iYXRjaC1ub3JtJztcbmltcG9ydCB7IGJpYXNBZGQgfSBmcm9tICcuL29wcy9iaWFzLWFkZCc7XG5pbXBvcnQgeyBiaWFzU3BsaXRHZWx1IH0gZnJvbSAnLi9vcHMvYmlhcy1zcGxpdC1nZWx1JztcbmltcG9ydCAqIGFzIGJpbmFyeU9wcyBmcm9tICcuL29wcy9iaW5hcnktb3AnO1xuaW1wb3J0IHsgY29uY2F0LCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9jb25jYXQnO1xuaW1wb3J0IHsgY29udiwgcGFyc2VDb252QXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2NvbnYnO1xuaW1wb3J0IHsgY29udlRyYW5zcG9zZSwgcGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2NvbnYtdHJhbnNwb3NlJztcbmltcG9ydCB7IGN1bXN1bSwgcGFyc2VDdW1TdW1BdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvY3Vtc3VtJztcbmltcG9ydCB7IGRlcHRoVG9TcGFjZSwgcGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZGVwdGgtdG8tc3BhY2UnO1xuaW1wb3J0IHsgZWluc3VtLCBwYXJzZUVpbnN1bUF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9laW5zdW0nO1xuaW1wb3J0IHsgZXhwYW5kIH0gZnJvbSAnLi9vcHMvZXhwYW5kJztcbmltcG9ydCB7IGZhc3RHZWx1IH0gZnJvbSAnLi9vcHMvZmFzdC1nZWx1JztcbmltcG9ydCB7IGdhdGhlciwgcGFyc2VHYXRoZXJBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZ2F0aGVyJztcbmltcG9ydCB7IGdhdGhlck5ELCBwYXJzZUdhdGhlck5EQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2dhdGhlci1uZCc7XG5pbXBvcnQgeyBnYXRoZXJCbG9ja1F1YW50aXplZCwgcGFyc2VHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9nYXRoZXItYmxvY2stcXVhbnRpemVkJztcbmltcG9ydCB7IGdhdGhlckVsZW1lbnRzLCBwYXJzZUdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2dhdGhlci1lbGVtZW50cyc7XG5pbXBvcnQgeyBnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZ2VtbSc7XG5pbXBvcnQgeyBncmlkU2FtcGxlLCBwYXJzZUdyaWRTYW1wbGVBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZ3JpZC1zYW1wbGUnO1xuaW1wb3J0IHsgZ3JvdXBRdWVyeUF0dGVudGlvbiB9IGZyb20gJy4vb3BzL2dyb3VwLXF1ZXJ5LWF0dGVudGlvbic7XG5pbXBvcnQgeyBpbnN0YW5jZU5vcm0gfSBmcm9tICcuL29wcy9pbnN0YW5jZS1ub3JtJztcbmltcG9ydCB7IGxheWVyTm9ybSB9IGZyb20gJy4vb3BzL2xheWVyLW5vcm0nO1xuaW1wb3J0IHsgbWF0TXVsIH0gZnJvbSAnLi9vcHMvbWF0bXVsJztcbmltcG9ydCB7IG1hdE11bE5CaXRzLCBwYXJzZU1hdE11bE5CaXRzQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL21hdG11bG5iaXRzJztcbmltcG9ydCB7IG11bHRpSGVhZEF0dGVudGlvbiwgcGFyc2VNdWx0aUhlYWRBdHRlbnRpb25BdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvbXVsdGloZWFkLWF0dGVudGlvbic7XG5pbXBvcnQgeyBwYWQgfSBmcm9tICcuL29wcy9wYWQnO1xuaW1wb3J0ICogYXMgcG9vbCBmcm9tICcuL29wcy9wb29sJztcbmltcG9ydCB7IGRlcXVhbnRpemVMaW5lYXIsIHBhcnNlRGVxdWFudGl6ZUxpbmVhckF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9xdWFudGl6ZS1saW5lYXInO1xuaW1wb3J0IHsgcmFuZ2UgfSBmcm9tICcuL29wcy9yYW5nZSc7XG5pbXBvcnQgeyBzY2F0dGVyTkQsIHBhcnNlU2NhdHRlck5EQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL3NjYXR0ZXItbmQnO1xuaW1wb3J0IHtcbiAgcmVkdWNlTDEsXG4gIHJlZHVjZUwyLFxuICByZWR1Y2VMb2dTdW0sXG4gIHJlZHVjZUxvZ1N1bUV4cCxcbiAgcmVkdWNlTWF4LFxuICByZWR1Y2VNZWFuLFxuICByZWR1Y2VNaW4sXG4gIHJlZHVjZVByb2QsXG4gIHJlZHVjZVN1bSxcbiAgcmVkdWNlU3VtU3F1YXJlLFxufSBmcm9tICcuL29wcy9yZWR1Y2UnO1xuaW1wb3J0IHsgcGFyc2VSZXNpemVBdHRyaWJ1dGVzLCByZXNpemUgfSBmcm9tICcuL29wcy9yZXNpemUnO1xuaW1wb3J0IHsgcm90YXJ5RW1iZWRkaW5nIH0gZnJvbSAnLi9vcHMvcm90YXJ5LWVtYmVkZGluZyc7XG5pbXBvcnQgeyBza2lwTGF5ZXJOb3JtIH0gZnJvbSAnLi9vcHMvc2tpcC1sYXllci1ub3JtJztcbmltcG9ydCB7IHBhcnNlU2xpY2VBdHRyaWJ1dGVzLCBzbGljZSB9IGZyb20gJy4vb3BzL3NsaWNlJztcbmltcG9ydCB7IHBhcnNlU29mdG1heEF0dHJpYnV0ZXMsIHNvZnRtYXggfSBmcm9tICcuL29wcy9zb2Z0bWF4JztcbmltcG9ydCB7IHBhcnNlU3BsaXRBdHRyaWJ1dGVzLCBzcGxpdCB9IGZyb20gJy4vb3BzL3NwbGl0JztcbmltcG9ydCB7IHRpbGUgfSBmcm9tICcuL29wcy90aWxlJztcbmltcG9ydCB7IHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlcywgdHJhbnNwb3NlIH0gZnJvbSAnLi9vcHMvdHJhbnNwb3NlJztcbmltcG9ydCAqIGFzIHVuYXJ5T3BzIGZyb20gJy4vb3BzL3VuYXJ5LW9wJztcbmltcG9ydCB7IHdoZXJlIH0gZnJvbSAnLi9vcHMvd2hlcmUnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgUnVuRnVuY3Rpb24gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZT86IHVua25vd24pID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBQYXJzZUF0dHJpYnV0ZUZ1bmN0aW9uID0gKGF0dHJpYnV0ZVJhdzogdW5rbm93bikgPT4gdW5rbm93bjtcbmV4cG9ydCB0eXBlIE9wZXJhdG9ySW1wbGVtZW50YXRpb24gPSBbUnVuRnVuY3Rpb25dIHwgW1J1bkZ1bmN0aW9uLCBQYXJzZUF0dHJpYnV0ZUZ1bmN0aW9uXTtcblxuZXhwb3J0IGNvbnN0IFdFQkdQVV9PUF9SRVNPTFZFX1JVTEVTOiBNYXA8c3RyaW5nLCBPcGVyYXRvckltcGxlbWVudGF0aW9uPiA9IG5ldyBNYXAoW1xuICBbJ0FicycsIFt1bmFyeU9wcy5hYnNdXSxcbiAgWydBY29zJywgW3VuYXJ5T3BzLmFjb3NdXSxcbiAgWydBY29zaCcsIFt1bmFyeU9wcy5hY29zaF1dLFxuICBbJ0FkZCcsIFtiaW5hcnlPcHMuYWRkXV0sXG4gIFsnQXJnTWF4JywgW2FyZ01heCwgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzXV0sXG4gIFsnQXJnTWluJywgW2FyZ01pbiwgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzXV0sXG4gIFsnQXNpbicsIFt1bmFyeU9wcy5hc2luXV0sXG4gIFsnQXNpbmgnLCBbdW5hcnlPcHMuYXNpbmhdXSxcbiAgWydBdGFuJywgW3VuYXJ5T3BzLmF0YW5dXSxcbiAgWydBdGFuaCcsIFt1bmFyeU9wcy5hdGFuaF1dLFxuICBbJ0F0dGVudGlvbicsIFthdHRlbnRpb25dXSxcbiAgLy8gVE9ETzogc3VwcG9ydCBuZXcgYXR0cmlidXRlcyBmb3IgQXZlcmFnZVBvb2wtMTBcbiAgWydBdmVyYWdlUG9vbCcsIFtwb29sLmF2ZXJhZ2VQb29sLCBwb29sLnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXV0sXG4gIFsnQmF0Y2hOb3JtYWxpemF0aW9uJywgW2JhdGNoTm9ybV1dLFxuICBbJ0JpYXNBZGQnLCBbYmlhc0FkZF1dLFxuICBbJ0JpYXNTcGxpdEdlbHUnLCBbYmlhc1NwbGl0R2VsdV1dLFxuICBbJ0Nhc3QnLCBbdW5hcnlPcHMuY2FzdCwgdW5hcnlPcHMucGFyc2VDYXN0QXR0cmlidXRlc11dLFxuICBbJ0NlaWwnLCBbdW5hcnlPcHMuY2VpbF1dLFxuICBbJ0NsaXAnLCBbdW5hcnlPcHMuY2xpcF1dLFxuICBbJ0NvbmNhdCcsIFtjb25jYXQsIHBhcnNlQ29uY2F0QXR0cmlidXRlc11dLFxuICBbJ0NvbnYnLCBbY29udiwgcGFyc2VDb252QXR0cmlidXRlc11dLFxuICBbJ0NvbnZUcmFuc3Bvc2UnLCBbY29udlRyYW5zcG9zZSwgcGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlc11dLFxuICBbJ0NvcycsIFt1bmFyeU9wcy5jb3NdXSxcbiAgWydDb3NoJywgW3VuYXJ5T3BzLmNvc2hdXSxcbiAgWydDdW1TdW0nLCBbY3Vtc3VtLCBwYXJzZUN1bVN1bUF0dHJpYnV0ZXNdXSxcbiAgWydEZXB0aFRvU3BhY2UnLCBbZGVwdGhUb1NwYWNlLCBwYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXNdXSxcbiAgWydEZXF1YW50aXplTGluZWFyJywgW2RlcXVhbnRpemVMaW5lYXIsIHBhcnNlRGVxdWFudGl6ZUxpbmVhckF0dHJpYnV0ZXNdXSxcbiAgWydEaXYnLCBbYmluYXJ5T3BzLmRpdl1dLFxuICBbJ0VpbnN1bScsIFtlaW5zdW0sIHBhcnNlRWluc3VtQXR0cmlidXRlc11dLFxuICBbJ0VsdScsIFt1bmFyeU9wcy5lbHUsIHVuYXJ5T3BzLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sXG4gIFsnRXF1YWwnLCBbYmluYXJ5T3BzLmVxdWFsXV0sXG4gIFsnRXJmJywgW3VuYXJ5T3BzLmVyZl1dLFxuICBbJ0V4cCcsIFt1bmFyeU9wcy5leHBdXSxcbiAgWydFeHBhbmQnLCBbZXhwYW5kXV0sXG4gIFsnRmFzdEdlbHUnLCBbZmFzdEdlbHVdXSxcbiAgWydGbG9vcicsIFt1bmFyeU9wcy5mbG9vcl1dLFxuICBbJ0Z1c2VkQ29udicsIFtjb252LCBwYXJzZUNvbnZBdHRyaWJ1dGVzXV0sXG4gIFsnR2F0aGVyJywgW2dhdGhlciwgcGFyc2VHYXRoZXJBdHRyaWJ1dGVzXV0sXG4gIFsnR2F0aGVyRWxlbWVudHMnLCBbZ2F0aGVyRWxlbWVudHMsIHBhcnNlR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzXV0sXG4gIFsnR2F0aGVyQmxvY2tRdWFudGl6ZWQnLCBbZ2F0aGVyQmxvY2tRdWFudGl6ZWQsIHBhcnNlR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzXV0sXG4gIFsnR2F0aGVyTkQnLCBbZ2F0aGVyTkQsIHBhcnNlR2F0aGVyTkRBdHRyaWJ1dGVzXV0sXG4gIFsnR2VsdScsIFt1bmFyeU9wcy5nZWx1XV0sXG4gIFsnR2VtbScsIFtnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzXV0sXG4gIFsnR2xvYmFsQXZlcmFnZVBvb2wnLCBbcG9vbC5nbG9iYWxBdmVyYWdlUG9vbCwgcG9vbC5wYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlc11dLFxuICBbJ0dsb2JhbE1heFBvb2wnLCBbcG9vbC5nbG9iYWxNYXhQb29sLCBwb29sLnBhcnNlR2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXNdXSxcbiAgWydHcmVhdGVyJywgW2JpbmFyeU9wcy5ncmVhdGVyXV0sXG4gIFsnR3JlYXRlck9yRXF1YWwnLCBbYmluYXJ5T3BzLmdyZWF0ZXJPckVxdWFsXV0sXG4gIFsnR3JpZFNhbXBsZScsIFtncmlkU2FtcGxlLCBwYXJzZUdyaWRTYW1wbGVBdHRyaWJ1dGVzXV0sXG4gIFsnR3JvdXBRdWVyeUF0dGVudGlvbicsIFtncm91cFF1ZXJ5QXR0ZW50aW9uXV0sXG4gIFsnSGFyZFNpZ21vaWQnLCBbdW5hcnlPcHMuaGFyZFNpZ21vaWQsIHVuYXJ5T3BzLnBhcnNlSGFyZFNpZ21vaWRBdHRyaWJ1dGVzXV0sXG4gIFsnSW5zdGFuY2VOb3JtYWxpemF0aW9uJywgW2luc3RhbmNlTm9ybV1dLFxuICBbJ0xheWVyTm9ybWFsaXphdGlvbicsIFtsYXllck5vcm1dXSxcbiAgWydMZWFreVJlbHUnLCBbdW5hcnlPcHMubGVha3lSZWx1LCB1bmFyeU9wcy5wYXJzZUFscGhhQXR0cmlidXRlc11dLFxuICBbJ0xlc3MnLCBbYmluYXJ5T3BzLmxlc3NdXSxcbiAgWydMZXNzT3JFcXVhbCcsIFtiaW5hcnlPcHMubGVzc09yRXF1YWxdXSxcbiAgWydMb2cnLCBbdW5hcnlPcHMubG9nXV0sXG4gIFsnTWF0TXVsJywgW21hdE11bF1dLFxuICBbJ01hdE11bE5CaXRzJywgW21hdE11bE5CaXRzLCBwYXJzZU1hdE11bE5CaXRzQXR0cmlidXRlc11dLFxuICAvLyBUT0RPOiBzdXBwb3J0IG5ldyBhdHRyaWJ1dGVzIGZvciBNYXhQb29sLTggYW5kIE1heFBvb2wtMTBcbiAgWydNYXhQb29sJywgW3Bvb2wubWF4UG9vbCwgcG9vbC5wYXJzZU1heFBvb2xBdHRyaWJ1dGVzXV0sXG4gIFsnTXVsJywgW2JpbmFyeU9wcy5tdWxdXSxcbiAgWydNdWx0aUhlYWRBdHRlbnRpb24nLCBbbXVsdGlIZWFkQXR0ZW50aW9uLCBwYXJzZU11bHRpSGVhZEF0dGVudGlvbkF0dHJpYnV0ZXNdXSxcbiAgWydOZWcnLCBbdW5hcnlPcHMubmVnXV0sXG4gIFsnTm90JywgW3VuYXJ5T3BzLm5vdF1dLFxuICBbJ1BhZCcsIFtwYWRdXSxcbiAgWydQb3cnLCBbYmluYXJ5T3BzLnBvd11dLFxuICBbJ1F1aWNrR2VsdScsIFt1bmFyeU9wcy5xdWlja2dlbHUsIHVuYXJ5T3BzLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sXG4gIFsnUmFuZ2UnLCBbcmFuZ2VdXSxcbiAgWydSZWNpcHJvY2FsJywgW3VuYXJ5T3BzLnJlY2lwcm9jYWxdXSxcbiAgWydSZWR1Y2VNaW4nLCBbcmVkdWNlTWluXV0sXG4gIFsnUmVkdWNlTWVhbicsIFtyZWR1Y2VNZWFuXV0sXG4gIFsnUmVkdWNlTWF4JywgW3JlZHVjZU1heF1dLFxuICBbJ1JlZHVjZVN1bScsIFtyZWR1Y2VTdW1dXSxcbiAgWydSZWR1Y2VQcm9kJywgW3JlZHVjZVByb2RdXSxcbiAgWydSZWR1Y2VMMScsIFtyZWR1Y2VMMV1dLFxuICBbJ1JlZHVjZUwyJywgW3JlZHVjZUwyXV0sXG4gIFsnUmVkdWNlTG9nU3VtJywgW3JlZHVjZUxvZ1N1bV1dLFxuICBbJ1JlZHVjZUxvZ1N1bUV4cCcsIFtyZWR1Y2VMb2dTdW1FeHBdXSxcbiAgWydSZWR1Y2VTdW1TcXVhcmUnLCBbcmVkdWNlU3VtU3F1YXJlXV0sXG4gIFsnUmVsdScsIFt1bmFyeU9wcy5yZWx1XV0sXG4gIFsnUmVzaXplJywgW3Jlc2l6ZSwgcGFyc2VSZXNpemVBdHRyaWJ1dGVzXV0sXG4gIFsnUm90YXJ5RW1iZWRkaW5nJywgW3JvdGFyeUVtYmVkZGluZ11dLFxuICBbJ1NjYXR0ZXJORCcsIFtzY2F0dGVyTkQsIHBhcnNlU2NhdHRlck5EQXR0cmlidXRlc11dLFxuICBbJ1NpZ21vaWQnLCBbdW5hcnlPcHMuc2lnbW9pZF1dLFxuICBbJ1NpbicsIFt1bmFyeU9wcy5zaW5dXSxcbiAgWydTaW5oJywgW3VuYXJ5T3BzLnNpbmhdXSxcbiAgWydTbGljZScsIFtzbGljZSwgcGFyc2VTbGljZUF0dHJpYnV0ZXNdXSxcbiAgWydTa2lwTGF5ZXJOb3JtYWxpemF0aW9uJywgW3NraXBMYXllck5vcm1dXSxcbiAgWydTcGxpdCcsIFtzcGxpdCwgcGFyc2VTcGxpdEF0dHJpYnV0ZXNdXSxcbiAgWydTcXJ0JywgW3VuYXJ5T3BzLnNxcnRdXSxcbiAgWydTb2Z0bWF4JywgW3NvZnRtYXgsIHBhcnNlU29mdG1heEF0dHJpYnV0ZXNdXSxcbiAgWydTdWInLCBbYmluYXJ5T3BzLnN1Yl1dLFxuICBbJ1RhbicsIFt1bmFyeU9wcy50YW5dXSxcbiAgWydUYW5oJywgW3VuYXJ5T3BzLnRhbmhdXSxcbiAgWydUaHJlc2hvbGRlZFJlbHUnLCBbdW5hcnlPcHMudGhyZXNob2xkZWRSZWx1LCB1bmFyeU9wcy5wYXJzZUFscGhhQXR0cmlidXRlc11dLFxuICBbJ1RpbGUnLCBbdGlsZV1dLFxuICBbJ1RyYW5zcG9zZScsIFt0cmFuc3Bvc2UsIHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlc11dLFxuICBbJ1doZXJlJywgW3doZXJlXV0sXG5dKTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVFJBQ0VfRlVOQ19CRUdJTiwgVFJBQ0VfRlVOQ19FTkQgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBXZWJHcHVCYWNrZW5kIH0gZnJvbSAnLi4vYmFja2VuZC13ZWJncHUnO1xuaW1wb3J0IHsgTE9HX0RFQlVHIH0gZnJvbSAnLi4vbG9nJztcblxuaW1wb3J0IHsgY3JlYXRlU2hhZGVySGVscGVyIH0gZnJvbSAnLi9vcHMvY29tbW9uJztcbmltcG9ydCB7IEFydGlmYWN0LCBHcHVEYXRhLCBQcm9ncmFtSW5mbyB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIFByb2dyYW1NYW5hZ2VyIGlzIHRoZSBtYWluIGNsYXNzIGJlaGluZCBydW5uaW5nIGNvbXB1dGF0aW9uc1xuICogSXQgYnVpbGRzIFByb2dyYW1JbmZvJ3MgaW50byBBcnRpZmFjdHNcbiAqIEl0IGNvbXBpbGVzIGdpdmVuIFByb2dyYW1JbmZvJ3MgaW50byBXZWJHTCBQcm9yYW1zIChjYWNoZWQgYXMgQXJ0aWZhY3RzKVxuICogVXNlcyB0aGUgYXJ0aWZhY3QgdG8gcnVuIHRoZSBjb21wdXRhdGlvbiBieSBjYWxsaW5nIERyYXcgb25cbiAqIHRoZSBXZWJHTCBkcmF3aW5nIGJ1ZmZlclxuICogUHJvZ3JhbU1hbmFnZXIgYXV0b21hdGljYWxseSBtYXBzIChiaW5kcykgaW5wdXQgdmFyaWFibGVzIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIExvY2F0aW9uJ3MgaW4gdGhlIGJpbmFyeSBwcm9ncmFtXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9ncmFtTWFuYWdlciB7XG4gIHJlcG86IE1hcDx1bmtub3duLCBBcnRpZmFjdD47IC8vIHRoaXMgc2hvdWxkIGJlIHBlci1zZXNzaW9uIG9iamVjdFxuICBhdHRyaWJ1dGVzQm91bmQ6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBiYWNrZW5kOiBXZWJHcHVCYWNrZW5kKSB7XG4gICAgdGhpcy5yZXBvID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXR0cmlidXRlc0JvdW5kID0gZmFsc2U7XG4gIH1cbiAgZ2V0QXJ0aWZhY3Qoa2V5OiB1bmtub3duKTogQXJ0aWZhY3QgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJlcG8uZ2V0KGtleSk7XG4gIH1cbiAgc2V0QXJ0aWZhY3Qoa2V5OiB1bmtub3duLCBhcnRpZmFjdDogQXJ0aWZhY3QpOiB2b2lkIHtcbiAgICB0aGlzLnJlcG8uc2V0KGtleSwgYXJ0aWZhY3QpO1xuICB9XG4gIHJ1bihcbiAgICBidWlsZEFydGlmYWN0OiBBcnRpZmFjdCxcbiAgICBpbnB1dHM6IEdwdURhdGFbXSxcbiAgICBvdXRwdXRzOiBHcHVEYXRhW10sXG4gICAgZGlzcGF0Y2hHcm91cDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgIHVuaWZvcm1CdWZmZXJCaW5kaW5nOiBHUFVCaW5kaW5nUmVzb3VyY2UgfCB1bmRlZmluZWQsXG4gICk6IHZvaWQge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oYnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lKTtcbiAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmJhY2tlbmQuZGV2aWNlO1xuICAgIGNvbnN0IGNvbXB1dGVQYXNzRW5jb2RlciA9IHRoaXMuYmFja2VuZC5nZXRDb21wdXRlUGFzc0VuY29kZXIoKTtcbiAgICB0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIpO1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgZW50cmllcy5wdXNoKHsgYmluZGluZzogZW50cmllcy5sZW5ndGgsIHJlc291cmNlOiB7IGJ1ZmZlcjogaW5wdXQuYnVmZmVyIH0gfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgIGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGVudHJpZXMubGVuZ3RoLCByZXNvdXJjZTogeyBidWZmZXI6IG91dHB1dC5idWZmZXIgfSB9KTtcbiAgICB9XG4gICAgaWYgKHVuaWZvcm1CdWZmZXJCaW5kaW5nKSB7XG4gICAgICBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBlbnRyaWVzLmxlbmd0aCwgcmVzb3VyY2U6IHVuaWZvcm1CdWZmZXJCaW5kaW5nIH0pO1xuICAgIH1cbiAgICBjb25zdCBiaW5kR3JvdXAgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKHtcbiAgICAgIGxheW91dDogYnVpbGRBcnRpZmFjdC5jb21wdXRlUGlwZWxpbmUuZ2V0QmluZEdyb3VwTGF5b3V0KDApLFxuICAgICAgZW50cmllcyxcbiAgICAgIGxhYmVsOiBidWlsZEFydGlmYWN0LnByb2dyYW1JbmZvLm5hbWUsXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXMgPT09ICdjYXB0dXJpbmcnKSB7XG4gICAgICBjb25zdCBjb21tYW5kSW5mbyA9IHtcbiAgICAgICAga2VybmVsSWQ6IHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsSWQhLFxuICAgICAgICBjb21wdXRlUGlwZWxpbmU6IGJ1aWxkQXJ0aWZhY3QuY29tcHV0ZVBpcGVsaW5lLFxuICAgICAgICBiaW5kR3JvdXAsXG4gICAgICAgIGRpc3BhdGNoR3JvdXAsXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2Vzc2lvbkNvbW1hbmRMaXN0ID0gdGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkISk7XG4gICAgICBzZXNzaW9uQ29tbWFuZExpc3QhLnB1c2goY29tbWFuZEluZm8pO1xuICAgIH1cblxuICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRQaXBlbGluZShidWlsZEFydGlmYWN0LmNvbXB1dGVQaXBlbGluZSk7XG4gICAgY29tcHV0ZVBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCgwLCBiaW5kR3JvdXApO1xuICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5kaXNwYXRjaFdvcmtncm91cHMoLi4uZGlzcGF0Y2hHcm91cCk7XG4gICAgdGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICsgMSk7XG4gICAgdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlciA+PSB0aGlzLmJhY2tlbmQubWF4RGlzcGF0Y2hOdW1iZXIgfHxcbiAgICAgIHRoaXMuYmFja2VuZC5xdWVyeVR5cGUgPT09ICdhdC1wYXNzZXMnXG4gICAgKSB7XG4gICAgICB0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgPj0gdGhpcy5iYWNrZW5kLm1heERpc3BhdGNoTnVtYmVyKSB7XG4gICAgICB0aGlzLmJhY2tlbmQuZmx1c2goKTtcbiAgICB9XG4gICAgVFJBQ0VfRlVOQ19FTkQoYnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lKTtcbiAgfVxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIC8vIHRoaXMucmVwby5mb3JFYWNoKGEgPT4gdGhpcy5nbENvbnRleHQuZGVsZXRlUHJvZ3JhbShhLnByb2dyYW0pKTtcbiAgfVxuICBidWlsZChwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogQXJ0aWZhY3Qge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4ocHJvZ3JhbUluZm8ubmFtZSk7XG4gICAgY29uc3QgZGV2aWNlID0gdGhpcy5iYWNrZW5kLmRldmljZTtcbiAgICBjb25zdCBlbmFibGVEaXJlY3RpdmVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gRW5hYmxlIFdHU0wgZXh0ZW5zaW9ucyBiYXNlZCBvbiBhdmFpbGFibGUgV2ViR1BVIGZlYXR1cmVzXG4gICAgY29uc3QgZXh0ZW5zaW9uc0luZm86IEFycmF5PHsgZmVhdHVyZTogR1BVRmVhdHVyZU5hbWU7IGV4dGVuc2lvbjogc3RyaW5nIH0+ID0gW1xuICAgICAgeyBmZWF0dXJlOiAnc2hhZGVyLWYxNicsIGV4dGVuc2lvbjogJ2YxNicgfSxcbiAgICAgIHsgZmVhdHVyZTogJ3N1Ymdyb3VwcycgYXMgR1BVRmVhdHVyZU5hbWUsIGV4dGVuc2lvbjogJ3N1Ymdyb3VwcycgfSxcbiAgICBdO1xuICAgIGV4dGVuc2lvbnNJbmZvLmZvckVhY2goKGluZm8pID0+IHtcbiAgICAgIGlmIChkZXZpY2UuZmVhdHVyZXMuaGFzKGluZm8uZmVhdHVyZSkpIHtcbiAgICAgICAgZW5hYmxlRGlyZWN0aXZlcy5wdXNoKGBlbmFibGUgJHtpbmZvLmV4dGVuc2lvbn07YCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBzaGFkZXJIZWxwZXIgPSBjcmVhdGVTaGFkZXJIZWxwZXIobm9ybWFsaXplZERpc3BhdGNoR3JvdXBTaXplLCB0aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cyk7XG4gICAgY29uc3QgdXNlckNvZGUgPSBwcm9ncmFtSW5mby5nZXRTaGFkZXJTb3VyY2Uoc2hhZGVySGVscGVyKTtcbiAgICBjb25zdCBjb2RlID0gYCR7ZW5hYmxlRGlyZWN0aXZlcy5qb2luKCdcXG4nKX1cXG4ke3NoYWRlckhlbHBlci5hZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zfVxcbiR7dXNlckNvZGV9YDtcbiAgICBjb25zdCBzaGFkZXJNb2R1bGUgPSBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHsgY29kZSwgbGFiZWw6IHByb2dyYW1JbmZvLm5hbWUgfSk7XG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdICR7cHJvZ3JhbUluZm8ubmFtZX0gc2hhZGVyIGNvZGU6ICR7Y29kZX1gKTtcblxuICAgIGNvbnN0IGNvbXB1dGVQaXBlbGluZSA9IGRldmljZS5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe1xuICAgICAgY29tcHV0ZTogeyBtb2R1bGU6IHNoYWRlck1vZHVsZSwgZW50cnlQb2ludDogJ21haW4nIH0sXG4gICAgICBsYXlvdXQ6ICdhdXRvJyxcbiAgICAgIGxhYmVsOiBwcm9ncmFtSW5mby5uYW1lLFxuICAgIH0pO1xuXG4gICAgVFJBQ0VfRlVOQ19FTkQocHJvZ3JhbUluZm8ubmFtZSk7XG4gICAgcmV0dXJuIHsgcHJvZ3JhbUluZm8sIGNvbXB1dGVQaXBlbGluZSwgdW5pZm9ybVZhcmlhYmxlc0luZm86IHNoYWRlckhlbHBlci52YXJpYWJsZXNJbmZvIH07XG4gIH1cblxuICBub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZShcbiAgICBkaXNwYXRjaEdyb3VwOiBSZXR1cm5UeXBlPFByb2dyYW1JbmZvWydnZXRSdW5EYXRhJ10+WydkaXNwYXRjaEdyb3VwJ10sXG4gICk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gICAgY29uc3QgeCA9IHR5cGVvZiBkaXNwYXRjaEdyb3VwID09PSAnbnVtYmVyJyA/IGRpc3BhdGNoR3JvdXAgOiBkaXNwYXRjaEdyb3VwLng7XG4gICAgY29uc3QgeSA9IHR5cGVvZiBkaXNwYXRjaEdyb3VwID09PSAnbnVtYmVyJyA/IDEgOiBkaXNwYXRjaEdyb3VwLnkgfHwgMTtcbiAgICBjb25zdCB6ID0gdHlwZW9mIGRpc3BhdGNoR3JvdXAgPT09ICdudW1iZXInID8gMSA6IGRpc3BhdGNoR3JvdXAueiB8fCAxO1xuICAgIGNvbnN0IGxpbWl0UGVyRGltZW5zaW9uID0gdGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb247XG4gICAgaWYgKHggPD0gbGltaXRQZXJEaW1lbnNpb24gJiYgeSA8PSBsaW1pdFBlckRpbWVuc2lvbiAmJiB6IDw9IGxpbWl0UGVyRGltZW5zaW9uKSB7XG4gICAgICByZXR1cm4gW3gsIHksIHpdO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0geCAqIHkgKiB6O1xuICAgIGxldCBkaXNwYXRjaEF2ZXJhZ2UgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KHNpemUpKTtcbiAgICBpZiAoZGlzcGF0Y2hBdmVyYWdlID4gbGltaXRQZXJEaW1lbnNpb24pIHtcbiAgICAgIGRpc3BhdGNoQXZlcmFnZSA9IE1hdGguY2VpbChNYXRoLmNicnQoc2l6ZSkpO1xuICAgICAgaWYgKGRpc3BhdGNoQXZlcmFnZSA+IGxpbWl0UGVyRGltZW5zaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVG90YWwgZGlzcGF0Y2ggc2l6ZSBleGNlZWRzIFdlYkdQVSBtYXhpbXVtLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtkaXNwYXRjaEF2ZXJhZ2UsIGRpc3BhdGNoQXZlcmFnZSwgZGlzcGF0Y2hBdmVyYWdlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtkaXNwYXRjaEF2ZXJhZ2UsIGRpc3BhdGNoQXZlcmFnZSwgMV07XG4gICAgfVxuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEVudiwgVGVuc29yLCBUUkFDRSwgVFJBQ0VfRlVOQ19CRUdJTiwgVFJBQ0VfRlVOQ19FTkQgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBEYXRhVHlwZSwgdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcgfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XG5cbmltcG9ydCB7IGNvbmZpZ3VyZUxvZ2dlciwgTE9HX0RFQlVHIH0gZnJvbSAnLi9sb2cnO1xuaW1wb3J0IHsgY3JlYXRlVmlldywgVGVuc29yVmlldyB9IGZyb20gJy4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgY3JlYXRlR3B1RGF0YU1hbmFnZXIsIGRvd25sb2FkR3B1RGF0YSwgR3B1RGF0YU1hbmFnZXIgfSBmcm9tICcuL3dlYmdwdS9ncHUtZGF0YS1tYW5hZ2VyJztcbmltcG9ydCB7IFJ1bkZ1bmN0aW9uLCBXRUJHUFVfT1BfUkVTT0xWRV9SVUxFUyB9IGZyb20gJy4vd2ViZ3B1L29wLXJlc29sdmUtcnVsZXMnO1xuaW1wb3J0IHsgUHJvZ3JhbU1hbmFnZXIgfSBmcm9tICcuL3dlYmdwdS9wcm9ncmFtLW1hbmFnZXInO1xuaW1wb3J0IHtcbiAgQWRhcHRlckluZm8sXG4gIENvbXB1dGVDb250ZXh0LFxuICBHcHVBcmNoaXRlY3R1cmUsXG4gIEdwdURhdGEsXG4gIEdwdVZlbmRvcixcbiAgUHJvZ3JhbUluZm8sXG4gIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LFxuICBTZXNzaW9uU3RhdGUsXG4gIFRpbWVzdGFtcFF1ZXJ5LFxufSBmcm9tICcuL3dlYmdwdS90eXBlcyc7XG5cbmludGVyZmFjZSBDb21tYW5kSW5mbyB7XG4gIHJlYWRvbmx5IGtlcm5lbElkOiBudW1iZXI7XG4gIHJlYWRvbmx5IGNvbXB1dGVQaXBlbGluZTogR1BVQ29tcHV0ZVBpcGVsaW5lO1xuICByZWFkb25seSBiaW5kR3JvdXA6IEdQVUJpbmRHcm91cDtcbiAgcmVhZG9ubHkgZGlzcGF0Y2hHcm91cDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xufVxuXG5pbnRlcmZhY2UgS2VybmVsSW5mbyB7XG4gIHJlYWRvbmx5IGtlcm5lbFR5cGU6IHN0cmluZztcbiAgcmVhZG9ubHkga2VybmVsTmFtZTogc3RyaW5nO1xuICByZWFkb25seSBrZXJuZWxFbnRyeTogUnVuRnVuY3Rpb247XG4gIHJlYWRvbmx5IGF0dHJpYnV0ZXM6IFsoKGF0dHJpYnV0ZTogdW5rbm93bikgPT4gdW5rbm93bikgfCB1bmRlZmluZWQsIHVua25vd25dO1xufVxuXG5pbnRlcmZhY2UgUGVuZGluZ0tlcm5lbEluZm8ge1xuICByZWFkb25seSBrZXJuZWxJZDogbnVtYmVyO1xuICByZWFkb25seSBwcm9ncmFtTmFtZTogc3RyaW5nO1xuICByZWFkb25seSBpbnB1dFRlbnNvclZpZXdzOiByZWFkb25seSBUZW5zb3JWaWV3W107XG4gIHJlYWRvbmx5IG91dHB1dFRlbnNvclZpZXdzOiByZWFkb25seSBUZW5zb3JWaWV3W107XG59XG5cbmNvbnN0IGdldFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5S2V5ID0gKFxuICBpbnB1dFRlbnNvcnM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgaW5wdXREZXBlbmRlbmNpZXM6IHJlYWRvbmx5IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10sXG4pOiBzdHJpbmcgPT4ge1xuICBpZiAoaW5wdXREZXBlbmRlbmNpZXMubGVuZ3RoICE9PSBpbnB1dFRlbnNvcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGlucHV0RGVwZW5kZW5jaWVzIGxlbmd0aCAke2lucHV0RGVwZW5kZW5jaWVzLmxlbmd0aH0gaXMgbm90IGVxdWFsIHRvIGlucHV0VGVuc29ycyBsZW5ndGggJHtcbiAgICAgICAgaW5wdXRUZW5zb3JzLmxlbmd0aFxuICAgICAgfS5gLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBpbnB1dEluZm9zOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0VGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHR5cGUgPSBpbnB1dFRlbnNvcnNbaV0uZGF0YVR5cGU7XG4gICAgc3dpdGNoIChpbnB1dERlcGVuZGVuY2llc1tpXSkge1xuICAgICAgY2FzZSAnbm9uZSc6IHtcbiAgICAgICAgaW5wdXRJbmZvcy5wdXNoKCcnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICd0eXBlJzoge1xuICAgICAgICBpbnB1dEluZm9zLnB1c2goYCR7dHlwZX1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdyYW5rJzoge1xuICAgICAgICBjb25zdCByYW5rID0gaW5wdXRUZW5zb3JzW2ldLmRpbXMubGVuZ3RoO1xuICAgICAgICBpbnB1dEluZm9zLnB1c2goYCR7dHlwZX07JHtyYW5rfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2RpbXMnOiB7XG4gICAgICAgIGNvbnN0IGRpbXMgPSBpbnB1dFRlbnNvcnNbaV0uZGltcy5qb2luKCcsJyk7XG4gICAgICAgIGlucHV0SW5mb3MucHVzaChgJHt0eXBlfTske2RpbXN9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBpbnB1dCBkZXBlbmRlbmN5OiAke2lucHV0RGVwZW5kZW5jaWVzW2ldfWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnB1dEluZm9zLmpvaW4oJ3wnKTtcbn07XG5cbi8qKlxuICogZ2V0IGEgdW5pcXVlIGtleSByZXByZXNlbnRpbmcgdGhlIHByb2dyYW0gZnJvbSB0aGUgcHJvZ3JhbSBpbmZvLCBpbnB1dCBzaGFwZXMgYW5kIHR5cGVzLlxuICpcbiAqIEByZXR1cm5zIGEgdW5pcXVlIGtleSBpcyBhIHNob3J0ZXIgc3RyaW5nIHRoYW4gdGhlIHNoYWRlciBzb3VyY2UsIHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgaW5mb3JtYXRpb24gdG8gaWRlbnRpZnkgYVxuICogcHJvZ3JhbS4gaWYgdGhlIGtleSBpcyB0aGUgc2FtZSwgdGhlIHByb2dyYW0gc2hhZGVyIHNvdXJjZSBzaG91bGQgYmUgdGhlIHNhbWUsIHNvIHdlIGNhbiByZXVzZSB0aGUgcHJvZ3JhbS5cbiAqXG4gKi9cbmNvbnN0IGdldFByb2dyYW1JbmZvVW5pcXVlS2V5ID0gKFxuICBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sXG4gIGlucHV0VGVuc29yczogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBpczFEaW1lbnNpb25EaXNwYXRjaDogYm9vbGVhbixcbik6IHN0cmluZyA9PiB7XG4gIC8vIGZpbmFsIGtleSBmb3JtYXQ6XG4gIC8vIDxQUk9HUkFNX05BTUU+WzxQUk9HUkFNX0NVU1RPTV9DQUNIRV9ISU5UPl06aXMxRGltZW5zaW9uRGlzcGF0Y2g6PElOUFVUU19JTkZPXzA+fDxJTlBVVFNfSU5GT18xPnwuLi5cbiAgbGV0IGtleSA9IHByb2dyYW1JbmZvLm5hbWU7XG4gIGlmIChwcm9ncmFtSW5mby5zaGFkZXJDYWNoZT8uaGludCkge1xuICAgIGtleSArPSAnWycgKyBwcm9ncmFtSW5mby5zaGFkZXJDYWNoZS5oaW50ICsgJ10nO1xuICB9XG4gIGtleSArPVxuICAgICc6JyArXG4gICAgaXMxRGltZW5zaW9uRGlzcGF0Y2ggK1xuICAgIGA6JHtnZXRQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeUtleShcbiAgICAgIGlucHV0VGVuc29ycyxcbiAgICAgIHByb2dyYW1JbmZvLnNoYWRlckNhY2hlPy5pbnB1dERlcGVuZGVuY2llcyA/P1xuICAgICAgICBuZXcgQXJyYXk8UHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3k+KGlucHV0VGVuc29ycy5sZW5ndGgpLmZpbGwoJ2RpbXMnKSxcbiAgICApfWA7XG4gIHJldHVybiBrZXk7XG59O1xuXG5jbGFzcyBBZGFwdGVySW5mb0ltcGwgaW1wbGVtZW50cyBBZGFwdGVySW5mbyB7XG4gIHJlYWRvbmx5IGFyY2hpdGVjdHVyZT86IHN0cmluZztcbiAgcmVhZG9ubHkgdmVuZG9yPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXJJbmZvOiBHUFVBZGFwdGVySW5mbykge1xuICAgIGlmIChhZGFwdGVySW5mbykge1xuICAgICAgdGhpcy5hcmNoaXRlY3R1cmUgPSBhZGFwdGVySW5mby5hcmNoaXRlY3R1cmU7XG4gICAgICB0aGlzLnZlbmRvciA9IGFkYXB0ZXJJbmZvLnZlbmRvcjtcbiAgICB9XG4gIH1cblxuICBpc0FyY2hpdGVjdHVyZShhcmNoaXRlY3R1cmU6IEdwdUFyY2hpdGVjdHVyZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFyY2hpdGVjdHVyZSA9PT0gYXJjaGl0ZWN0dXJlO1xuICB9XG5cbiAgaXNWZW5kb3IodmVuZG9yOiBHcHVWZW5kb3IpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy52ZW5kb3IgPT09IHZlbmRvcjtcbiAgfVxufVxuXG4vKipcbiAqIHRoaXMgY2xhc3MgaXMgZGVzaWduZWQgdG8gc3RvcmUgc3RhdHVzIGFuZCBiZWluZyB1c2VkIGFzIGEgc2luZ2xldG9uIGZvciBKU0VQLiBJdCB3aWxsIGJlIHBhc3NlZCB0byBqc2VwSW5pdCgpIGFzXG4gKiB0aGUgZmlyc3QgcGFyYW1ldGVyIHNvIHRoYXQgaXQgaXMgc3RvcmVkIGZvciBmdXR1cmUgdXNlLlxuICovXG5leHBvcnQgY2xhc3MgV2ViR3B1QmFja2VuZCB7XG4gIGFkYXB0ZXJJbmZvOiBBZGFwdGVySW5mb0ltcGw7XG4gIGRldmljZTogR1BVRGV2aWNlO1xuICAvKipcbiAgICogYW4gaW5zdGFuY2Ugb2YgR3B1RGF0YU1hbmFnZXIgdG8gbWFuYWdlIGEgR3B1RGF0YUlkIC0+IEdwdUJ1ZmZlciBtYXBwaW5nXG4gICAqL1xuICBncHVEYXRhTWFuYWdlcjogR3B1RGF0YU1hbmFnZXI7XG4gIC8qKlxuICAgKiBhbiBpbnN0YW5jZSBvZiBQcm9ncmFtTWFuYWdlciB0byBidWlsZCBhbmQgcnVuIFdlYkdQVSBjb21wdXRlIHNoYWRlciBwcm9ncmFtLCBhbmQgbWFuYWdlIGEgUHJvZ3JhbUtleSAtPiBQcm9ncmFtXG4gICAqIGFydGlmYWN0cyBtYXBwaW5nXG4gICAqL1xuICBwcm9ncmFtTWFuYWdlcjogUHJvZ3JhbU1hbmFnZXI7XG5cbiAgLyoqXG4gICAqIHJlcHJlc2VudGluZyB0aGUgc2Vzc2lvbiBJRCBvZiB3aGljaCBpcyBjdXJyZW50bHkgYmVpbmcgcnVuLlxuICAgKiBgbnVsbGAgbWVhbnMgbm8gc2Vzc2lvbiBpcyBiZWluZyBydW4uXG4gICAqIG9ubHkgdmFsaWQgd2hlbiBzZXNzaW9uLnJ1biBpcyBleGVjdXRlZC5cbiAgICovXG4gIGN1cnJlbnRTZXNzaW9uSWQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiByZXByZXNlbnRpbmcgdGhlIGtlcm5lbCBJRCBvZiB3aGljaCBpcyBjdXJyZW50bHkgYmVpbmcgY29tcHV0ZWQgKENQVSBjb2RlIHBlcnNwZWN0aXZlKS5cbiAgICogYG51bGxgIG1lYW5zIG5vIGtlcm5lbCBpcyBiZWluZyBjb21wdXRlZC5cbiAgICogb25seSBvbmUga2VybmVsIGNhbiBiZSBjb21wdXRlZCBhdCBhIG1vbWVudC5cbiAgICovXG4gIGN1cnJlbnRLZXJuZWxJZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIC8qKlxuICAgKiBhIGxpc3Qgb2YgdGVtcG9yYXJ5IEdQVSBkYXRhIGZvciB0aGUgY3VycmVudCBrZXJuZWwuIHNob3VsZCByZWxlYXNlIHdoZW4gdGhlIGtlcm5lbCBkb25lIGNvbXB1dGF0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSB0ZW1wb3JhcnlEYXRhOiBHcHVEYXRhW107XG4gIC8qKlxuICAgKiBhIEtlcm5lbElEIC0+IGEgR1BVIGRhdGEgbGlzdCwgd2hpY2ggc3RvcmVzIHBlcnNpc3RlbnQgR1BVIGRhdGEgb3duZWQgYnkgdGhlIHNwZWNpZmljIGtlcm5lbC5cbiAgICovXG4gIHByaXZhdGUga2VybmVsUGVyc2lzdGVudERhdGE6IE1hcDxudW1iZXIsIEdwdURhdGFbXT47XG4gIC8qKlxuICAgKiBhIEtlcm5lbElEIC0+IGEgY3VzdG9tIGRhdGEsIHdoaWNoIHN0b3JlcyBjdXN0b20gZGF0YSBvd25lZCBieSB0aGUgc3BlY2lmaWMga2VybmVsLlxuICAgKi9cbiAgcHJpdmF0ZSBrZXJuZWxDdXN0b21EYXRhOiBNYXA8bnVtYmVyLCB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfT47XG4gIC8qKlxuICAgKiBnZXQgdGhlIGN1c3RvbSBkYXRhIG9mIHRoZSBjdXJyZW50IGtlcm5lbFxuICAgKi9cbiAgZ2V0IGN1cnJlbnRLZXJuZWxDdXN0b21EYXRhKCk6IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9IHtcbiAgICBpZiAodGhpcy5jdXJyZW50S2VybmVsSWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogY3VycmVudEtlcm5lbElkIGlzIG51bGwuIChzaG91bGQgbm90IGhhcHBlbiknKTtcbiAgICB9XG5cbiAgICBsZXQgZGF0YSA9IHRoaXMua2VybmVsQ3VzdG9tRGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgdGhpcy5rZXJuZWxDdXN0b21EYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCwgZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvLyBLZXJuZWxJRCAtPiBrZXJuZWxJbmZvIG1hcHBpbmdcbiAga2VybmVsczogTWFwPG51bWJlciwgS2VybmVsSW5mbz47XG4gIHByaXZhdGUgY29tbWFuZEVuY29kZXI6IEdQVUNvbW1hbmRFbmNvZGVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgY29tcHV0ZVBhc3NFbmNvZGVyOiBHUFVDb21wdXRlUGFzc0VuY29kZXIgfCBudWxsID0gbnVsbDtcbiAgbWF4RGlzcGF0Y2hOdW1iZXIgPSAxNjtcbiAgcGVuZGluZ0Rpc3BhdGNoTnVtYmVyID0gMDtcblxuICAvLyBpbmZvIG9mIGtlcm5lbHMgcGVuZGluZyBzdWJtaXNzaW9uIGZvciBhIHNpbmdsZSBiYXRjaFxuICBwcml2YXRlIHBlbmRpbmdLZXJuZWxzOiBQZW5kaW5nS2VybmVsSW5mb1tdID0gW107XG4gIC8vIHF1ZXJ5UmVhZEJ1ZmZlciAtPiBwZW5kaW5nS2VybmVscyBtYXBwaW5nIGZvciBhbGwgdGhlIGJhdGNoZXNcbiAgcHJpdmF0ZSBwZW5kaW5nUXVlcmllczogTWFwPEdQVUJ1ZmZlciwgUGVuZGluZ0tlcm5lbEluZm9bXT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgcXVlcnlSZXNvbHZlQnVmZmVyPzogR1BVQnVmZmVyO1xuICBwcml2YXRlIHF1ZXJ5U2V0PzogR1BVUXVlcnlTZXQ7XG4gIHByaXZhdGUgcXVlcnlUaW1lQmFzZT86IGJpZ2ludDtcbiAgcXVlcnlUeXBlOiBUaW1lc3RhbXBRdWVyeTtcblxuICBlbnY6IEVudjtcbiAgc2Vzc2lvblN0YXR1czogU2Vzc2lvblN0YXRlID0gJ2RlZmF1bHQnO1xuICAvKipcbiAgICogYSBTZXNzaW9uSUQgLT4gQ29tbWFuZEluZm9bXSBtYXBwaW5nLiBJdCdzIHVzZWQgdG8gcmVjb3JkIGFsbCBHUFUgY29tbWFuZHMgZm9yIGNvcnJlc3BvbmRpbmcgc2Vzc2lvbi5cbiAgICovXG4gIGNhcHR1cmVkQ29tbWFuZExpc3Q6IE1hcDxudW1iZXIsIENvbW1hbmRJbmZvW10+ID0gbmV3IE1hcCgpO1xuXG4gIC8qKlxuICAgKiBhIFNlc3Npb25JRCAtPiBQZW5kaW5nS2VybmVsSW5mb1tdIG1hcHBpbmcgZm9yIHByb2ZpbGluZy5cbiAgICovXG4gIHByaXZhdGUgY2FwdHVyZWRQZW5kaW5nS2VybmVsczogTWFwPG51bWJlciwgUGVuZGluZ0tlcm5lbEluZm9bXT4gPSBuZXcgTWFwKCk7XG5cbiAgLyoqXG4gICAqIGEgU2Vzc2lvbklEIC0+IGEgTWFwIG9mIChJbnB1dE91dHB1dEluZGV4IC0+IFtJRCwgR1BVQnVmZmVyXSkgbWFwcGluZy5cbiAgICovXG4gIHNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nOiBNYXA8bnVtYmVyLCBNYXA8bnVtYmVyLCBbbnVtYmVyLCBHUFVCdWZmZXJdPj4gPSBuZXcgTWFwKCk7XG5cbiAgYXN5bmMgaW5pdGlhbGl6ZShlbnY6IEVudiwgYWRhcHRlcjogR1BVQWRhcHRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIGNvbnN0IHJlcXVpcmVkRmVhdHVyZXM6IEdQVUZlYXR1cmVOYW1lW10gPSBbXTtcbiAgICBjb25zdCBkZXZpY2VEZXNjcmlwdG9yOiBHUFVEZXZpY2VEZXNjcmlwdG9yID0ge1xuICAgICAgcmVxdWlyZWRMaW1pdHM6IHtcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUsXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbixcbiAgICAgICAgbWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplOiBhZGFwdGVyLmxpbWl0cy5tYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemUsXG4gICAgICAgIG1heEJ1ZmZlclNpemU6IGFkYXB0ZXIubGltaXRzLm1heEJ1ZmZlclNpemUsXG4gICAgICAgIG1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cDogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLFxuICAgICAgICBtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVg6IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCxcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFNpemVZOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVksXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWjogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVaLFxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkRmVhdHVyZXMsXG4gICAgfTtcblxuICAgIC8vIFRyeSByZXF1aXJpbmcgV2ViR1BVIGZlYXR1cmVzXG4gICAgY29uc3QgcmVxdWlyZUZlYXR1cmVJZkF2YWlsYWJsZSA9IChmZWF0dXJlOiBHUFVGZWF0dXJlTmFtZSkgPT5cbiAgICAgIGFkYXB0ZXIuZmVhdHVyZXMuaGFzKGZlYXR1cmUpICYmIHJlcXVpcmVkRmVhdHVyZXMucHVzaChmZWF0dXJlKSAmJiB0cnVlO1xuICAgIC8vIFRyeSBjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXMgYW5kIGZhbGxiYWNrIHRvIHRpbWVzdGFtcC1xdWVyeVxuICAgIGlmICghcmVxdWlyZUZlYXR1cmVJZkF2YWlsYWJsZSgnY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzJyBhcyBHUFVGZWF0dXJlTmFtZSkpIHtcbiAgICAgIHJlcXVpcmVGZWF0dXJlSWZBdmFpbGFibGUoJ3RpbWVzdGFtcC1xdWVyeScpO1xuICAgIH1cbiAgICByZXF1aXJlRmVhdHVyZUlmQXZhaWxhYmxlKCdzaGFkZXItZjE2Jyk7XG4gICAgLy8gVHJ5IHN1Ymdyb3Vwc1xuICAgIHJlcXVpcmVGZWF0dXJlSWZBdmFpbGFibGUoJ3N1Ymdyb3VwcycgYXMgR1BVRmVhdHVyZU5hbWUpO1xuXG4gICAgdGhpcy5kZXZpY2UgPSBhd2FpdCBhZGFwdGVyLnJlcXVlc3REZXZpY2UoZGV2aWNlRGVzY3JpcHRvcik7XG4gICAgdGhpcy5hZGFwdGVySW5mbyA9IG5ldyBBZGFwdGVySW5mb0ltcGwoYWRhcHRlci5pbmZvIHx8IChhd2FpdCBhZGFwdGVyLnJlcXVlc3RBZGFwdGVySW5mbygpKSk7XG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlciA9IGNyZWF0ZUdwdURhdGFNYW5hZ2VyKHRoaXMpO1xuICAgIHRoaXMucHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIodGhpcyk7XG4gICAgdGhpcy5rZXJuZWxzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5rZXJuZWxDdXN0b21EYXRhID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gc2V0IHVwIGZsYWdzIGZvciBsb2dnZXJcbiAgICBjb25maWd1cmVMb2dnZXIoZW52LmxvZ0xldmVsISwgISFlbnYuZGVidWcpO1xuXG4gICAgLy8gVE9ETzogc2V0IHVwIGZsYWdzXG5cbiAgICB0aGlzLmRldmljZS5vbnVuY2FwdHVyZWRlcnJvciA9IChldikgPT4ge1xuICAgICAgaWYgKGV2LmVycm9yIGluc3RhbmNlb2YgR1BVVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIHVuY2F1Z2h0IFdlYkdQVSB2YWxpZGF0aW9uIGVycm9yIHdhcyByYWlzZWQ6ICR7ZXYuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSwgJ2RldmljZScsIHtcbiAgICAgIHZhbHVlOiB0aGlzLmRldmljZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsICdhZGFwdGVyJywge1xuICAgICAgdmFsdWU6IGFkYXB0ZXIsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB9KTtcblxuICAgIC8vIGluaXQgcXVlcnlUeXBlLCB3aGljaCBpcyBuZWNlc3NhcnkgZm9yIEluZmVyZW5jZVNlc3Npb24uY3JlYXRlXG4gICAgdGhpcy5zZXRRdWVyeVR5cGUoKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnF1ZXJ5U2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5xdWVyeVNldC5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgZ2V0Q29tbWFuZEVuY29kZXIoKTogR1BVQ29tbWFuZEVuY29kZXIge1xuICAgIGlmICghdGhpcy5jb21tYW5kRW5jb2Rlcikge1xuICAgICAgdGhpcy5jb21tYW5kRW5jb2RlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbW1hbmRFbmNvZGVyO1xuICB9XG5cbiAgZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk6IEdQVUNvbXB1dGVQYXNzRW5jb2RlciB7XG4gICAgaWYgKCF0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcikge1xuICAgICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSB0aGlzLmdldENvbW1hbmRFbmNvZGVyKCk7XG4gICAgICBjb25zdCBjb21wdXRlUGFzc0Rlc2NyaXB0b3I6IEdQVUNvbXB1dGVQYXNzRGVzY3JpcHRvciA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5xdWVyeVR5cGUgPT09ICdhdC1wYXNzZXMnKSB7XG4gICAgICAgIGNvbXB1dGVQYXNzRGVzY3JpcHRvci50aW1lc3RhbXBXcml0ZXMgPSB7XG4gICAgICAgICAgcXVlcnlTZXQ6IHRoaXMucXVlcnlTZXQhLFxuICAgICAgICAgIGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6IHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMixcbiAgICAgICAgICBlbmRPZlBhc3NXcml0ZUluZGV4OiB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKyAxLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luQ29tcHV0ZVBhc3MoY29tcHV0ZVBhc3NEZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyO1xuICB9XG5cbiAgZW5kQ29tcHV0ZVBhc3MoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyKSB7XG4gICAgICB0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKTtcbiAgICAgIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmbHVzaCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY29tbWFuZEVuY29kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XG5cbiAgICB0aGlzLmVuZENvbXB1dGVQYXNzKCk7XG4gICAgbGV0IHF1ZXJ5UmVhZEJ1ZmZlcjogR1BVQnVmZmVyO1xuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICB0aGlzLmNvbW1hbmRFbmNvZGVyLnJlc29sdmVRdWVyeVNldChcbiAgICAgICAgdGhpcy5xdWVyeVNldCEsXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMixcbiAgICAgICAgdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIhLFxuICAgICAgICAwLFxuICAgICAgKTtcblxuICAgICAgcXVlcnlSZWFkQnVmZmVyID0gdGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB7IHNpemU6IHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMiAqIDgsIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRCB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIH0sXG4gICAgICApO1xuXG4gICAgICB0aGlzLnBlbmRpbmdRdWVyaWVzLnNldChxdWVyeVJlYWRCdWZmZXIsIHRoaXMucGVuZGluZ0tlcm5lbHMpO1xuICAgICAgdGhpcy5wZW5kaW5nS2VybmVscyA9IFtdO1xuICAgICAgdGhpcy5jb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXG4gICAgICAgIHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyISxcbiAgICAgICAgMCxcbiAgICAgICAgcXVlcnlSZWFkQnVmZmVyLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKiA4LFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuY29tbWFuZEVuY29kZXIuZmluaXNoKCldKTtcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZnJlc2hQZW5kaW5nQnVmZmVycygpO1xuICAgIHRoaXMuY29tbWFuZEVuY29kZXIgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID0gMDtcblxuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICB2b2lkIHF1ZXJ5UmVhZEJ1ZmZlciEubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKS50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWFwcGVkRGF0YSA9IG5ldyBCaWdVaW50NjRBcnJheShxdWVyeVJlYWRCdWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKSk7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdLZXJuZWxzID0gdGhpcy5wZW5kaW5nUXVlcmllcy5nZXQocXVlcnlSZWFkQnVmZmVyKSE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcGVkRGF0YS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwZW5kaW5nS2VybmVsSW5mbyA9IHBlbmRpbmdLZXJuZWxzW2ldO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbElkID0gcGVuZGluZ0tlcm5lbEluZm8ua2VybmVsSWQ7XG4gICAgICAgICAgY29uc3Qga2VybmVsSW5mbyA9IHRoaXMua2VybmVscy5nZXQoa2VybmVsSWQpITtcbiAgICAgICAgICBjb25zdCBrZXJuZWxUeXBlID0ga2VybmVsSW5mby5rZXJuZWxUeXBlO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbE5hbWUgPSBrZXJuZWxJbmZvLmtlcm5lbE5hbWU7XG4gICAgICAgICAgY29uc3QgcHJvZ3JhbU5hbWUgPSBwZW5kaW5nS2VybmVsSW5mby5wcm9ncmFtTmFtZTtcbiAgICAgICAgICBjb25zdCBpbnB1dFRlbnNvclZpZXdzID0gcGVuZGluZ0tlcm5lbEluZm8uaW5wdXRUZW5zb3JWaWV3cztcbiAgICAgICAgICBjb25zdCBvdXRwdXRUZW5zb3JWaWV3cyA9IHBlbmRpbmdLZXJuZWxJbmZvLm91dHB1dFRlbnNvclZpZXdzO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZVU2NCA9IG1hcHBlZERhdGFbaSAqIDJdO1xuICAgICAgICAgIGNvbnN0IGVuZFRpbWVVNjQgPSBtYXBwZWREYXRhW2kgKiAyICsgMV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucXVlcnlUaW1lQmFzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMucXVlcnlUaW1lQmFzZSA9IHN0YXJ0VGltZVU2NDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBOdW1iZXIoc3RhcnRUaW1lVTY0IC0gdGhpcy5xdWVyeVRpbWVCYXNlKTtcbiAgICAgICAgICBjb25zdCBlbmRUaW1lID0gTnVtYmVyKGVuZFRpbWVVNjQgLSB0aGlzLnF1ZXJ5VGltZUJhc2UpO1xuXG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihzdGFydFRpbWUpIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihlbmRUaW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luY29ycmVjdCB0aW1lc3RhbXAgcmFuZ2UnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ub25kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nLm9uZGF0YSh7XG4gICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgIGlucHV0c01ldGFkYXRhOiBpbnB1dFRlbnNvclZpZXdzLm1hcCgodmFsdWUpID0+ICh7XG4gICAgICAgICAgICAgICAgZGltczogdmFsdWUuZGltcyxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcodmFsdWUuZGF0YVR5cGUpLFxuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgIG91dHB1dHNNZXRhZGF0YTogb3V0cHV0VGVuc29yVmlld3MubWFwKCh2YWx1ZSkgPT4gKHtcbiAgICAgICAgICAgICAgICBkaW1zOiB2YWx1ZS5kaW1zLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2YWx1ZS5kYXRhVHlwZSksXG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAga2VybmVsSWQsXG4gICAgICAgICAgICAgIGtlcm5lbFR5cGUsXG4gICAgICAgICAgICAgIGtlcm5lbE5hbWUsXG4gICAgICAgICAgICAgIHByb2dyYW1OYW1lLFxuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWQsIHByaW50IHRoZSBwcm9maWxpbmcgbWVzc2FnZSB0byBjb25zb2xlXG4gICAgICAgICAgICBsZXQgaW5wdXRTaGFwZXMgPSAnJztcbiAgICAgICAgICAgIGlucHV0VGVuc29yVmlld3MuZm9yRWFjaCgodmFsdWUsIGkpID0+IHtcbiAgICAgICAgICAgICAgaW5wdXRTaGFwZXMgKz0gYGlucHV0WyR7aX1dOiBbJHt2YWx1ZS5kaW1zfV0gfCAke3RlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHZhbHVlLmRhdGFUeXBlKX0sIGA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBvdXRwdXRTaGFwZXMgPSAnJztcbiAgICAgICAgICAgIG91dHB1dFRlbnNvclZpZXdzLmZvckVhY2goKHZhbHVlLCBpKSA9PiB7XG4gICAgICAgICAgICAgIG91dHB1dFNoYXBlcyArPSBgb3V0cHV0WyR7aX1dOiBbJHt2YWx1ZS5kaW1zfV0gfCAke3RlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHZhbHVlLmRhdGFUeXBlKX0sIGA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYFtwcm9maWxpbmddIGtlcm5lbCBcIiR7a2VybmVsSWR9fCR7a2VybmVsVHlwZX18JHtrZXJuZWxOYW1lfXwke3Byb2dyYW1OYW1lfVwiICR7aW5wdXRTaGFwZXN9JHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZXNcbiAgICAgICAgICAgICAgfXN0YXJ0IHRpbWU6ICR7c3RhcnRUaW1lfSBucywgZXhlY3V0aW9uIHRpbWU6ICR7ZW5kVGltZSAtIHN0YXJ0VGltZX0gbnNgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgVFJBQ0UoJ0dQVScsIGAke3Byb2dyYW1OYW1lfTo6JHtzdGFydFRpbWVVNjR9Ojoke2VuZFRpbWVVNjR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcnlSZWFkQnVmZmVyLnVubWFwKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ1F1ZXJpZXMuZGVsZXRlKHF1ZXJ5UmVhZEJ1ZmZlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBydW4gYSBXZWJHUFUgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHByb2dyYW0gYSBQcm9ncmFtSW5mbyBpbnN0YW5jZVxuICAgKiBAcGFyYW0gaW5wdXRUZW5zb3JWaWV3cyBhIFRlbnNvclZpZXcgYXJyYXkuIGVhY2ggZWxlbWVudCByZXByZXNlbnRzIGEgdmFsdWUgYWxyZWFkeSBleGlzdHMgaW4gR1BVLlxuICAgKiBAcGFyYW0gb3V0cHV0SW5kaWNlcyBhbiBpbmRpY2VzIGFycmF5LiBlYWNoIGVsZW1lbnQgY2FuIGJlIGVpdGhlciAtMSAodGVtcG9yYXJ5IGRhdGEpLCAtMiAocGVyc2lzdGVudCBkYXRhKSBvciBhblxuICAgKiBpbmRleCB0byB0aGUga2VybmVsJ3Mgb3V0cHV0LlxuICAgKiBAcGFyYW0gY3JlYXRlS2VybmVsT3V0cHV0IGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBjcmVhdGUgYSB2YWx1ZSB0byBrZXJuZWwncyBvdXRwdXQgd2l0aCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICogQHBhcmFtIGNyZWF0ZUludGVybWVkaWF0ZU91dHB1dCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgY3JlYXRlIGEgdmFsdWUgYXMgYSBpbnRlcm1lZGlhdGUgdmFsdWUsIGVpdGhlciB0ZW1wb3JhcnlcbiAgICogb3IgcGVyc2lzdGVudCAob3duZWQgYnkgdGhlIGN1cnJlbnQga2VybmVsKVxuICAgKiBAcmV0dXJucyBhIFRlbnNvclZpZXcgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gICAqL1xuICBydW4oXG4gICAgcHJvZ3JhbTogUHJvZ3JhbUluZm8sXG4gICAgaW5wdXRUZW5zb3JWaWV3czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICAgIG91dHB1dEluZGljZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGNyZWF0ZUtlcm5lbE91dHB1dDogKGluZGV4OiBudW1iZXIsIGRhdGFUeXBlOiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBUZW5zb3JWaWV3LFxuICAgIGNyZWF0ZUludGVybWVkaWF0ZU91dHB1dDogKGRhdGFUeXBlOiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBUZW5zb3JWaWV3LFxuICAgIG91dHB1dENvdW50OiBudW1iZXIsXG4gICk6IFRlbnNvclZpZXdbXSB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTihwcm9ncmFtLm5hbWUpO1xuICAgIC8vIGNyZWF0ZSBpbmZvIGZvciBpbnB1dHNcbiAgICBjb25zdCBpbnB1dERhdGFzOiBHcHVEYXRhW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0VGVuc29yVmlld3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBpbnB1dFRlbnNvclZpZXdzW2ldLmRhdGE7XG4gICAgICAvLyBpZiB0ZW5zb3IgdmlldyBkYXRhIGlzIDAsIGl0IG1lYW5zIHRoZSBvdXRwdXQgaXMgemVyby1zaXplZCB0ZW5zb3IsIGFuZCB0aGVyZSBpcyBubyBHUFUgZGF0YSBmb3IgaXQuXG4gICAgICBpZiAoZGF0YSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdwdURhdGEgPSB0aGlzLmdwdURhdGFNYW5hZ2VyLmdldChkYXRhKTtcbiAgICAgIGlmICghZ3B1RGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBpbnB1dDogJHtkYXRhfWApO1xuICAgICAgfVxuICAgICAgaW5wdXREYXRhcy5wdXNoKGdwdURhdGEpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgb3V0cHV0cywgZGlzcGF0Y2hHcm91cCwgcHJvZ3JhbVVuaWZvcm1zIH0gPSBwcm9ncmFtLmdldFJ1bkRhdGEoaW5wdXRUZW5zb3JWaWV3cyk7XG5cbiAgICAvLyBjaGVjayBvdXRwdXQgaW5kaWNlc1xuICAgIGNvbnN0IHZhbGlkYXRlZE91dHB1dEluZGljZXMgPSBvdXRwdXRJbmRpY2VzLmxlbmd0aCA9PT0gMCA/IG91dHB1dHMubWFwKChfLCBpKSA9PiBpKSA6IG91dHB1dEluZGljZXM7XG4gICAgaWYgKHZhbGlkYXRlZE91dHB1dEluZGljZXMubGVuZ3RoICE9PSBvdXRwdXRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPdXRwdXQgc2l6ZSAke3ZhbGlkYXRlZE91dHB1dEluZGljZXMubGVuZ3RofSBtdXN0IGJlIGVxdWFsIHRvICR7b3V0cHV0cy5sZW5ndGh9LmApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBpbmZvIGZvciBvdXRwdXRzXG4gICAgY29uc3Qgb3V0cHV0VGVuc29yVmlld3M6IFRlbnNvclZpZXdbXSA9IFtdO1xuICAgIGNvbnN0IG91dHB1dERhdGFzOiBHcHVEYXRhW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIHZhbHVlIC0xIGFuZCAtMiBhcmUgdXNlZCBmb3IgY3JlYXRpbmcgdGVtcG9yYXJ5IGFuZCBwZXJzaXN0ZW50IG91dHB1dHMuXG4gICAgICAvLyB2YWx1ZSAtMyBpcyB1c2VkIGZvciBwbGFjZWhvbGRlciBvdXRwdXQuIFNvIC0zLCAtMiwgLTEgYW5kIDAsIDEsIDIsIC4uLiBhcmUgdmFsaWRcbiAgICAgIC8vIG91dHB1dCBpbmRpY2VzLiBzZWUgdHlwZSBkZWZpbml0aW9uIG9mIENvbXB1dGVDb250ZXh0SW5wdXRzT3V0cHV0c01hcHBpbmcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmIChcbiAgICAgICAgIU51bWJlci5pc0ludGVnZXIodmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSkgfHxcbiAgICAgICAgdmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSA8IC0zIHx8XG4gICAgICAgIHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPj0gb3V0cHV0Q291bnRcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3V0cHV0IGluZGV4OiAke3ZhbGlkYXRlZE91dHB1dEluZGljZXNbaV19YCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSA9PT0gLTMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1RlbXBvcmFyeSA9IHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPT09IC0xO1xuICAgICAgY29uc3QgaXNQZXJzaXN0ZW50ID0gdmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSA9PT0gLTI7XG4gICAgICBjb25zdCB0ZW5zb3JWaWV3ID1cbiAgICAgICAgaXNUZW1wb3JhcnkgfHwgaXNQZXJzaXN0ZW50XG4gICAgICAgICAgPyBjcmVhdGVJbnRlcm1lZGlhdGVPdXRwdXQob3V0cHV0c1tpXS5kYXRhVHlwZSwgb3V0cHV0c1tpXS5kaW1zKVxuICAgICAgICAgIDogY3JlYXRlS2VybmVsT3V0cHV0KHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0sIG91dHB1dHNbaV0uZGF0YVR5cGUsIG91dHB1dHNbaV0uZGltcyk7XG4gICAgICBvdXRwdXRUZW5zb3JWaWV3cy5wdXNoKHRlbnNvclZpZXcpO1xuICAgICAgLy8gaWYgdGVuc29yIHZpZXcgZGF0YSBpcyAwLCBpdCBtZWFucyB0aGUgb3V0cHV0IGlzIHplcm8tc2l6ZWQgdGVuc29yLCBhbmQgdGhlcmUgaXMgbm8gR1BVIGRhdGEgZm9yIGl0LlxuICAgICAgaWYgKHRlbnNvclZpZXcuZGF0YSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdwdURhdGEgPSB0aGlzLmdwdURhdGFNYW5hZ2VyLmdldCh0ZW5zb3JWaWV3LmRhdGEpO1xuICAgICAgaWYgKCFncHVEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIG91dHB1dDogJHt0ZW5zb3JWaWV3LmRhdGF9YCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNUZW1wb3JhcnkpIHtcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlEYXRhLnB1c2goZ3B1RGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNQZXJzaXN0ZW50KSB7XG4gICAgICAgIGxldCBwZXJzaXN0ZW50RGF0YSA9IHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkISk7XG4gICAgICAgIGlmICghcGVyc2lzdGVudERhdGEpIHtcbiAgICAgICAgICBwZXJzaXN0ZW50RGF0YSA9IFtdO1xuICAgICAgICAgIHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkISwgcGVyc2lzdGVudERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHBlcnNpc3RlbnREYXRhLnB1c2goZ3B1RGF0YSk7XG4gICAgICB9XG4gICAgICBvdXRwdXREYXRhcy5wdXNoKGdwdURhdGEpO1xuICAgIH1cblxuICAgIC8vIHdoZW4gdGhlcmUgYXJlIGFueSB6ZXJvLXNpemVkIHRlbnNvciBpbiB0aGUgaW5wdXRzIG9yIG91dHB1dHMsIHdlIHNob3VsZCByZXBvcnQgZXJyb3IgdW5sZXNzIGFsbCBvdXRwdXRzIGFyZVxuICAgIC8vIHplcm8tc2l6ZWQgdGVuc29ycy5cbiAgICBpZiAoaW5wdXREYXRhcy5sZW5ndGggIT09IGlucHV0VGVuc29yVmlld3MubGVuZ3RoIHx8IG91dHB1dERhdGFzLmxlbmd0aCAhPT0gb3V0cHV0VGVuc29yVmlld3MubGVuZ3RoKSB7XG4gICAgICAvLyBpZiBhbGwgb3V0cHV0cyBhcmUgemVyby1zaXplZCB0ZW5zb3JzLCB0aGVyZSBpcyBubyBuZWVkIHRvIHJ1biB0aGUgcHJvZ3JhbS5cbiAgICAgIGlmIChvdXRwdXREYXRhcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgVFJBQ0VfRlVOQ19FTkQocHJvZ3JhbS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dFRlbnNvclZpZXdzO1xuICAgICAgfVxuICAgICAgLy8gaWYgc29tZSBvdXRwdXRzIGFyZSB6ZXJvLXNpemVkIHRlbnNvcnMsIHJlcG9ydCBhbiBlcnJvci5cbiAgICAgIC8vXG4gICAgICAvLyBUT0RPOiBzbyBmYXIgd2UgZG9uJ3Qgc2VlIGFueSB1c2UgY2FzZSB0aGF0IG91dHB1dHMgaW5jbHVkZSBib3RoIHplcm8tc2l6ZWQgdGVuc29ycyBhbmQgbm9uLXplcm8tc2l6ZWQgdGVuc29ycy5cbiAgICAgIC8vIElmIHdlIHNlZSBzdWNoIHVzZSBjYXNlLCB3ZSBuZWVkIHRvIG1ha2UgYSBjaGFuZ2UgaGVyZSB0byBzdXBwb3J0IGl0LlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUHJvZ3JhbSAke3Byb2dyYW0ubmFtZX0gaGFzIHplcm8tc2l6ZWQgdGVuc29yKHMpIGluIGlucHV0cyBvciBvdXRwdXRzLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgbm93LmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGxvYWQgdW5pZm9ybXNcbiAgICAvLyBUT0RPOiBhZGQgY2FjaGUgZm9yIHVuaWZvcm0gKGlzIGl0IG5lY2Vzc2FyeT8pXG4gICAgLy9cbiAgICBsZXQgdW5pZm9ybUJ1ZmZlckJpbmRpbmc6IEdQVUJpbmRpbmdSZXNvdXJjZSB8IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvZ3JhbVVuaWZvcm1zKSB7XG4gICAgICBsZXQgY3VycmVudE9mZnNldCA9IDA7XG4gICAgICBjb25zdCBvZmZzZXRzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICBwcm9ncmFtVW5pZm9ybXMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIHYuZGF0YSA9PT0gJ251bWJlcicgPyBbdi5kYXRhXSA6IHYuZGF0YTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9XR1NMLyNhbGlnbm9mXG4gICAgICAgIGNvbnN0IHNpemVPZkVsZW1lbnQgPSB2LnR5cGUgPT09IERhdGFUeXBlLmZsb2F0MTYgPyAyIDogNDtcbiAgICAgICAgbGV0IHNpemVPZlZlY09yTWF0O1xuICAgICAgICBsZXQgYmFzZUFsaWdubWVudDtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNikge1xuICAgICAgICAgIGJhc2VBbGlnbm1lbnQgPSBkYXRhLmxlbmd0aCA+IDQgPyAxNiA6IGRhdGEubGVuZ3RoID4gMiA/IDggOiBkYXRhLmxlbmd0aCAqIHNpemVPZkVsZW1lbnQ7XG4gICAgICAgICAgc2l6ZU9mVmVjT3JNYXQgPSBkYXRhLmxlbmd0aCA+IDQgPyAxNiA6IHNpemVPZkVsZW1lbnQgKiBkYXRhLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlQWxpZ25tZW50ID0gZGF0YS5sZW5ndGggPD0gMiA/IGRhdGEubGVuZ3RoICogc2l6ZU9mRWxlbWVudCA6IDE2O1xuICAgICAgICAgIHNpemVPZlZlY09yTWF0ID0gMTY7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudE9mZnNldCA9IE1hdGguY2VpbChjdXJyZW50T2Zmc2V0IC8gYmFzZUFsaWdubWVudCkgKiBiYXNlQWxpZ25tZW50O1xuICAgICAgICBvZmZzZXRzLnB1c2goY3VycmVudE9mZnNldCk7XG4gICAgICAgIC8vIEZvciBub24tZmxvYXQxNiB0eXBlLCB3aGVuIGRhdGEubGVuZ3RoID4gNCwgdGhlIHVuaWZvcm0gdmFyaWFibGUgaXMgb2YgdHlwZSBhcnJheTx2ZWM0PGkzMnx1MzJ8ZjMyPixOPiwgd2hlcmVcbiAgICAgICAgLy8gTiA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDQpIGFuZCBTaXplT2YodmVjNDxpMzJ8dTMyfGYzMj4pID0gMTYuIFRoZSB0b3RhbCBieXRlIGxlbmd0aCBpcyBOICpcbiAgICAgICAgLy8gU2l6ZU9mKHZlYzQ8aTMyfHUzMnxmMzI+KS4gRm9yIGZsb2F0MTYgdHlwZSwgd2hlbiBkYXRhLmxlbmd0aCA+IDQsIHRoZSB1bmlmb3JtIHZhcmlhYmxlIGlzIG9mIHR5cGVcbiAgICAgICAgLy8gYXJyYXk8bWF0Mng0PGYxNj4sTj4sIHdoZXJlIE4gPSBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyA4KSBhbmQgU2l6ZU9mKG1hdDJ4NDxmMTY+KSA9IDE2LiBUaGUgdG90YWwgYnl0ZVxuICAgICAgICAvLyBsZW5ndGggaXMgTiAqIFNpemVPZihtYXQyeDQ8ZjE2PikuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRQZXJWZWNPck1hdCA9IHYudHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNiA/IDggOiA0O1xuICAgICAgICBjdXJyZW50T2Zmc2V0ICs9XG4gICAgICAgICAgZGF0YS5sZW5ndGggPiA0ID8gTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gZWxlbWVudFBlclZlY09yTWF0KSAqIHNpemVPZlZlY09yTWF0IDogZGF0YS5sZW5ndGggKiBzaXplT2ZFbGVtZW50O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE1lZXQgYWxpZ25tZW50IG9mIHN0cnVjdCBoZXJlOiBodHRwczovL3d3dy53My5vcmcvVFIvV0dTTC8jYWxpZ25tZW50LWFuZC1zaXplLiBGb3Igc2ltcGxpY2l0eSwgc2V0XG4gICAgICAvLyBtYXhBbGlnbm1lbnRPZkZpZWxkIHRvIDE2IHNpbmNlIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBoYXMgYmVlbiByb3VuZGVkIHVwIHRvIDE2LlxuICAgICAgY29uc3QgbWF4QWxpZ25tZW50T2ZGaWVsZCA9IDE2O1xuICAgICAgY3VycmVudE9mZnNldCA9IE1hdGguY2VpbChjdXJyZW50T2Zmc2V0IC8gbWF4QWxpZ25tZW50T2ZGaWVsZCkgKiBtYXhBbGlnbm1lbnRPZkZpZWxkO1xuICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoY3VycmVudE9mZnNldCk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRzW2ldO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIHYuZGF0YSA9PT0gJ251bWJlcicgPyBbdi5kYXRhXSA6IHYuZGF0YTtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gRGF0YVR5cGUuaW50MzIpIHtcbiAgICAgICAgICBuZXcgSW50MzJBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0LCBkYXRhLmxlbmd0aCkuc2V0KGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gRGF0YVR5cGUudWludDMyKSB7XG4gICAgICAgICAgbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGRhdGEubGVuZ3RoKS5zZXQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAodi50eXBlID09PSBEYXRhVHlwZS5mbG9hdDE2KSB7XG4gICAgICAgICAgbmV3IFVpbnQxNkFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGRhdGEubGVuZ3RoKS5zZXQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAodi50eXBlID09PSBEYXRhVHlwZS5mbG9hdCkge1xuICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgZGF0YS5sZW5ndGgpLnNldChkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHVuaWZvcm0gdHlwZTogJHt0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2LnR5cGUpfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdW5pZm9ybUJ1ZmZlckRhdGEgPVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShjdXJyZW50T2Zmc2V0LCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pO1xuICAgICAgdGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIodW5pZm9ybUJ1ZmZlckRhdGEuYnVmZmVyLCAwLCBhcnJheUJ1ZmZlciwgMCwgY3VycmVudE9mZnNldCk7XG4gICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodW5pZm9ybUJ1ZmZlckRhdGEuaWQpO1xuICAgICAgdW5pZm9ybUJ1ZmZlckJpbmRpbmcgPSB7IG9mZnNldDogMCwgc2l6ZTogY3VycmVudE9mZnNldCwgYnVmZmVyOiB1bmlmb3JtQnVmZmVyRGF0YS5idWZmZXIgfTtcbiAgICB9XG5cbiAgICBjb25zdCBub3JtYWxpemVkRGlzcGF0Y2hHcm91cCA9IHRoaXMucHJvZ3JhbU1hbmFnZXIubm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUoZGlzcGF0Y2hHcm91cCk7XG4gICAgY29uc3QgaXMxRGltZW5zaW9uRGlzcGF0Y2ggPSBub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXSA9PT0gMSAmJiBub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXSA9PT0gMTtcbiAgICAvLyBnZXQgcHJvZ3JhbSBpbmZvXG4gICAgY29uc3Qga2V5ID0gZ2V0UHJvZ3JhbUluZm9VbmlxdWVLZXkocHJvZ3JhbSwgaW5wdXRUZW5zb3JWaWV3cywgaXMxRGltZW5zaW9uRGlzcGF0Y2gpO1xuICAgIGxldCBhcnRpZmFjdCA9IHRoaXMucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3Qoa2V5KTtcbiAgICBpZiAoIWFydGlmYWN0KSB7XG4gICAgICBhcnRpZmFjdCA9IHRoaXMucHJvZ3JhbU1hbmFnZXIuYnVpbGQocHJvZ3JhbSwgbm9ybWFsaXplZERpc3BhdGNoR3JvdXApO1xuICAgICAgdGhpcy5wcm9ncmFtTWFuYWdlci5zZXRBcnRpZmFjdChrZXksIGFydGlmYWN0KTtcbiAgICAgIExPR19ERUJVRygnaW5mbycsICgpID0+IGBbYXJ0aWZhY3RdIGtleTogJHtrZXl9LCBwcm9ncmFtTmFtZTogJHtwcm9ncmFtLm5hbWV9YCk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgdW5pZm9ybSB2YXJpYWJsZXNcbiAgICBpZiAocHJvZ3JhbVVuaWZvcm1zICYmIGFydGlmYWN0LnVuaWZvcm1WYXJpYWJsZXNJbmZvKSB7XG4gICAgICBpZiAocHJvZ3JhbVVuaWZvcm1zLmxlbmd0aCAhPT0gYXJ0aWZhY3QudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVW5pZm9ybSB2YXJpYWJsZXMgY291bnQgbWlzbWF0Y2g6IGV4cGVjdCAke2FydGlmYWN0LnVuaWZvcm1WYXJpYWJsZXNJbmZvLmxlbmd0aH0sIGdvdCAke1xuICAgICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLmxlbmd0aFxuICAgICAgICAgIH0gaW4gcHJvZ3JhbSBcIiR7YXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZX1cIi5gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9ncmFtVW5pZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdW5pZm9ybSA9IHByb2dyYW1Vbmlmb3Jtc1tpXTtcbiAgICAgICAgY29uc3QgYWN0dWFsVHlwZSA9IHVuaWZvcm0udHlwZTtcbiAgICAgICAgY29uc3QgYWN0dWFsTGVuZ3RoID0gdHlwZW9mIHVuaWZvcm0uZGF0YSA9PT0gJ251bWJlcicgPyAxIDogdW5pZm9ybS5kYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3QgW3R5cGUsIGxlbmd0aF0gPSBhcnRpZmFjdC51bmlmb3JtVmFyaWFibGVzSW5mb1tpXTtcbiAgICAgICAgaWYgKGFjdHVhbFR5cGUgIT09IHR5cGUgfHwgYWN0dWFsTGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVW5pZm9ybSB2YXJpYWJsZSAke2l9IG1pc21hdGNoOiBleHBlY3QgdHlwZSAke3R5cGV9IHdpdGggc2l6ZSAke2xlbmd0aH0sIGdvdCB0eXBlICR7XG4gICAgICAgICAgICAgIGFjdHVhbFR5cGVcbiAgICAgICAgICAgIH0gd2l0aCBzaXplICR7YWN0dWFsTGVuZ3RofSBpbiBwcm9ncmFtIFwiJHthcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lfVwiLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIExPR19ERUJVRyhcbiAgICAgICdpbmZvJyxcbiAgICAgICgpID0+XG4gICAgICAgIGBbUHJvZ3JhbU1hbmFnZXJdIHJ1biBcIiR7cHJvZ3JhbS5uYW1lfVwiIChrZXk9JHtrZXl9KSB3aXRoICR7bm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMF19eCR7XG4gICAgICAgICAgbm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV1cbiAgICAgICAgfXgke25vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzJdfWAsXG4gICAgKTtcblxuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ25vbmUnIHx8IHRoaXMuc2Vzc2lvblN0YXR1cyA9PT0gJ2NhcHR1cmluZycpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdLZXJuZWxJbmZvOiBQZW5kaW5nS2VybmVsSW5mbyA9IHtcbiAgICAgICAga2VybmVsSWQ6IHRoaXMuY3VycmVudEtlcm5lbElkISxcbiAgICAgICAgcHJvZ3JhbU5hbWU6IGFydGlmYWN0LnByb2dyYW1JbmZvLm5hbWUsXG4gICAgICAgIGlucHV0VGVuc29yVmlld3MsXG4gICAgICAgIG91dHB1dFRlbnNvclZpZXdzLFxuICAgICAgfTtcbiAgICAgIHRoaXMucGVuZGluZ0tlcm5lbHMucHVzaChwZW5kaW5nS2VybmVsSW5mbyk7XG5cbiAgICAgIGlmICh0aGlzLnNlc3Npb25TdGF0dXMgPT09ICdjYXB0dXJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb25QZW5kaW5nS2VybmVscyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISk7XG4gICAgICAgIHNlc3Npb25QZW5kaW5nS2VybmVscyEucHVzaChwZW5kaW5nS2VybmVsSW5mbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wcm9ncmFtTWFuYWdlci5ydW4oYXJ0aWZhY3QsIGlucHV0RGF0YXMsIG91dHB1dERhdGFzLCBub3JtYWxpemVkRGlzcGF0Y2hHcm91cCwgdW5pZm9ybUJ1ZmZlckJpbmRpbmcpO1xuXG4gICAgVFJBQ0VfRlVOQ19FTkQocHJvZ3JhbS5uYW1lKTtcbiAgICByZXR1cm4gb3V0cHV0VGVuc29yVmlld3M7XG4gIH1cblxuICB1cGxvYWQoZ3B1RGF0YUlkOiBudW1iZXIsIGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnVwbG9hZChncHVEYXRhSWQsIGRhdGEpO1xuICB9XG5cbiAgbWVtY3B5KHNyYzogbnVtYmVyLCBkc3Q6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIubWVtY3B5KHNyYywgZHN0KTtcbiAgfVxuXG4gIGFzeW5jIGRvd25sb2FkKGdwdURhdGFJZDogbnVtYmVyLCBnZXRUYXJnZXRCdWZmZXI6ICgpID0+IFVpbnQ4QXJyYXkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyB0aGUgdW5kZXJseWluZyBidWZmZXIgbWF5IGJlIGNoYW5nZWQgYWZ0ZXIgdGhlIGFzeW5jIGZ1bmN0aW9uIGlzIGNhbGxlZC4gc28gd2UgdXNlIGEgZ2V0dGVyIGZ1bmN0aW9uIHRvIG1ha2Ugc3VyZVxuICAgIC8vIHRoZSBidWZmZXIgaXMgdXAtdG8tZGF0ZS5cbiAgICBhd2FpdCB0aGlzLmdwdURhdGFNYW5hZ2VyLmRvd25sb2FkKGdwdURhdGFJZCwgZ2V0VGFyZ2V0QnVmZmVyKTtcbiAgfVxuXG4gIGFsbG9jKHNpemU6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHNpemUpLmlkO1xuICB9XG5cbiAgZnJlZShwdHI6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShwdHIpO1xuICB9XG5cbiAgY3JlYXRlS2VybmVsKGtlcm5lbFR5cGU6IHN0cmluZywga2VybmVsSWQ6IG51bWJlciwgYXR0cmlidXRlOiB1bmtub3duLCBrZXJuZWxOYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBvcCA9IFdFQkdQVV9PUF9SRVNPTFZFX1JVTEVTLmdldChrZXJuZWxUeXBlKTtcbiAgICBpZiAoIW9wKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgaW1wbGVtZW50ZWQ6ICR7a2VybmVsVHlwZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXJuZWxJbmZvOiBLZXJuZWxJbmZvID0ge1xuICAgICAga2VybmVsVHlwZSxcbiAgICAgIGtlcm5lbE5hbWUsXG4gICAgICBrZXJuZWxFbnRyeTogb3BbMF0sXG4gICAgICBhdHRyaWJ1dGVzOiBbb3BbMV0sIGF0dHJpYnV0ZV0sXG4gICAgfTtcbiAgICB0aGlzLmtlcm5lbHMuc2V0KGtlcm5lbElkLCBrZXJuZWxJbmZvKTtcbiAgfVxuXG4gIHJlbGVhc2VLZXJuZWwoa2VybmVsSWQ6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHBlcnNpc3RlbnREYXRhID0gdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQoa2VybmVsSWQpO1xuICAgIGlmIChwZXJzaXN0ZW50RGF0YSkge1xuICAgICAgZm9yIChjb25zdCBkYXRhIG9mIHBlcnNpc3RlbnREYXRhKSB7XG4gICAgICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShkYXRhLmlkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZGVsZXRlKGtlcm5lbElkKTtcbiAgICB9XG5cbiAgICB0aGlzLmtlcm5lbEN1c3RvbURhdGEuZGVsZXRlKGtlcm5lbElkKTtcbiAgICB0aGlzLmtlcm5lbHMuZGVsZXRlKGtlcm5lbElkKTtcbiAgfVxuXG4gIGNvbXB1dGVLZXJuZWwoa2VybmVsSWQ6IG51bWJlciwgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGVycm9yczogQXJyYXk8UHJvbWlzZTxzdHJpbmcgfCBudWxsPj4pOiBudW1iZXIge1xuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVscy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgY3JlYXRlZDogJHtrZXJuZWxJZH1gKTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsVHlwZSA9IGtlcm5lbC5rZXJuZWxUeXBlO1xuICAgIGNvbnN0IGtlcm5lbE5hbWUgPSBrZXJuZWwua2VybmVsTmFtZTtcbiAgICBjb25zdCBrZXJuZWxFbnRyeSA9IGtlcm5lbC5rZXJuZWxFbnRyeTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ga2VybmVsLmF0dHJpYnV0ZXM7XG4gICAgaWYgKHRoaXMuY3VycmVudEtlcm5lbElkICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBcIlske2tlcm5lbFR5cGV9XSAke2tlcm5lbE5hbWV9XCIgaXMgbm90IGFsbG93ZWQgdG8gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5YCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudEtlcm5lbElkID0ga2VybmVsSWQ7XG5cbiAgICAvLyBwYXJzZSBhdHRyaWJ1dGVzIGlmIG5lY2Vzc2FyeVxuICAgIGlmIChhdHRyaWJ1dGVzWzBdKSB7XG4gICAgICBhdHRyaWJ1dGVzWzFdID0gYXR0cmlidXRlc1swXShhdHRyaWJ1dGVzWzFdKTtcbiAgICAgIGF0dHJpYnV0ZXNbMF0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgTE9HX0RFQlVHKCdpbmZvJywgKCkgPT4gYFtXZWJHUFVdIFN0YXJ0IHRvIHJ1biBrZXJuZWwgXCJbJHtrZXJuZWxUeXBlfV0gJHtrZXJuZWxOYW1lfVwiLi4uYCk7XG5cbiAgICBjb25zdCB1c2VFcnJvclNjb3BlID0gdGhpcy5lbnYuZGVidWc7XG5cbiAgICB0aGlzLnRlbXBvcmFyeURhdGEgPSBbXTtcbiAgICB0cnkge1xuICAgICAgaWYgKHVzZUVycm9yU2NvcGUpIHtcbiAgICAgICAgdGhpcy5kZXZpY2UucHVzaEVycm9yU2NvcGUoJ3ZhbGlkYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAga2VybmVsRW50cnkoY29udGV4dCwgYXR0cmlidXRlc1sxXSk7XG4gICAgICByZXR1cm4gMDsgLy8gT1JUX09LXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JzLnB1c2goUHJvbWlzZS5yZXNvbHZlKGBbV2ViR1BVXSBLZXJuZWwgXCJbJHtrZXJuZWxUeXBlfV0gJHtrZXJuZWxOYW1lfVwiIGZhaWxlZC4gJHtlfWApKTtcbiAgICAgIHJldHVybiAxOyAvLyBPUlRfRkFJTFxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodXNlRXJyb3JTY29wZSkge1xuICAgICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgICB0aGlzLmRldmljZVxuICAgICAgICAgICAgLnBvcEVycm9yU2NvcGUoKVxuICAgICAgICAgICAgLnRoZW4oKGVycikgPT5cbiAgICAgICAgICAgICAgZXJyID8gYEdQVSB2YWxpZGF0aW9uIGVycm9yIGZvciBrZXJuZWwgXCJbJHtrZXJuZWxUeXBlfV0gJHtrZXJuZWxOYW1lfVwiOiAke2Vyci5tZXNzYWdlfWAgOiBudWxsLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBkYXRhIG9mIHRoaXMudGVtcG9yYXJ5RGF0YSkge1xuICAgICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoZGF0YS5pZCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRlbXBvcmFyeURhdGEgPSBbXTtcbiAgICAgIHRoaXMuY3VycmVudEtlcm5lbElkID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyAjcmVnaW9uIGV4dGVybmFsIGJ1ZmZlclxuICByZWdpc3RlckJ1ZmZlcihzZXNzaW9uSWQ6IG51bWJlciwgaW5kZXg6IG51bWJlciwgYnVmZmVyOiBHUFVCdWZmZXIsIHNpemU6IG51bWJlcik6IG51bWJlciB7XG4gICAgbGV0IHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcgPSB0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldChzZXNzaW9uSWQpO1xuICAgIGlmICghc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZykge1xuICAgICAgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuc2V0KHNlc3Npb25JZCwgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGJ1ZmZlciBtYXkgYmUgdXNlciBjcmVhdGVkLCBvciBtYW5hZ2VkIGJ5IEdQVSBkYXRhIG1hbmFnZXIuXG4gICAgLy8gVGhlIEdQVSBkYXRhIG1hbmFnZXIgd2lsbCBub3QgbWFuYWdlIHRoZXNlIGJ1ZmZlcnMuIHdlIHJlZ2lzdGVyIHRoZW0gYXMgZXh0ZXJuYWwgYnVmZmVycy5cbiAgICAvL1xuICAgIC8vIFRoZSBtYXAgYHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmdgIGlzIHVzZWQgdG8gc3RvcmUgdGhlIGRhdGEgSUQgYW5kIGJ1ZmZlciBmb3IgZWFjaCBpbnB1dC9vdXRwdXQuIE9uY2UgYVxuICAgIC8vIHNwZWNpZmljIGlucHV0L291dHB1dCBpcyByZWdpc3RlcmVkLCB0aGUgZGF0YSBJRCB3aWxsIG5vdCBjaGFuZ2UuXG4gICAgY29uc3QgcHJldmlvdXNCdWZmZXIgPSBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nLmdldChpbmRleCk7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoYnVmZmVyLCBzaXplLCBwcmV2aW91c0J1ZmZlcik7XG4gICAgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZy5zZXQoaW5kZXgsIFtpZCwgYnVmZmVyXSk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIHVucmVnaXN0ZXJCdWZmZXJzKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3Qgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyA9IHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHNlc3Npb25JZCk7XG4gICAgaWYgKHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcpIHtcbiAgICAgIHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcuZm9yRWFjaCgoYnVmZmVySW5mbykgPT4gdGhpcy5ncHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoYnVmZmVySW5mb1swXSkpO1xuICAgICAgdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICB9XG4gIH1cbiAgZ2V0QnVmZmVyKGdwdURhdGFJZDogbnVtYmVyKTogR1BVQnVmZmVyIHtcbiAgICBjb25zdCBncHVEYXRhID0gdGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoZ3B1RGF0YUlkKTtcbiAgICBpZiAoIWdwdURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGJ1ZmZlcjogJHtncHVEYXRhSWR9YCk7XG4gICAgfVxuICAgIHJldHVybiBncHVEYXRhLmJ1ZmZlcjtcbiAgfVxuICBjcmVhdGVEb3dubG9hZGVyKFxuICAgIGdwdUJ1ZmZlcjogR1BVQnVmZmVyLFxuICAgIHNpemU6IG51bWJlcixcbiAgICB0eXBlOiBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzLFxuICApOiAoKSA9PiBQcm9taXNlPFRlbnNvci5EYXRhVHlwZT4ge1xuICAgIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZG93bmxvYWRHcHVEYXRhKHRoaXMsIGdwdUJ1ZmZlciwgc2l6ZSk7XG4gICAgICByZXR1cm4gY3JlYXRlVmlldyhkYXRhLmJ1ZmZlciwgdHlwZSk7XG4gICAgfTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG4gIHdyaXRlVGltZXN0YW1wKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdpbnNpZGUtcGFzc2VzJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyIGFzIGFueSkud3JpdGVUaW1lc3RhbXAodGhpcy5xdWVyeVNldCwgaW5kZXgpO1xuICB9XG4gIHNldFF1ZXJ5VHlwZSgpOiB2b2lkIHtcbiAgICB0aGlzLnF1ZXJ5VHlwZSA9ICdub25lJztcbiAgICBpZiAoXG4gICAgICB0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nPy5tb2RlID09PSAnZGVmYXVsdCcgfHxcbiAgICAgICh0eXBlb2YgdGhpcy5lbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gdGhpcy5lbnYud2FzbS50cmFjZSA6IHRoaXMuZW52LnRyYWNlKVxuICAgICkge1xuICAgICAgaWYgKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcygnY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzJykpIHtcbiAgICAgICAgdGhpcy5xdWVyeVR5cGUgPSAnaW5zaWRlLXBhc3Nlcyc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcygndGltZXN0YW1wLXF1ZXJ5JykpIHtcbiAgICAgICAgdGhpcy5xdWVyeVR5cGUgPSAnYXQtcGFzc2VzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnbm9uZScgJiYgdHlwZW9mIHRoaXMucXVlcnlTZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMucXVlcnlTZXQgPSB0aGlzLmRldmljZS5jcmVhdGVRdWVyeVNldCh7XG4gICAgICAgICAgdHlwZTogJ3RpbWVzdGFtcCcsXG4gICAgICAgICAgY291bnQ6IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgKiAyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICB7IHNpemU6IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgKiAyICogOCwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIHwgR1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRSB9LFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNhcHR1cmVCZWdpbigpOiB2b2lkIHtcbiAgICBMT0dfREVCVUcoJ2luZm8nLCAnY2FwdHVyZUJlZ2luJyk7XG4gICAgaWYgKCF0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpKSB7XG4gICAgICB0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3Quc2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEsIFtdKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpKSB7XG4gICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuc2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEsIFtdKTtcbiAgICB9XG4gICAgLy8gZmx1c2ggdGhlIGxlZnQgY29tbWFuZHMgYmVmb3JlIHdlIGNoYW5nZSB0aGUgc3RhdHVzLlxuICAgIHRoaXMuZmx1c2goKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnY2FwdHVyaW5nJztcbiAgfVxuICBjYXB0dXJlRW5kKCk6IHZvaWQge1xuICAgIExPR19ERUJVRygnaW5mbycsICdjYXB0dXJlRW5kJyk7XG4gICAgLy8gZmx1c2ggdGhlIGxlZnQgY29tbWFuZHMgYmVmb3JlIHdlIGNoYW5nZSB0aGUgc3RhdHVzLlxuICAgIHRoaXMuZmx1c2goKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnZGVmYXVsdCc7XG4gIH1cbiAgcmVwbGF5KCk6IHZvaWQge1xuICAgIExPR19ERUJVRygnaW5mbycsICdyZXBsYXknKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAncmVwbGF5aW5nJztcbiAgICBjb25zdCBzZXNzaW9uQ29tbWFuZExpc3QgPSB0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpO1xuICAgIGNvbnN0IHNlc3Npb25QZW5kaW5nS2VybmVscyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISk7XG4gICAgY29uc3QgbGVuZ3RoID0gc2Vzc2lvbkNvbW1hbmRMaXN0IS5sZW5ndGg7XG4gICAgdGhpcy5wZW5kaW5nS2VybmVscyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbXB1dGVQYXNzRW5jb2RlciA9IHRoaXMuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7XG4gICAgICBjb25zdCBjb21tYW5kID0gc2Vzc2lvbkNvbW1hbmRMaXN0IVtpXTtcbiAgICAgIHRoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyKTtcbiAgICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRQaXBlbGluZShjb21tYW5kLmNvbXB1dGVQaXBlbGluZSk7XG4gICAgICBjb21wdXRlUGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDAsIGNvbW1hbmQuYmluZEdyb3VwKTtcbiAgICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5kaXNwYXRjaFdvcmtncm91cHMoLi4uY29tbWFuZC5kaXNwYXRjaEdyb3VwKTtcbiAgICAgIHRoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICsgMSk7XG4gICAgICB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrO1xuICAgICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKHNlc3Npb25QZW5kaW5nS2VybmVscyFbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID49IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgfHwgdGhpcy5xdWVyeVR5cGUgPT09ICdhdC1wYXNzZXMnKSB7XG4gICAgICAgIHRoaXMuZW5kQ29tcHV0ZVBhc3MoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciA+PSB0aGlzLm1heERpc3BhdGNoTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZmx1c2ggdGhlIGxlZnQgY29tbWFuZHMgYmVmb3JlIHdlIGNoYW5nZSB0aGUgc3RhdHVzLlxuICAgIHRoaXMuZmx1c2goKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnZGVmYXVsdCc7XG4gIH1cblxuICBvbkNyZWF0ZVNlc3Npb24oKTogdm9pZCB7XG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci5vbkNyZWF0ZVNlc3Npb24oKTtcbiAgfVxuXG4gIG9uUmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJCdWZmZXJzKHNlc3Npb25JZCk7XG4gICAgaWYgKHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5oYXMoc2Vzc2lvbklkKSkge1xuICAgICAgdGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmRlbGV0ZShzZXNzaW9uSWQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmhhcyhzZXNzaW9uSWQpKSB7XG4gICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgfVxuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIub25SZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQpO1xuICB9XG5cbiAgb25SdW5TdGFydChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICB0aGlzLnNldFF1ZXJ5VHlwZSgpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB0eXBlIHsgRW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMsIERhdGFUeXBlIH0gZnJvbSAnLi4vd2FzbS1jb21tb24nO1xuXG5pbXBvcnQgdHlwZSB7IE9ydFdhc21Nb2R1bGUgfSBmcm9tICcuLi93YXNtLXR5cGVzJztcblxuaW1wb3J0IHR5cGUgeyBXZWJHcHVCYWNrZW5kIH0gZnJvbSAnLi9iYWNrZW5kLXdlYmdwdSc7XG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuL2xvZyc7XG5pbXBvcnQgdHlwZSB7IFRlbnNvclZpZXcgfSBmcm9tICcuL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgdHlwZSB7IEFkYXB0ZXJJbmZvLCBDb21wdXRlQ29udGV4dCwgQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZywgUHJvZ3JhbUluZm8gfSBmcm9tICcuL3dlYmdwdS90eXBlcyc7XG5pbXBvcnQgeyBXZWJOTkJhY2tlbmQgfSBmcm9tICcuL2JhY2tlbmQtd2Vibm4nO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbmNsYXNzIFRlbnNvclZpZXdJbXBsIGltcGxlbWVudHMgVGVuc29yVmlldyB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgbW9kdWxlOiBPcnRXYXNtTW9kdWxlLFxuICAgIHB1YmxpYyByZWFkb25seSBkYXRhVHlwZTogbnVtYmVyLFxuICAgIHB1YmxpYyByZWFkb25seSBkYXRhOiBudW1iZXIsXG4gICAgcHVibGljIHJlYWRvbmx5IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICApIHt9XG5cbiAgZ2V0RmxvYXQzMkFycmF5KCk6IEZsb2F0MzJBcnJheSB7XG4gICAgaWYgKHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSB0eXBlJyk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRDb3VudCA9IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcyk7XG4gICAgcmV0dXJuIGVsZW1lbnRDb3VudCA9PT0gMFxuICAgICAgPyBuZXcgRmxvYXQzMkFycmF5KClcbiAgICAgIDogbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsIHRoaXMuZGF0YSwgZWxlbWVudENvdW50KTtcbiAgfVxuXG4gIGdldEJpZ0ludDY0QXJyYXkoKTogQmlnSW50NjRBcnJheSB7XG4gICAgaWYgKHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDY0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSB0eXBlJyk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRDb3VudCA9IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcyk7XG4gICAgcmV0dXJuIGVsZW1lbnRDb3VudCA9PT0gMFxuICAgICAgPyBuZXcgQmlnSW50NjRBcnJheSgpXG4gICAgICA6IG5ldyBCaWdJbnQ2NEFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xuICB9XG5cbiAgZ2V0SW50MzJBcnJheSgpOiBJbnQzMkFycmF5IHtcbiAgICBpZiAodGhpcy5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50MzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUnKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudENvdW50ID0gU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKTtcbiAgICByZXR1cm4gZWxlbWVudENvdW50ID09PSAwID8gbmV3IEludDMyQXJyYXkoKSA6IG5ldyBJbnQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xuICB9XG5cbiAgZ2V0VWludDE2QXJyYXkoKTogVWludDE2QXJyYXkge1xuICAgIGlmICh0aGlzLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdDE2ICYmIHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLnVpbnQxNikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgdHlwZScpO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50Q291bnQgPSBTaGFwZVV0aWwuc2l6ZSh0aGlzLmRpbXMpO1xuICAgIHJldHVybiBlbGVtZW50Q291bnQgPT09IDAgPyBuZXcgVWludDE2QXJyYXkoKSA6IG5ldyBVaW50MTZBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsIHRoaXMuZGF0YSwgZWxlbWVudENvdW50KTtcbiAgfVxuXG4gIHJlc2hhcGUobmV3RGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JWaWV3IHtcbiAgICBpZiAoU2hhcGVVdGlsLnNpemUobmV3RGltcykgIT09IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBuZXcgc2hhcGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZW5zb3JWaWV3SW1wbCh0aGlzLm1vZHVsZSwgdGhpcy5kYXRhVHlwZSwgdGhpcy5kYXRhLCBuZXdEaW1zKTtcbiAgfVxufVxuXG5jbGFzcyBDb21wdXRlQ29udGV4dEltcGwgaW1wbGVtZW50cyBDb21wdXRlQ29udGV4dCB7XG4gIHJlYWRvbmx5IGFkYXB0ZXJJbmZvOiBBZGFwdGVySW5mbztcbiAgcmVhZG9ubHkgb3BLZXJuZWxDb250ZXh0OiBudW1iZXI7XG4gIHJlYWRvbmx5IGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdO1xuICByZWFkb25seSBvdXRwdXRDb3VudDogbnVtYmVyO1xuICBnZXQga2VybmVsQ3VzdG9tRGF0YSgpOiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfSB7XG4gICAgcmV0dXJuIHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsQ3VzdG9tRGF0YTtcbiAgfVxuICBnZXQgY3VzdG9tRGF0YUJ1ZmZlcigpOiBVaW50OEFycmF5IHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuSEVBUFU4LnN1YmFycmF5KHRoaXMuY3VzdG9tRGF0YU9mZnNldCwgdGhpcy5jdXN0b21EYXRhT2Zmc2V0ICsgdGhpcy5jdXN0b21EYXRhU2l6ZSk7XG4gIH1cbiAgcHJpdmF0ZSBjdXN0b21EYXRhT2Zmc2V0ID0gMDtcbiAgcHJpdmF0ZSBjdXN0b21EYXRhU2l6ZSA9IDA7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgbW9kdWxlOiBPcnRXYXNtTW9kdWxlLFxuICAgIHByaXZhdGUgYmFja2VuZDogV2ViR3B1QmFja2VuZCxcbiAgICBjb250ZXh0RGF0YU9mZnNldDogbnVtYmVyLFxuICApIHtcbiAgICB0aGlzLmFkYXB0ZXJJbmZvID0gYmFja2VuZC5hZGFwdGVySW5mbztcblxuICAgIC8vIGV4dHJhY3QgY29udGV4dCBkYXRhXG4gICAgY29uc3QgcHRyU2l6ZSA9IG1vZHVsZS5QVFJfU0laRTtcbiAgICBsZXQgZGF0YUluZGV4ID0gY29udGV4dERhdGFPZmZzZXQgLyBtb2R1bGUuUFRSX1NJWkU7XG4gICAgY29uc3QgdHlwZSA9IHB0clNpemUgPT09IDQgPyAnaTMyJyA6ICdpNjQnO1xuICAgIHRoaXMub3BLZXJuZWxDb250ZXh0ID0gTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssIHR5cGUpKTtcbiAgICBjb25zdCBpbnB1dENvdW50ID0gTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssIHR5cGUpKTtcbiAgICB0aGlzLm91dHB1dENvdW50ID0gTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssIHR5cGUpKTtcbiAgICB0aGlzLmN1c3RvbURhdGFPZmZzZXQgPSBOdW1iZXIobW9kdWxlLmdldFZhbHVlKHB0clNpemUgKiBkYXRhSW5kZXgrKywgJyonKSk7XG4gICAgdGhpcy5jdXN0b21EYXRhU2l6ZSA9IE51bWJlcihtb2R1bGUuZ2V0VmFsdWUocHRyU2l6ZSAqIGRhdGFJbmRleCsrLCB0eXBlKSk7XG5cbiAgICBjb25zdCBpbnB1dHM6IFRlbnNvclZpZXdbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IE51bWJlcihtb2R1bGUuZ2V0VmFsdWUocHRyU2l6ZSAqIGRhdGFJbmRleCsrLCB0eXBlKSk7XG4gICAgICBjb25zdCBkYXRhID0gTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssICcqJykpO1xuICAgICAgY29uc3QgZGltID0gTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssIHR5cGUpKTtcbiAgICAgIGNvbnN0IGRpbXM6IG51bWJlcltdID0gW107XG4gICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgZCsrKSB7XG4gICAgICAgIGRpbXMucHVzaChOdW1iZXIobW9kdWxlLmdldFZhbHVlKHB0clNpemUgKiBkYXRhSW5kZXgrKywgdHlwZSkpKTtcbiAgICAgIH1cbiAgICAgIGlucHV0cy5wdXNoKG5ldyBUZW5zb3JWaWV3SW1wbChtb2R1bGUsIGRhdGFUeXBlLCBkYXRhLCBkaW1zKSk7XG4gICAgfVxuICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICB9XG5cbiAgY29tcHV0ZShwcm9ncmFtOiBQcm9ncmFtSW5mbywgaW5wdXRzT3V0cHV0c01hcHBpbmc/OiBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nKTogVGVuc29yVmlld1tdIHtcbiAgICAvLyBwcmVwYXJlIGlucHV0cy4gaW5wdXRzIHNob3VsZCBhbHdheXMgYmUgdmFsaWQgZGF0YS5cbiAgICBjb25zdCBtYXBwZWRJbnB1dHMgPVxuICAgICAgaW5wdXRzT3V0cHV0c01hcHBpbmc/LmlucHV0cz8ubWFwKChpKSA9PiAodHlwZW9mIGkgPT09ICdudW1iZXInID8gdGhpcy5pbnB1dHNbaV0gOiBpKSkgPz8gdGhpcy5pbnB1dHM7XG4gICAgLy8gcHJlcGFyZSBvdXRwdXRzLlxuICAgIGNvbnN0IG91dHB1dEluZGljZXMgPSBpbnB1dHNPdXRwdXRzTWFwcGluZz8ub3V0cHV0cyA/PyBbXTtcbiAgICBjb25zdCBjcmVhdGVLZXJuZWxPdXRwdXQgPSAoaW5kZXg6IG51bWJlciwgZGF0YVR5cGU6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JWaWV3ID0+XG4gICAgICBuZXcgVGVuc29yVmlld0ltcGwodGhpcy5tb2R1bGUsIGRhdGFUeXBlLCB0aGlzLm91dHB1dChpbmRleCwgZGltcyksIGRpbXMpO1xuICAgIGNvbnN0IGNyZWF0ZVRlbXBvcmFyeU91dHB1dCA9IChkYXRhVHlwZTogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvclZpZXcgPT4ge1xuICAgICAgY29uc3QgYnVmZmVyU2l6ZSA9IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzKGRhdGFUeXBlLCBkaW1zKTtcbiAgICAgIGlmICghYnVmZmVyU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkYXRhVHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdwdURhdGFJZCA9IGJ1ZmZlclNpemUgPiAwID8gdGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShidWZmZXJTaXplKS5pZCA6IDA7XG4gICAgICByZXR1cm4gbmV3IFRlbnNvclZpZXdJbXBsKHRoaXMubW9kdWxlLCBkYXRhVHlwZSwgZ3B1RGF0YUlkLCBkaW1zKTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmJhY2tlbmQucnVuKFxuICAgICAgcHJvZ3JhbSxcbiAgICAgIG1hcHBlZElucHV0cyxcbiAgICAgIG91dHB1dEluZGljZXMsXG4gICAgICBjcmVhdGVLZXJuZWxPdXRwdXQsXG4gICAgICBjcmVhdGVUZW1wb3JhcnlPdXRwdXQsXG4gICAgICB0aGlzLm91dHB1dENvdW50LFxuICAgICk7XG4gIH1cblxuICBvdXRwdXQoaW5kZXg6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5tb2R1bGUuc3RhY2tTYXZlKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHB0clNpemUgPSB0aGlzLm1vZHVsZS5QVFJfU0laRTtcbiAgICAgIGNvbnN0IHR5cGUgPSBwdHJTaXplID09PSA0ID8gJ2kzMicgOiAnaTY0JztcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLm1vZHVsZS5zdGFja0FsbG9jKCgxICsgZGltcy5sZW5ndGgpICogcHRyU2l6ZSAvKiBzaXplb2Yoc2l6ZV90KSAqLyk7XG4gICAgICB0aGlzLm1vZHVsZS5zZXRWYWx1ZShkYXRhLCBkaW1zLmxlbmd0aCwgdHlwZSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5tb2R1bGUuc2V0VmFsdWUoZGF0YSArIHB0clNpemUgKiAoaSArIDEpLCBkaW1zW2ldLCB0eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1vZHVsZS5fSnNlcE91dHB1dCEodGhpcy5vcEtlcm5lbENvbnRleHQsIGluZGV4LCBkYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZ2VuZXJhdGUga2VybmVsJ3Mgb3V0cHV0WyR7aW5kZXh9XSB3aXRoIGRpbXMgWyR7ZGltc31dLiBgICtcbiAgICAgICAgICAnSWYgeW91IGFyZSBydW5uaW5nIHdpdGggcHJlLWFsbG9jYXRlZCBvdXRwdXQsIHBsZWFzZSBtYWtlIHN1cmUgdGhlIG91dHB1dCB0eXBlL2RpbXMgYXJlIGNvcnJlY3QuICcgK1xuICAgICAgICAgIGBFcnJvcjogJHtlfWAsXG4gICAgICApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLm1vZHVsZS5zdGFja1Jlc3RvcmUoc3RhY2spO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgSlNFUCB3aXRoIFdlYkdQVSBiYWNrZW5kLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBsb2FkZWQgYW5kIGluaXRpYWxpemVkIChcIl9PcnRJbml0XCIgaXMgY2FsbGVkKSwgb25jZSBmb3JcbiAqIGVhY2ggb2YgdGhlIGZvbGxvd2luZyBFUHMgaWYgdGhleSBhcmUgc3BlY2lmaWVkOlxuICogLSBcIndlYmdwdVwiXG4gKiAtIFwid2Vibm5cIlxuICpcbiAqIEZvciBXZWJHUFUsIHRoaXMgZnVuY3Rpb24gZXhwZWN0czpcbiAqICAtIFdlYkdQVSBpcyBlbmFibGVkIGluIGJ1aWxkIChCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCA9PT0gZmFsc2UpLlxuICogIC0gV2ViR1BVIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LiAoYSB2YWxpZCBHUFVBZGFwdGVyIGlzIHBhc3NlZCBpbilcbiAqXG4gKiBGb3IgV2ViTk4sIHRoaXMgZnVuY3Rpb24gZXhwZWN0czpcbiAqIC0gV2ViTk4gaXMgZW5hYmxlZCBpbiBidWlsZCAoQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgPT09IGZhbHNlKS5cbiAqIC0gV2ViTk4gaXMgYXZhaWxhYmxlIGluIGN1cnJlbnQgZW52aXJvbm1lbnQuIChuYXZpZ2F0b3IubWwgaXMgbm90IHVuZGVmaW5lZClcbiAqXG4gKiBJZiB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlIGlzIG5vdCBidWlsdCB3aXRoIEpTRVAgc3VwcG9ydCwgdGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIGVycm9yLiBUaGlzIHdpbGwgaW52YWxpZGF0ZVxuICogJ3dlYmdwdScvJ3dlYm5uJyBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIEVQLCBlaXRoZXIgXCJ3ZWJncHVcIiBvciBcIndlYm5uXCJcbiAqIEBwYXJhbSBtb2R1bGUgLSB0aGUgT1JUIFdlYkFzc2VtYmx5IG1vZHVsZVxuICogQHBhcmFtIGVudiAtIHRoZSBPUlQgZW52aXJvbm1lbnQgdmFyaWFibGUgKG9ydC5lbnYpXG4gKiBAcGFyYW0gZ3B1QWRhcHRlciAtIHRoZSBwcmUtY3JlYXRlZCBHUFUgYWRhcHRlclxuICovXG5leHBvcnQgY29uc3QgaW5pdCA9IGFzeW5jIChcbiAgbmFtZTogJ3dlYmdwdScgfCAnd2Vibm4nLFxuICBtb2R1bGU6IE9ydFdhc21Nb2R1bGUsXG4gIGVudjogRW52LFxuICBncHVBZGFwdGVyPzogR1BVQWRhcHRlcixcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCBqc2VwSW5pdCA9IG1vZHVsZS5qc2VwSW5pdDtcbiAgaWYgKCFqc2VwSW5pdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgSlNFUC4gVGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBub3QgYnVpbHQgd2l0aCBKU0VQIHN1cHBvcnQuJyk7XG4gIH1cblxuICBpZiAobmFtZSA9PT0gJ3dlYmdwdScpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgIGNvbnN0IHdlYkdwdUJhY2tlbmRJbXBsID0gcmVxdWlyZSgnLi9iYWNrZW5kLXdlYmdwdScpLldlYkdwdUJhY2tlbmQ7XG4gICAgY29uc3QgYmFja2VuZCA9IG5ldyB3ZWJHcHVCYWNrZW5kSW1wbCgpO1xuICAgIGF3YWl0IGJhY2tlbmQuaW5pdGlhbGl6ZShlbnYsIGdwdUFkYXB0ZXIhKTtcblxuICAgIGpzZXBJbml0KCd3ZWJncHUnLCBbXG4gICAgICAvLyBiYWNrZW5kXG4gICAgICBiYWNrZW5kLFxuXG4gICAgICAvLyBqc2VwQWxsb2MoKVxuICAgICAgKHNpemU6IG51bWJlcikgPT4gYmFja2VuZC5hbGxvYyhOdW1iZXIoc2l6ZSkpLFxuXG4gICAgICAvLyBqc2VwRnJlZSgpXG4gICAgICAocHRyOiBudW1iZXIpID0+IGJhY2tlbmQuZnJlZShwdHIpLFxuXG4gICAgICAvLyBqc2VwQ29weShzcmMsIGRzdCwgc2l6ZSwgaXNTb3VyY2VHcHUpXG4gICAgICAoc3JjOiBudW1iZXIsIGRzdDogbnVtYmVyLCBzaXplOiBudW1iZXIsIGlzU291cmNlR3B1ID0gZmFsc2UpID0+IHtcbiAgICAgICAgaWYgKGlzU291cmNlR3B1KSB7XG4gICAgICAgICAgTE9HX0RFQlVHKFxuICAgICAgICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgICAgICAgKCkgPT4gYFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9HcHU6IHNyYz0ke051bWJlcihzcmMpfSwgZHN0PSR7TnVtYmVyKGRzdCl9LCBzaXplPSR7TnVtYmVyKHNpemUpfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBiYWNrZW5kLm1lbWNweShOdW1iZXIoc3JjKSwgTnVtYmVyKGRzdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIExPR19ERUJVRyhcbiAgICAgICAgICAgICd2ZXJib3NlJyxcbiAgICAgICAgICAgICgpID0+XG4gICAgICAgICAgICAgIGBbV2ViR1BVXSBqc2VwQ29weUNwdVRvR3B1OiBkYXRhT2Zmc2V0PSR7TnVtYmVyKHNyYyl9LCBncHVEYXRhSWQ9JHtOdW1iZXIoZHN0KX0sIHNpemU9JHtOdW1iZXIoc2l6ZSl9YCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBtb2R1bGUuSEVBUFU4LnN1YmFycmF5KE51bWJlcihzcmMgPj4+IDApLCBOdW1iZXIoc3JjID4+PiAwKSArIE51bWJlcihzaXplKSk7XG4gICAgICAgICAgYmFja2VuZC51cGxvYWQoTnVtYmVyKGRzdCksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBqc2VwQ29weUFzeW5jKHNyYywgZHN0LCBzaXplKVxuICAgICAgYXN5bmMgKGdwdURhdGFJZDogbnVtYmVyLCBkYXRhT2Zmc2V0OiBudW1iZXIsIHNpemU6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgICBMT0dfREVCVUcoXG4gICAgICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgICAgICgpID0+IGBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHtncHVEYXRhSWR9LCBkYXRhT2Zmc2V0PSR7ZGF0YU9mZnNldH0sIHNpemU9JHtzaXplfWAsXG4gICAgICAgICk7XG5cbiAgICAgICAgYXdhaXQgYmFja2VuZC5kb3dubG9hZChOdW1iZXIoZ3B1RGF0YUlkKSwgKCkgPT5cbiAgICAgICAgICBtb2R1bGUuSEVBUFU4LnN1YmFycmF5KE51bWJlcihkYXRhT2Zmc2V0KSA+Pj4gMCwgTnVtYmVyKGRhdGFPZmZzZXQgKyBzaXplKSA+Pj4gMCksXG4gICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICAvLyBqc2VwQ3JlYXRlS2VybmVsXG4gICAgICAoa2VybmVsVHlwZTogc3RyaW5nLCBrZXJuZWxJZDogbnVtYmVyLCBhdHRyaWJ1dGU6IHVua25vd24pID0+XG4gICAgICAgIGJhY2tlbmQuY3JlYXRlS2VybmVsKFxuICAgICAgICAgIGtlcm5lbFR5cGUsXG4gICAgICAgICAgTnVtYmVyKGtlcm5lbElkKSxcbiAgICAgICAgICBhdHRyaWJ1dGUsXG4gICAgICAgICAgbW9kdWxlLlVURjhUb1N0cmluZyhtb2R1bGUuX0pzZXBHZXROb2RlTmFtZSEoTnVtYmVyKGtlcm5lbElkKSkpLFxuICAgICAgICApLFxuXG4gICAgICAvLyBqc2VwUmVsZWFzZUtlcm5lbFxuICAgICAgKGtlcm5lbDogbnVtYmVyKSA9PiBiYWNrZW5kLnJlbGVhc2VLZXJuZWwoa2VybmVsKSxcblxuICAgICAgLy8ganNlcFJ1blxuICAgICAgKGtlcm5lbDogbnVtYmVyLCBjb250ZXh0RGF0YU9mZnNldDogbnVtYmVyLCBzZXNzaW9uSGFuZGxlOiBudW1iZXIsIGVycm9yczogQXJyYXk8UHJvbWlzZTxzdHJpbmcgfCBudWxsPj4pID0+IHtcbiAgICAgICAgTE9HX0RFQlVHKFxuICAgICAgICAgICd2ZXJib3NlJyxcbiAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgYFtXZWJHUFVdIGpzZXBSdW46IHNlc3Npb25IYW5kbGU9JHtzZXNzaW9uSGFuZGxlfSwga2VybmVsPSR7a2VybmVsfSwgY29udGV4dERhdGFPZmZzZXQ9JHtjb250ZXh0RGF0YU9mZnNldH1gLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IENvbXB1dGVDb250ZXh0SW1wbChtb2R1bGUsIGJhY2tlbmQsIE51bWJlcihjb250ZXh0RGF0YU9mZnNldCkpO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5jb21wdXRlS2VybmVsKE51bWJlcihrZXJuZWwpLCBjb250ZXh0LCBlcnJvcnMpO1xuICAgICAgfSxcbiAgICAgIC8vIGpzZXBDYXB0dXJlQmVnaW5cbiAgICAgICgpID0+IGJhY2tlbmQuY2FwdHVyZUJlZ2luKCksXG4gICAgICAvLyBqc2VwQ2FwdHVyZUVuZFxuICAgICAgKCkgPT4gYmFja2VuZC5jYXB0dXJlRW5kKCksXG4gICAgICAvLyBqc2VwUmVwbGF5XG4gICAgICAoKSA9PiBiYWNrZW5kLnJlcGxheSgpLFxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJhY2tlbmQgPSBuZXcgV2ViTk5CYWNrZW5kKGVudik7XG4gICAganNlcEluaXQoJ3dlYm5uJywgW1xuICAgICAgYmFja2VuZCxcbiAgICAgIC8vIHdlYm5uUmVzZXJ2ZVRlbnNvcklkXG4gICAgICAoKSA9PiBiYWNrZW5kLnJlc2VydmVUZW5zb3JJZCgpLFxuICAgICAgLy8gd2Vibm5SZWxlYXNlVGVuc29ySWRcbiAgICAgICh0ZW5zb3JJZDogbnVtYmVyKSA9PiBiYWNrZW5kLnJlbGVhc2VUZW5zb3JJZCh0ZW5zb3JJZCksXG4gICAgICAvLyB3ZWJubkVuc3VyZVRlbnNvclxuICAgICAgYXN5bmMgKFxuICAgICAgICBzZXNzaW9uSWQ6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgICAgICAgdGVuc29ySWQ6IG51bWJlcixcbiAgICAgICAgb25ueERhdGFUeXBlOiBudW1iZXIsXG4gICAgICAgIHNoYXBlOiBudW1iZXJbXSxcbiAgICAgICAgY29weU9sZDogYm9vbGVhbixcbiAgICAgICkgPT4gYmFja2VuZC5lbnN1cmVUZW5zb3Ioc2Vzc2lvbklkLCB0ZW5zb3JJZCwgb25ueERhdGFUeXBlLCBzaGFwZSwgY29weU9sZCksXG4gICAgICAvLyB3ZWJublVwbG9hZFRlbnNvclxuICAgICAgKHRlbnNvcklkOiBudW1iZXIsIGRhdGE6IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgYmFja2VuZC51cGxvYWRUZW5zb3IodGVuc29ySWQsIGRhdGEpO1xuICAgICAgfSxcbiAgICAgIC8vIHdlYm5uRG93bmxvYWRUZW5zb3JcbiAgICAgIGFzeW5jICh0ZW5zb3JJZDogbnVtYmVyLCBkc3RCdWZmZXI6IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKSA9PiBiYWNrZW5kLmRvd25sb2FkVGVuc29yKHRlbnNvcklkLCBkc3RCdWZmZXIpLFxuICAgICAgLy8gd2Vibm5SZWdpc3Rlck1MQ29udGV4dFxuICAgICAgKHNlc3Npb25JZDogbnVtYmVyLCBtbENvbnRleHQ6IE1MQ29udGV4dCkgPT4gYmFja2VuZC5yZWdpc3Rlck1MQ29udGV4dChzZXNzaW9uSWQsIG1sQ29udGV4dCksXG4gICAgICAvLyB3ZWJubkVuYWJsZVRyYWNlRXZlbnRcbiAgICAgICEhZW52LnRyYWNlLFxuICAgIF0pO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLyBXZWJOTiBBUEkgY3VycmVudGx5IGRvZXMgbm90IGhhdmUgYSBUeXBlU2NyaXB0IGRlZmluaXRpb24gZmlsZS4gVGhpcyBmaWxlIGlzIGEgd29ya2Fyb3VuZCB3aXRoIHR5cGVzIGdlbmVyYXRlZCBmcm9tXG4vLyBXZWJOTiBBUEkgc3BlY2lmaWNhdGlvbi5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJtYWNoaW5lbGVhcm5pbmcvd2Vibm4vaXNzdWVzLzY3N1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cImpzZXAvd2Vibm4vd2Vibm4uZC50c1wiIC8+XG5cbmltcG9ydCB7IEVudiwgSW5mZXJlbmNlU2Vzc2lvbiwgVGVuc29yLCBUUkFDRV9FVkVOVF9CRUdJTiwgVFJBQ0VfRVZFTlRfRU5EIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtcbiAgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsXG4gIFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YSxcbiAgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGEsXG4gIFRlbnNvck1ldGFkYXRhLFxufSBmcm9tICcuL3Byb3h5LW1lc3NhZ2VzJztcbmltcG9ydCB7IHNldFJ1bk9wdGlvbnMgfSBmcm9tICcuL3J1bi1vcHRpb25zJztcbmltcG9ydCB7IHNldFNlc3Npb25PcHRpb25zIH0gZnJvbSAnLi9zZXNzaW9uLW9wdGlvbnMnO1xuaW1wb3J0IHtcbiAgY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMsXG4gIGRhdGFMb2NhdGlvblN0cmluZ1RvRW51bSxcbiAgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlLFxuICBpc01MVGVuc29yU3VwcG9ydGVkVHlwZSxcbiAgbG9nTGV2ZWxTdHJpbmdUb0VudW0sXG4gIHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nLFxuICB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSxcbiAgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yLFxufSBmcm9tICcuL3dhc20tY29tbW9uJztcbmltcG9ydCB7IGdldEluc3RhbmNlIH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHsgYWxsb2NXYXNtU3RyaW5nLCBjaGVja0xhc3RFcnJvciB9IGZyb20gJy4vd2FzbS11dGlscyc7XG5pbXBvcnQgeyBsb2FkRmlsZSB9IGZyb20gJy4vd2FzbS11dGlscy1sb2FkLWZpbGUnO1xuXG4vLyAjcmVnaW9uIEluaXRpYWxpemF0aW9uc1xuXG4vKipcbiAqIFRoZXJlIGFyZSA0IGRpZmZlcmVudCBcImluaXRpYWxpemF0aW9uXCIgc3RlcHMgZm9yIE9SVC4gVGhleSBoYXBwZW4gaW4gZGlmZmVyZW50IHBsYWNlcyBhbmQgZGlmZmVyZW50IHRpbWUuXG4gKlxuICogMS4gSmF2YVNjcmlwdCBpbml0aWFsaXphdGlvbiBmb3Igb25ueHJ1bnRpbWUtY29tbW9uIGFuZCBvbm54cnVudGltZS13ZWIuXG4gKiAgICBUaGlzIGlzIHRoZSBmaXJzdCBpbml0aWFsaXphdGlvbiBzdGVwLiBJbiB0aGlzIHN0ZXAsIG9ubnhydW50aW1lLXdlYiBjYWxscyBvbm54cnVudGltZS1jb21tb24ncyByZWdpc3RlckJhY2tlbmQoKVxuICogZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgdG8gcmVnaXN0ZXIgYWxsIHRoZSBhdmFpbGFibGUgYmFja2VuZHMuIFRoZSBiYWNrZW5kIHJlZ2lzdHJhdGlvbiBpcyB2ZXJ5IGZhc3QuIEl0IG9ubHlcbiAqIHJlZ2lzdGVycyB0aGUgYmFja2VuZCBuYW1lIHdpdGggdGhlIHVuaW5pdGlhbGl6ZWQgYmFja2VuZCBvYmplY3QuIE5vIGhlYXZ5IGluaXRpYWxpemF0aW9uIGlzIGRvbmUgaW4gdGhpcyBzdGVwLlxuICogICAgUmVmZXIgdG8gd2ViL2xpYi9pbmRleC50cyBmb3IgdGhlIGJhY2tlbmQgcmVnaXN0cmF0aW9uLlxuICpcbiAqIDIuIFdlYkFzc2VtYmx5IGFydGlmYWN0IGluaXRpYWxpemF0aW9uLlxuICogICAgVGhpcyBoYXBwZW5zIHdoZW4gYW55IHJlZ2lzdGVyZWQgd2FzbSBiYWNrZW5kIGlzIHVzZWQgZm9yIHRoZSBmaXJzdCB0aW1lIChpZS4gYG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZSgpYCBpc1xuICogY2FsbGVkKS4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgZG9lcyB0aGUgZm9sbG93aW5nczpcbiAqICAgICAtIGNyZWF0ZSBhIHByb3h5IHdvcmtlciBhbmQgbWFrZSBzdXJlIHRoZSBwcm94eSB3b3JrZXIgaXMgcmVhZHkgdG8gcmVjZWl2ZSBtZXNzYWdlcywgaWYgcHJveHkgaXMgZW5hYmxlZC5cbiAqICAgICAtIHBlcmZvcm0gZmVhdHVyZSBkZXRlY3Rpb24sIGxvY2F0ZSBjb3JyZWN0IFdlYkFzc2VtYmx5IGFydGlmYWN0IHBhdGggYW5kIGNhbGwgdGhlIEVtc2NyaXB0ZW4gZ2VuZXJhdGVkXG4gKiBKYXZhU2NyaXB0IGNvZGUgdG8gaW5pdGlhbGl6ZSB0aGUgV2ViQXNzZW1ibHkgcnVudGltZS5cbiAqICAgICAgICAgLSBpZiBwcm94eSBpcyBlbmFibGVkLCB0aGlzIHN0ZXAgaGFwcGVucyBpbiB0aGUgcHJveHkgd29ya2VyIHVzaW5nIG1lc3NhZ2UgJ2luaXQtd2FzbScuXG4gKiAgICAgICAgIC0gZG93bmxvYWRpbmcgdGhlICdvcnQtd2FzbXsuLi59Lndhc20nIGZpbGUgaXMgZG9uZSBpbiB0aGlzIHN0ZXAuXG4gKiAgICAgICAgIC0gaWYgbXVsdGktdGhyZWFkIGlzIGVuYWJsZWQsIG9uZSBvciBtb3JlIHdlYndvcmtlciB3aWxsIGJlIGNyZWF0ZWQgdG8gaW5pdGlhbGl6ZSB0aGUgUFRocmVhZCB0aHJlYWRwb29sLlxuICpcbiAqIDMuIE9SVCBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cbiAqICAgIFRoaXMgaGFwcGVucyBhZnRlciBzdGVwIDIuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIHBlcmZvcm1zIE9OTlggUnVudGltZSBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cbiAqIEZ1bmN0aW9uIGBfT3J0SW5pdCgpYCBpcyBjYWxsZWQgaW4gdGhpcyBzdGVwLlxuICogICAgIC0gaWYgcHJveHkgaXMgZW5hYmxlZCwgdGhpcyBzdGVwIGhhcHBlbnMgaW4gdGhlIHByb3h5IHdvcmtlciB1c2luZyBtZXNzYWdlICdpbml0LW9ydCcuXG4gKiAgICAgLSBsb2dnaW5nIGxldmVsIChvcnQuZW52LmxvZ0xldmVsKSBhbmQgdGhyZWFkIG51bWJlciAob3J0LmVudi53YXNtLm51bVRocmVhZHMpIGFyZSBzZXQgaW4gdGhpcyBzdGVwLlxuICpcbiAqIDQuIFNlc3Npb24gaW5pdGlhbGl6YXRpb24uXG4gKiAgICBUaGlzIGhhcHBlbnMgd2hlbiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIGlzIGNhbGxlZC4gVW5saWtlIHRoZSBmaXJzdCAzIHN0ZXBzICh0aGV5IG9ubHkgY2FsbGVkIG9uY2UpLFxuICogdGhpcyBzdGVwIHdpbGwgYmUgZG9uZSBmb3IgZWFjaCBzZXNzaW9uLiBJbiB0aGlzIHN0ZXAsIG9ubnhydW50aW1lLXdlYiBkb2VzIHRoZSBmb2xsb3dpbmdzOlxuICogICAgSWYgdGhlIHBhcmFtZXRlciBpcyBhIFVSTDpcbiAqICAgIC0gZG93bmxvYWQgdGhlIG1vZGVsIGRhdGEgZnJvbSB0aGUgVVJMLlxuICogICAgLSBjb3B5IHRoZSBtb2RlbCBkYXRhIHRvIHRoZSBXQVNNIGhlYXAuIChwcm94eTogJ2NvcHktZnJvbScpXG4gKiAgICAtIGRlcmVmZXJlbmNlIHRoZSBtb2RlbCBidWZmZXIuIFRoaXMgc3RlcCBhbGxvd3MgdGhlIG9yaWdpbmFsIEFycmF5QnVmZmVyIHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuICogICAgLSBjYWxsIGBfT3J0Q3JlYXRlU2Vzc2lvbigpYCB0byBjcmVhdGUgdGhlIHNlc3Npb24uIChwcm94eTogJ2NyZWF0ZScpXG4gKlxuICogICAgSWYgdGhlIHBhcmFtZXRlciBpcyBhIFVpbnQ4QXJyYXkgb2JqZWN0OlxuICogICAgLSBjb3B5IHRoZSBtb2RlbCBkYXRhIHRvIHRoZSBXQVNNIGhlYXAuIChwcm94eTogJ2NvcHktZnJvbScpXG4gKiAgICAtIGNhbGwgYF9PcnRDcmVhdGVTZXNzaW9uKClgIHRvIGNyZWF0ZSB0aGUgc2Vzc2lvbi4gKHByb3h5OiAnY3JlYXRlJylcbiAqXG4gKlxuICovXG5cbi8qKlxuICogaW5pdGlhbGl6ZSBPUlQgZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtIG51bVRocmVhZHMgU2V0R2xvYmFsSW50cmFPcE51bVRocmVhZHMobnVtVGhyZWFkcylcbiAqIEBwYXJhbSBsb2dnaW5nTGV2ZWwgQ3JlYXRlRW52KHN0YXRpY19jYXN0PE9ydExvZ2dpbmdMZXZlbD4obG9nZ2luZ19sZXZlbCkpXG4gKi9cbmNvbnN0IGluaXRPcnQgPSAobnVtVGhyZWFkczogbnVtYmVyLCBsb2dnaW5nTGV2ZWw6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCBlcnJvckNvZGUgPSBnZXRJbnN0YW5jZSgpLl9PcnRJbml0KG51bVRocmVhZHMsIGxvZ2dpbmdMZXZlbCk7XG4gIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuXCIpO1xuICB9XG59O1xuXG4vKipcbiAqIGluaXRpYWxpemUgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSBlbnYgcGFzc2VkIGluIHRoZSBlbnZpcm9ubWVudCBjb25maWcgb2JqZWN0LlxuICovXG5leHBvcnQgY29uc3QgaW5pdFJ1bnRpbWUgPSBhc3luYyAoZW52OiBFbnYpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgLy8gaW5pdCBPUlRcbiAgaW5pdE9ydChlbnYud2FzbS5udW1UaHJlYWRzISwgbG9nTGV2ZWxTdHJpbmdUb0VudW0oZW52LmxvZ0xldmVsKSk7XG59O1xuXG4vKipcbiAqIHBlcmZvcm0gRVAgc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24uXG4gKlxuICogQHBhcmFtIGVudlxuICogQHBhcmFtIGVwTmFtZVxuICovXG5leHBvcnQgY29uc3QgaW5pdEVwID0gYXN5bmMgKGVudjogRW52LCBlcE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAvLyBpbml0aWFsaXplIEFTWU5DSUZZIHN1cHBvcnRcbiAgZ2V0SW5zdGFuY2UoKS5hc3luY0luaXQ/LigpO1xuXG4gIC8vIHBlcmZvcm0gV2ViR1BVIGF2YWlsYWJpbGl0eSBjaGVjayAoIGVpdGhlciBKU0VQIG9yIFdlYkdQVSBFUCApXG4gIGxldCB3ZWJncHVBZGFwdGVyID0gZW52LndlYmdwdS5hZGFwdGVyIGFzIEdQVUFkYXB0ZXIgfCBudWxsO1xuICBpZiAoZXBOYW1lID09PSAnd2ViZ3B1Jykge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLmdwdSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHUFUgaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50Jyk7XG4gICAgfVxuICAgIGlmICghd2ViZ3B1QWRhcHRlcikge1xuICAgICAgLy8gaWYgYWRhcHRlciBpcyBub3Qgc2V0LCByZXF1ZXN0IGEgbmV3IGFkYXB0ZXIuXG4gICAgICBjb25zdCBwb3dlclByZWZlcmVuY2UgPSBlbnYud2ViZ3B1LnBvd2VyUHJlZmVyZW5jZTtcbiAgICAgIGlmIChwb3dlclByZWZlcmVuY2UgIT09IHVuZGVmaW5lZCAmJiBwb3dlclByZWZlcmVuY2UgIT09ICdsb3ctcG93ZXInICYmIHBvd2VyUHJlZmVyZW5jZSAhPT0gJ2hpZ2gtcGVyZm9ybWFuY2UnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwb3dlclByZWZlcmVuY2Ugc2V0dGluZzogXCIke3Bvd2VyUHJlZmVyZW5jZX1cImApO1xuICAgICAgfVxuICAgICAgY29uc3QgZm9yY2VGYWxsYmFja0FkYXB0ZXIgPSBlbnYud2ViZ3B1LmZvcmNlRmFsbGJhY2tBZGFwdGVyO1xuICAgICAgaWYgKGZvcmNlRmFsbGJhY2tBZGFwdGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGZvcmNlRmFsbGJhY2tBZGFwdGVyICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZvcmNlRmFsbGJhY2tBZGFwdGVyIHNldHRpbmc6IFwiJHtmb3JjZUZhbGxiYWNrQWRhcHRlcn1cImApO1xuICAgICAgfVxuICAgICAgd2ViZ3B1QWRhcHRlciA9IGF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoeyBwb3dlclByZWZlcmVuY2UsIGZvcmNlRmFsbGJhY2tBZGFwdGVyIH0pO1xuICAgICAgaWYgKCF3ZWJncHVBZGFwdGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBuZWVkIHRvIGVuYWJsZSBmbGFnIFwiLS1lbmFibGUtdW5zYWZlLXdlYmdwdVwiIGlmIHlvdSBhcmUgdXNpbmcgQ2hyb21lLicsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFkYXB0ZXIgaXMgc2V0LCB2YWxpZGF0ZSBpdC5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHdlYmdwdUFkYXB0ZXIubGltaXRzICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICB0eXBlb2Ygd2ViZ3B1QWRhcHRlci5mZWF0dXJlcyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgdHlwZW9mIHdlYmdwdUFkYXB0ZXIucmVxdWVzdERldmljZSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHUFUgYWRhcHRlciBzZXQgaW4gYGVudi53ZWJncHUuYWRhcHRlcmAuIEl0IG11c3QgYmUgYSBHUFVBZGFwdGVyIG9iamVjdC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBwZXJmb3JtIFdlYk5OIGF2YWlsYWJpbGl0eSBjaGVjayAoIGVpdGhlciBKU0VQIG9yIFdlYk5OIEVQIClcbiAgaWYgKGVwTmFtZSA9PT0gJ3dlYm5uJykge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhKG5hdmlnYXRvciBhcyB1bmtub3duIGFzIHsgbWw6IHVua25vd24gfSkubWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViTk4gaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgY29uc3QgaW5pdEpzZXAgPSByZXF1aXJlKCcuL2pzZXAvaW5pdCcpLmluaXQ7XG5cbiAgICBpZiAoZXBOYW1lID09PSAnd2ViZ3B1Jykge1xuICAgICAgYXdhaXQgaW5pdEpzZXAoJ3dlYmdwdScsIGdldEluc3RhbmNlKCksIGVudiwgd2ViZ3B1QWRhcHRlcik7XG4gICAgfVxuICAgIGlmIChlcE5hbWUgPT09ICd3ZWJubicpIHtcbiAgICAgIGF3YWl0IGluaXRKc2VwKCd3ZWJubicsIGdldEluc3RhbmNlKCksIGVudik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSAmJiBlcE5hbWUgPT09ICd3ZWJncHUnKSB7XG4gICAgICBnZXRJbnN0YW5jZSgpLndlYmdwdUluaXQhKChkZXZpY2UpID0+IHtcbiAgICAgICAgZW52LndlYmdwdS5kZXZpY2UgPSBkZXZpY2U7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCTk4gJiYgZXBOYW1lID09PSAnd2Vibm4nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgICAgY29uc3QgYmFja2VuZCA9IG5ldyAocmVxdWlyZSgnLi9qc2VwL2JhY2tlbmQtd2Vibm4nKS5XZWJOTkJhY2tlbmQpKGVudik7XG4gICAgICBnZXRJbnN0YW5jZSgpLndlYm5uSW5pdCEoW1xuICAgICAgICBiYWNrZW5kLFxuICAgICAgICAvLyB3ZWJublJlc2VydmVUZW5zb3JJZFxuICAgICAgICAoKSA9PiBiYWNrZW5kLnJlc2VydmVUZW5zb3JJZCgpLFxuICAgICAgICAvLyB3ZWJublJlbGVhc2VUZW5zb3JJZCxcbiAgICAgICAgKHRlbnNvcklkOiBudW1iZXIpID0+IGJhY2tlbmQucmVsZWFzZVRlbnNvcklkKHRlbnNvcklkKSxcbiAgICAgICAgLy8gd2Vibm5FbnN1cmVUZW5zb3JcbiAgICAgICAgYXN5bmMgKHNlc3Npb25JZDogbnVtYmVyIHwgdW5kZWZpbmVkLCB0ZW5zb3JJZDogbnVtYmVyLCBvbm54RGF0YVR5cGU6IG51bWJlciwgc2hhcGU6IG51bWJlcltdLCBjb3B5T2xkKSA9PlxuICAgICAgICAgIGJhY2tlbmQuZW5zdXJlVGVuc29yKHNlc3Npb25JZCwgdGVuc29ySWQsIG9ubnhEYXRhVHlwZSwgc2hhcGUsIGNvcHlPbGQpLFxuICAgICAgICAvLyB3ZWJublVwbG9hZFRlbnNvclxuICAgICAgICAodGVuc29ySWQ6IG51bWJlciwgZGF0YTogVWludDhBcnJheSkgPT4ge1xuICAgICAgICAgIGJhY2tlbmQudXBsb2FkVGVuc29yKHRlbnNvcklkLCBkYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gd2Vibm5Eb3dubG9hZFRlbnNvclxuICAgICAgICBhc3luYyAodGVuc29ySWQ6IG51bWJlciwgZHN0QnVmZmVyOiBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcikgPT5cbiAgICAgICAgICBiYWNrZW5kLmRvd25sb2FkVGVuc29yKHRlbnNvcklkLCBkc3RCdWZmZXIpLFxuICAgICAgICAvLyB3ZWJublJlZ2lzdGVyTUxDb250ZXh0XG4gICAgICAgIChzZXNzaW9uSWQ6IG51bWJlciwgbWxDb250ZXh0OiBNTENvbnRleHQpID0+IGJhY2tlbmQucmVnaXN0ZXJNTENvbnRleHQoc2Vzc2lvbklkLCBtbENvbnRleHQpLFxuICAgICAgICAvLyB3ZWJubkVuYWJsZVRyYWNlRXZlbnRcbiAgICAgICAgISFlbnYudHJhY2UsXG4gICAgICBdKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vICNlbmRyZWdpb24gSW5pdGlhbGl6YXRpb25zXG5cbi8qKlxuICogdmFsaWQgZGF0YSBsb2NhdGlvbnMgZm9yIGlucHV0L291dHB1dCB0ZW5zb3JzLlxuICovXG50eXBlIFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0ID1cbiAgfCAnY3B1J1xuICB8ICdjcHUtcGlubmVkJ1xuICB8ICdncHUtYnVmZmVyJ1xuICB8ICdtbC10ZW5zb3InXG4gIC8vIFVzZSAnbWwtdGVuc29yJyBkdXJpbmcgaW5mZXJlbmNlLCBidXQgb3V0cHV0IGEgdGVuc29yIGxvY2F0ZWQgb24gdGhlIENQVS5cbiAgfCAnbWwtdGVuc29yLWNwdS1vdXRwdXQnO1xuXG50eXBlIElPQmluZGluZ1N0YXRlID0ge1xuICAvKipcbiAgICogdGhlIGhhbmRsZSBvZiBJTyBiaW5kaW5nLlxuICAgKi9cbiAgcmVhZG9ubHkgaGFuZGxlOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIHRoZSBwcmVmZXJyZWQgbG9jYXRpb24gZm9yIGVhY2ggb3V0cHV0IHRlbnNvci5cbiAgICpcbiAgICogdmFsdWUgaXMgb25lIG9mICdjcHUnLCAnY3B1LXBpbm5lZCcsICdncHUtYnVmZmVyJywgJ21sLXRlbnNvcicuXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6IHJlYWRvbmx5IFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0W107XG5cbiAgLyoqXG4gICAqIGVudW0gdmFsdWUgb2YgdGhlIHByZWZlcnJlZCBsb2NhdGlvbiBmb3IgZWFjaCBvdXRwdXQgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDogcmVhZG9ubHkgbnVtYmVyW107XG59O1xuXG4vKipcbiAqICB0dXBsZSBlbGVtZW50cyBhcmU6IEluZmVyZW5jZVNlc3Npb24gSUQ7IGlucHV0TmFtZXNVVEY4RW5jb2RlZDsgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZDsgYmluZGluZ1N0YXRlXG4gKi9cbnR5cGUgU2Vzc2lvbk1ldGFkYXRhID0gW1xuICBpbmZlcmVuY2VTZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5wdXROYW1lc1VURjhFbmNvZGVkOiBudW1iZXJbXSxcbiAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZDogbnVtYmVyW10sXG4gIGJpbmRpbmdTdGF0ZTogSU9CaW5kaW5nU3RhdGUgfCBudWxsLFxuICBlbmFibGVHcmFwaENhcHR1cmU6IGJvb2xlYW4sXG4gIGlucHV0T3V0cHV0Qm91bmQ6IGJvb2xlYW4sXG5dO1xuXG5jb25zdCBhY3RpdmVTZXNzaW9ucyA9IG5ldyBNYXA8bnVtYmVyLCBTZXNzaW9uTWV0YWRhdGE+KCk7XG5cbi8qKlxuICogZ2V0IHRoZSBpbnB1dC9vdXRwdXQgY291bnQgb2YgdGhlIHNlc3Npb24uXG4gKiBAcGFyYW0gc2Vzc2lvbkhhbmRsZSB0aGUgaGFuZGxlIHJlcHJlc2VudGluZyB0aGUgc2Vzc2lvbi4gc2hvdWxkIGJlIG5vbi16ZXJvLlxuICogQHJldHVybnMgYSB0dXBsZSBpbmNsdWRpbmcgMiBudW1iZXJzLCByZXByZXNlbnRpbmcgdGhlIGlucHV0IGNvdW50IGFuZCBvdXRwdXQgY291bnQuXG4gKi9cbmNvbnN0IGdldFNlc3Npb25JbnB1dE91dHB1dENvdW50ID0gKHNlc3Npb25IYW5kbGU6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICB0cnkge1xuICAgIGNvbnN0IHB0clNpemUgPSB3YXNtLlBUUl9TSVpFO1xuICAgIGNvbnN0IGRhdGFPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoMiAqIHB0clNpemUpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEdldElucHV0T3V0cHV0Q291bnQoc2Vzc2lvbkhhbmRsZSwgZGF0YU9mZnNldCwgZGF0YU9mZnNldCArIHB0clNpemUpO1xuICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHB0clNpemUgPT09IDQgPyAnaTMyJyA6ICdpNjQnO1xuICAgIHJldHVybiBbTnVtYmVyKHdhc20uZ2V0VmFsdWUoZGF0YU9mZnNldCwgdHlwZSkpLCBOdW1iZXIod2FzbS5nZXRWYWx1ZShkYXRhT2Zmc2V0ICsgcHRyU2l6ZSwgdHlwZSkpXTtcbiAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLnN0YWNrUmVzdG9yZShzdGFjayk7XG4gIH1cbn07XG5cbmNvbnN0IGdldFNlc3Npb25JbnB1dE91dHB1dE1ldGFkYXRhID0gKFxuICBzZXNzaW9uSGFuZGxlOiBudW1iZXIsXG4gIGluZGV4OiBudW1iZXIsXG4pOiBbbmFtZU9mZnNldDogbnVtYmVyLCBlbGVtZW50VHlwZTogbnVtYmVyLCBkaW1zPzogQXJyYXk8bnVtYmVyIHwgc3RyaW5nPl0gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICBsZXQgbWV0YWRhdGFPZmZzZXQgPSAwO1xuICB0cnkge1xuICAgIGNvbnN0IHB0clNpemUgPSB3YXNtLlBUUl9TSVpFO1xuICAgIGNvbnN0IGRhdGFPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoMiAqIHB0clNpemUpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEdldElucHV0T3V0cHV0TWV0YWRhdGEoc2Vzc2lvbkhhbmRsZSwgaW5kZXgsIGRhdGFPZmZzZXQsIGRhdGFPZmZzZXQgKyBwdHJTaXplKTtcbiAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBtZXRhZGF0YS5cIik7XG4gICAgfVxuICAgIGNvbnN0IG5hbWVPZmZzZXQgPSBOdW1iZXIod2FzbS5nZXRWYWx1ZShkYXRhT2Zmc2V0LCAnKicpKTtcbiAgICBtZXRhZGF0YU9mZnNldCA9IE51bWJlcih3YXNtLmdldFZhbHVlKGRhdGFPZmZzZXQgKyBwdHJTaXplLCAnKicpKTtcbiAgICAvLyBnZXQgZWxlbWVudCB0eXBlXG4gICAgY29uc3QgZWxlbWVudFR5cGUgPSB3YXNtLkhFQVAzMlttZXRhZGF0YU9mZnNldCAvIDRdO1xuICAgIGlmIChlbGVtZW50VHlwZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtuYW1lT2Zmc2V0LCAwXTsgLy8gbm9uLXRlbnNvclxuICAgIH1cblxuICAgIC8vIGdldCBkaW1zIGNvdW50XG4gICAgY29uc3QgZGltc0NvdW50ID0gd2FzbS5IRUFQVTMyW21ldGFkYXRhT2Zmc2V0IC8gNCArIDFdO1xuICAgIC8vIGdldCBkaW1zXG4gICAgY29uc3QgZGltczogQXJyYXk8bnVtYmVyIHwgc3RyaW5nPiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHN5bWJvbGljRGltTmFtZU9mZnNldCA9IE51bWJlcih3YXNtLmdldFZhbHVlKG1ldGFkYXRhT2Zmc2V0ICsgOCArIGkgKiBwdHJTaXplLCAnKicpKTtcbiAgICAgIGRpbXMucHVzaChcbiAgICAgICAgc3ltYm9saWNEaW1OYW1lT2Zmc2V0ICE9PSAwXG4gICAgICAgICAgPyB3YXNtLlVURjhUb1N0cmluZyhzeW1ib2xpY0RpbU5hbWVPZmZzZXQpXG4gICAgICAgICAgOiBOdW1iZXIod2FzbS5nZXRWYWx1ZShtZXRhZGF0YU9mZnNldCArIDggKyAoaSArIGRpbXNDb3VudCkgKiBwdHJTaXplLCAnKicpKSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBbbmFtZU9mZnNldCwgZWxlbWVudFR5cGUsIGRpbXNdO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgICBpZiAobWV0YWRhdGFPZmZzZXQgIT09IDApIHtcbiAgICAgIHdhc20uX09ydEZyZWUobWV0YWRhdGFPZmZzZXQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBhbGxvY2F0ZSB0aGUgbWVtb3J5IGFuZCBtZW1jcHkgdGhlIGV4dGVybmFsIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gbW9kZWwgLSB0aGUgZXh0ZXJuYWwgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIG1vZGVsIGRhdGEuIE11c3Qgbm90IGJlIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgV0FTTSBoZWFwLlxuICogQHJldHVybnMgYSAyLWVsZW1lbnRzIHR1cGxlIC0gdGhlIHBvaW50ZXIgYW5kIHNpemUgb2YgdGhlIGFsbG9jYXRlZCBidWZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIgPSAobW9kZWw6IFVpbnQ4QXJyYXkpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IG1vZGVsRGF0YU9mZnNldCA9IHdhc20uX21hbGxvYyhtb2RlbC5ieXRlTGVuZ3RoKTtcbiAgaWYgKG1vZGVsRGF0YU9mZnNldCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHttb2RlbC5ieXRlTGVuZ3RofS5gKTtcbiAgfVxuICB3YXNtLkhFQVBVOC5zZXQobW9kZWwsIG1vZGVsRGF0YU9mZnNldCk7XG4gIHJldHVybiBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbC5ieXRlTGVuZ3RoXTtcbn07XG5cbi8qKlxuICogY3JlYXRlIGFuIGluZmVyZW5jZSBzZXNzaW9uIGZyb20gYSBtb2RlbCBkYXRhIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gbW9kZWxEYXRhIC0gZWl0aGVyIGEgVWludDhBcnJheSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBtb2RlbCBkYXRhLCBvciBhIDItZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyB0aGVcbiAqICAgICBwb2ludGVyIGFuZCBzaXplIG9mIHRoZSBtb2RlbCBkYXRhIGJ1ZmZlci5cbiAqIEBwYXJhbSBvcHRpb25zIGFuIG9wdGlvbmFsIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBhIDMtZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyBbc2Vzc2lvbiBoYW5kbGUsIGlucHV0IG5hbWVzLCBvdXRwdXQgbmFtZXNdXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTZXNzaW9uID0gYXN5bmMgKFxuICBtb2RlbERhdGE6IFVpbnQ4QXJyYXkgfCBTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcixcbiAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YT4gPT4ge1xuICBsZXQgbW9kZWxEYXRhT2Zmc2V0OiBudW1iZXIsIG1vZGVsRGF0YUxlbmd0aDogbnVtYmVyO1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShtb2RlbERhdGEpKSB7XG4gICAgLy8gaWYgbW9kZWwgZGF0YSBpcyBhbiBhcnJheSwgaXQgbXVzdCBiZSBhIDItZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyB0aGUgcG9pbnRlciBhbmQgc2l6ZSBvZiB0aGUgbW9kZWwgZGF0YVxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBtb2RlbERhdGE7XG4gIH0gZWxzZSBpZiAobW9kZWxEYXRhLmJ1ZmZlciA9PT0gd2FzbS5IRUFQVTguYnVmZmVyKSB7XG4gICAgLy8gaWYgbW9kZWwgZGF0YSB1c2VzIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgV0FTTSBoZWFwLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgaXQuXG4gICAgW21vZGVsRGF0YU9mZnNldCwgbW9kZWxEYXRhTGVuZ3RoXSA9IFttb2RlbERhdGEuYnl0ZU9mZnNldCwgbW9kZWxEYXRhLmJ5dGVMZW5ndGhdO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aGVyd2lzZSwgY29weSB0aGUgbW9kZWwgZGF0YSB0byB0aGUgV0FTTSBoZWFwLlxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKG1vZGVsRGF0YSk7XG4gIH1cblxuICBsZXQgc2Vzc2lvbkhhbmRsZSA9IDA7XG4gIGxldCBzZXNzaW9uT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGxldCBpb0JpbmRpbmdIYW5kbGUgPSAwO1xuICBsZXQgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBpbnB1dE5hbWVzVVRGOEVuY29kZWQgPSBbXTtcbiAgY29uc3Qgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCA9IFtdO1xuXG4gIHRyeSB7XG4gICAgW3Nlc3Npb25PcHRpb25zSGFuZGxlLCBhbGxvY3NdID0gYXdhaXQgc2V0U2Vzc2lvbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucz8uZXh0ZXJuYWxEYXRhICYmIHdhc20ubW91bnRFeHRlcm5hbERhdGEpIHtcbiAgICAgIGNvbnN0IGxvYWRpbmdQcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIG9wdGlvbnMuZXh0ZXJuYWxEYXRhKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycgPyBmaWxlIDogZmlsZS5wYXRoO1xuICAgICAgICBsb2FkaW5nUHJvbWlzZXMucHVzaChcbiAgICAgICAgICBsb2FkRmlsZSh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycgPyBmaWxlIDogZmlsZS5kYXRhKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB3YXNtLm1vdW50RXh0ZXJuYWxEYXRhKHBhdGgsIGRhdGEpO1xuICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyB3YWl0IGZvciBhbGwgZXh0ZXJuYWwgZGF0YSBmaWxlcyB0byBiZSBsb2FkZWRcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGxvYWRpbmdQcm9taXNlcyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwcm92aWRlciBvZiBvcHRpb25zPy5leGVjdXRpb25Qcm92aWRlcnMgPz8gW10pIHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyTmFtZSA9IHR5cGVvZiBwcm92aWRlciA9PT0gJ3N0cmluZycgPyBwcm92aWRlciA6IHByb3ZpZGVyLm5hbWU7XG4gICAgICBpZiAocHJvdmlkZXJOYW1lID09PSAnd2Vibm4nKSB7XG4gICAgICAgIHdhc20uc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3Qgd2Vibm5PcHRpb25zID0gcHJvdmlkZXIgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5PcHRpb25zV2l0aE1MQ29udGV4dCk/LmNvbnRleHQ7XG4gICAgICAgICAgY29uc3QgZ3B1RGV2aWNlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OT3B0aW9uc1dlYkdwdSk/LmdwdURldmljZTtcbiAgICAgICAgICBjb25zdCBkZXZpY2VUeXBlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OQ29udGV4dE9wdGlvbnMpPy5kZXZpY2VUeXBlO1xuICAgICAgICAgIGNvbnN0IHBvd2VyUHJlZmVyZW5jZSA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkNvbnRleHRPcHRpb25zKT8ucG93ZXJQcmVmZXJlbmNlO1xuICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICB3YXNtLmN1cnJlbnRDb250ZXh0ID0gY29udGV4dCBhcyBNTENvbnRleHQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChncHVEZXZpY2UpIHtcbiAgICAgICAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSBhd2FpdCB3YXNtLndlYm5uQ3JlYXRlTUxDb250ZXh0IShncHVEZXZpY2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXNtLmN1cnJlbnRDb250ZXh0ID0gYXdhaXQgd2FzbS53ZWJubkNyZWF0ZU1MQ29udGV4dCEoeyBkZXZpY2VUeXBlLCBwb3dlclByZWZlcmVuY2UgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSBhd2FpdCB3YXNtLndlYm5uQ3JlYXRlTUxDb250ZXh0ISgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlc3Npb25IYW5kbGUgPSBhd2FpdCB3YXNtLl9PcnRDcmVhdGVTZXNzaW9uKG1vZGVsRGF0YU9mZnNldCwgbW9kZWxEYXRhTGVuZ3RoLCBzZXNzaW9uT3B0aW9uc0hhbmRsZSk7XG4gICAgd2FzbS53ZWJncHVPbkNyZWF0ZVNlc3Npb24/LihzZXNzaW9uSGFuZGxlKTtcbiAgICBpZiAoc2Vzc2lvbkhhbmRsZSA9PT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLlwiKTtcbiAgICB9XG5cbiAgICB3YXNtLmpzZXBPbkNyZWF0ZVNlc3Npb24/LigpO1xuXG4gICAgLy8gY2xlYXIgY3VycmVudCBNTENvbnRleHQgYWZ0ZXIgc2Vzc2lvbiBjcmVhdGlvblxuICAgIGlmICh3YXNtLmN1cnJlbnRDb250ZXh0KSB7XG4gICAgICB3YXNtLndlYm5uUmVnaXN0ZXJNTENvbnRleHQhKHNlc3Npb25IYW5kbGUsIHdhc20uY3VycmVudENvbnRleHQpO1xuICAgICAgd2FzbS5jdXJyZW50Q29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgIHdhc20uc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBbaW5wdXRDb3VudCwgb3V0cHV0Q291bnRdID0gZ2V0U2Vzc2lvbklucHV0T3V0cHV0Q291bnQoc2Vzc2lvbkhhbmRsZSk7XG5cbiAgICBjb25zdCBlbmFibGVHcmFwaENhcHR1cmUgPSAhIW9wdGlvbnM/LmVuYWJsZUdyYXBoQ2FwdHVyZTtcblxuICAgIGNvbnN0IGlucHV0TmFtZXMgPSBbXTtcbiAgICBjb25zdCBvdXRwdXROYW1lcyA9IFtdO1xuICAgIGNvbnN0IGlucHV0TWV0YWRhdGE6IEluZmVyZW5jZVNlc3Npb24uVmFsdWVNZXRhZGF0YVtdID0gW107XG4gICAgY29uc3Qgb3V0cHV0TWV0YWRhdGE6IEluZmVyZW5jZVNlc3Npb24uVmFsdWVNZXRhZGF0YVtdID0gW107XG4gICAgY29uc3Qgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOiBTdXBwb3J0ZWRUZW5zb3JEYXRhTG9jYXRpb25Gb3JJbnB1dE91dHB1dFtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IFtuYW1lT2Zmc2V0LCBlbGVtZW50VHlwZSwgc2hhcGVdID0gZ2V0U2Vzc2lvbklucHV0T3V0cHV0TWV0YWRhdGEoc2Vzc2lvbkhhbmRsZSwgaSk7XG4gICAgICBpZiAobmFtZU9mZnNldCA9PT0gMCkge1xuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lLlwiKTtcbiAgICAgIH1cbiAgICAgIGlucHV0TmFtZXNVVEY4RW5jb2RlZC5wdXNoKG5hbWVPZmZzZXQpO1xuICAgICAgY29uc3QgbmFtZSA9IHdhc20uVVRGOFRvU3RyaW5nKG5hbWVPZmZzZXQpO1xuICAgICAgaW5wdXROYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgaW5wdXRNZXRhZGF0YS5wdXNoKFxuICAgICAgICBlbGVtZW50VHlwZSA9PT0gMFxuICAgICAgICAgID8geyBuYW1lLCBpc1RlbnNvcjogZmFsc2UgfVxuICAgICAgICAgIDogeyBuYW1lLCBpc1RlbnNvcjogdHJ1ZSwgdHlwZTogdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcoZWxlbWVudFR5cGUpLCBzaGFwZTogc2hhcGUhIH0sXG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IFtuYW1lT2Zmc2V0LCBlbGVtZW50VHlwZSwgc2hhcGVdID0gZ2V0U2Vzc2lvbklucHV0T3V0cHV0TWV0YWRhdGEoc2Vzc2lvbkhhbmRsZSwgaSArIGlucHV0Q291bnQpO1xuICAgICAgaWYgKG5hbWVPZmZzZXQgPT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpO1xuICAgICAgfVxuICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZC5wdXNoKG5hbWVPZmZzZXQpO1xuICAgICAgY29uc3QgbmFtZVN0cmluZyA9IHdhc20uVVRGOFRvU3RyaW5nKG5hbWVPZmZzZXQpO1xuICAgICAgb3V0cHV0TmFtZXMucHVzaChuYW1lU3RyaW5nKTtcbiAgICAgIG91dHB1dE1ldGFkYXRhLnB1c2goXG4gICAgICAgIGVsZW1lbnRUeXBlID09PSAwXG4gICAgICAgICAgPyB7IG5hbWU6IG5hbWVTdHJpbmcsIGlzVGVuc29yOiBmYWxzZSB9XG4gICAgICAgICAgOiB7IG5hbWU6IG5hbWVTdHJpbmcsIGlzVGVuc29yOiB0cnVlLCB0eXBlOiB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyhlbGVtZW50VHlwZSksIHNoYXBlOiBzaGFwZSEgfSxcbiAgICAgICk7XG5cbiAgICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgfHwgIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpIHtcbiAgICAgICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSAmJiBvcHRpb25zPy5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLnB1c2goJ2dwdS1idWZmZXInKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9XG4gICAgICAgICAgdHlwZW9mIG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBvcHRpb25zLnByZWZlcnJlZE91dHB1dExvY2F0aW9uXG4gICAgICAgICAgICA6IChvcHRpb25zPy5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj8uW25hbWVTdHJpbmddID8/ICdjcHUnKTtcbiAgICAgICAgY29uc3QgaXNHcmFwaE91dHB1dCA9IHdhc20ud2Vibm5Jc0dyYXBoT3V0cHV0O1xuICAgICAgICBpZiAobG9jYXRpb24gPT09ICdjcHUnICYmIGlzR3JhcGhPdXRwdXQgJiYgaXNHcmFwaE91dHB1dChzZXNzaW9uSGFuZGxlLCBuYW1lU3RyaW5nKSkge1xuICAgICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5wdXNoKCdtbC10ZW5zb3ItY3B1LW91dHB1dCcpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhdGlvbiAhPT0gJ2NwdScgJiYgbG9jYXRpb24gIT09ICdjcHUtcGlubmVkJyAmJiBsb2NhdGlvbiAhPT0gJ2dwdS1idWZmZXInICYmIGxvY2F0aW9uICE9PSAnbWwtdGVuc29yJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke2xvY2F0aW9ufS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5hYmxlR3JhcGhDYXB0dXJlICYmIGxvY2F0aW9uICE9PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke2xvY2F0aW9ufS4gT25seSAnZ3B1LWJ1ZmZlcicgbG9jYXRpb24gaXMgc3VwcG9ydGVkIHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1c2UgSU8gYmluZGluZyBvbmx5IHdoZW4gYXQgbGVhc3Qgb25lIG91dHB1dCBpcyBwcmVmZXJyZWQgdG8gYmUgb24gR1BVLlxuICAgIGxldCBiaW5kaW5nU3RhdGU6IElPQmluZGluZ1N0YXRlIHwgbnVsbCA9IG51bGw7XG4gICAgaWYgKFxuICAgICAgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCB8fCAhQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkgJiZcbiAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5zb21lKChsKSA9PiBsID09PSAnZ3B1LWJ1ZmZlcicgfHwgbCA9PT0gJ21sLXRlbnNvcicgfHwgbCA9PT0gJ21sLXRlbnNvci1jcHUtb3V0cHV0JylcbiAgICApIHtcbiAgICAgIGlvQmluZGluZ0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZUJpbmRpbmcoc2Vzc2lvbkhhbmRsZSk7XG4gICAgICBpZiAoaW9CaW5kaW5nSGFuZGxlID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgY3JlYXRlIElPIGJpbmRpbmcuXCIpO1xuICAgICAgfVxuXG4gICAgICBiaW5kaW5nU3RhdGUgPSB7XG4gICAgICAgIGhhbmRsZTogaW9CaW5kaW5nSGFuZGxlLFxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMsXG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6IG91dHB1dFByZWZlcnJlZExvY2F0aW9uc1xuICAgICAgICAgIC8vICdtbC10ZW5zb3ItY3B1LW91dHB1dCcgaXMgdHJlYXRlZCBhcyAnbWwtdGVuc29yJyBmb3IgdGhlIHB1cnBvc2Ugb2YgSU8gYmluZGluZy5cbiAgICAgICAgICAubWFwKChsKSA9PiAobCA9PT0gJ21sLXRlbnNvci1jcHUtb3V0cHV0JyA/ICdtbC10ZW5zb3InIDogbCkpXG4gICAgICAgICAgLm1hcCgobCkgPT4gZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtKGwpKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgYWN0aXZlU2Vzc2lvbnMuc2V0KHNlc3Npb25IYW5kbGUsIFtcbiAgICAgIHNlc3Npb25IYW5kbGUsXG4gICAgICBpbnB1dE5hbWVzVVRGOEVuY29kZWQsXG4gICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgYmluZGluZ1N0YXRlLFxuICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgZmFsc2UsXG4gICAgXSk7XG4gICAgcmV0dXJuIFtzZXNzaW9uSGFuZGxlLCBpbnB1dE5hbWVzLCBvdXRwdXROYW1lcywgaW5wdXRNZXRhZGF0YSwgb3V0cHV0TWV0YWRhdGFdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcblxuICAgIGlmIChpb0JpbmRpbmdIYW5kbGUgIT09IDApIHtcbiAgICAgIGlmICh3YXNtLl9PcnRSZWxlYXNlQmluZGluZyhpb0JpbmRpbmdIYW5kbGUpICE9PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgcmVsZWFzZSBJTyBiaW5kaW5nLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbkhhbmRsZSAhPT0gMCkge1xuICAgICAgaWYgKHdhc20uX09ydFJlbGVhc2VTZXNzaW9uKHNlc3Npb25IYW5kbGUpICE9PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLl9mcmVlKG1vZGVsRGF0YU9mZnNldCk7XG4gICAgaWYgKHNlc3Npb25PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICBpZiAod2FzbS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHNlc3Npb25PcHRpb25zSGFuZGxlKSAhPT0gMCkge1xuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbiBvcHRpb25zLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYWxsb2NzLmZvckVhY2goKGFsbG9jKSA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XG5cbiAgICAvLyB1bm1vdW50IGV4dGVybmFsIGRhdGEgaWYgbmVjZXNzYXJ5XG4gICAgd2FzbS51bm1vdW50RXh0ZXJuYWxEYXRhPy4oKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlbGVhc2VTZXNzaW9uID0gKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gIGlmICghc2Vzc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlbGVhc2Ugc2Vzc2lvbi4gaW52YWxpZCBzZXNzaW9uIGlkOiAke3Nlc3Npb25JZH1gKTtcbiAgfVxuICBjb25zdCBbc2Vzc2lvbkhhbmRsZSwgaW5wdXROYW1lc1VURjhFbmNvZGVkLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkLCBpb0JpbmRpbmdTdGF0ZSwgZW5hYmxlR3JhcGhDYXB0dXJlXSA9IHNlc3Npb247XG5cbiAgaWYgKGlvQmluZGluZ1N0YXRlKSB7XG4gICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSkge1xuICAgICAgaWYgKHdhc20uX09ydENsZWFyQm91bmRPdXRwdXRzKGlvQmluZGluZ1N0YXRlLmhhbmRsZSkgIT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjbGVhciBib3VuZCBvdXRwdXRzLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ1N0YXRlLmhhbmRsZSkgIT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgcmVsZWFzZSBJTyBiaW5kaW5nLlwiKTtcbiAgICB9XG4gIH1cblxuICB3YXNtLmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oc2Vzc2lvbklkKTtcbiAgd2FzbS53ZWJubk9uUmVsZWFzZVNlc3Npb24/LihzZXNzaW9uSWQpO1xuICB3YXNtLndlYmdwdU9uUmVsZWFzZVNlc3Npb24/LihzZXNzaW9uSWQpO1xuXG4gIGlucHV0TmFtZXNVVEY4RW5jb2RlZC5mb3JFYWNoKChidWYpID0+IHdhc20uX09ydEZyZWUoYnVmKSk7XG4gIG91dHB1dE5hbWVzVVRGOEVuY29kZWQuZm9yRWFjaCgoYnVmKSA9PiB3YXNtLl9PcnRGcmVlKGJ1ZikpO1xuICBpZiAod2FzbS5fT3J0UmVsZWFzZVNlc3Npb24oc2Vzc2lvbkhhbmRsZSkgIT09IDApIHtcbiAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbi5cIik7XG4gIH1cbiAgYWN0aXZlU2Vzc2lvbnMuZGVsZXRlKHNlc3Npb25JZCk7XG59O1xuXG5leHBvcnQgY29uc3QgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yID0gYXN5bmMgKFxuICB0ZW5zb3I6IFRlbnNvck1ldGFkYXRhIHwgbnVsbCxcbiAgdGVuc29ySGFuZGxlczogbnVtYmVyW10sXG4gIGFsbG9jczogbnVtYmVyW10sXG4gIHNlc3Npb25JZDogbnVtYmVyLFxuICB0ZW5zb3JOYW1lVVRGOEVuY29kZWQ6IG51bWJlcixcbiAgaW5kZXg6IG51bWJlcixcbiAgZW5hYmxlR3JhcGhDYXB0dXJlID0gZmFsc2UsXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKCF0ZW5zb3IpIHtcbiAgICB0ZW5zb3JIYW5kbGVzLnB1c2goMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IHB0clNpemUgPSB3YXNtLlBUUl9TSVpFO1xuXG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yWzBdO1xuICBjb25zdCBkaW1zID0gdGVuc29yWzFdO1xuICBjb25zdCBsb2NhdGlvbiA9IHRlbnNvclszXTtcbiAgbGV0IGFjdHVhbExvY2F0aW9uID0gbG9jYXRpb247XG5cbiAgbGV0IHJhd0RhdGE6IG51bWJlcjtcbiAgbGV0IGRhdGFCeXRlTGVuZ3RoOiBudW1iZXI7XG5cbiAgaWYgKGRhdGFUeXBlID09PSAnc3RyaW5nJyAmJiAobG9jYXRpb24gPT09ICdncHUtYnVmZmVyJyB8fCBsb2NhdGlvbiA9PT0gJ21sLXRlbnNvcicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLicpO1xuICB9XG5cbiAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSAmJiBsb2NhdGlvbiAhPT0gJ2dwdS1idWZmZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4dGVybmFsIGJ1ZmZlciBtdXN0IGJlIHByb3ZpZGVkIGZvciBpbnB1dC9vdXRwdXQgaW5kZXggJHtpbmRleH0gd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gLFxuICAgICk7XG4gIH1cblxuICBpZiAobG9jYXRpb24gPT09ICdncHUtYnVmZmVyJykge1xuICAgIGNvbnN0IGdwdUJ1ZmZlciA9IHRlbnNvclsyXS5ncHVCdWZmZXI7XG4gICAgZGF0YUJ5dGVMZW5ndGggPSBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyh0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSksIGRpbXMpITtcblxuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkge1xuICAgICAgY29uc3QgcmVnaXN0ZXJCdWZmZXIgPSB3YXNtLndlYmdwdVJlZ2lzdGVyQnVmZmVyO1xuICAgICAgaWYgKCFyZWdpc3RlckJ1ZmZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO1xuICAgICAgfVxuXG4gICAgICByYXdEYXRhID0gcmVnaXN0ZXJCdWZmZXIoZ3B1QnVmZmVyLCBzZXNzaW9uSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWdpc3RlckJ1ZmZlciA9IHdhc20uanNlcFJlZ2lzdGVyQnVmZmVyO1xuICAgICAgaWYgKCFyZWdpc3RlckJ1ZmZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO1xuICAgICAgfVxuICAgICAgcmF3RGF0YSA9IHJlZ2lzdGVyQnVmZmVyKHNlc3Npb25JZCwgaW5kZXgsIGdwdUJ1ZmZlciwgZGF0YUJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsb2NhdGlvbiA9PT0gJ21sLXRlbnNvcicpIHtcbiAgICBjb25zdCBtbFRlbnNvciA9IHRlbnNvclsyXS5tbFRlbnNvciBhcyBNTFRlbnNvcjtcbiAgICBkYXRhQnl0ZUxlbmd0aCA9IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzKHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKSwgZGltcykhO1xuXG4gICAgY29uc3QgcmVnaXN0ZXJNTFRlbnNvciA9IHdhc20ud2Vibm5SZWdpc3Rlck1MVGVuc29yO1xuICAgIGlmICghcmVnaXN0ZXJNTFRlbnNvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7XG4gICAgfVxuICAgIHJhd0RhdGEgPSByZWdpc3Rlck1MVGVuc29yKHNlc3Npb25JZCwgbWxUZW5zb3IsIHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKSwgZGltcyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGF0YSA9IHRlbnNvclsyXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAvLyBzdHJpbmcgdGVuc29yXG4gICAgICBkYXRhQnl0ZUxlbmd0aCA9IHB0clNpemUgKiBkYXRhLmxlbmd0aDtcbiAgICAgIHJhd0RhdGEgPSB3YXNtLl9tYWxsb2MoZGF0YUJ5dGVMZW5ndGgpO1xuICAgICAgYWxsb2NzLnB1c2gocmF3RGF0YSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7aX0gaXMgbm90IGEgc3RyaW5nYCk7XG4gICAgICAgIH1cbiAgICAgICAgd2FzbS5zZXRWYWx1ZShyYXdEYXRhICsgaSAqIHB0clNpemUsIGFsbG9jV2FzbVN0cmluZyhkYXRhW2ldLCBhbGxvY3MpLCAnKicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc0dyYXBoSW5wdXQgPSB3YXNtLndlYm5uSXNHcmFwaElucHV0O1xuICAgICAgY29uc3QgaXNHcmFwaE91dHB1dCA9IHdhc20ud2Vibm5Jc0dyYXBoT3V0cHV0O1xuICAgICAgaWYgKGRhdGFUeXBlICE9PSAnc3RyaW5nJyAmJiBpc0dyYXBoSW5wdXQgJiYgaXNHcmFwaE91dHB1dCkge1xuICAgICAgICBjb25zdCB0ZW5zb3JOYW1lID0gd2FzbS5VVEY4VG9TdHJpbmcodGVuc29yTmFtZVVURjhFbmNvZGVkKTtcbiAgICAgICAgLy8gUHJvbW90ZSB0aGUgdGVuc29yIHRvICdtbC10ZW5zb3InIGlmIGl0IGlzIGEgZ3JhcGggaW5wdXQuXG4gICAgICAgIGlmIChpc0dyYXBoSW5wdXQoc2Vzc2lvbklkLCB0ZW5zb3JOYW1lKSB8fCBpc0dyYXBoT3V0cHV0KHNlc3Npb25JZCwgdGVuc29yTmFtZSkpIHtcbiAgICAgICAgICBjb25zdCBkYXRhVHlwZUVudW0gPSB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSk7XG4gICAgICAgICAgZGF0YUJ5dGVMZW5ndGggPSBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyhkYXRhVHlwZUVudW0sIGRpbXMpITtcbiAgICAgICAgICBhY3R1YWxMb2NhdGlvbiA9ICdtbC10ZW5zb3InO1xuICAgICAgICAgIGNvbnN0IGNyZWF0ZVRlbXBvcmFyeVRlbnNvciA9IHdhc20ud2Vibm5DcmVhdGVUZW1wb3JhcnlUZW5zb3I7XG4gICAgICAgICAgY29uc3QgdXBsb2FkVGVuc29yID0gd2FzbS53ZWJublVwbG9hZFRlbnNvcjtcbiAgICAgICAgICBpZiAoIWNyZWF0ZVRlbXBvcmFyeVRlbnNvciB8fCAhdXBsb2FkVGVuc29yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdGVuc29ySWQgPSBhd2FpdCBjcmVhdGVUZW1wb3JhcnlUZW5zb3Ioc2Vzc2lvbklkLCBkYXRhVHlwZUVudW0sIGRpbXMgYXMgbnVtYmVyW10pO1xuICAgICAgICAgIHVwbG9hZFRlbnNvcih0ZW5zb3JJZCwgbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKSk7XG4gICAgICAgICAgcmF3RGF0YSA9IHRlbnNvcklkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFCeXRlTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIHJhd0RhdGEgPSB3YXNtLl9tYWxsb2MoZGF0YUJ5dGVMZW5ndGgpO1xuICAgICAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xuICAgICAgICAgIHdhc20uSEVBUFU4LnNldChuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhQnl0ZUxlbmd0aCksIHJhd0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhQnl0ZUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgcmF3RGF0YSA9IHdhc20uX21hbGxvYyhkYXRhQnl0ZUxlbmd0aCk7XG4gICAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xuICAgICAgICB3YXNtLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YUJ5dGVMZW5ndGgpLCByYXdEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBzdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gIGNvbnN0IGRpbXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoNCAqIGRpbXMubGVuZ3RoKTtcbiAgdHJ5IHtcbiAgICBkaW1zLmZvckVhY2goKGQsIGluZGV4KSA9PiB3YXNtLnNldFZhbHVlKGRpbXNPZmZzZXQgKyBpbmRleCAqIHB0clNpemUsIGQsIHB0clNpemUgPT09IDQgPyAnaTMyJyA6ICdpNjQnKSk7XG4gICAgY29uc3QgdGVuc29yID0gd2FzbS5fT3J0Q3JlYXRlVGVuc29yKFxuICAgICAgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0oZGF0YVR5cGUpLFxuICAgICAgcmF3RGF0YSxcbiAgICAgIGRhdGFCeXRlTGVuZ3RoLFxuICAgICAgZGltc09mZnNldCxcbiAgICAgIGRpbXMubGVuZ3RoLFxuICAgICAgZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtKGFjdHVhbExvY2F0aW9uKSxcbiAgICApO1xuICAgIGlmICh0ZW5zb3IgPT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBjcmVhdGUgdGVuc29yIGZvciBpbnB1dC9vdXRwdXQuIHNlc3Npb249JHtzZXNzaW9uSWR9LCBpbmRleD0ke2luZGV4fS5gKTtcbiAgICB9XG4gICAgdGVuc29ySGFuZGxlcy5wdXNoKHRlbnNvcik7XG4gIH0gZmluYWxseSB7XG4gICAgd2FzbS5zdGFja1Jlc3RvcmUoc3RhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIHBlcmZvcm0gaW5mZXJlbmNlIHJ1blxuICovXG5leHBvcnQgY29uc3QgcnVuID0gYXN5bmMgKFxuICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgaW5wdXRUZW5zb3JzOiBUZW5zb3JNZXRhZGF0YVtdLFxuICBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgb3V0cHV0VGVuc29yczogQXJyYXk8VGVuc29yTWV0YWRhdGEgfCBudWxsPixcbiAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuKTogUHJvbWlzZTxUZW5zb3JNZXRhZGF0YVtdPiA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBwdHJTaXplID0gd2FzbS5QVFJfU0laRTtcbiAgY29uc3Qgc2Vzc2lvbiA9IGFjdGl2ZVNlc3Npb25zLmdldChzZXNzaW9uSWQpO1xuICBpZiAoIXNlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBydW4gaW5mZXJlbmNlLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7c2Vzc2lvbklkfWApO1xuICB9XG4gIGNvbnN0IHNlc3Npb25IYW5kbGUgPSBzZXNzaW9uWzBdO1xuICBjb25zdCBpbnB1dE5hbWVzVVRGOEVuY29kZWQgPSBzZXNzaW9uWzFdO1xuICBjb25zdCBvdXRwdXROYW1lc1VURjhFbmNvZGVkID0gc2Vzc2lvblsyXTtcbiAgY29uc3QgaW9CaW5kaW5nU3RhdGUgPSBzZXNzaW9uWzNdO1xuICBjb25zdCBlbmFibGVHcmFwaENhcHR1cmUgPSBzZXNzaW9uWzRdO1xuICBjb25zdCBpbnB1dE91dHB1dEJvdW5kID0gc2Vzc2lvbls1XTtcblxuICBjb25zdCBpbnB1dENvdW50ID0gaW5wdXRJbmRpY2VzLmxlbmd0aDtcbiAgY29uc3Qgb3V0cHV0Q291bnQgPSBvdXRwdXRJbmRpY2VzLmxlbmd0aDtcblxuICBsZXQgcnVuT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGxldCBydW5PcHRpb25zQWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IGlucHV0VGVuc29ySGFuZGxlczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgb3V0cHV0VGVuc29ySGFuZGxlczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgaW5wdXRPdXRwdXRBbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgY29uc3QgYmVmb3JlUnVuU3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICBjb25zdCBpbnB1dFZhbHVlc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhpbnB1dENvdW50ICogcHRyU2l6ZSk7XG4gIGNvbnN0IGlucHV0TmFtZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoaW5wdXRDb3VudCAqIHB0clNpemUpO1xuICBjb25zdCBvdXRwdXRWYWx1ZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2Mob3V0cHV0Q291bnQgKiBwdHJTaXplKTtcbiAgY29uc3Qgb3V0cHV0TmFtZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2Mob3V0cHV0Q291bnQgKiBwdHJTaXplKTtcblxuICB0cnkge1xuICAgIFtydW5PcHRpb25zSGFuZGxlLCBydW5PcHRpb25zQWxsb2NzXSA9IHNldFJ1bk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBUUkFDRV9FVkVOVF9CRUdJTignd2FzbSBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3InKTtcbiAgICAvLyBjcmVhdGUgaW5wdXQgdGVuc29yc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICBhd2FpdCBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3IoXG4gICAgICAgIGlucHV0VGVuc29yc1tpXSxcbiAgICAgICAgaW5wdXRUZW5zb3JIYW5kbGVzLFxuICAgICAgICBpbnB1dE91dHB1dEFsbG9jcyxcbiAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICBpbnB1dE5hbWVzVVRGOEVuY29kZWRbaW5wdXRJbmRpY2VzW2ldXSxcbiAgICAgICAgaW5wdXRJbmRpY2VzW2ldLFxuICAgICAgICBlbmFibGVHcmFwaENhcHR1cmUsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBvdXRwdXQgdGVuc29yc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgYXdhaXQgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yKFxuICAgICAgICBvdXRwdXRUZW5zb3JzW2ldLFxuICAgICAgICBvdXRwdXRUZW5zb3JIYW5kbGVzLFxuICAgICAgICBpbnB1dE91dHB1dEFsbG9jcyxcbiAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkW291dHB1dEluZGljZXNbaV1dLFxuICAgICAgICBpbnB1dENvdW50ICsgb3V0cHV0SW5kaWNlc1tpXSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgKTtcbiAgICB9XG4gICAgVFJBQ0VfRVZFTlRfRU5EKCd3YXNtIHByZXBhcmVJbnB1dE91dHB1dFRlbnNvcicpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcbiAgICAgIHdhc20uc2V0VmFsdWUoaW5wdXRWYWx1ZXNPZmZzZXQgKyBpICogcHRyU2l6ZSwgaW5wdXRUZW5zb3JIYW5kbGVzW2ldLCAnKicpO1xuICAgICAgd2FzbS5zZXRWYWx1ZShpbnB1dE5hbWVzT2Zmc2V0ICsgaSAqIHB0clNpemUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZFtpbnB1dEluZGljZXNbaV1dLCAnKicpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgIHdhc20uc2V0VmFsdWUob3V0cHV0VmFsdWVzT2Zmc2V0ICsgaSAqIHB0clNpemUsIG91dHB1dFRlbnNvckhhbmRsZXNbaV0sICcqJyk7XG4gICAgICB3YXNtLnNldFZhbHVlKG91dHB1dE5hbWVzT2Zmc2V0ICsgaSAqIHB0clNpemUsIG91dHB1dE5hbWVzVVRGOEVuY29kZWRbb3V0cHV0SW5kaWNlc1tpXV0sICcqJyk7XG4gICAgfVxuXG4gICAgaWYgKCghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgfHwgIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpICYmIGlvQmluZGluZ1N0YXRlICYmICFpbnB1dE91dHB1dEJvdW5kKSB7XG4gICAgICBjb25zdCB7IGhhbmRsZSwgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkIH0gPSBpb0JpbmRpbmdTdGF0ZTtcblxuICAgICAgaWYgKGlucHV0TmFtZXNVVEY4RW5jb2RlZC5sZW5ndGggIT09IGlucHV0Q291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBpbnB1dCBjb3VudCBmcm9tIGZlZWRzICgke2lucHV0Q291bnR9KSBpcyBleHBlY3RlZCB0byBiZSBhbHdheXMgZXF1YWwgdG8gbW9kZWwncyBpbnB1dCBjb3VudCAoJHtpbnB1dE5hbWVzVVRGOEVuY29kZWQubGVuZ3RofSkuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgVFJBQ0VfRVZFTlRfQkVHSU4oJ3dhc20gYmluZElucHV0c091dHB1dHMnKTtcbiAgICAgIC8vIHByb2Nlc3MgaW5wdXRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBpbmRleCA9IGlucHV0SW5kaWNlc1tpXTtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gYXdhaXQgd2FzbS5fT3J0QmluZElucHV0KGhhbmRsZSwgaW5wdXROYW1lc1VURjhFbmNvZGVkW2luZGV4XSwgaW5wdXRUZW5zb3JIYW5kbGVzW2ldKTtcbiAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBiaW5kIGlucHV0WyR7aX1dIGZvciBzZXNzaW9uPSR7c2Vzc2lvbklkfS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwcm9jZXNzIHByZS1hbGxvY2F0ZWQgb3V0cHV0c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gb3V0cHV0SW5kaWNlc1tpXTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBvdXRwdXRUZW5zb3JzW2ldPy5bM107IC8vIHVuZGVmaW5lZCBtZWFucyBvdXRwdXQgaXMgbm90IHByZS1hbGxvY2F0ZWQuXG5cbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgLy8gb3V0cHV0IGlzIHByZS1hbGxvY2F0ZWQuIGJpbmQgdGhlIHRlbnNvci5cbiAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRCaW5kT3V0cHV0KGhhbmRsZSwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtpbmRleF0sIG91dHB1dFRlbnNvckhhbmRsZXNbaV0sIDApO1xuICAgICAgICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBiaW5kIHByZS1hbGxvY2F0ZWQgb3V0cHV0WyR7aX1dIGZvciBzZXNzaW9uPSR7c2Vzc2lvbklkfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3V0cHV0IGlzIG5vdCBwcmUtYWxsb2NhdGVkLiByZXNldCBwcmVmZXJyZWQgbG9jYXRpb24uXG4gICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5fT3J0QmluZE91dHB1dChcbiAgICAgICAgICAgIGhhbmRsZSxcbiAgICAgICAgICAgIG91dHB1dE5hbWVzVVRGOEVuY29kZWRbaW5kZXhdLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWRbaW5kZXhdLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgb3V0cHV0WyR7aX1dIHRvICR7b3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW2ldfSBmb3Igc2Vzc2lvbj0ke3Nlc3Npb25JZH0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBUUkFDRV9FVkVOVF9FTkQoJ3dhc20gYmluZElucHV0c091dHB1dHMnKTtcbiAgICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSWQsIFtcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcbiAgICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBpb0JpbmRpbmdTdGF0ZSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgICB0cnVlLFxuICAgICAgXSk7XG4gICAgfVxuXG4gICAgd2FzbS5qc2VwT25SdW5TdGFydD8uKHNlc3Npb25IYW5kbGUpO1xuICAgIHdhc20ud2Vibm5PblJ1blN0YXJ0Py4oc2Vzc2lvbkhhbmRsZSk7XG5cbiAgICBsZXQgZXJyb3JDb2RlOiBudW1iZXI7XG4gICAgaWYgKCghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgfHwgIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpICYmIGlvQmluZGluZ1N0YXRlKSB7XG4gICAgICBlcnJvckNvZGUgPSBhd2FpdCB3YXNtLl9PcnRSdW5XaXRoQmluZGluZyhcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcbiAgICAgICAgaW9CaW5kaW5nU3RhdGUuaGFuZGxlLFxuICAgICAgICBvdXRwdXRDb3VudCxcbiAgICAgICAgb3V0cHV0VmFsdWVzT2Zmc2V0LFxuICAgICAgICBydW5PcHRpb25zSGFuZGxlLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JDb2RlID0gYXdhaXQgd2FzbS5fT3J0UnVuKFxuICAgICAgICBzZXNzaW9uSGFuZGxlLFxuICAgICAgICBpbnB1dE5hbWVzT2Zmc2V0LFxuICAgICAgICBpbnB1dFZhbHVlc09mZnNldCxcbiAgICAgICAgaW5wdXRDb3VudCxcbiAgICAgICAgb3V0cHV0TmFtZXNPZmZzZXQsXG4gICAgICAgIG91dHB1dENvdW50LFxuICAgICAgICBvdXRwdXRWYWx1ZXNPZmZzZXQsXG4gICAgICAgIHJ1bk9wdGlvbnNIYW5kbGUsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKCdmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXQ6IFRlbnNvck1ldGFkYXRhW10gPSBbXTtcbiAgICBjb25zdCBvdXRwdXRQcm9taXNlczogQXJyYXk8UHJvbWlzZTxbbnVtYmVyLCBUZW5zb3IuRGF0YVR5cGVdPj4gPSBbXTtcblxuICAgIFRSQUNFX0VWRU5UX0JFR0lOKCd3YXNtIFByb2Nlc3NPdXRwdXRUZW5zb3InKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHRlbnNvciA9IE51bWJlcih3YXNtLmdldFZhbHVlKG91dHB1dFZhbHVlc09mZnNldCArIGkgKiBwdHJTaXplLCAnKicpKTtcbiAgICAgIGlmICh0ZW5zb3IgPT09IG91dHB1dFRlbnNvckhhbmRsZXNbaV0pIHtcbiAgICAgICAgLy8gb3V0cHV0IHRlbnNvciBpcyBwcmUtYWxsb2NhdGVkLiBubyBuZWVkIHRvIGNvcHkgZGF0YS5cbiAgICAgICAgb3V0cHV0LnB1c2gob3V0cHV0VGVuc29yc1tpXSEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmVmb3JlR2V0VGVuc29yRGF0YVN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgICAgIC8vIHN0YWNrIGFsbG9jYXRlIDQgcG9pbnRlciB2YWx1ZVxuICAgICAgY29uc3QgdGVuc29yRGF0YU9mZnNldCA9IHdhc20uc3RhY2tBbGxvYyg0ICogcHRyU2l6ZSk7XG5cbiAgICAgIGxldCBrZWVwT3V0cHV0VGVuc29yID0gZmFsc2U7XG4gICAgICBsZXQgdHlwZTogVGVuc29yLlR5cGUgfCB1bmRlZmluZWQsXG4gICAgICAgIGRhdGFPZmZzZXQgPSAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5fT3J0R2V0VGVuc29yRGF0YShcbiAgICAgICAgICB0ZW5zb3IsXG4gICAgICAgICAgdGVuc29yRGF0YU9mZnNldCxcbiAgICAgICAgICB0ZW5zb3JEYXRhT2Zmc2V0ICsgcHRyU2l6ZSxcbiAgICAgICAgICB0ZW5zb3JEYXRhT2Zmc2V0ICsgMiAqIHB0clNpemUsXG5cbiAgICAgICAgICB0ZW5zb3JEYXRhT2Zmc2V0ICsgMyAqIHB0clNpemUsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYWNjZXNzIG91dHB1dCB0ZW5zb3IgZGF0YSBvbiBpbmRleCAke2l9LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHB0clNpemUgPT09IDQgPyAnaTMyJyA6ICdpNjQnO1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IE51bWJlcih3YXNtLmdldFZhbHVlKHRlbnNvckRhdGFPZmZzZXQsIHZhbHVlVHlwZSkpO1xuICAgICAgICBkYXRhT2Zmc2V0ID0gd2FzbS5nZXRWYWx1ZSh0ZW5zb3JEYXRhT2Zmc2V0ICsgcHRyU2l6ZSwgJyonKTtcbiAgICAgICAgY29uc3QgZGltc09mZnNldCA9IHdhc20uZ2V0VmFsdWUodGVuc29yRGF0YU9mZnNldCArIHB0clNpemUgKiAyLCAnKicpO1xuICAgICAgICBjb25zdCBkaW1zTGVuZ3RoID0gTnVtYmVyKHdhc20uZ2V0VmFsdWUodGVuc29yRGF0YU9mZnNldCArIHB0clNpemUgKiAzLCB2YWx1ZVR5cGUpKTtcbiAgICAgICAgY29uc3QgZGltcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRpbXMucHVzaChOdW1iZXIod2FzbS5nZXRWYWx1ZShkaW1zT2Zmc2V0ICsgaSAqIHB0clNpemUsIHZhbHVlVHlwZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2FzbS5fT3J0RnJlZShkaW1zT2Zmc2V0KSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZnJlZSBtZW1vcnkgZm9yIHRlbnNvciBkaW1zLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplID0gZGltcy5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiLCAxKTtcbiAgICAgICAgdHlwZSA9IHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKGRhdGFUeXBlKTtcblxuICAgICAgICBjb25zdCBwcmVmZXJyZWRMb2NhdGlvbiA9IGlvQmluZGluZ1N0YXRlPy5vdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbb3V0cHV0SW5kaWNlc1tpXV07XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHByZWZlcnJlZExvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicgfHwgcHJlZmVycmVkTG9jYXRpb24gPT09ICdtbC10ZW5zb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN0cmluZ0RhdGE6IHN0cmluZ1tdID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdhc20uZ2V0VmFsdWUoZGF0YU9mZnNldCArIGkgKiBwdHJTaXplLCAnKicpO1xuICAgICAgICAgICAgY29uc3QgbmV4dE9mZnNldCA9IHdhc20uZ2V0VmFsdWUoZGF0YU9mZnNldCArIChpICsgMSkgKiBwdHJTaXplLCAnKicpO1xuICAgICAgICAgICAgY29uc3QgbWF4Qnl0ZXNUb1JlYWQgPSBpID09PSBzaXplIC0gMSA/IHVuZGVmaW5lZCA6IG5leHRPZmZzZXQgLSBvZmZzZXQ7XG4gICAgICAgICAgICBzdHJpbmdEYXRhLnB1c2god2FzbS5VVEY4VG9TdHJpbmcob2Zmc2V0LCBtYXhCeXRlc1RvUmVhZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQucHVzaChbdHlwZSwgZGltcywgc3RyaW5nRGF0YSwgJ2NwdSddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBhIGNlcnRhaW4gb3V0cHV0J3MgcHJlZmVycmVkIGxvY2F0aW9uIGlzIEdQVSBidXQgdGhlIHRlbnNvciBpcyBlbXB0eSwgd2Ugc3RpbGwgbmVlZCB0byBjcmVhdGUgYSBDUFVcbiAgICAgICAgICAvLyB0ZW5zb3IgZm9yIGl0LiBUaGVyZSBpcyBubyBtYXBwaW5nIEdQVSBidWZmZXIgZm9yIGFuIGVtcHR5IHRlbnNvci5cbiAgICAgICAgICBpZiAocHJlZmVycmVkTG9jYXRpb24gPT09ICdncHUtYnVmZmVyJyAmJiBzaXplID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZ2V0QnVmZmVyID0gIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUgPyB3YXNtLndlYmdwdUdldEJ1ZmZlciA6IHdhc20uanNlcEdldEJ1ZmZlcjtcbiAgICAgICAgICAgIGlmICghZ2V0QnVmZmVyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJlZmVycmVkTG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGdwdUJ1ZmZlciA9IGdldEJ1ZmZlcihkYXRhT2Zmc2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclNpemUgPSBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyhkYXRhVHlwZSwgc2l6ZSk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyU2l6ZSA9PT0gdW5kZWZpbmVkIHx8ICFpc0dwdUJ1ZmZlclN1cHBvcnRlZFR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZG8gbm90IHJlbGVhc2UgdGhlIHRlbnNvciByaWdodCBub3cuIGl0IHdpbGwgYmUgcmVsZWFzZWQgd2hlbiB1c2VyIGNhbGxzIHRlbnNvci5kaXNwb3NlKCkuXG4gICAgICAgICAgICBrZWVwT3V0cHV0VGVuc29yID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVKSB7XG4gICAgICAgICAgICAgIHdhc20ud2ViZ3B1UmVnaXN0ZXJCdWZmZXIhKGdwdUJ1ZmZlciwgc2Vzc2lvbklkLCBkYXRhT2Zmc2V0KTtcbiAgICAgICAgICAgICAgY29uc3QgZG93bmxvYWREYXRhRnVuY3Rpb24gPSB3YXNtLndlYmdwdUNyZWF0ZURvd25sb2FkZXIhKGdwdUJ1ZmZlciwgYnVmZmVyU2l6ZSwgc2Vzc2lvbklkKTtcbiAgICAgICAgICAgICAgb3V0cHV0LnB1c2goW1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgZGltcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBncHVCdWZmZXIsXG4gICAgICAgICAgICAgICAgICBkb3dubG9hZDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IGRvd25sb2FkRGF0YUZ1bmN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgKHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0eXBlISkpKGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgYXMgVGVuc29yLkRhdGFUeXBlTWFwW1RlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXNdO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhc20uX09ydFJlbGVhc2VUZW5zb3IodGVuc29yKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgcmVsZWFzZSB0ZW5zb3IuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2dwdS1idWZmZXInLFxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dHB1dC5wdXNoKFtcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGRpbXMsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZ3B1QnVmZmVyLFxuICAgICAgICAgICAgICAgICAgZG93bmxvYWQ6IHdhc20uanNlcENyZWF0ZURvd25sb2FkZXIhKGdwdUJ1ZmZlciwgYnVmZmVyU2l6ZSwgdHlwZSksXG4gICAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcikgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2UgdGVuc29yLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdncHUtYnVmZmVyJyxcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ21sLXRlbnNvcicgJiYgc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVuc3VyZVRlbnNvciA9IHdhc20ud2Vibm5FbnN1cmVUZW5zb3I7XG4gICAgICAgICAgICBjb25zdCBpc0dyYXBoSW5wdXRPdXRwdXRUeXBlU3VwcG9ydGVkID0gd2FzbS53ZWJubklzR3JhcGhJbnB1dE91dHB1dFR5cGVTdXBwb3J0ZWQ7XG4gICAgICAgICAgICBpZiAoIWVuc3VyZVRlbnNvciB8fCAhaXNHcmFwaElucHV0T3V0cHV0VHlwZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwibWwtdGVuc29yXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYk5OLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGVuc29yU2l6ZSA9IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzKGRhdGFUeXBlLCBzaXplKTtcbiAgICAgICAgICAgIGlmICh0ZW5zb3JTaXplID09PSB1bmRlZmluZWQgfHwgIWlzTUxUZW5zb3JTdXBwb3J0ZWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzR3JhcGhJbnB1dE91dHB1dFR5cGVTdXBwb3J0ZWQoc2Vzc2lvbklkLCB0eXBlLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBwcmVmZXJyZWRMb2NhdGlvbiBcIm1sLXRlbnNvclwiIGZvciAke3R5cGV9IG91dHB1dCBpcyBub3Qgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgV2ViTk4gQ29udGV4dC5gLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZ3JhcGggaGFzIGJlZW4gcGFydGl0aW9uZWQsIHRoZSBvdXRwdXQgdGVuc29yIG1heSBoYXZlIG5vdCBiZWVuIGNyZWF0ZWQuIEZvciB0aGlzIHJlYXNvbiwgd2UgdXNlXG4gICAgICAgICAgICAvLyBlbnN1cmVUZW5zb3IgdG8gZ2V0L2NyZWF0ZSB0aGUgTUxUZW5zb3IuIEluIHdoaWNoIGNhc2UsIHdlIGRvbid0IG5lZWQgdG8gY29weSB0aGUgZGF0YSBpZiBhIG5ldyB0ZW5zb3JcbiAgICAgICAgICAgIC8vIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgICAgICBjb25zdCBtbFRlbnNvciA9IGF3YWl0IGVuc3VyZVRlbnNvcihzZXNzaW9uSWQsIGRhdGFPZmZzZXQsIGRhdGFUeXBlLCBkaW1zLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIGRvIG5vdCByZWxlYXNlIHRoZSB0ZW5zb3IgcmlnaHQgbm93LiBpdCB3aWxsIGJlIHJlbGVhc2VkIHdoZW4gdXNlciBjYWxscyB0ZW5zb3IuZGlzcG9zZSgpLlxuICAgICAgICAgICAga2VlcE91dHB1dFRlbnNvciA9IHRydWU7XG5cbiAgICAgICAgICAgIG91dHB1dC5wdXNoKFtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgZGltcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1sVGVuc29yLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkOiB3YXNtLndlYm5uQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyIShkYXRhT2Zmc2V0LCB0eXBlKSxcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB3YXNtLndlYm5uUmVsZWFzZVRlbnNvcklkIShkYXRhT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIHdhc20uX09ydFJlbGVhc2VUZW5zb3IodGVuc29yKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAnbWwtdGVuc29yJyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJlZmVycmVkTG9jYXRpb24gPT09ICdtbC10ZW5zb3ItY3B1LW91dHB1dCcgJiYgc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB3YXNtLndlYm5uQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyIShkYXRhT2Zmc2V0LCB0eXBlIGFzIFRlbnNvci5NTFRlbnNvckRhdGFUeXBlcykoKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gb3V0cHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIC8vIERlbGF5IHRoZSBkYXRhIGRvd25sb2FkIGFuZCByZWxlYXNpbmcgdGhlIHRlbnNvciB1bnRpbCB3ZSBjYW4gd2FpdCBmb3IgYWxsIG91dHB1dCB0ZW5zb3JzIHRvIGJlIGRvd25sb2FkZWQuXG4gICAgICAgICAgICBrZWVwT3V0cHV0VGVuc29yID0gdHJ1ZTtcbiAgICAgICAgICAgIG91dHB1dFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBbbnVtYmVyLCBUZW5zb3IuRGF0YVR5cGVdID0gW2luZGV4LCBhd2FpdCBkYXRhXTtcbiAgICAgICAgICAgICAgICB3YXNtLndlYm5uUmVsZWFzZVRlbnNvcklkIShkYXRhT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfSkoKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChbdHlwZSwgZGltcywgW10sICdjcHUnXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgdHlwZWRBcnJheUNvbnN0cnVjdG9yKHNpemUpO1xuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKS5zZXQoXG4gICAgICAgICAgICAgIHdhc20uSEVBUFU4LnN1YmFycmF5KGRhdGFPZmZzZXQsIGRhdGFPZmZzZXQgKyBkYXRhLmJ5dGVMZW5ndGgpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKFt0eXBlLCBkaW1zLCBkYXRhLCAnY3B1J10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5zdGFja1Jlc3RvcmUoYmVmb3JlR2V0VGVuc29yRGF0YVN0YWNrKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIGRhdGFPZmZzZXQpIHtcbiAgICAgICAgICB3YXNtLl9mcmVlKGRhdGFPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgha2VlcE91dHB1dFRlbnNvcikge1xuICAgICAgICAgIHdhc20uX09ydFJlbGVhc2VUZW5zb3IodGVuc29yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpb0JpbmRpbmdTdGF0ZSAmJiAhZW5hYmxlR3JhcGhDYXB0dXJlKSB7XG4gICAgICBpZiAod2FzbS5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoaW9CaW5kaW5nU3RhdGUuaGFuZGxlKSAhPT0gMCkge1xuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGNsZWFyIGJvdW5kIG91dHB1dHMuXCIpO1xuICAgICAgfVxuICAgICAgYWN0aXZlU2Vzc2lvbnMuc2V0KHNlc3Npb25JZCwgW1xuICAgICAgICBzZXNzaW9uSGFuZGxlLFxuICAgICAgICBpbnB1dE5hbWVzVVRGOEVuY29kZWQsXG4gICAgICAgIG91dHB1dE5hbWVzVVRGOEVuY29kZWQsXG4gICAgICAgIGlvQmluZGluZ1N0YXRlLFxuICAgICAgICBlbmFibGVHcmFwaENhcHR1cmUsXG4gICAgICAgIGZhbHNlLFxuICAgICAgXSk7XG4gICAgfVxuICAgIC8vIFdhaXQgZm9yIGFsbCBvdXRwdXQgdGVuc29yIGRhdGEgdG8gYmUgZG93bmxvYWRlZC5cbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgZGF0YV0gb2YgYXdhaXQgUHJvbWlzZS5hbGwob3V0cHV0UHJvbWlzZXMpKSB7XG4gICAgICBvdXRwdXRbaW5kZXhdWzJdID0gZGF0YTtcbiAgICB9XG4gICAgVFJBQ0VfRVZFTlRfRU5EKCd3YXNtIFByb2Nlc3NPdXRwdXRUZW5zb3InKTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20ud2Vibm5PblJ1bkVuZD8uKHNlc3Npb25IYW5kbGUpO1xuXG4gICAgd2FzbS5zdGFja1Jlc3RvcmUoYmVmb3JlUnVuU3RhY2spO1xuXG4gICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVKSB7XG4gICAgICBpbnB1dFRlbnNvcnMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICBpZiAodCAmJiB0WzNdID09PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICAgICAgICB3YXNtLndlYmdwdVVucmVnaXN0ZXJCdWZmZXIhKHRbMl0uZ3B1QnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvdXRwdXRUZW5zb3JzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgaWYgKHQgJiYgdFszXSA9PT0gJ2dwdS1idWZmZXInKSB7XG4gICAgICAgICAgd2FzbS53ZWJncHVVbnJlZ2lzdGVyQnVmZmVyISh0WzJdLmdwdUJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpbnB1dFRlbnNvckhhbmRsZXMuZm9yRWFjaCgodikgPT4gd2FzbS5fT3J0UmVsZWFzZVRlbnNvcih2KSk7XG4gICAgb3V0cHV0VGVuc29ySGFuZGxlcy5mb3JFYWNoKCh2KSA9PiB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHYpKTtcbiAgICBpbnB1dE91dHB1dEFsbG9jcy5mb3JFYWNoKChwKSA9PiB3YXNtLl9mcmVlKHApKTtcblxuICAgIGlmIChydW5PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhydW5PcHRpb25zSGFuZGxlKTtcbiAgICB9XG4gICAgcnVuT3B0aW9uc0FsbG9jcy5mb3JFYWNoKChwKSA9PiB3YXNtLl9mcmVlKHApKTtcbiAgfVxufTtcblxuLyoqXG4gKiBlbmQgcHJvZmlsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBlbmRQcm9maWxpbmcgPSAoc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IHNlc3Npb24gPSBhY3RpdmVTZXNzaW9ucy5nZXQoc2Vzc2lvbklkKTtcbiAgaWYgKCFzZXNzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNlc3Npb24gaWQnKTtcbiAgfVxuICBjb25zdCBzZXNzaW9uSGFuZGxlID0gc2Vzc2lvblswXTtcblxuICAvLyBwcm9maWxlIGZpbGUgbmFtZSBpcyBub3QgdXNlZCB5ZXQsIGJ1dCBpdCBtdXN0IGJlIGZyZWVkLlxuICBjb25zdCBwcm9maWxlRmlsZU5hbWUgPSB3YXNtLl9PcnRFbmRQcm9maWxpbmcoc2Vzc2lvbkhhbmRsZSk7XG4gIGlmIChwcm9maWxlRmlsZU5hbWUgPT09IDApIHtcbiAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGdldCBhbiBwcm9maWxlIGZpbGUgbmFtZS5cIik7XG4gIH1cbiAgd2FzbS5fT3J0RnJlZShwcm9maWxlRmlsZU5hbWUpO1xufTtcblxuZXhwb3J0IGNvbnN0IGV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzID0gKHRlbnNvcnM6IHJlYWRvbmx5IFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW10pOiBBcnJheUJ1ZmZlckxpa2VbXSA9PiB7XG4gIGNvbnN0IGJ1ZmZlcnM6IEFycmF5QnVmZmVyTGlrZVtdID0gW107XG4gIGZvciAoY29uc3QgdGVuc29yIG9mIHRlbnNvcnMpIHtcbiAgICBjb25zdCBkYXRhID0gdGVuc29yWzJdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSAmJiAnYnVmZmVyJyBpbiBkYXRhKSB7XG4gICAgICBidWZmZXJzLnB1c2goZGF0YS5idWZmZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYnVmZmVycztcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGVudiwgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7XG4gIE9ydFdhc21NZXNzYWdlLFxuICBTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcixcbiAgU2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhLFxuICBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YSxcbiAgVGVuc29yTWV0YWRhdGEsXG59IGZyb20gJy4vcHJveHktbWVzc2FnZXMnO1xuaW1wb3J0ICogYXMgY29yZSBmcm9tICcuL3dhc20tY29yZS1pbXBsJztcbmltcG9ydCB7IGluaXRpYWxpemVXZWJBc3NlbWJseSB9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcbmltcG9ydCB7XG4gIGltcG9ydFByb3h5V29ya2VyLFxuICBpbmZlcldhc21QYXRoUHJlZml4RnJvbVNjcmlwdFNyYyxcbiAgaXNFc21JbXBvcnRNZXRhVXJsSGFyZGNvZGVkQXNGaWxlVXJpLFxufSBmcm9tICcuL3dhc20tdXRpbHMtaW1wb3J0JztcblxuY29uc3QgaXNQcm94eSA9ICgpOiBib29sZWFuID0+ICEhZW52Lndhc20ucHJveHkgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmxldCBwcm94eVdvcmtlcjogV29ya2VyIHwgdW5kZWZpbmVkO1xubGV0IGluaXRpYWxpemluZyA9IGZhbHNlO1xubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG5sZXQgYWJvcnRlZCA9IGZhbHNlO1xubGV0IHRlbXBvcmFyeU9iamVjdFVybDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG50eXBlIFByb21pc2VDYWxsYmFja3M8VCA9IHZvaWQ+ID0gW3Jlc29sdmU6IChyZXN1bHQ6IFQpID0+IHZvaWQsIHJlamVjdDogKHJlYXNvbjogdW5rbm93bikgPT4gdm9pZF07XG5sZXQgaW5pdFdhc21DYWxsYmFja3M6IFByb21pc2VDYWxsYmFja3M7XG5jb25zdCBxdWV1ZWRDYWxsYmFja3M6IE1hcDxPcnRXYXNtTWVzc2FnZVsndHlwZSddLCBBcnJheTxQcm9taXNlQ2FsbGJhY2tzPHVua25vd24+Pj4gPSBuZXcgTWFwKCk7XG5cbmNvbnN0IGVucXVldWVDYWxsYmFja3MgPSAodHlwZTogT3J0V2FzbU1lc3NhZ2VbJ3R5cGUnXSwgY2FsbGJhY2tzOiBQcm9taXNlQ2FsbGJhY2tzPHVua25vd24+KTogdm9pZCA9PiB7XG4gIGNvbnN0IHF1ZXVlID0gcXVldWVkQ2FsbGJhY2tzLmdldCh0eXBlKTtcbiAgaWYgKHF1ZXVlKSB7XG4gICAgcXVldWUucHVzaChjYWxsYmFja3MpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlZENhbGxiYWNrcy5zZXQodHlwZSwgW2NhbGxiYWNrc10pO1xuICB9XG59O1xuXG5jb25zdCBlbnN1cmVXb3JrZXIgPSAoKTogdm9pZCA9PiB7XG4gIGlmIChpbml0aWFsaXppbmcgfHwgIWluaXRpYWxpemVkIHx8IGFib3J0ZWQgfHwgIXByb3h5V29ya2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3b3JrZXIgbm90IHJlYWR5Jyk7XG4gIH1cbn07XG5cbmNvbnN0IG9uUHJveHlXb3JrZXJNZXNzYWdlID0gKGV2OiBNZXNzYWdlRXZlbnQ8T3J0V2FzbU1lc3NhZ2U+KTogdm9pZCA9PiB7XG4gIHN3aXRjaCAoZXYuZGF0YS50eXBlKSB7XG4gICAgY2FzZSAnaW5pdC13YXNtJzpcbiAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgaWYgKGV2LmRhdGEuZXJyKSB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBpbml0V2FzbUNhbGxiYWNrc1sxXShldi5kYXRhLmVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGluaXRXYXNtQ2FsbGJhY2tzWzBdKCk7XG4gICAgICB9XG4gICAgICBpZiAodGVtcG9yYXJ5T2JqZWN0VXJsKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGVtcG9yYXJ5T2JqZWN0VXJsKTtcbiAgICAgICAgdGVtcG9yYXJ5T2JqZWN0VXJsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5pdC1lcCc6XG4gICAgY2FzZSAnY29weS1mcm9tJzpcbiAgICBjYXNlICdjcmVhdGUnOlxuICAgIGNhc2UgJ3JlbGVhc2UnOlxuICAgIGNhc2UgJ3J1bic6XG4gICAgY2FzZSAnZW5kLXByb2ZpbGluZyc6IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHF1ZXVlZENhbGxiYWNrcy5nZXQoZXYuZGF0YS50eXBlKSE7XG4gICAgICBpZiAoZXYuZGF0YS5lcnIpIHtcbiAgICAgICAgY2FsbGJhY2tzLnNoaWZ0KCkhWzFdKGV2LmRhdGEuZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrcy5zaGlmdCgpIVswXShldi5kYXRhLm91dCEpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplV2ViQXNzZW1ibHlBbmRPcnRSdW50aW1lID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGluaXRpYWxpemluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0V2FzbSgpJyBkZXRlY3RlZC5cIik7XG4gIH1cbiAgaWYgKGFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0V2FzbSgpJyBmYWlsZWQuXCIpO1xuICB9XG5cbiAgaW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBwcm94eVdvcmtlcj8udGVybWluYXRlKCk7XG5cbiAgICAgIHZvaWQgaW1wb3J0UHJveHlXb3JrZXIoKS50aGVuKChbb2JqZWN0VXJsLCB3b3JrZXJdKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJveHlXb3JrZXIgPSB3b3JrZXI7XG4gICAgICAgICAgcHJveHlXb3JrZXIub25lcnJvciA9IChldjogRXJyb3JFdmVudCkgPT4gcmVqZWN0KGV2KTtcbiAgICAgICAgICBwcm94eVdvcmtlci5vbm1lc3NhZ2UgPSBvblByb3h5V29ya2VyTWVzc2FnZTtcbiAgICAgICAgICBpbml0V2FzbUNhbGxiYWNrcyA9IFtyZXNvbHZlLCByZWplY3RdO1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0geyB0eXBlOiAnaW5pdC13YXNtJywgaW46IGVudiB9O1xuXG4gICAgICAgICAgLy8gaWYgdGhlIHByb3h5IHdvcmtlciBpcyBsb2FkZWQgZnJvbSBhIGJsb2IgVVJMLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgcGF0aCBpbmZvcm1hdGlvbiBpcyBub3QgbG9zdC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIHdoZW4gYGVudi53YXNtLndhc21QYXRoc2AgaXMgbm90IHNldCwgd2UgbmVlZCB0byBwYXNzIHRoZSBwYXRoIGluZm9ybWF0aW9uIHRvIHRoZSB3b3JrZXIuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoIUJVSUxEX0RFRlMuRU5BQkxFX0JVTkRMRV9XQVNNX0pTICYmICFtZXNzYWdlLmluIS53YXNtLndhc21QYXRocyAmJiBvYmplY3RVcmwpIHtcbiAgICAgICAgICAgIC8vIGZvciBhIGJ1aWxkIG5vdCBidW5kbGVkIHRoZSB3YXNtIEpTLCB3ZSBuZWVkIHRvIHBhc3MgdGhlIHBhdGggcHJlZml4IHRvIHRoZSB3b3JrZXIuXG4gICAgICAgICAgICAvLyB0aGUgcGF0aCBwcmVmaXggd2lsbCBiZSB1c2VkIHRvIHJlc29sdmUgdGhlIHBhdGggdG8gYm90aCB0aGUgd2FzbSBKUyBhbmQgdGhlIHdhc20gZmlsZS5cbiAgICAgICAgICAgIGNvbnN0IGluZmVycmVkV2FzbVBhdGhQcmVmaXggPSBpbmZlcldhc21QYXRoUHJlZml4RnJvbVNjcmlwdFNyYygpO1xuICAgICAgICAgICAgaWYgKGluZmVycmVkV2FzbVBhdGhQcmVmaXgpIHtcbiAgICAgICAgICAgICAgbWVzc2FnZS5pbiEud2FzbS53YXNtUGF0aHMgPSBpbmZlcnJlZFdhc21QYXRoUHJlZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIEJVSUxEX0RFRlMuSVNfRVNNICYmXG4gICAgICAgICAgICBCVUlMRF9ERUZTLkVOQUJMRV9CVU5ETEVfV0FTTV9KUyAmJlxuICAgICAgICAgICAgIW1lc3NhZ2UuaW4hLndhc20ud2FzbVBhdGhzICYmXG4gICAgICAgICAgICAob2JqZWN0VXJsIHx8IGlzRXNtSW1wb3J0TWV0YVVybEhhcmRjb2RlZEFzRmlsZVVyaSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIGZvciBhIGJ1aWxkIGJ1bmRsZWQgdGhlIHdhc20gSlMsIGlmIGVpdGhlciBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgaXMgbWV0OlxuICAgICAgICAgICAgLy8gLSB0aGUgcHJveHkgd29ya2VyIGlzIGxvYWRlZCBmcm9tIGEgYmxvYiBVUkxcbiAgICAgICAgICAgIC8vIC0gYGltcG9ydC5tZXRhLnVybGAgaXMgYSBmaWxlIFVSTCwgaXQgbWVhbnMgaXQgaXMgb3ZlcndyaXR0ZW4gYnkgdGhlIGJ1bmRsZXIuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gaW4gZWl0aGVyIGNhc2UsIHRoZSBwYXRoIGluZm9ybWF0aW9uIGlzIGxvc3QsIHdlIG5lZWQgdG8gcGFzcyB0aGUgcGF0aCBvZiB0aGUgLndhc20gZmlsZSB0byB0aGUgd29ya2VyLlxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB1c2UgdGhlIGJ1bmRsZXIgcHJlZmVycmVkIFVSTCBmb3JtYXQ6XG4gICAgICAgICAgICAvLyBuZXcgVVJMKCdmaWxlbmFtZScsIGltcG9ydC5tZXRhLnVybClcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGJ1bmRsZXIgY2FuIGhhbmRsZSB0aGUgZmlsZSB1c2luZyBjb3JyZXNwb25kaW5nIGxvYWRlcnMuXG4gICAgICAgICAgICBtZXNzYWdlLmluIS53YXNtLndhc21QYXRocyA9IHtcbiAgICAgICAgICAgICAgd2FzbTogIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQXG4gICAgICAgICAgICAgICAgPyBuZXcgVVJMKCdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbScsIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCkuaHJlZlxuICAgICAgICAgICAgICAgIDogIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFVcbiAgICAgICAgICAgICAgICAgID8gbmV3IFVSTCgnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5hc3luY2lmeS53YXNtJywgQlVJTERfREVGUy5FU01fSU1QT1JUX01FVEFfVVJMKS5ocmVmXG4gICAgICAgICAgICAgICAgICA6IG5ldyBVUkwoJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbScsIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCkuaHJlZixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb3h5V29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIHRlbXBvcmFyeU9iamVjdFVybCA9IG9iamVjdFVybDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KGVudi53YXNtKTtcbiAgICAgIGF3YWl0IGNvcmUuaW5pdFJ1bnRpbWUoZW52KTtcbiAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgIHRocm93IGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVPcnRFcCA9IGFzeW5jIChlcE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdpbml0LWVwJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdpbml0LWVwJywgaW46IHsgZXBOYW1lLCBlbnYgfSB9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IGNvcmUuaW5pdEVwKGVudiwgZXBOYW1lKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIgPSBhc3luYyAoYnVmZmVyOiBVaW50OEFycmF5KTogUHJvbWlzZTxTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcj4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygnY29weS1mcm9tJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdjb3B5LWZyb20nLCBpbjogeyBidWZmZXIgfSB9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFtidWZmZXIuYnVmZmVyXSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvcmUuY29weUZyb21FeHRlcm5hbEJ1ZmZlcihidWZmZXIpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU2Vzc2lvbiA9IGFzeW5jIChcbiAgbW9kZWw6IFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyIHwgVWludDhBcnJheSxcbiAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YT4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIC8vIGNoZWNrIHVuc3VwcG9ydGVkIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucz8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2Vzc2lvbiBvcHRpb24gXCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvblwiIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO1xuICAgIH1cbiAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8U2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdjcmVhdGUnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ2NyZWF0ZScsIGluOiB7IG1vZGVsLCBvcHRpb25zOiB7IC4uLm9wdGlvbnMgfSB9IH07XG4gICAgICBjb25zdCB0cmFuc2ZlcmFibGU6IFRyYW5zZmVyYWJsZVtdID0gW107XG4gICAgICBpZiAobW9kZWwgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKG1vZGVsLmJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJhYmxlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29yZS5jcmVhdGVTZXNzaW9uKG1vZGVsLCBvcHRpb25zKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlbGVhc2VTZXNzaW9uID0gYXN5bmMgKHNlc3Npb25JZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ3JlbGVhc2UnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ3JlbGVhc2UnLCBpbjogc2Vzc2lvbklkIH07XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29yZS5yZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcnVuID0gYXN5bmMgKFxuICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgaW5wdXRzOiBUZW5zb3JNZXRhZGF0YVtdLFxuICBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgb3V0cHV0czogQXJyYXk8VGVuc29yTWV0YWRhdGEgfCBudWxsPixcbiAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuKTogUHJvbWlzZTxUZW5zb3JNZXRhZGF0YVtdPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgLy8gY2hlY2sgaW5wdXRzIGxvY2F0aW9uXG4gICAgaWYgKGlucHV0cy5zb21lKCh0KSA9PiB0WzNdICE9PSAnY3B1JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29yIG9uIEdQVSBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgb3V0cHV0cyBsb2NhdGlvblxuICAgIGlmIChvdXRwdXRzLnNvbWUoKHQpID0+IHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZS1hbGxvY2F0ZWQgb3V0cHV0IHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtcbiAgICB9XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW10+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ3J1bicsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6YWJsZUlucHV0cyA9IGlucHV0cyBhcyBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdOyAvLyBldmVyeSBpbnB1dCBpcyBvbiBDUFUuXG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogJ3J1bicsXG4gICAgICAgIGluOiB7IHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHM6IHNlcmlhbGl6YWJsZUlucHV0cywgb3V0cHV0SW5kaWNlcywgb3B0aW9ucyB9LFxuICAgICAgfTtcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlLCBjb3JlLmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKHNlcmlhbGl6YWJsZUlucHV0cykpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb3JlLnJ1bihzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBvdXRwdXRzLCBvcHRpb25zKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGVuZFByb2ZpbGluZyA9IGFzeW5jIChzZXNzaW9uSWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdlbmQtcHJvZmlsaW5nJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdlbmQtcHJvZmlsaW5nJywgaW46IHNlc3Npb25JZCB9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvcmUuZW5kUHJvZmlsaW5nKHNlc3Npb25JZCk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7XG4gIEluZmVyZW5jZVNlc3Npb24sXG4gIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyLFxuICBTZXNzaW9uSGFuZGxlcixcbiAgVGVuc29yLFxuICBUUkFDRV9GVU5DX0JFR0lOLFxuICBUUkFDRV9GVU5DX0VORCxcbn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsIFRlbnNvck1ldGFkYXRhIH0gZnJvbSAnLi9wcm94eS1tZXNzYWdlcyc7XG5pbXBvcnQgeyBjb3B5RnJvbUV4dGVybmFsQnVmZmVyLCBjcmVhdGVTZXNzaW9uLCBlbmRQcm9maWxpbmcsIHJlbGVhc2VTZXNzaW9uLCBydW4gfSBmcm9tICcuL3Byb3h5LXdyYXBwZXInO1xuaW1wb3J0IHsgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlLCBpc01MVGVuc29yU3VwcG9ydGVkVHlwZSB9IGZyb20gJy4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi93YXNtLXV0aWxzLWVudic7XG5pbXBvcnQgeyBsb2FkRmlsZSB9IGZyb20gJy4vd2FzbS11dGlscy1sb2FkLWZpbGUnO1xuXG5leHBvcnQgY29uc3QgZW5jb2RlVGVuc29yTWV0YWRhdGEgPSAodGVuc29yOiBUZW5zb3IsIGdldE5hbWU6ICgpID0+IHN0cmluZyk6IFRlbnNvck1ldGFkYXRhID0+IHtcbiAgc3dpdGNoICh0ZW5zb3IubG9jYXRpb24pIHtcbiAgICBjYXNlICdjcHUnOlxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHRlbnNvci5kYXRhLCAnY3B1J107XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gW3RlbnNvci50eXBlLCB0ZW5zb3IuZGltcywgeyBncHVCdWZmZXI6IHRlbnNvci5ncHVCdWZmZXIgfSwgJ2dwdS1idWZmZXInXTtcbiAgICBjYXNlICdtbC10ZW5zb3InOlxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHsgbWxUZW5zb3I6IHRlbnNvci5tbFRlbnNvciB9LCAnbWwtdGVuc29yJ107XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke3RlbnNvci5sb2NhdGlvbn0gZm9yICR7Z2V0TmFtZSgpfWApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZGVjb2RlVGVuc29yTWV0YWRhdGEgPSAodGVuc29yOiBUZW5zb3JNZXRhZGF0YSk6IFRlbnNvciA9PiB7XG4gIHN3aXRjaCAodGVuc29yWzNdKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvclswXSwgdGVuc29yWzJdLCB0ZW5zb3JbMV0pO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOiB7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclswXTtcbiAgICAgIGlmICghaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKGRhdGFUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfSBmb3IgZGVzZXJpYWxpemluZyBHUFUgdGVuc29yYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGdwdUJ1ZmZlciwgZG93bmxvYWQsIGRpc3Bvc2UgfSA9IHRlbnNvclsyXTtcbiAgICAgIHJldHVybiBUZW5zb3IuZnJvbUdwdUJ1ZmZlcihncHVCdWZmZXIsIHsgZGF0YVR5cGUsIGRpbXM6IHRlbnNvclsxXSwgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG4gICAgfVxuICAgIGNhc2UgJ21sLXRlbnNvcic6IHtcbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yWzBdO1xuICAgICAgaWYgKCFpc01MVGVuc29yU3VwcG9ydGVkVHlwZShkYXRhVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkYXRhVHlwZX0gZm9yIGRlc2VyaWFsaXppbmcgTUxUZW5zb3IgdGVuc29yYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IG1sVGVuc29yLCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gdGVuc29yWzJdO1xuICAgICAgcmV0dXJuIFRlbnNvci5mcm9tTUxUZW5zb3IobWxUZW5zb3IsIHsgZGF0YVR5cGUsIGRpbXM6IHRlbnNvclsxXSwgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHt0ZW5zb3JbM119YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIgaW1wbGVtZW50cyBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciB7XG4gIHByaXZhdGUgc2Vzc2lvbklkOiBudW1iZXI7XG5cbiAgaW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG4gIG91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcbiAgaW5wdXRNZXRhZGF0YTogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhW107XG4gIG91dHB1dE1ldGFkYXRhOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGFbXTtcblxuICBhc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeShwYXRoOiBzdHJpbmcpOiBQcm9taXNlPFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyPiB7XG4gICAgLy8gZmV0Y2ggbW9kZWwgZnJvbSB1cmwgYW5kIG1vdmUgdG8gd2FzbSBoZWFwLlxuICAgIHJldHVybiBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKGF3YWl0IGxvYWRGaWxlKHBhdGgpKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRNb2RlbChwYXRoT3JCdWZmZXI6IHN0cmluZyB8IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIGxldCBtb2RlbDogUGFyYW1ldGVyczx0eXBlb2YgY3JlYXRlU2Vzc2lvbj5bMF07XG5cbiAgICBpZiAodHlwZW9mIHBhdGhPckJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgLy8gbm9kZVxuICAgICAgICBtb2RlbCA9IGF3YWl0IGxvYWRGaWxlKHBhdGhPckJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBicm93c2VyXG4gICAgICAgIC8vIGZldGNoIG1vZGVsIGFuZCBjb3B5IHRvIHdhc20gaGVhcC5cbiAgICAgICAgbW9kZWwgPSBhd2FpdCB0aGlzLmZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHBhdGhPckJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsID0gcGF0aE9yQnVmZmVyO1xuICAgIH1cblxuICAgIFt0aGlzLnNlc3Npb25JZCwgdGhpcy5pbnB1dE5hbWVzLCB0aGlzLm91dHB1dE5hbWVzLCB0aGlzLmlucHV0TWV0YWRhdGEsIHRoaXMub3V0cHV0TWV0YWRhdGFdID0gYXdhaXQgY3JlYXRlU2Vzc2lvbihcbiAgICAgIG1vZGVsLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gIH1cblxuICBhc3luYyBkaXNwb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiByZWxlYXNlU2Vzc2lvbih0aGlzLnNlc3Npb25JZCk7XG4gIH1cblxuICBhc3luYyBydW4oXG4gICAgZmVlZHM6IFNlc3Npb25IYW5kbGVyLkZlZWRzVHlwZSxcbiAgICBmZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcbiAgICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8U2Vzc2lvbkhhbmRsZXIuUmV0dXJuVHlwZT4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICBjb25zdCBpbnB1dEFycmF5OiBUZW5zb3JbXSA9IFtdO1xuICAgIGNvbnN0IGlucHV0SW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICBPYmplY3QuZW50cmllcyhmZWVkcykuZm9yRWFjaCgoa3ZwKSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0ga3ZwWzBdO1xuICAgICAgY29uc3QgdGVuc29yID0ga3ZwWzFdO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmlucHV0TmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0ICcke25hbWV9J2ApO1xuICAgICAgfVxuICAgICAgaW5wdXRBcnJheS5wdXNoKHRlbnNvcik7XG4gICAgICBpbnB1dEluZGljZXMucHVzaChpbmRleCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvdXRwdXRBcnJheTogQXJyYXk8VGVuc29yIHwgbnVsbD4gPSBbXTtcbiAgICBjb25zdCBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xuICAgIE9iamVjdC5lbnRyaWVzKGZldGNoZXMpLmZvckVhY2goKGt2cCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGt2cFswXTtcbiAgICAgIGNvbnN0IHRlbnNvciA9IGt2cFsxXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke25hbWV9J2ApO1xuICAgICAgfVxuICAgICAgb3V0cHV0QXJyYXkucHVzaCh0ZW5zb3IpO1xuICAgICAgb3V0cHV0SW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlucHV0cyA9IGlucHV0QXJyYXkubWFwKCh0LCBpKSA9PlxuICAgICAgZW5jb2RlVGVuc29yTWV0YWRhdGEodCwgKCkgPT4gYGlucHV0IFwiJHt0aGlzLmlucHV0TmFtZXNbaW5wdXRJbmRpY2VzW2ldXX1cImApLFxuICAgICk7XG4gICAgY29uc3Qgb3V0cHV0cyA9IG91dHB1dEFycmF5Lm1hcCgodCwgaSkgPT5cbiAgICAgIHQgPyBlbmNvZGVUZW5zb3JNZXRhZGF0YSh0LCAoKSA9PiBgb3V0cHV0IFwiJHt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dfVwiYCkgOiBudWxsLFxuICAgICk7XG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcnVuKHRoaXMuc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgb3V0cHV0cywgb3B0aW9ucyk7XG5cbiAgICBjb25zdCByZXN1bHRNYXA6IFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGUgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdE1hcFt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dXSA9IG91dHB1dEFycmF5W2ldID8/IGRlY29kZVRlbnNvck1ldGFkYXRhKHJlc3VsdHNbaV0pO1xuICAgIH1cbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICAgIHJldHVybiByZXN1bHRNYXA7XG4gIH1cblxuICBzdGFydFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgcHJvZmlsaW5nXG4gIH1cblxuICBlbmRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgdm9pZCBlbmRQcm9maWxpbmcodGhpcy5zZXNzaW9uSWQpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEJhY2tlbmQsIGVudiwgSW5mZXJlbmNlU2Vzc2lvbiwgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBpbml0aWFsaXplT3J0RXAsIGluaXRpYWxpemVXZWJBc3NlbWJseUFuZE9ydFJ1bnRpbWUgfSBmcm9tICcuL3dhc20vcHJveHktd3JhcHBlcic7XG5pbXBvcnQgeyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIgfSBmcm9tICcuL3dhc20vc2Vzc2lvbi1oYW5kbGVyLWluZmVyZW5jZSc7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyBhbGwgZmxhZ3MgZm9yIFdlYkFzc2VtYmx5LlxuICpcbiAqIFRob3NlIGZsYWdzIGFyZSBhY2Nlc3NpYmxlIGZyb20gYG9ydC5lbnYud2FzbWAuIFVzZXJzIGFyZSBhbGxvdyB0byBzZXQgdGhvc2UgZmxhZ3MgYmVmb3JlIHRoZSBmaXJzdCBpbmZlcmVuY2Ugc2Vzc2lvblxuICogYmVpbmcgY3JlYXRlZCwgdG8gb3ZlcnJpZGUgZGVmYXVsdCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVGbGFncyA9ICgpOiB2b2lkID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYud2FzbS5pbml0VGltZW91dCAhPT0gJ251bWJlcicgfHwgZW52Lndhc20uaW5pdFRpbWVvdXQgPCAwKSB7XG4gICAgZW52Lndhc20uaW5pdFRpbWVvdXQgPSAwO1xuICB9XG5cbiAgY29uc3Qgc2ltZCA9IGVudi53YXNtLnNpbWQ7XG4gIGlmICh0eXBlb2Ygc2ltZCAhPT0gJ2Jvb2xlYW4nICYmIHNpbWQgIT09IHVuZGVmaW5lZCAmJiBzaW1kICE9PSAnZml4ZWQnICYmIHNpbWQgIT09ICdyZWxheGVkJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYFByb3BlcnR5IFwiZW52Lndhc20uc2ltZFwiIGlzIHNldCB0byB1bmtub3duIHZhbHVlIFwiJHtzaW1kfVwiLiBSZXNldCBpdCB0byBcXGBmYWxzZVxcYCBhbmQgaWdub3JlIFNJTUQgZmVhdHVyZSBjaGVja2luZy5gLFxuICAgICk7XG4gICAgZW52Lndhc20uc2ltZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbnYud2FzbS5wcm94eSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgZW52Lndhc20ucHJveHkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW52Lndhc20udHJhY2UgIT09ICdib29sZWFuJykge1xuICAgIGVudi53YXNtLnRyYWNlID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGVudi53YXNtLm51bVRocmVhZHMgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGVudi53YXNtLm51bVRocmVhZHMpIHx8IGVudi53YXNtLm51bVRocmVhZHMgPD0gMCkge1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgbG9naWMgb25seSBhcHBsaWVzIHdoZW4gYG9ydC5lbnYud2FzbS5udW1UaHJlYWRzYCBpcyBub3Qgc2V0IGJ5IHVzZXIuIFdlIHdpbGwgYWx3YXlzIGhvbm9yIHVzZXInc1xuICAgIC8vIHNldHRpbmcgaWYgaXQgaXMgcHJvdmlkZWQuXG5cbiAgICAvLyBCcm93c2VyOiB3aGVuIGNyb3NzT3JpZ2luSXNvbGF0ZWQgaXMgZmFsc2UsIFNoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhdmFpbGFibGUgc28gV2ViQXNzZW1ibHkgdGhyZWFkcyB3aWxsIG5vdFxuICAgIC8vIHdvcmsuIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBzZXQgbnVtVGhyZWFkcyB0byAxLlxuICAgIC8vXG4gICAgLy8gVGhlcmUgaXMgYW4gZXhjZXB0aW9uOiB3aGVuIHRoZSBicm93c2VyIGlzIGNvbmZpZ3VyZWQgdG8gZm9yY2UtZW5hYmxlIFNoYXJlZEFycmF5QnVmZmVyIChlLmcuIENocm9tdWltIHdpdGhcbiAgICAvLyAtLWVuYWJsZS1mZWF0dXJlcz1TaGFyZWRBcnJheUJ1ZmZlciksIGl0IGlzIHBvc3NpYmxlIHRoYXQgYHNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZGAgaXMgZmFsc2UgYW5kXG4gICAgLy8gU2hhcmVkQXJyYXlCdWZmZXIgaXMgYXZhaWxhYmxlIGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgdXN1YWxseSBmb3IgdGVzdGluZy4gSW4gdGhpcyBjYXNlLCAgd2Ugd2lsbCBzdGlsbCBzZXRcbiAgICAvLyBudW1UaHJlYWRzIHRvIDEgaGVyZS4gSWYgd2Ugd2FudCB0byBlbmFibGUgbXVsdGktdGhyZWFkaW5nIGluIHRlc3QsIHdlIHNob3VsZCBzZXQgYG9ydC5lbnYud2FzbS5udW1UaHJlYWRzYCB0byBhXG4gICAgLy8gdmFsdWUgZ3JlYXRlciB0aGFuIDEuXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKSB7XG4gICAgICBlbnYud2FzbS5udW1UaHJlYWRzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbnVtQ3B1TG9naWNhbENvcmVzID1cbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCdub2RlOm9zJykuY3B1cygpLmxlbmd0aCA6IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O1xuICAgICAgZW52Lndhc20ubnVtVGhyZWFkcyA9IE1hdGgubWluKDQsIE1hdGguY2VpbCgobnVtQ3B1TG9naWNhbENvcmVzIHx8IDEpIC8gMikpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNsYXNzIE9ubnhydW50aW1lV2ViQXNzZW1ibHlCYWNrZW5kIGltcGxlbWVudHMgQmFja2VuZCB7XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGluaXRpYWxpemVzIHRoZSBXZWJBc3NlbWJseSBiYWNrZW5kLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9ubHkgb25jZSBmb3IgZWFjaCBiYWNrZW5kIG5hbWUuIEl0IHdpbGwgYmUgY2FsbGVkIHRoZSBmaXJzdCB0aW1lIHdoZW5cbiAgICogYG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZSgpYCBpcyBjYWxsZWQgd2l0aCBhIHJlZ2lzdGVyZWQgYmFja2VuZCBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0gYmFja2VuZE5hbWUgLSB0aGUgcmVnaXN0ZXJlZCBiYWNrZW5kIG5hbWUuXG4gICAqL1xuICBhc3luYyBpbml0KGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBwb3B1bGF0ZSB3YXNtIGZsYWdzXG4gICAgaW5pdGlhbGl6ZUZsYWdzKCk7XG5cbiAgICAvLyBpbml0IHdhc21cbiAgICBhd2FpdCBpbml0aWFsaXplV2ViQXNzZW1ibHlBbmRPcnRSdW50aW1lKCk7XG5cbiAgICAvLyBwZXJmb3JtZSBFUCBzcGVjaWZpYyBpbml0aWFsaXphdGlvblxuICAgIGF3YWl0IGluaXRpYWxpemVPcnRFcChiYWNrZW5kTmFtZSk7XG4gIH1cbiAgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPjtcbiAgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoXG4gICAgYnVmZmVyOiBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPjtcbiAgYXN5bmMgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoXG4gICAgcGF0aE9yQnVmZmVyOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPiB7XG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIoKTtcbiAgICBhd2FpdCBoYW5kbGVyLmxvYWRNb2RlbChwYXRoT3JCdWZmZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiBoYW5kbGVyO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3YXNtQmFja2VuZCA9IG5ldyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCgpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXG5cbi8vIFdlIHVzZSBcInJlcXVpcmVcIiBpbnN0ZWFkIG9mIFwiaW1wb3J0XCIgaGVyZSBiZWNhdXNlIGltcG9ydCBzdGF0ZW1lbnQgbXVzdCBiZSBwdXQgaW4gdG9wIGxldmVsLiBPdXIgY3VycmVudCBjb2RlIGRvZXNcbi8vIG5vdCBhbGxvdyBidW5kbGVyIHRvIHRyZWUtc2hha2luZyBjb2RlIGFzIGV4cGVjdGVkIGJlY2F1c2Ugc29tZSBjb2RlcyBhcmUgdHJlYXRlZCBhcyBoYXZpbmcgc2lkZSBlZmZlY3RzLlxuLy8gU28gd2UgaW1wb3J0IGNvZGUgaW5zaWRlIHRoZSBpZi1jbGF1c2UgdG8gYWxsb3cgYnVuZGxlciByZW1vdmUgdGhlIGNvZGUgc2FmZWx5LlxuXG5leHBvcnQgKiBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuaW1wb3J0ICogYXMgb3J0IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5leHBvcnQgZGVmYXVsdCBvcnQ7XG5cbmltcG9ydCB7IHJlZ2lzdGVyQmFja2VuZCwgZW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xuXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHTCkge1xuICBjb25zdCBvbm54anNCYWNrZW5kID0gcmVxdWlyZSgnLi9iYWNrZW5kLW9ubnhqcycpLm9ubnhqc0JhY2tlbmQ7XG4gIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ2wnLCBvbm54anNCYWNrZW5kLCAtMTApO1xufVxuXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQICYmICFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVKSB7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnVGhlIGN1cnJlbnQgYnVpbGQgaXMgc3BlY2lmaWVkIHRvIGVuYWJsZSBib3RoIEpTRVAgYW5kIFdlYkdQVSBFUC4gVGhpcyBpcyBub3QgYSB2YWxpZCBjb25maWd1cmF0aW9uLiAnICtcbiAgICAgICdKU0VQIGFuZCBXZWJHUFUgRVBzIGNhbm5vdCBiZSBlbmFibGVkIGF0IHRoZSBzYW1lIHRpbWUuJyxcbiAgKTtcbn1cblxuaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCTk4gJiYgQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgJiYgQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ1RoZSBjdXJyZW50IGJ1aWxkIGlzIHNwZWNpZmllZCB0byBlbmFibGUgV2ViTk4gRVAgd2l0aG91dCBKU0VQIG9yIFdlYkdQVSBFUC4gVGhpcyBpcyBub3QgYSB2YWxpZCBjb25maWd1cmF0aW9uLiAnICtcbiAgICAgICdXZWJOTiBFUCByZXF1aXJlcyBlaXRoZXIgSlNFUCBvciBXZWJHUFUgRVAgdG8gYmUgZW5hYmxlZC4nLFxuICApO1xufVxuXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNKSB7XG4gIGNvbnN0IHdhc21CYWNrZW5kID0gcmVxdWlyZSgnLi9iYWNrZW5kLXdhc20nKS53YXNtQmFja2VuZDtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCB8fCAhQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkge1xuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ3B1Jywgd2FzbUJhY2tlbmQsIDUpO1xuICB9XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQk5OKSB7XG4gICAgcmVnaXN0ZXJCYWNrZW5kKCd3ZWJubicsIHdhc21CYWNrZW5kLCA1KTtcbiAgfVxuICByZWdpc3RlckJhY2tlbmQoJ2NwdScsIHdhc21CYWNrZW5kLCAxMCk7XG4gIHJlZ2lzdGVyQmFja2VuZCgnd2FzbScsIHdhc21CYWNrZW5kLCAxMCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbnYudmVyc2lvbnMsICd3ZWInLCB7IHZhbHVlOiB2ZXJzaW9uLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IC9qcy9zY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLnRzXG4vLyBEbyBub3QgbW9kaWZ5IGZpbGUgY29udGVudCBtYW51YWxseS5cblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMS4yMy4wLWRldi4yMDI1MDkwNi1lY2IyNmZiNzc1JztcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7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SUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JBQUFDO0FBQUEsSUFBQTtBQUFBLGVBQUFDO0FBQUEsSUFBQTtBQUFBO0FBU0E7QUFDQTtBQUdBOzs7QUNQTyxNQUFNQyxXQUFVOzs7QURLdkIsTUFBTyxnQkFBUTtBQUtmLE1BQUksT0FBMkI7QUFDN0IsVUFBTSxnQkFBZ0IsS0FBNEI7QUFDbEQsb0JBQWdCLFNBQVMsZUFBZSxHQUFHO0FBQUEsRUFDN0M7QUFFQSxNQUFnQyxPQUE0QjtBQUMxRCxVQUFNLElBQUk7QUFBQSxNQUNSO0FBQUEsSUFFRjtBQUFBLEVBQ0Y7QUFFQSxNQUFpQyxPQUFzRDtBQUNyRixVQUFNLElBQUk7QUFBQSxNQUNSO0FBQUEsSUFFRjtBQUFBLEVBQ0Y7QUFFQSxNQUFJLE1BQTBCO0FBQzVCLFVBQU1DLGVBQWMsMERBQTBCO0FBQzlDLFFBQUksTUFBd0Q7QUFDMUQsc0JBQWdCLFVBQVVBLGNBQWEsQ0FBQztBQUFBLElBQzFDO0FBQ0EsUUFBSSxNQUEyQjtBQUM3QixzQkFBZ0IsU0FBU0EsY0FBYSxDQUFDO0FBQUEsSUFDekM7QUFDQSxvQkFBZ0IsT0FBT0EsY0FBYSxFQUFFO0FBQ3RDLG9CQUFnQixRQUFRQSxjQUFhLEVBQUU7QUFBQSxFQUN6QztBQUVBLFNBQU8sZUFBZUMsS0FBSSxVQUFVLE9BQU8sRUFBRSxPQUFPQyxVQUFTLFlBQVksS0FBSyxDQUFDOyIsCiAgIm5hbWVzIjogWyJpIiwgImVudiIsICJGbG9hdDE2QXJyYXkiLCAiVGVuc29yIiwgIlRlbnNvciIsICJJbmZlcmVuY2VTZXNzaW9uIiwgIkluZmVyZW5jZVNlc3Npb24iLCAiVGVuc29yIiwgImVudiIsICJlbnYiLCAid2FzbSIsICJ3YXNtIiwgIndhc20iLCAibG9jYXRpb24iLCAicGFkIiwgInRlbnNvciIsICJlbnYiLCAibWxDb250ZXh0SW5kZXgiLCAid2FzbSIsICJpbml0IiwgIm9mZnNldHMiLCAiaW5kaWNlcyIsICJpbXBsIiwgInZhbGlkYXRlSW5wdXRzIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiYSIsICJiIiwgInZhbGlkYXRlSW5wdXRzIiwgImkiLCAiaW5wdXRWYXJpYWJsZSIsICJ0cmFuc3Bvc2UiLCAib3V0cHV0VmFyaWFibGUiLCAiaW5uZXJFbGVtZW50U2l6ZSIsICJwYWQiLCAidmFsaWRhdGVJbnB1dHMiLCAiY29udklucHV0cyIsICJ0cmFuc3Bvc2VkV2VpZ2h0IiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInBlcm1GdW5jdGlvbkJvZHkiLCAic3ltYm9sIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJjYWxjdWxhdGVPdXRwdXRTaGFwZSIsICJmYXN0R2VsdSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJpbnB1dHMiLCAib3V0cHV0U2l6ZSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAid2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImRhdGFUeXBlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImVudiIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiY29tcG9uZW50cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJnZXRPdXRwdXRTaGFwZSIsICJhIiwgImIiLCAiYyIsICJmYXN0R2VsdSIsICJlbnYiLCAiaSIsICJlbnYiLCAiZW52IiwgIndhc20iLCAibG9jYXRpb24iLCAiaW5kZXgiLCAidGVuc29yIiwgImVycm9yQ29kZSIsICJpIiwgImluaXRpYWxpemluZyIsICJpbml0aWFsaXplZCIsICJhYm9ydGVkIiwgImNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIiLCAiY3JlYXRlU2Vzc2lvbiIsICJyZWxlYXNlU2Vzc2lvbiIsICJydW4iLCAiZW5kUHJvZmlsaW5nIiwgImVudiIsICJUZW5zb3IiLCAiY29weUZyb21FeHRlcm5hbEJ1ZmZlciIsICJjcmVhdGVTZXNzaW9uIiwgInJlbGVhc2VTZXNzaW9uIiwgInJ1biIsICJlbmRQcm9maWxpbmciLCAiZW52IiwgIkluZmVyZW5jZVNlc3Npb24iLCAiVGVuc29yIiwgImVudiIsICJ2ZXJzaW9uIiwgIndhc21CYWNrZW5kIiwgImVudiIsICJ2ZXJzaW9uIl0KfQo=
